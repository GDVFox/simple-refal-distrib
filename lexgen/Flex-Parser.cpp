// Automatically generated file. Don't edit!
#include "refalrts.h"


// identifier #Alt
template <typename SREFAL_PARAM_INT>
struct ident_Alt {
  static const char *name() {
    return "Alt";
  }
};

// identifier #AnyChar
template <typename SREFAL_PARAM_INT>
struct ident_AnyChar {
  static const char *name() {
    return "AnyChar";
  }
};

// identifier #Char
template <typename SREFAL_PARAM_INT>
struct ident_Char {
  static const char *name() {
    return "Char";
  }
};

// identifier #ComplexTermSYMBOL
template <typename SREFAL_PARAM_INT>
struct ident_ComplexTermSYMBOL {
  static const char *name() {
    return "ComplexTermSYMBOL";
  }
};

// identifier #Direct
template <typename SREFAL_PARAM_INT>
struct ident_Direct {
  static const char *name() {
    return "Direct";
  }
};

// identifier #Domain
template <typename SREFAL_PARAM_INT>
struct ident_Domain {
  static const char *name() {
    return "Domain";
  }
};

// identifier #ErrorDomain
template <typename SREFAL_PARAM_INT>
struct ident_ErrorDomain {
  static const char *name() {
    return "ErrorDomain";
  }
};

// identifier #Inverted
template <typename SREFAL_PARAM_INT>
struct ident_Inverted {
  static const char *name() {
    return "Inverted";
  }
};

// identifier #ManyOne
template <typename SREFAL_PARAM_INT>
struct ident_ManyOne {
  static const char *name() {
    return "ManyOne";
  }
};

// identifier #ManyZero
template <typename SREFAL_PARAM_INT>
struct ident_ManyZero {
  static const char *name() {
    return "ManyZero";
  }
};

// identifier #Name
template <typename SREFAL_PARAM_INT>
struct ident_Name {
  static const char *name() {
    return "Name";
  }
};

// identifier #NamedDomain
template <typename SREFAL_PARAM_INT>
struct ident_NamedDomain {
  static const char *name() {
    return "NamedDomain";
  }
};

// identifier #NamedGroup
template <typename SREFAL_PARAM_INT>
struct ident_NamedGroup {
  static const char *name() {
    return "NamedGroup";
  }
};

// identifier #NamedRegexp
template <typename SREFAL_PARAM_INT>
struct ident_NamedRegexp {
  static const char *name() {
    return "NamedRegexp";
  }
};

// identifier #NextState
template <typename SREFAL_PARAM_INT>
struct ident_NextState {
  static const char *name() {
    return "NextState";
  }
};

// identifier #NoNextState
template <typename SREFAL_PARAM_INT>
struct ident_NoNextState {
  static const char *name() {
    return "NoNextState";
  }
};

// identifier #Optional
template <typename SREFAL_PARAM_INT>
struct ident_Optional {
  static const char *name() {
    return "Optional";
  }
};

// identifier #Regexp
template <typename SREFAL_PARAM_INT>
struct ident_Regexp {
  static const char *name() {
    return "Regexp";
  }
};

// identifier #SkippedDomain
template <typename SREFAL_PARAM_INT>
struct ident_SkippedDomain {
  static const char *name() {
    return "SkippedDomain";
  }
};

// identifier #Subexpr
template <typename SREFAL_PARAM_INT>
struct ident_Subexpr {
  static const char *name() {
    return "Subexpr";
  }
};

// identifier #TAlt
template <typename SREFAL_PARAM_INT>
struct ident_TAlt {
  static const char *name() {
    return "TAlt";
  }
};

// identifier #TAny
template <typename SREFAL_PARAM_INT>
struct ident_TAny {
  static const char *name() {
    return "TAny";
  }
};

// identifier #TArrow
template <typename SREFAL_PARAM_INT>
struct ident_TArrow {
  static const char *name() {
    return "TArrow";
  }
};

// identifier #TChar
template <typename SREFAL_PARAM_INT>
struct ident_TChar {
  static const char *name() {
    return "TChar";
  }
};

// identifier #TCloseBracket
template <typename SREFAL_PARAM_INT>
struct ident_TCloseBracket {
  static const char *name() {
    return "TCloseBracket";
  }
};

// identifier #TComma
template <typename SREFAL_PARAM_INT>
struct ident_TComma {
  static const char *name() {
    return "TComma";
  }
};

// identifier #TEOF
template <typename SREFAL_PARAM_INT>
struct ident_TEOF {
  static const char *name() {
    return "TEOF";
  }
};

// identifier #TEndGroup
template <typename SREFAL_PARAM_INT>
struct ident_TEndGroup {
  static const char *name() {
    return "TEndGroup";
  }
};

// identifier #TEndRegexp
template <typename SREFAL_PARAM_INT>
struct ident_TEndRegexp {
  static const char *name() {
    return "TEndRegexp";
  }
};

// identifier #TEquals
template <typename SREFAL_PARAM_INT>
struct ident_TEquals {
  static const char *name() {
    return "TEquals";
  }
};

// identifier #TErrorMessage
template <typename SREFAL_PARAM_INT>
struct ident_TErrorMessage {
  static const char *name() {
    return "TErrorMessage";
  }
};

// identifier #TFlush
template <typename SREFAL_PARAM_INT>
struct ident_TFlush {
  static const char *name() {
    return "TFlush";
  }
};

// identifier #TGroupRange
template <typename SREFAL_PARAM_INT>
struct ident_TGroupRange {
  static const char *name() {
    return "TGroupRange";
  }
};

// identifier #TInclude
template <typename SREFAL_PARAM_INT>
struct ident_TInclude {
  static const char *name() {
    return "TInclude";
  }
};

// identifier #TInvertGroup
template <typename SREFAL_PARAM_INT>
struct ident_TInvertGroup {
  static const char *name() {
    return "TInvertGroup";
  }
};

// identifier #TName
template <typename SREFAL_PARAM_INT>
struct ident_TName {
  static const char *name() {
    return "TName";
  }
};

// identifier #TOneMany
template <typename SREFAL_PARAM_INT>
struct ident_TOneMany {
  static const char *name() {
    return "TOneMany";
  }
};

// identifier #TOpenBracket
template <typename SREFAL_PARAM_INT>
struct ident_TOpenBracket {
  static const char *name() {
    return "TOpenBracket";
  }
};

// identifier #TOptional
template <typename SREFAL_PARAM_INT>
struct ident_TOptional {
  static const char *name() {
    return "TOptional";
  }
};

// identifier #TSkip
template <typename SREFAL_PARAM_INT>
struct ident_TSkip {
  static const char *name() {
    return "TSkip";
  }
};

// identifier #TStartGroup
template <typename SREFAL_PARAM_INT>
struct ident_TStartGroup {
  static const char *name() {
    return "TStartGroup";
  }
};

// identifier #TStartRegexp
template <typename SREFAL_PARAM_INT>
struct ident_TStartRegexp {
  static const char *name() {
    return "TStartRegexp";
  }
};

// identifier #TStateEnd
template <typename SREFAL_PARAM_INT>
struct ident_TStateEnd {
  static const char *name() {
    return "TStateEnd";
  }
};

// identifier #TStateStart
template <typename SREFAL_PARAM_INT>
struct ident_TStateStart {
  static const char *name() {
    return "TStateStart";
  }
};

// identifier #TZeroMany
template <typename SREFAL_PARAM_INT>
struct ident_TZeroMany {
  static const char *name() {
    return "TZeroMany";
  }
};

// identifier #Term
template <typename SREFAL_PARAM_INT>
struct ident_Term {
  static const char *name() {
    return "Term";
  }
};

// identifier #TermSYMBOL
template <typename SREFAL_PARAM_INT>
struct ident_TermSYMBOL {
  static const char *name() {
    return "TermSYMBOL";
  }
};

extern refalrts::RefalFunction& Fetch;
extern refalrts::RefalFunction& Flex_TextFromToken;
extern refalrts::RefalFunction& ErrorAt;
namespace /* unnamed */ {
refalrts::RefalSwap descr_G_Tokens("G-Tokens");
refalrts::RefalFunction& G_Tokens = descr_G_Tokens;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_Current_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& Current;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_MoveNext_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& MoveNext;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_CurrentTag_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& CurrentTag;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_CurrentAttr_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& CurrentAttr;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_CurrentPos_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& CurrentPos;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_Expect_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& Expect;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& Generalize;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_Error_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& Error;
} // unnamed namespace

extern refalrts::RefalFunction& Flex_Parse;
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseDescription_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseDescription;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseDescriptions_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseDescriptions;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseSubexpr_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseSubexpr;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseDomain_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseDomain;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseDomainFrom_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseDomainFrom;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseStatesOpt_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseStatesOpt;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseDomainTo_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseDomainTo;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseFlush_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseFlush;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseNextStateOpt_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseNextStateOpt;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseState_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseState;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseNameOpt_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseNameOpt;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseRegexp_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseRegexp;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseComplexTerm_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseComplexTerm;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseTerm_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseTerm;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseRepeater_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseRepeater;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseSimpleTerm_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseSimpleTerm;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseSet_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseSet;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseInvertOpt_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseInvertOpt;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseComplexSYMBOLSETS_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseComplexSYMBOLSETS;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseComplexSYMBOLSET_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseComplexSYMBOLSET;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseOptSYMBOL_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseOptSYMBOL;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseStates_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseStates;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseStateNames_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseStateNames;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseNextName_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseNextName;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseAlt_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseAlt;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseAltTail_L1;
} // unnamed namespace

namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseAltTail;
} // unnamed namespace


#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_Current_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & G_Tokens
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 19, 0, 0},
      // </0 & Current\1/4 (/7 s.Type#2/9 t.Position#2/10 e.Info#2/5 )/8 e.OtherTokens#2/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icBracketLeftSave, 0, 5, 2},
      // closed e.OtherTokens#2 as range 2
      {refalrts::icsVarLeft, 0, 9, 5},
      {refalrts::ictVarLeftSave, 0, 10, 5},
      // closed e.Info#2 as range 5
      //DEBUG: e.OtherTokens#2: 2
      //DEBUG: s.Type#2: 9
      //DEBUG: t.Position#2: 10
      //DEBUG: e.Info#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } (/12 s.Type#2/9/13 t.Position#2/10/14 e.Info#2/5/16 )/18 Tile{ AsIs: </0 Reuse: & G-Tokens/4 AsIs: (/7 AsIs: s.Type#2/9 AsIs: t.Position#2/10 AsIs: e.Info#2/5 AsIs: )/8 AsIs: e.OtherTokens#2/2 AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 12},
      {refalrts::icCopySTVar, 13, 9, 0},
      {refalrts::icCopyEVar, 14, 10, 0},
      {refalrts::icCopyEVar, 16, 5, 0},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 18},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 7, 8, 0},
      {refalrts::icLinkBrackets, 12, 18, 0},
      {refalrts::icSetRes, 0, 0, 0},
      {refalrts::icSpliceTile, 12, 18, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_Current_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_Current_L1(
  "Current\\1",
  scope_gen_Current_L1::raa,
  scope_gen_Current_L1::functions,
  scope_gen_Current_L1::idents,
  scope_gen_Current_L1::numbers,
  scope_gen_Current_L1::strings,
  scope_gen_Current_L1::filename
);
refalrts::RefalFunction& gen_Current_L1 = descr_gen_Current_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_Current_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  // </0 & Current\1/4 (/7 s.Type#2/9 t.Position#2/10 e.Info#2/5 )/8 e.OtherTokens#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.OtherTokens#2 as range 2
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  context[11] = refalrts::tvar_left( context[10], context[5], context[6] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  // closed e.Info#2 as range 5
  //DEBUG: e.OtherTokens#2: 2
  //DEBUG: s.Type#2: 9
  //DEBUG: t.Position#2: 10
  //DEBUG: e.Info#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } (/12 s.Type#2/9/13 t.Position#2/10/14 e.Info#2/5/16 )/18 Tile{ AsIs: </0 Reuse: & G-Tokens/4 AsIs: (/7 AsIs: s.Type#2/9 AsIs: t.Position#2/10 AsIs: e.Info#2/5 AsIs: )/8 AsIs: e.OtherTokens#2/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[13], context[9]))
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[14], context[15], context[10], context[11]))
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[18] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & G_Tokens );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::link_brackets( context[12], context[18] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[0];
  res = refalrts::splice_evar( res, context[12], context[18] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_Current_L1(func_gen_Current_L1, "Current\\1");
refalrts::RefalFunction& gen_Current_L1 = descr_gen_Current_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_Current {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_Current_L1,
      & G_Tokens
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & Current/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & G-Tokens/5 >/6 & Current\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_Current

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_Current(
  "Current",
  scope_Current::raa,
  scope_Current::functions,
  scope_Current::idents,
  scope_Current::numbers,
  scope_Current::strings,
  scope_Current::filename
);
refalrts::RefalFunction& Current = descr_Current;

} // unnamed namespace

#else
static refalrts::FnResult func_Current(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Current/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & G-Tokens/5 >/6 & Current\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & G_Tokens ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_Current_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_Current(func_Current, "Current");
refalrts::RefalFunction& Current = descr_Current;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_MoveNext_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & G_Tokens
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 7, 0, 0},
      // </0 & MoveNext\1/4 t.First#2/5 e.OtherTokens#2/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::ictVarLeftSave, 0, 5, 2},
      // closed e.OtherTokens#2 as range 2
      //DEBUG: t.First#2: 5
      //DEBUG: e.OtherTokens#2: 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} t.First#2/5 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & G-Tokens/4 } Tile{ AsIs: e.OtherTokens#2/2 } Tile{ AsIs: >/1 ]] }
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_MoveNext_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_MoveNext_L1(
  "MoveNext\\1",
  scope_gen_MoveNext_L1::raa,
  scope_gen_MoveNext_L1::functions,
  scope_gen_MoveNext_L1::idents,
  scope_gen_MoveNext_L1::numbers,
  scope_gen_MoveNext_L1::strings,
  scope_gen_MoveNext_L1::filename
);
refalrts::RefalFunction& gen_MoveNext_L1 = descr_gen_MoveNext_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_MoveNext_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 7 elems
  refalrts::Iter context[7];
  refalrts::zeros( context, 7 );
  // </0 & MoveNext\1/4 t.First#2/5 e.OtherTokens#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  // closed e.OtherTokens#2 as range 2
  //DEBUG: t.First#2: 5
  //DEBUG: e.OtherTokens#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} t.First#2/5 {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & G-Tokens/4 } Tile{ AsIs: e.OtherTokens#2/2 } Tile{ AsIs: >/1 ]] }
  refalrts::update_name( context[4], & G_Tokens );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_MoveNext_L1(func_gen_MoveNext_L1, "MoveNext\\1");
refalrts::RefalFunction& gen_MoveNext_L1 = descr_gen_MoveNext_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_MoveNext {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_MoveNext_L1,
      & G_Tokens
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & MoveNext/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & G-Tokens/5 >/6 & MoveNext\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_MoveNext

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_MoveNext(
  "MoveNext",
  scope_MoveNext::raa,
  scope_MoveNext::functions,
  scope_MoveNext::idents,
  scope_MoveNext::numbers,
  scope_MoveNext::strings,
  scope_MoveNext::filename
);
refalrts::RefalFunction& MoveNext = descr_MoveNext;

} // unnamed namespace

#else
static refalrts::FnResult func_MoveNext(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & MoveNext/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & G-Tokens/5 >/6 & MoveNext\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & G_Tokens ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_MoveNext_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_MoveNext(func_MoveNext, "MoveNext");
refalrts::RefalFunction& MoveNext = descr_MoveNext;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_CurrentTag_L1 {
    static const char *filename = "Flex-Parser.cpp";
    using refalrts::functions;
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 12, 0, 0},
      // </0 & CurrentTag\1/4 (/7 s.Type#2/9 t.Position#2/10 e.Info#2/5 )/8 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icBracketLeftSave, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icsVarLeft, 0, 9, 5},
      {refalrts::ictVarLeftSave, 0, 10, 5},
      // closed e.Info#2 as range 5
      //DEBUG: s.Type#2: 9
      //DEBUG: t.Position#2: 10
      //DEBUG: e.Info#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & CurrentTag\1/4 (/7 s.Type#2/9 t.Position#2/10 e.Info#2/5 )/8 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: s.Type2 #9/1 ]] }
      {refalrts::icReinitSVar, 0, 9, 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_CurrentTag_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_CurrentTag_L1(
  "CurrentTag\\1",
  scope_gen_CurrentTag_L1::raa,
  scope_gen_CurrentTag_L1::functions,
  scope_gen_CurrentTag_L1::idents,
  scope_gen_CurrentTag_L1::numbers,
  scope_gen_CurrentTag_L1::strings,
  scope_gen_CurrentTag_L1::filename
);
refalrts::RefalFunction& gen_CurrentTag_L1 = descr_gen_CurrentTag_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_CurrentTag_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & CurrentTag\1/4 (/7 s.Type#2/9 t.Position#2/10 e.Info#2/5 )/8 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  context[11] = refalrts::tvar_left( context[10], context[5], context[6] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  // closed e.Info#2 as range 5
  //DEBUG: s.Type#2: 9
  //DEBUG: t.Position#2: 10
  //DEBUG: e.Info#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & CurrentTag\1/4 (/7 s.Type#2/9 t.Position#2/10 e.Info#2/5 )/8 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: s.Type2 #9/1 ]] }
  refalrts::reinit_svar( context[1], context[9] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_CurrentTag_L1(func_gen_CurrentTag_L1, "CurrentTag\\1");
refalrts::RefalFunction& gen_CurrentTag_L1 = descr_gen_CurrentTag_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_CurrentTag {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_CurrentTag_L1,
      & Current
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & CurrentTag/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & Current/5 >/6 & CurrentTag\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_CurrentTag

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_CurrentTag(
  "CurrentTag",
  scope_CurrentTag::raa,
  scope_CurrentTag::functions,
  scope_CurrentTag::idents,
  scope_CurrentTag::numbers,
  scope_CurrentTag::strings,
  scope_CurrentTag::filename
);
refalrts::RefalFunction& CurrentTag = descr_CurrentTag;

} // unnamed namespace

#else
static refalrts::FnResult func_CurrentTag(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & CurrentTag/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & Current/5 >/6 & CurrentTag\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_CurrentTag_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_CurrentTag(func_CurrentTag, "CurrentTag");
refalrts::RefalFunction& CurrentTag = descr_CurrentTag;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_CurrentAttr_L1 {
    static const char *filename = "Flex-Parser.cpp";
    using refalrts::functions;
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 12, 0, 0},
      // </0 & CurrentAttr\1/4 (/7 s.Type#2/9 t.Position#2/10 e.Info#2/5 )/8 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icBracketLeftSave, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icsVarLeft, 0, 9, 5},
      {refalrts::ictVarLeftSave, 0, 10, 5},
      // closed e.Info#2 as range 5
      //DEBUG: s.Type#2: 9
      //DEBUG: t.Position#2: 10
      //DEBUG: e.Info#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & CurrentAttr\1/4 (/7 s.Type#2/9 t.Position#2/10 {REMOVED TILE} )/8 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: e.Info#2/5 } Tile{ ]] }
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 5},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_CurrentAttr_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_CurrentAttr_L1(
  "CurrentAttr\\1",
  scope_gen_CurrentAttr_L1::raa,
  scope_gen_CurrentAttr_L1::functions,
  scope_gen_CurrentAttr_L1::idents,
  scope_gen_CurrentAttr_L1::numbers,
  scope_gen_CurrentAttr_L1::strings,
  scope_gen_CurrentAttr_L1::filename
);
refalrts::RefalFunction& gen_CurrentAttr_L1 = descr_gen_CurrentAttr_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_CurrentAttr_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & CurrentAttr\1/4 (/7 s.Type#2/9 t.Position#2/10 e.Info#2/5 )/8 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  context[11] = refalrts::tvar_left( context[10], context[5], context[6] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  // closed e.Info#2 as range 5
  //DEBUG: s.Type#2: 9
  //DEBUG: t.Position#2: 10
  //DEBUG: e.Info#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & CurrentAttr\1/4 (/7 s.Type#2/9 t.Position#2/10 {REMOVED TILE} )/8 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.Info#2/5 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_CurrentAttr_L1(func_gen_CurrentAttr_L1, "CurrentAttr\\1");
refalrts::RefalFunction& gen_CurrentAttr_L1 = descr_gen_CurrentAttr_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_CurrentAttr {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_CurrentAttr_L1,
      & Current
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & CurrentAttr/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & Current/5 >/6 & CurrentAttr\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_CurrentAttr

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_CurrentAttr(
  "CurrentAttr",
  scope_CurrentAttr::raa,
  scope_CurrentAttr::functions,
  scope_CurrentAttr::idents,
  scope_CurrentAttr::numbers,
  scope_CurrentAttr::strings,
  scope_CurrentAttr::filename
);
refalrts::RefalFunction& CurrentAttr = descr_CurrentAttr;

} // unnamed namespace

#else
static refalrts::FnResult func_CurrentAttr(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & CurrentAttr/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & Current/5 >/6 & CurrentAttr\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_CurrentAttr_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_CurrentAttr(func_CurrentAttr, "CurrentAttr");
refalrts::RefalFunction& CurrentAttr = descr_CurrentAttr;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_CurrentPos_L1 {
    static const char *filename = "Flex-Parser.cpp";
    using refalrts::functions;
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 12, 0, 0},
      // </0 & CurrentPos\1/4 (/7 s.Type#2/9 t.Position#2/10 e.Info#2/5 )/8 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icBracketLeftSave, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icsVarLeft, 0, 9, 5},
      {refalrts::ictVarLeftSave, 0, 10, 5},
      // closed e.Info#2 as range 5
      //DEBUG: s.Type#2: 9
      //DEBUG: t.Position#2: 10
      //DEBUG: e.Info#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & CurrentPos\1/4 (/7 s.Type#2/9 {REMOVED TILE} e.Info#2/5 )/8 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: t.Position#2/10 } Tile{ ]] }
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 10, 11, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_CurrentPos_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_CurrentPos_L1(
  "CurrentPos\\1",
  scope_gen_CurrentPos_L1::raa,
  scope_gen_CurrentPos_L1::functions,
  scope_gen_CurrentPos_L1::idents,
  scope_gen_CurrentPos_L1::numbers,
  scope_gen_CurrentPos_L1::strings,
  scope_gen_CurrentPos_L1::filename
);
refalrts::RefalFunction& gen_CurrentPos_L1 = descr_gen_CurrentPos_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_CurrentPos_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & CurrentPos\1/4 (/7 s.Type#2/9 t.Position#2/10 e.Info#2/5 )/8 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  context[11] = refalrts::tvar_left( context[10], context[5], context[6] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  // closed e.Info#2 as range 5
  //DEBUG: s.Type#2: 9
  //DEBUG: t.Position#2: 10
  //DEBUG: e.Info#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & CurrentPos\1/4 (/7 s.Type#2/9 {REMOVED TILE} e.Info#2/5 )/8 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: t.Position#2/10 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[10], context[11] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_CurrentPos_L1(func_gen_CurrentPos_L1, "CurrentPos\\1");
refalrts::RefalFunction& gen_CurrentPos_L1 = descr_gen_CurrentPos_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_CurrentPos {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_CurrentPos_L1,
      & Current
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & CurrentPos/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & Current/5 >/6 & CurrentPos\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_CurrentPos

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_CurrentPos(
  "CurrentPos",
  scope_CurrentPos::raa,
  scope_CurrentPos::functions,
  scope_CurrentPos::idents,
  scope_CurrentPos::numbers,
  scope_CurrentPos::strings,
  scope_CurrentPos::filename
);
refalrts::RefalFunction& CurrentPos = descr_CurrentPos;

} // unnamed namespace

#else
static refalrts::FnResult func_CurrentPos(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & CurrentPos/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & Current/5 >/6 & CurrentPos\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_CurrentPos_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_CurrentPos(func_CurrentPos, "CurrentPos");
refalrts::RefalFunction& CurrentPos = descr_CurrentPos;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_Expect_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & MoveNext
    };
    using refalrts::idents;
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {", but expected ", 15},
      {"expected ", 9}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 21, 0, 0},
      //FAST GEN: s.$ ( e.$ ) s.$
      //GLOBAL GEN: s.$ ( e.$ ) s.$
      // </0 & Expect\1/4 s.idx#0/5 (/8 e.idxVB#0/6 )/9 s.idxVT#0/10 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icBracketLeftSave, 0, 6, 2},
      // closed e.idxVB#0 as range 6
      {refalrts::icsVarLeft, 0, 10, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +8, 0, 0},
      // s.idx ( e.idx ) s.idx
      // </0 & Expect\1/4 s.Expected#1/5 (/8 e.ExpectedDescription#1/6 )/9 s.Expected#1/10 >/1
      {refalrts::icsRepeatTerm, 10, 5, 10},
      // closed e.ExpectedDescription#1 as range 6
      //DEBUG: s.Expected#1: 5
      //DEBUG: e.ExpectedDescription#1: 6
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Expected#1/5 (/8 e.ExpectedDescription#1/6 )/9 s.Expected#1/10 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 } Tile{ AsIs: >/1 ]] }
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx ( e.idx ) s.idx
      // </0 & Expect\1/4 s.Expected#1/5 (/8 e.ExpectedDescription#1/6 )/9 s.Unexpected#2/10 >/1
      // closed e.ExpectedDescription#1 as range 6
      //DEBUG: s.Expected#1: 5
      //DEBUG: s.Unexpected#2: 10
      //DEBUG: e.ExpectedDescription#1: 6
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Expected#1/5 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.Unexpected#2/10 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 } Tile{ HalfReuse: 'U'/8 } Tile{ HalfReuse: 'n'/9 }"expected "/11 </13 & Flex-TextFromToken/14 </15 & Current/16 >/17 >/18", but expected "/19 Tile{ AsIs: e.ExpectedDescription#1/6 } Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 13},
      {refalrts::icAllocFunc, 0, 2, 14},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 15},
      {refalrts::icAllocFunc, 0, 1, 16},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 17},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 18},
      {refalrts::icAllocString, 0, 0, 19},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitChar, 0, 'U', 8},
      {refalrts::icReinitChar, 0, 'n', 9},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 18},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 17},
      {refalrts::icPushStack, 0, 0, 15},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 6},
      {refalrts::icSpliceTile, 11, 20, 0},
      {refalrts::icSpliceTile, 9, 9, 0},
      {refalrts::icSpliceTile, 8, 8, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_Expect_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_Expect_L1(
  "Expect\\1",
  scope_gen_Expect_L1::raa,
  scope_gen_Expect_L1::functions,
  scope_gen_Expect_L1::idents,
  scope_gen_Expect_L1::numbers,
  scope_gen_Expect_L1::strings,
  scope_gen_Expect_L1::filename
);
refalrts::RefalFunction& gen_Expect_L1 = descr_gen_Expect_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_Expect_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  //FAST GEN: s.$ ( e.$ ) s.$
  //GLOBAL GEN: s.$ ( e.$ ) s.$
  // </0 & Expect\1/4 s.idx#0/5 (/8 e.idxVB#0/6 )/9 s.idxVT#0/10 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  // closed e.idxVB#0 as range 6
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // s.idx ( e.idx ) s.idx
    // </0 & Expect\1/4 s.Expected#1/5 (/8 e.ExpectedDescription#1/6 )/9 s.Expected#1/10 >/1
    if( ! refalrts::repeated_stvar_term( context[10], context[5] ) )
      continue;
    // closed e.ExpectedDescription#1 as range 6
    //DEBUG: s.Expected#1: 5
    //DEBUG: e.ExpectedDescription#1: 6

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.Expected#1/5 (/8 e.ExpectedDescription#1/6 )/9 s.Expected#1/10 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 } Tile{ AsIs: >/1 ]] }
    refalrts::update_name( context[4], & MoveNext );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx ( e.idx ) s.idx
  // </0 & Expect\1/4 s.Expected#1/5 (/8 e.ExpectedDescription#1/6 )/9 s.Unexpected#2/10 >/1
  // closed e.ExpectedDescription#1 as range 6
  //DEBUG: s.Expected#1: 5
  //DEBUG: s.Unexpected#2: 10
  //DEBUG: e.ExpectedDescription#1: 6

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Expected#1/5 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.Unexpected#2/10 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 } Tile{ HalfReuse: 'U'/8 } Tile{ HalfReuse: 'n'/9 }"expected "/11 </13 & Flex-TextFromToken/14 </15 & Current/16 >/17 >/18", but expected "/19 Tile{ AsIs: e.ExpectedDescription#1/6 } Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[11], context[12], "expected ", 9 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[16], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[19], context[20], ", but expected ", 15 ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::reinit_char( context[8], 'U' );
  refalrts::reinit_char( context[9], 'n' );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[15] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[7] );
  res = refalrts::splice_evar( res, context[11], context[20] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[8], context[8] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_Expect_L1(func_gen_Expect_L1, "Expect\\1");
refalrts::RefalFunction& gen_Expect_L1 = descr_gen_Expect_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_Expect {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_Expect_L1,
      & refalrts::create_closure,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 15, 0, 0},
      // </0 & Expect/4 s.Expected#1/5 e.ExpectedDescription#1/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      // closed e.ExpectedDescription#1 as range 2
      //DEBUG: s.Expected#1: 5
      //DEBUG: e.ExpectedDescription#1: 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 } </6 & CurrentTag/7 >/8 </9 & @create_closure@/10 & Expect\1/11 Tile{ AsIs: s.Expected#1/5 } (/12 Tile{ AsIs: e.ExpectedDescription#1/2 } )/13 >/14 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 6},
      {refalrts::icAllocFunc, 0, 3, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 9},
      {refalrts::icAllocFunc, 0, 2, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 13},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 14},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 14},
      {refalrts::icPushStack, 0, 0, 9},
      {refalrts::icLinkBrackets, 12, 13, 0},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 13, 14, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 12, 12, 0},
      {refalrts::icSpliceTile, 5, 5, 0},
      {refalrts::icSpliceTile, 6, 11, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_Expect

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_Expect(
  "Expect",
  scope_Expect::raa,
  scope_Expect::functions,
  scope_Expect::idents,
  scope_Expect::numbers,
  scope_Expect::strings,
  scope_Expect::filename
);
refalrts::RefalFunction& Expect = descr_Expect;

} // unnamed namespace

#else
static refalrts::FnResult func_Expect(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & Expect/4 s.Expected#1/5 e.ExpectedDescription#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.ExpectedDescription#1 as range 2
  //DEBUG: s.Expected#1: 5
  //DEBUG: e.ExpectedDescription#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 } </6 & CurrentTag/7 >/8 </9 & @create_closure@/10 & Expect\1/11 Tile{ AsIs: s.Expected#1/5 } (/12 Tile{ AsIs: e.ExpectedDescription#1/2 } )/13 >/14 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], & refalrts::create_closure ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & gen_Expect_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[9] );
  refalrts::link_brackets( context[12], context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[6] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[5], context[5] );
  res = refalrts::splice_evar( res, context[6], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_Expect(func_Expect, "Expect");
refalrts::RefalFunction& Expect = descr_Expect;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_Generalize {
    static const char *filename = "Flex-Parser.cpp";
    using refalrts::functions;
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 3, 0, 0},
      {refalrts::icIssueMemory, 22, 0, 0},
      //FAST GEN: s.$ e.$
      //GLOBAL GEN: s.$ e.$
      // </0 & Generalize/4 s.idx#0/5 e.idxV#0/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      // closed e.idxV#0 as range 2
      {refalrts::icOnFailGoTo, +15, 0, 0},
      // s.idx e.idx
      // </0 & Generalize/4 s.Tag#1/5 e.Generics-B#1/6 (/10 s.GenericTag#1/12 e.Tags-B#1/13 s.Tag#1/15 e.Tags-E#1/8 )/11 e.Generics-E#1/2 >/1
      {refalrts::icSave, 0, 16, 2},
      {refalrts::icEPrepare, 0, 6, 16},
      {refalrts::icEStart, 0, 6, 16},
      {refalrts::icSave, 0, 18, 16},
      {refalrts::icBracketLeftSave, 0, 8, 18},
      // closed e.Generics-E#1 as range 18(2)
      {refalrts::icsVarLeft, 0, 12, 8},
      {refalrts::icEPrepare, 0, 13, 8},
      {refalrts::icEStart, 0, 13, 8},
      {refalrts::icSave, 0, 20, 8},
      {refalrts::icsRepeatLeft, 15, 5, 20},
      // closed e.Tags-E#1 as range 20(8)
      //DEBUG: s.Tag#1: 5
      //DEBUG: e.Generics-B#1: 6
      //DEBUG: e.Generics-E#1: 2
      //DEBUG: s.GenericTag#1: 12
      //DEBUG: e.Tags-B#1: 13
      //DEBUG: e.Tags-E#1: 8
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & Generalize/4 s.Tag#1/5 e.Generics-B#1/6 (/10 s.GenericTag#1/12 e.Tags-B#1/13 s.Tag#1/15 e.Tags-E#1/20(8) )/11 e.Generics-E#1/18(2) {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: s.GenericTag1 #12/1 ]] }
      {refalrts::icReinitSVar, 0, 12, 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx e.idx
      // </0 & Generalize/4 s.Tag#1/5 e.Generics#1/2 >/1
      // closed e.Generics#1 as range 2
      //DEBUG: s.Tag#1: 5
      //DEBUG: e.Generics#1: 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & Generalize/4 s.Tag#1/5 e.Generics#1/2 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: s.Tag1 #5/1 ]] }
      {refalrts::icReinitSVar, 0, 5, 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_Generalize

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_Generalize(
  "Generalize",
  scope_Generalize::raa,
  scope_Generalize::functions,
  scope_Generalize::idents,
  scope_Generalize::numbers,
  scope_Generalize::strings,
  scope_Generalize::filename
);
refalrts::RefalFunction& Generalize = descr_Generalize;

} // unnamed namespace

#else
static refalrts::FnResult func_Generalize(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 22 elems
  refalrts::Iter context[22];
  refalrts::zeros( context, 22 );
  //FAST GEN: s.$ e.$
  //GLOBAL GEN: s.$ e.$
  // </0 & Generalize/4 s.idx#0/5 e.idxV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxV#0 as range 2
  do {
    // s.idx e.idx
    // </0 & Generalize/4 s.Tag#1/5 e.Generics-B#1/6 (/10 s.GenericTag#1/12 e.Tags-B#1/13 s.Tag#1/15 e.Tags-E#1/8 )/11 e.Generics-E#1/2 >/1
    context[16] = context[2];
    context[17] = context[3];
    context[6] = 0;
    context[7] = 0;
    refalrts::start_e_loop();
    do {
      context[18] = context[16];
      context[19] = context[17];
      context[8] = 0;
      context[9] = 0;
      context[10] = refalrts::brackets_left( context[8], context[9], context[18], context[19] );
      if( ! context[10] )
        continue;
      refalrts::bracket_pointers(context[10], context[11]);
      // closed e.Generics-E#1 as range 18(2)
      if( ! refalrts::svar_left( context[12], context[8], context[9] ) )
        continue;
      context[13] = 0;
      context[14] = 0;
      refalrts::start_e_loop();
      do {
        context[20] = context[8];
        context[21] = context[9];
        if( ! refalrts::repeated_stvar_left( context[15], context[5], context[20], context[21] ) )
          continue;
        // closed e.Tags-E#1 as range 20(8)
        //DEBUG: s.Tag#1: 5
        //DEBUG: e.Generics-B#1: 6
        //DEBUG: e.Generics-E#1: 2
        //DEBUG: s.GenericTag#1: 12
        //DEBUG: e.Tags-B#1: 13
        //DEBUG: e.Tags-E#1: 8

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} </0 & Generalize/4 s.Tag#1/5 e.Generics-B#1/6 (/10 s.GenericTag#1/12 e.Tags-B#1/13 s.Tag#1/15 e.Tags-E#1/20(8) )/11 e.Generics-E#1/18(2) {REMOVED TILE}
        //RESULT: Tile{ [[ } Tile{ HalfReuse: s.GenericTag1 #12/1 ]] }
        refalrts::reinit_svar( context[1], context[12] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[1];
        refalrts::use( res );
        refalrts::splice_to_freelist_open( trash_prev, res );
        return refalrts::cSuccess;
      } while ( refalrts::open_evar_advance( context[13], context[14], context[8], context[9] ) );
    } while ( refalrts::open_evar_advance( context[6], context[7], context[16], context[17] ) );
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx e.idx
  // </0 & Generalize/4 s.Tag#1/5 e.Generics#1/2 >/1
  // closed e.Generics#1 as range 2
  //DEBUG: s.Tag#1: 5
  //DEBUG: e.Generics#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Generalize/4 s.Tag#1/5 e.Generics#1/2 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: s.Tag1 #5/1 ]] }
  refalrts::reinit_svar( context[1], context[5] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_Generalize(func_Generalize, "Generalize");
refalrts::RefalFunction& Generalize = descr_Generalize;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_Error_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & ErrorAt
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 16, 0, 0},
      // </0 & Error\1/4 (/7 e.Message#1/5 )/8 (/11 s.Type#2/13 t.Pos#2/14 e.Info#2/9 )/12 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icBracketLeftSave, 0, 5, 2},
      {refalrts::icBracketLeftSave, 0, 9, 2},
      {refalrts::icEmpty, 0, 0, 2},
      // closed e.Message#1 as range 5
      {refalrts::icsVarLeft, 0, 13, 9},
      {refalrts::ictVarLeftSave, 0, 14, 9},
      // closed e.Info#2 as range 9
      //DEBUG: e.Message#1: 5
      //DEBUG: s.Type#2: 13
      //DEBUG: t.Pos#2: 14
      //DEBUG: e.Info#2: 9
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 (/11 s.Type#2/13 {REMOVED TILE} e.Info#2/9 )/12 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ErrorAt/4 } Tile{ AsIs: t.Pos#2/14 } Tile{ AsIs: e.Message#1/5 } Tile{ AsIs: >/1 ]] }
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 5},
      {refalrts::icSpliceTile, 14, 15, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_Error_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_Error_L1(
  "Error\\1",
  scope_gen_Error_L1::raa,
  scope_gen_Error_L1::functions,
  scope_gen_Error_L1::idents,
  scope_gen_Error_L1::numbers,
  scope_gen_Error_L1::strings,
  scope_gen_Error_L1::filename
);
refalrts::RefalFunction& gen_Error_L1 = descr_gen_Error_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_Error_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  // </0 & Error\1/4 (/7 e.Message#1/5 )/8 (/11 s.Type#2/13 t.Pos#2/14 e.Info#2/9 )/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Message#1 as range 5
  if( ! refalrts::svar_left( context[13], context[9], context[10] ) )
    return refalrts::cRecognitionImpossible;
  context[15] = refalrts::tvar_left( context[14], context[9], context[10] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  // closed e.Info#2 as range 9
  //DEBUG: e.Message#1: 5
  //DEBUG: s.Type#2: 13
  //DEBUG: t.Pos#2: 14
  //DEBUG: e.Info#2: 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 (/11 s.Type#2/13 {REMOVED TILE} e.Info#2/9 )/12 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & ErrorAt/4 } Tile{ AsIs: t.Pos#2/14 } Tile{ AsIs: e.Message#1/5 } Tile{ AsIs: >/1 ]] }
  refalrts::update_name( context[4], & ErrorAt );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_Error_L1(func_gen_Error_L1, "Error\\1");
refalrts::RefalFunction& gen_Error_L1 = descr_gen_Error_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_Error {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_Error_L1,
      & refalrts::create_closure,
      & Current
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 14, 0, 0},
      // </0 & Error/4 e.Message#1/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      // closed e.Message#1 as range 2
      //DEBUG: e.Message#1: 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 } </5 & Current/6 >/7 </8 & @create_closure@/9 & Error\1/10 (/11 Tile{ AsIs: e.Message#1/2 } )/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 5},
      {refalrts::icAllocFunc, 0, 3, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocFunc, 0, 1, 10},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icLinkBrackets, 11, 12, 0},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 12, 13, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 5, 11, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_Error

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_Error(
  "Error",
  scope_Error::raa,
  scope_Error::functions,
  scope_Error::idents,
  scope_Error::numbers,
  scope_Error::strings,
  scope_Error::filename
);
refalrts::RefalFunction& Error = descr_Error;

} // unnamed namespace

#else
static refalrts::FnResult func_Error(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  // </0 & Error/4 e.Message#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Message#1 as range 2
  //DEBUG: e.Message#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 } </5 & Current/6 >/7 </8 & @create_closure@/9 & Error\1/10 (/11 Tile{ AsIs: e.Message#1/2 } )/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & refalrts::create_closure ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], & gen_Error_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[5] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[12], context[13] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[5], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_Error(func_Error, "Error");
refalrts::RefalFunction& Error = descr_Error;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_Flex_Parse {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & G_Tokens,
      & ParseDescriptions,
      & ParseDescription
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 11, 0, 0},
      // </0 & Flex-Parse/4 e.Tokens#1/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      // closed e.Tokens#1 as range 2
      //DEBUG: e.Tokens#1: 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & G-Tokens/4 AsIs: e.Tokens#1/2 AsIs: >/1 } </5 & ParseDescription/6 >/7 </8 & ParseDescriptions/9 >/10 Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 5},
      {refalrts::icAllocFunc, 0, 2, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 1, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 10},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 10, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_Flex_Parse

} // unnamed namespace

refalrts::RASLFunction descr_Flex_Parse(
  "Flex-Parse",
  scope_Flex_Parse::raa,
  scope_Flex_Parse::functions,
  scope_Flex_Parse::idents,
  scope_Flex_Parse::numbers,
  scope_Flex_Parse::strings,
  scope_Flex_Parse::filename
);
refalrts::RefalFunction& Flex_Parse = descr_Flex_Parse;

#else
static refalrts::FnResult func_Flex_Parse(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  // </0 & Flex-Parse/4 e.Tokens#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Tokens#1 as range 2
  //DEBUG: e.Tokens#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & G-Tokens/4 AsIs: e.Tokens#1/2 AsIs: >/1 } </5 & ParseDescription/6 >/7 </8 & ParseDescriptions/9 >/10 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], & ParseDescription ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & ParseDescriptions ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[10] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & G_Tokens );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[10] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

refalrts::RefalNativeFunction descr_Flex_Parse(func_Flex_Parse, "Flex-Parse");
refalrts::RefalFunction& Flex_Parse = descr_Flex_Parse;

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseDescription_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & ParseDomain,
      & ParseSubexpr
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TEOF<int>::name,
      & ident_TStartRegexp<int>::name,
      & ident_TStateStart<int>::name,
      & ident_TName<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Expected domain or subexpr definition, but got ", 47}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 4, 0, 0},
      {refalrts::icIssueMemory, 14, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseDescription\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +9, 0, 0},
      // # TName
      // </0 & ParseDescription\1/4 # TName/5 >/1
      {refalrts::icIdentTerm, 0, 3, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseSubexpr/4 HalfReuse: >/5 } Tile{ ]] }
      {refalrts::icUpdateFunc, 0, 4, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrash, 0, 0, 5},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +9, 0, 0},
      // # TStateStart
      // </0 & ParseDescription\1/4 # TStateStart/5 >/1
      {refalrts::icIdentTerm, 0, 2, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseDomain/4 HalfReuse: >/5 } Tile{ ]] }
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrash, 0, 0, 5},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +9, 0, 0},
      // # TStartRegexp
      // </0 & ParseDescription\1/4 # TStartRegexp/5 >/1
      {refalrts::icIdentTerm, 0, 1, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseDomain/4 HalfReuse: >/5 } Tile{ ]] }
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrash, 0, 0, 5},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +5, 0, 0},
      // # TEOF
      // </0 & ParseDescription\1/4 # TEOF/5 >/1
      {refalrts::icIdentTerm, 0, 0, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseDescription\1/4 # TEOF/5 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ ]] }
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseDescription\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected domain or subexpr definition, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 0, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseDescription_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseDescription_L1(
  "ParseDescription\\1",
  scope_gen_ParseDescription_L1::raa,
  scope_gen_ParseDescription_L1::functions,
  scope_gen_ParseDescription_L1::idents,
  scope_gen_ParseDescription_L1::numbers,
  scope_gen_ParseDescription_L1::strings,
  scope_gen_ParseDescription_L1::filename
);
refalrts::RefalFunction& gen_ParseDescription_L1 = descr_gen_ParseDescription_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseDescription_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseDescription\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TName
    // </0 & ParseDescription\1/4 # TName/5 >/1
    if( ! refalrts::ident_term(  & ident_TName<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseSubexpr/4 HalfReuse: >/5 } Tile{ ]] }
    refalrts::update_name( context[4], & ParseSubexpr );
    refalrts::reinit_close_call( context[5] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[5], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TStateStart
    // </0 & ParseDescription\1/4 # TStateStart/5 >/1
    if( ! refalrts::ident_term(  & ident_TStateStart<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseDomain/4 HalfReuse: >/5 } Tile{ ]] }
    refalrts::update_name( context[4], & ParseDomain );
    refalrts::reinit_close_call( context[5] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[5], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TStartRegexp
    // </0 & ParseDescription\1/4 # TStartRegexp/5 >/1
    if( ! refalrts::ident_term(  & ident_TStartRegexp<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseDomain/4 HalfReuse: >/5 } Tile{ ]] }
    refalrts::update_name( context[4], & ParseDomain );
    refalrts::reinit_close_call( context[5] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[5], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TEOF
    // </0 & ParseDescription\1/4 # TEOF/5 >/1
    if( ! refalrts::ident_term(  & ident_TEOF<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & ParseDescription\1/4 # TEOF/5 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ ]] }
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseDescription\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected domain or subexpr definition, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "Expected domain or subexpr definition, but got ", 47 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseDescription_L1(func_gen_ParseDescription_L1, "ParseDescription\\1");
refalrts::RefalFunction& gen_ParseDescription_L1 = descr_gen_ParseDescription_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseDescription {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseDescription_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseDescription/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseDescription\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseDescription

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseDescription(
  "ParseDescription",
  scope_ParseDescription::raa,
  scope_ParseDescription::functions,
  scope_ParseDescription::idents,
  scope_ParseDescription::numbers,
  scope_ParseDescription::strings,
  scope_ParseDescription::filename
);
refalrts::RefalFunction& ParseDescription = descr_ParseDescription;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseDescription(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseDescription/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseDescription\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseDescription_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseDescription(func_ParseDescription, "ParseDescription");
refalrts::RefalFunction& ParseDescription = descr_ParseDescription;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseDescriptions_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & ParseDescription,
      & ParseDescriptions
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TEOF<int>::name,
      & ident_TStartRegexp<int>::name,
      & ident_TStateStart<int>::name,
      & ident_TName<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Expected domain or subexpr definition, but got ", 47}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 4, 0, 0},
      {refalrts::icIssueMemory, 14, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseDescriptions\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +14, 0, 0},
      // # TName
      // </0 & ParseDescriptions\1/4 # TName/5 >/1
      {refalrts::icIdentTerm, 0, 3, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseDescription/4 HalfReuse: >/5 HalfReuse: </1 } & ParseDescriptions/6 >/7 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 4, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 7},
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 7, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +14, 0, 0},
      // # TStateStart
      // </0 & ParseDescriptions\1/4 # TStateStart/5 >/1
      {refalrts::icIdentTerm, 0, 2, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseDescription/4 HalfReuse: >/5 HalfReuse: </1 } & ParseDescriptions/6 >/7 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 4, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 7},
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 7, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +14, 0, 0},
      // # TStartRegexp
      // </0 & ParseDescriptions\1/4 # TStartRegexp/5 >/1
      {refalrts::icIdentTerm, 0, 1, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseDescription/4 HalfReuse: >/5 HalfReuse: </1 } & ParseDescriptions/6 >/7 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 4, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 7},
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 7, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +5, 0, 0},
      // # TEOF
      // </0 & ParseDescriptions\1/4 # TEOF/5 >/1
      {refalrts::icIdentTerm, 0, 0, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseDescriptions\1/4 # TEOF/5 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ ]] }
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseDescriptions\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected domain or subexpr definition, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 0, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseDescriptions_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseDescriptions_L1(
  "ParseDescriptions\\1",
  scope_gen_ParseDescriptions_L1::raa,
  scope_gen_ParseDescriptions_L1::functions,
  scope_gen_ParseDescriptions_L1::idents,
  scope_gen_ParseDescriptions_L1::numbers,
  scope_gen_ParseDescriptions_L1::strings,
  scope_gen_ParseDescriptions_L1::filename
);
refalrts::RefalFunction& gen_ParseDescriptions_L1 = descr_gen_ParseDescriptions_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseDescriptions_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseDescriptions\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TName
    // </0 & ParseDescriptions\1/4 # TName/5 >/1
    if( ! refalrts::ident_term(  & ident_TName<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseDescription/4 HalfReuse: >/5 HalfReuse: </1 } & ParseDescriptions/6 >/7 Tile{ ]] }
    if( ! refalrts::alloc_name( context[6], & ParseDescriptions ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[7] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ParseDescription );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_open_call( context[1] );
    refalrts::push_stack( context[7] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TStateStart
    // </0 & ParseDescriptions\1/4 # TStateStart/5 >/1
    if( ! refalrts::ident_term(  & ident_TStateStart<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseDescription/4 HalfReuse: >/5 HalfReuse: </1 } & ParseDescriptions/6 >/7 Tile{ ]] }
    if( ! refalrts::alloc_name( context[6], & ParseDescriptions ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[7] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ParseDescription );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_open_call( context[1] );
    refalrts::push_stack( context[7] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TStartRegexp
    // </0 & ParseDescriptions\1/4 # TStartRegexp/5 >/1
    if( ! refalrts::ident_term(  & ident_TStartRegexp<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseDescription/4 HalfReuse: >/5 HalfReuse: </1 } & ParseDescriptions/6 >/7 Tile{ ]] }
    if( ! refalrts::alloc_name( context[6], & ParseDescriptions ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[7] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ParseDescription );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_open_call( context[1] );
    refalrts::push_stack( context[7] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TEOF
    // </0 & ParseDescriptions\1/4 # TEOF/5 >/1
    if( ! refalrts::ident_term(  & ident_TEOF<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & ParseDescriptions\1/4 # TEOF/5 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ ]] }
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseDescriptions\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected domain or subexpr definition, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "Expected domain or subexpr definition, but got ", 47 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseDescriptions_L1(func_gen_ParseDescriptions_L1, "ParseDescriptions\\1");
refalrts::RefalFunction& gen_ParseDescriptions_L1 = descr_gen_ParseDescriptions_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseDescriptions {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseDescriptions_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseDescriptions/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseDescriptions\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseDescriptions

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseDescriptions(
  "ParseDescriptions",
  scope_ParseDescriptions::raa,
  scope_ParseDescriptions::functions,
  scope_ParseDescriptions::idents,
  scope_ParseDescriptions::numbers,
  scope_ParseDescriptions::strings,
  scope_ParseDescriptions::filename
);
refalrts::RefalFunction& ParseDescriptions = descr_ParseDescriptions;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseDescriptions(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseDescriptions/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseDescriptions\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseDescriptions_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseDescriptions(func_ParseDescriptions, "ParseDescriptions");
refalrts::RefalFunction& ParseDescriptions = descr_ParseDescriptions;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseSubexpr_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & ParseRegexp,
      & Expect,
      & MoveNext,
      & CurrentAttr,
      & CurrentPos
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TEquals<int>::name,
      & ident_Subexpr<int>::name,
      & ident_TName<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Expected number, but got ", 25}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 22, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseSubexpr\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +35, 0, 0},
      // # TName
      // </0 & ParseSubexpr\1/4 # TName/5 >/1
      {refalrts::icIdentTerm, 0, 2, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } (/6 # Subexpr/7 </8 & CurrentPos/9 >/10 </11 & CurrentAttr/12 >/13 </14 & MoveNext/15 >/16 </17 & Expect/18 # TEquals/19 '='/20 >/21 Tile{ AsIs: </0 Reuse: & ParseRegexp/4 HalfReuse: >/5 HalfReuse: )/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 6},
      {refalrts::icAllocIdent, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 7, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 10},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 11},
      {refalrts::icAllocFunc, 0, 6, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 14},
      {refalrts::icAllocFunc, 0, 5, 15},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 16},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 17},
      {refalrts::icAllocFunc, 0, 4, 18},
      {refalrts::icAllocIdent, 0, 0, 19},
      {refalrts::icAllocChar, 0, '=', 20},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 21},
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 1},
      {refalrts::icLinkBrackets, 6, 1, 0},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 21},
      {refalrts::icPushStack, 0, 0, 17},
      {refalrts::icPushStack, 0, 0, 16},
      {refalrts::icPushStack, 0, 0, 14},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 11},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icSetRes, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 21, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseSubexpr\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected number, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 0, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseSubexpr_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseSubexpr_L1(
  "ParseSubexpr\\1",
  scope_gen_ParseSubexpr_L1::raa,
  scope_gen_ParseSubexpr_L1::functions,
  scope_gen_ParseSubexpr_L1::idents,
  scope_gen_ParseSubexpr_L1::numbers,
  scope_gen_ParseSubexpr_L1::strings,
  scope_gen_ParseSubexpr_L1::filename
);
refalrts::RefalFunction& gen_ParseSubexpr_L1 = descr_gen_ParseSubexpr_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseSubexpr_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 22 elems
  refalrts::Iter context[22];
  refalrts::zeros( context, 22 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseSubexpr\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TName
    // </0 & ParseSubexpr\1/4 # TName/5 >/1
    if( ! refalrts::ident_term(  & ident_TName<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/6 # Subexpr/7 </8 & CurrentPos/9 >/10 </11 & CurrentAttr/12 >/13 </14 & MoveNext/15 >/16 </17 & Expect/18 # TEquals/19 '='/20 >/21 Tile{ AsIs: </0 Reuse: & ParseRegexp/4 HalfReuse: >/5 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[7], & ident_Subexpr<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[9], & CurrentPos ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[12], & CurrentAttr ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[15], & MoveNext ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[18], & Expect ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[19], & ident_TEquals<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[20], '=' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ParseRegexp );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[6], context[1] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[17] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[10] );
    refalrts::push_stack( context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[6], context[21] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseSubexpr\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected number, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "Expected number, but got ", 25 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseSubexpr_L1(func_gen_ParseSubexpr_L1, "ParseSubexpr\\1");
refalrts::RefalFunction& gen_ParseSubexpr_L1 = descr_gen_ParseSubexpr_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseSubexpr {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseSubexpr_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseSubexpr/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseSubexpr\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseSubexpr

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseSubexpr(
  "ParseSubexpr",
  scope_ParseSubexpr::raa,
  scope_ParseSubexpr::functions,
  scope_ParseSubexpr::idents,
  scope_ParseSubexpr::numbers,
  scope_ParseSubexpr::strings,
  scope_ParseSubexpr::filename
);
refalrts::RefalFunction& ParseSubexpr = descr_ParseSubexpr;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseSubexpr(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseSubexpr/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseSubexpr\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseSubexpr_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseSubexpr(func_ParseSubexpr, "ParseSubexpr");
refalrts::RefalFunction& ParseSubexpr = descr_ParseSubexpr;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseDomain_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & ParseDomainTo,
      & Expect,
      & ParseDomainFrom,
      & CurrentPos
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TArrow<int>::name,
      & ident_Domain<int>::name,
      & ident_TStartRegexp<int>::name,
      & ident_TStateStart<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Expected start of a state or of a regular expression, but got ", 62},
      {"->", 2}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 2, 0, 0},
      {refalrts::icIssueMemory, 20, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseDomain\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +30, 0, 0},
      // # TStateStart
      // </0 & ParseDomain\1/4 # TStateStart/5 >/1
      {refalrts::icIdentTerm, 0, 3, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } (/6 # Domain/7 </8 & CurrentPos/9 >/10 </11 & ParseDomainFrom/12 >/13 </14 & Expect/15 # TArrow/16"->"/17 >/19 Tile{ AsIs: </0 Reuse: & ParseDomainTo/4 HalfReuse: >/5 HalfReuse: )/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 6},
      {refalrts::icAllocIdent, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 6, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 10},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 11},
      {refalrts::icAllocFunc, 0, 5, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 14},
      {refalrts::icAllocFunc, 0, 4, 15},
      {refalrts::icAllocIdent, 0, 0, 16},
      {refalrts::icAllocString, 0, 1, 17},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 19},
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 1},
      {refalrts::icLinkBrackets, 6, 1, 0},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 19},
      {refalrts::icPushStack, 0, 0, 14},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 11},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icSetRes, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 19, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +30, 0, 0},
      // # TStartRegexp
      // </0 & ParseDomain\1/4 # TStartRegexp/5 >/1
      {refalrts::icIdentTerm, 0, 2, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } (/6 # Domain/7 </8 & CurrentPos/9 >/10 </11 & ParseDomainFrom/12 >/13 </14 & Expect/15 # TArrow/16"->"/17 >/19 Tile{ AsIs: </0 Reuse: & ParseDomainTo/4 HalfReuse: >/5 HalfReuse: )/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 6},
      {refalrts::icAllocIdent, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 6, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 10},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 11},
      {refalrts::icAllocFunc, 0, 5, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 14},
      {refalrts::icAllocFunc, 0, 4, 15},
      {refalrts::icAllocIdent, 0, 0, 16},
      {refalrts::icAllocString, 0, 1, 17},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 19},
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 1},
      {refalrts::icLinkBrackets, 6, 1, 0},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 19},
      {refalrts::icPushStack, 0, 0, 14},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 11},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icSetRes, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 19, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseDomain\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected start of a state or of a regular expression, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 0, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseDomain_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseDomain_L1(
  "ParseDomain\\1",
  scope_gen_ParseDomain_L1::raa,
  scope_gen_ParseDomain_L1::functions,
  scope_gen_ParseDomain_L1::idents,
  scope_gen_ParseDomain_L1::numbers,
  scope_gen_ParseDomain_L1::strings,
  scope_gen_ParseDomain_L1::filename
);
refalrts::RefalFunction& gen_ParseDomain_L1 = descr_gen_ParseDomain_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseDomain_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 20 elems
  refalrts::Iter context[20];
  refalrts::zeros( context, 20 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseDomain\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TStateStart
    // </0 & ParseDomain\1/4 # TStateStart/5 >/1
    if( ! refalrts::ident_term(  & ident_TStateStart<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/6 # Domain/7 </8 & CurrentPos/9 >/10 </11 & ParseDomainFrom/12 >/13 </14 & Expect/15 # TArrow/16"->"/17 >/19 Tile{ AsIs: </0 Reuse: & ParseDomainTo/4 HalfReuse: >/5 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[7], & ident_Domain<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[9], & CurrentPos ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[12], & ParseDomainFrom ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[15], & Expect ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[16], & ident_TArrow<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "->", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[19] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ParseDomainTo );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[6], context[1] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[10] );
    refalrts::push_stack( context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[6], context[19] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TStartRegexp
    // </0 & ParseDomain\1/4 # TStartRegexp/5 >/1
    if( ! refalrts::ident_term(  & ident_TStartRegexp<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/6 # Domain/7 </8 & CurrentPos/9 >/10 </11 & ParseDomainFrom/12 >/13 </14 & Expect/15 # TArrow/16"->"/17 >/19 Tile{ AsIs: </0 Reuse: & ParseDomainTo/4 HalfReuse: >/5 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[7], & ident_Domain<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[9], & CurrentPos ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[12], & ParseDomainFrom ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[15], & Expect ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[16], & ident_TArrow<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "->", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[19] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ParseDomainTo );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[6], context[1] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[10] );
    refalrts::push_stack( context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[6], context[19] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseDomain\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected start of a state or of a regular expression, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "Expected start of a state or of a regular expression, but got ", 62 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseDomain_L1(func_gen_ParseDomain_L1, "ParseDomain\\1");
refalrts::RefalFunction& gen_ParseDomain_L1 = descr_gen_ParseDomain_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseDomain {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseDomain_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseDomain/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseDomain\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseDomain

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseDomain(
  "ParseDomain",
  scope_ParseDomain::raa,
  scope_ParseDomain::functions,
  scope_ParseDomain::idents,
  scope_ParseDomain::numbers,
  scope_ParseDomain::strings,
  scope_ParseDomain::filename
);
refalrts::RefalFunction& ParseDomain = descr_ParseDomain;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseDomain(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseDomain/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseDomain\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseDomain_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseDomain(func_ParseDomain, "ParseDomain");
refalrts::RefalFunction& ParseDomain = descr_ParseDomain;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseDomainFrom_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & ParseStatesOpt,
      & ParseRegexp
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TStartRegexp<int>::name,
      & ident_TStateStart<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Expected start of a state, but got ", 35}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 2, 0, 0},
      {refalrts::icIssueMemory, 14, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseDomainFrom\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +17, 0, 0},
      // # TStateStart
      // </0 & ParseDomainFrom\1/4 # TStateStart/5 >/1
      {refalrts::icIdentTerm, 0, 1, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: </4 HalfReuse: & ParseStatesOpt/5 AsIs: >/1 } )/6 </7 & ParseRegexp/8 >/9 Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 7},
      {refalrts::icAllocFunc, 0, 4, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 9},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 4},
      {refalrts::icReinitFunc, 0, 3, 5},
      {refalrts::icPushStack, 0, 0, 9},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icLinkBrackets, 0, 6, 0},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 9, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +17, 0, 0},
      // # TStartRegexp
      // </0 & ParseDomainFrom\1/4 # TStartRegexp/5 >/1
      {refalrts::icIdentTerm, 0, 0, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: </4 HalfReuse: & ParseStatesOpt/5 AsIs: >/1 } )/6 </7 & ParseRegexp/8 >/9 Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 7},
      {refalrts::icAllocFunc, 0, 4, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 9},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 4},
      {refalrts::icReinitFunc, 0, 3, 5},
      {refalrts::icPushStack, 0, 0, 9},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icLinkBrackets, 0, 6, 0},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 9, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseDomainFrom\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected start of a state, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 0, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseDomainFrom_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseDomainFrom_L1(
  "ParseDomainFrom\\1",
  scope_gen_ParseDomainFrom_L1::raa,
  scope_gen_ParseDomainFrom_L1::functions,
  scope_gen_ParseDomainFrom_L1::idents,
  scope_gen_ParseDomainFrom_L1::numbers,
  scope_gen_ParseDomainFrom_L1::strings,
  scope_gen_ParseDomainFrom_L1::filename
);
refalrts::RefalFunction& gen_ParseDomainFrom_L1 = descr_gen_ParseDomainFrom_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseDomainFrom_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseDomainFrom\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TStateStart
    // </0 & ParseDomainFrom\1/4 # TStateStart/5 >/1
    if( ! refalrts::ident_term(  & ident_TStateStart<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: </4 HalfReuse: & ParseStatesOpt/5 AsIs: >/1 } )/6 </7 & ParseRegexp/8 >/9 Tile{ ]] }
    if( ! refalrts::alloc_close_bracket( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[7] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[8], & ParseRegexp ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[9] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[0] );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & ParseStatesOpt );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[7] );
    refalrts::link_brackets( context[0], context[6] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[9] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TStartRegexp
    // </0 & ParseDomainFrom\1/4 # TStartRegexp/5 >/1
    if( ! refalrts::ident_term(  & ident_TStartRegexp<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: </4 HalfReuse: & ParseStatesOpt/5 AsIs: >/1 } )/6 </7 & ParseRegexp/8 >/9 Tile{ ]] }
    if( ! refalrts::alloc_close_bracket( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[7] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[8], & ParseRegexp ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[9] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[0] );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & ParseStatesOpt );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[7] );
    refalrts::link_brackets( context[0], context[6] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[9] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseDomainFrom\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected start of a state, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "Expected start of a state, but got ", 35 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseDomainFrom_L1(func_gen_ParseDomainFrom_L1, "ParseDomainFrom\\1");
refalrts::RefalFunction& gen_ParseDomainFrom_L1 = descr_gen_ParseDomainFrom_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseDomainFrom {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseDomainFrom_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseDomainFrom/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseDomainFrom\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseDomainFrom

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseDomainFrom(
  "ParseDomainFrom",
  scope_ParseDomainFrom::raa,
  scope_ParseDomainFrom::functions,
  scope_ParseDomainFrom::idents,
  scope_ParseDomainFrom::numbers,
  scope_ParseDomainFrom::strings,
  scope_ParseDomainFrom::filename
);
refalrts::RefalFunction& ParseDomainFrom = descr_ParseDomainFrom;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseDomainFrom(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseDomainFrom/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseDomainFrom\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseDomainFrom_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseDomainFrom(func_ParseDomainFrom, "ParseDomainFrom");
refalrts::RefalFunction& ParseDomainFrom = descr_ParseDomainFrom;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseStatesOpt_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & ParseStates
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TStateStart<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 6, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseStatesOpt\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +9, 0, 0},
      // # TStateStart
      // </0 & ParseStatesOpt\1/4 # TStateStart/5 >/1
      {refalrts::icIdentTerm, 0, 0, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseStates/4 HalfReuse: >/5 } Tile{ ]] }
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrash, 0, 0, 5},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseStatesOpt\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseStatesOpt\1/4 s.Other#2/5 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ ]] }
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseStatesOpt_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseStatesOpt_L1(
  "ParseStatesOpt\\1",
  scope_gen_ParseStatesOpt_L1::raa,
  scope_gen_ParseStatesOpt_L1::functions,
  scope_gen_ParseStatesOpt_L1::idents,
  scope_gen_ParseStatesOpt_L1::numbers,
  scope_gen_ParseStatesOpt_L1::strings,
  scope_gen_ParseStatesOpt_L1::filename
);
refalrts::RefalFunction& gen_ParseStatesOpt_L1 = descr_gen_ParseStatesOpt_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseStatesOpt_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseStatesOpt\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TStateStart
    // </0 & ParseStatesOpt\1/4 # TStateStart/5 >/1
    if( ! refalrts::ident_term(  & ident_TStateStart<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseStates/4 HalfReuse: >/5 } Tile{ ]] }
    refalrts::update_name( context[4], & ParseStates );
    refalrts::reinit_close_call( context[5] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[5], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseStatesOpt\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ParseStatesOpt\1/4 s.Other#2/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseStatesOpt_L1(func_gen_ParseStatesOpt_L1, "ParseStatesOpt\\1");
refalrts::RefalFunction& gen_ParseStatesOpt_L1 = descr_gen_ParseStatesOpt_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseStatesOpt {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseStatesOpt_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseStatesOpt/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseStatesOpt\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseStatesOpt

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseStatesOpt(
  "ParseStatesOpt",
  scope_ParseStatesOpt::raa,
  scope_ParseStatesOpt::functions,
  scope_ParseStatesOpt::idents,
  scope_ParseStatesOpt::numbers,
  scope_ParseStatesOpt::strings,
  scope_ParseStatesOpt::filename
);
refalrts::RefalFunction& ParseStatesOpt = descr_ParseStatesOpt;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseStatesOpt(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseStatesOpt/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseStatesOpt\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseStatesOpt_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseStatesOpt(func_ParseStatesOpt, "ParseStatesOpt");
refalrts::RefalFunction& ParseStatesOpt = descr_ParseStatesOpt;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseDomainTo_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & ParseFlush,
      & ParseNextStateOpt
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TFlush<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Expected named, skipped or error domain possibly followed by next state, but got ", 81}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 14, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseDomainTo\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +14, 0, 0},
      // # TFlush
      // </0 & ParseDomainTo\1/4 # TFlush/5 >/1
      {refalrts::icIdentTerm, 0, 0, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseFlush/4 HalfReuse: >/5 HalfReuse: </1 } & ParseNextStateOpt/6 >/7 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 4, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 7},
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 7, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseDomainTo\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected named, skipped or error domain possibly followed by next state, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 0, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseDomainTo_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseDomainTo_L1(
  "ParseDomainTo\\1",
  scope_gen_ParseDomainTo_L1::raa,
  scope_gen_ParseDomainTo_L1::functions,
  scope_gen_ParseDomainTo_L1::idents,
  scope_gen_ParseDomainTo_L1::numbers,
  scope_gen_ParseDomainTo_L1::strings,
  scope_gen_ParseDomainTo_L1::filename
);
refalrts::RefalFunction& gen_ParseDomainTo_L1 = descr_gen_ParseDomainTo_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseDomainTo_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseDomainTo\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TFlush
    // </0 & ParseDomainTo\1/4 # TFlush/5 >/1
    if( ! refalrts::ident_term(  & ident_TFlush<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseFlush/4 HalfReuse: >/5 HalfReuse: </1 } & ParseNextStateOpt/6 >/7 Tile{ ]] }
    if( ! refalrts::alloc_name( context[6], & ParseNextStateOpt ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[7] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ParseFlush );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_open_call( context[1] );
    refalrts::push_stack( context[7] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseDomainTo\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected named, skipped or error domain possibly followed by next state, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "Expected named, skipped or error domain possibly followed by next state, but got ", 81 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseDomainTo_L1(func_gen_ParseDomainTo_L1, "ParseDomainTo\\1");
refalrts::RefalFunction& gen_ParseDomainTo_L1 = descr_gen_ParseDomainTo_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseDomainTo {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseDomainTo_L1,
      & CurrentTag,
      & Generalize
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TErrorMessage<int>::name,
      & ident_TSkip<int>::name,
      & ident_TName<int>::name,
      & ident_TFlush<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 18, 0, 0},
      // </0 & ParseDomainTo/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & Generalize/5 </6 & CurrentTag/7 >/8 (/9 # TFlush/10 # TName/11 # TSkip/12 # TErrorMessage/13 )/14 >/15 & ParseDomainTo\1/16 >/17 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 3, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 6},
      {refalrts::icAllocFunc, 0, 2, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 9},
      {refalrts::icAllocIdent, 0, 3, 10},
      {refalrts::icAllocIdent, 0, 2, 11},
      {refalrts::icAllocIdent, 0, 1, 12},
      {refalrts::icAllocIdent, 0, 0, 13},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 14},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 15},
      {refalrts::icAllocFunc, 0, 1, 16},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 17},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 17},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 15},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icLinkBrackets, 9, 14, 0},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 17, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseDomainTo

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseDomainTo(
  "ParseDomainTo",
  scope_ParseDomainTo::raa,
  scope_ParseDomainTo::functions,
  scope_ParseDomainTo::idents,
  scope_ParseDomainTo::numbers,
  scope_ParseDomainTo::strings,
  scope_ParseDomainTo::filename
);
refalrts::RefalFunction& ParseDomainTo = descr_ParseDomainTo;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseDomainTo(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 18 elems
  refalrts::Iter context[18];
  refalrts::zeros( context, 18 );
  // </0 & ParseDomainTo/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & Generalize/5 </6 & CurrentTag/7 >/8 (/9 # TFlush/10 # TName/11 # TSkip/12 # TErrorMessage/13 )/14 >/15 & ParseDomainTo\1/16 >/17 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & Generalize ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[10], & ident_TFlush<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[11], & ident_TName<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[12], & ident_TSkip<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[13], & ident_TErrorMessage<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[16], & gen_ParseDomainTo_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[17] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[1] );
  refalrts::link_brackets( context[9], context[14] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[6] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[17] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseDomainTo(func_ParseDomainTo, "ParseDomainTo");
refalrts::RefalFunction& ParseDomainTo = descr_ParseDomainTo;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseFlush_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & MoveNext,
      & CurrentAttr
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_ErrorDomain<int>::name,
      & ident_TErrorMessage<int>::name,
      & ident_SkippedDomain<int>::name,
      & ident_TSkip<int>::name,
      & ident_NamedDomain<int>::name,
      & ident_TName<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Expected named, skipped or error domain, but got ", 49}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 3, 0, 0},
      {refalrts::icIssueMemory, 14, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseFlush\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +18, 0, 0},
      // # TName
      // </0 & ParseFlush\1/4 # TName/5 >/1
      {refalrts::icIdentTerm, 0, 5, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } (/6 # NamedDomain/7 </8 & CurrentAttr/9 >/10 Tile{ HalfReuse: )/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 6},
      {refalrts::icAllocIdent, 0, 4, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 4, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 10},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 4},
      {refalrts::icReinitFunc, 0, 3, 5},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icLinkBrackets, 6, 0, 0},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icSetRes, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 10, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +8, 0, 0},
      // # TSkip
      // </0 & ParseFlush\1/4 # TSkip/5 >/1
      {refalrts::icIdentTerm, 0, 3, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: # SkippedDomain/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
      {refalrts::icReinitIdent, 0, 2, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 4},
      {refalrts::icReinitFunc, 0, 3, 5},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +18, 0, 0},
      // # TErrorMessage
      // </0 & ParseFlush\1/4 # TErrorMessage/5 >/1
      {refalrts::icIdentTerm, 0, 1, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } (/6 # ErrorDomain/7 </8 & CurrentAttr/9 >/10 Tile{ HalfReuse: )/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 6},
      {refalrts::icAllocIdent, 0, 0, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 4, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 10},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 4},
      {refalrts::icReinitFunc, 0, 3, 5},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icLinkBrackets, 6, 0, 0},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icSetRes, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 10, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseFlush\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected named, skipped or error domain, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 0, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseFlush_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseFlush_L1(
  "ParseFlush\\1",
  scope_gen_ParseFlush_L1::raa,
  scope_gen_ParseFlush_L1::functions,
  scope_gen_ParseFlush_L1::idents,
  scope_gen_ParseFlush_L1::numbers,
  scope_gen_ParseFlush_L1::strings,
  scope_gen_ParseFlush_L1::filename
);
refalrts::RefalFunction& gen_ParseFlush_L1 = descr_gen_ParseFlush_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseFlush_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseFlush\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TName
    // </0 & ParseFlush\1/4 # TName/5 >/1
    if( ! refalrts::ident_term(  & ident_TName<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/6 # NamedDomain/7 </8 & CurrentAttr/9 >/10 Tile{ HalfReuse: )/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[7], & ident_NamedDomain<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[9], & CurrentAttr ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[10] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_close_bracket( context[0] );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & MoveNext );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[6], context[0] );
    refalrts::push_stack( context[10] );
    refalrts::push_stack( context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[6], context[10] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TSkip
    // </0 & ParseFlush\1/4 # TSkip/5 >/1
    if( ! refalrts::ident_term(  & ident_TSkip<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: # SkippedDomain/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
    refalrts::reinit_ident( context[0], & ident_SkippedDomain<int>::name );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & MoveNext );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TErrorMessage
    // </0 & ParseFlush\1/4 # TErrorMessage/5 >/1
    if( ! refalrts::ident_term(  & ident_TErrorMessage<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/6 # ErrorDomain/7 </8 & CurrentAttr/9 >/10 Tile{ HalfReuse: )/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[7], & ident_ErrorDomain<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[9], & CurrentAttr ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[10] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_close_bracket( context[0] );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & MoveNext );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[6], context[0] );
    refalrts::push_stack( context[10] );
    refalrts::push_stack( context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[6], context[10] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseFlush\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected named, skipped or error domain, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "Expected named, skipped or error domain, but got ", 49 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseFlush_L1(func_gen_ParseFlush_L1, "ParseFlush\\1");
refalrts::RefalFunction& gen_ParseFlush_L1 = descr_gen_ParseFlush_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseFlush {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseFlush_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseFlush/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseFlush\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseFlush

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseFlush(
  "ParseFlush",
  scope_ParseFlush::raa,
  scope_ParseFlush::functions,
  scope_ParseFlush::idents,
  scope_ParseFlush::numbers,
  scope_ParseFlush::strings,
  scope_ParseFlush::filename
);
refalrts::RefalFunction& ParseFlush = descr_ParseFlush;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseFlush(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseFlush/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseFlush\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseFlush_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseFlush(func_ParseFlush, "ParseFlush");
refalrts::RefalFunction& ParseFlush = descr_ParseFlush;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseNextStateOpt_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & MoveNext,
      & ParseState
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_NoNextState<int>::name,
      & ident_NextState<int>::name,
      & ident_TComma<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 11, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseNextStateOpt\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +18, 0, 0},
      // # TComma
      // </0 & ParseNextStateOpt\1/4 # TComma/5 >/1
      {refalrts::icIdentTerm, 0, 2, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: (/1 } # NextState/6 </7 & ParseState/8 >/9 )/10 Tile{ ]] }
      {refalrts::icAllocIdent, 0, 1, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 7},
      {refalrts::icAllocFunc, 0, 1, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 10},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 1},
      {refalrts::icLinkBrackets, 1, 10, 0},
      {refalrts::icPushStack, 0, 0, 9},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 10, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseNextStateOpt\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseNextStateOpt\1/4 s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: # NoNextState/1 ]] }
      {refalrts::icReinitIdent, 0, 0, 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseNextStateOpt_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseNextStateOpt_L1(
  "ParseNextStateOpt\\1",
  scope_gen_ParseNextStateOpt_L1::raa,
  scope_gen_ParseNextStateOpt_L1::functions,
  scope_gen_ParseNextStateOpt_L1::idents,
  scope_gen_ParseNextStateOpt_L1::numbers,
  scope_gen_ParseNextStateOpt_L1::strings,
  scope_gen_ParseNextStateOpt_L1::filename
);
refalrts::RefalFunction& gen_ParseNextStateOpt_L1 = descr_gen_ParseNextStateOpt_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseNextStateOpt_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseNextStateOpt\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TComma
    // </0 & ParseNextStateOpt\1/4 # TComma/5 >/1
    if( ! refalrts::ident_term(  & ident_TComma<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: (/1 } # NextState/6 </7 & ParseState/8 >/9 )/10 Tile{ ]] }
    if( ! refalrts::alloc_ident( context[6], & ident_NextState<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[7] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[8], & ParseState ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[10] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & MoveNext );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_open_bracket( context[1] );
    refalrts::link_brackets( context[1], context[10] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[7] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[10] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseNextStateOpt\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ParseNextStateOpt\1/4 s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: # NoNextState/1 ]] }
  refalrts::reinit_ident( context[1], & ident_NoNextState<int>::name );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseNextStateOpt_L1(func_gen_ParseNextStateOpt_L1, "ParseNextStateOpt\\1");
refalrts::RefalFunction& gen_ParseNextStateOpt_L1 = descr_gen_ParseNextStateOpt_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseNextStateOpt {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseNextStateOpt_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseNextStateOpt/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseNextStateOpt\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseNextStateOpt

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseNextStateOpt(
  "ParseNextStateOpt",
  scope_ParseNextStateOpt::raa,
  scope_ParseNextStateOpt::functions,
  scope_ParseNextStateOpt::idents,
  scope_ParseNextStateOpt::numbers,
  scope_ParseNextStateOpt::strings,
  scope_ParseNextStateOpt::filename
);
refalrts::RefalFunction& ParseNextStateOpt = descr_ParseNextStateOpt;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseNextStateOpt(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseNextStateOpt/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseNextStateOpt\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseNextStateOpt_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseNextStateOpt(func_ParseNextStateOpt, "ParseNextStateOpt");
refalrts::RefalFunction& ParseNextStateOpt = descr_ParseNextStateOpt;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseState_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & MoveNext,
      & Expect,
      & ParseNameOpt
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TStateEnd<int>::name,
      & ident_TStateStart<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Expected bracketed state expression, but got ", 45}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 15, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseState\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +24, 0, 0},
      // # TStateStart
      // </0 & ParseState\1/4 # TStateStart/5 >/1
      {refalrts::icIdentTerm, 0, 1, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: (/1 } </6 & ParseNameOpt/7 >/8 )/9 </10 & Expect/11 # TStateEnd/12 '>'/13 >/14 Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 6},
      {refalrts::icAllocFunc, 0, 5, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 4, 11},
      {refalrts::icAllocIdent, 0, 0, 12},
      {refalrts::icAllocChar, 0, '>', 13},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 14},
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 1},
      {refalrts::icPushStack, 0, 0, 14},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icLinkBrackets, 1, 9, 0},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 14, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseState\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected bracketed state expression, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 0, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseState_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseState_L1(
  "ParseState\\1",
  scope_gen_ParseState_L1::raa,
  scope_gen_ParseState_L1::functions,
  scope_gen_ParseState_L1::idents,
  scope_gen_ParseState_L1::numbers,
  scope_gen_ParseState_L1::strings,
  scope_gen_ParseState_L1::filename
);
refalrts::RefalFunction& gen_ParseState_L1 = descr_gen_ParseState_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseState_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseState\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TStateStart
    // </0 & ParseState\1/4 # TStateStart/5 >/1
    if( ! refalrts::ident_term(  & ident_TStateStart<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: (/1 } </6 & ParseNameOpt/7 >/8 )/9 </10 & Expect/11 # TStateEnd/12 '>'/13 >/14 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[7], & ParseNameOpt ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[11], & Expect ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[12], & ident_TStateEnd<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[13], '>' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[14] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & MoveNext );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_open_bracket( context[1] );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[10] );
    refalrts::link_brackets( context[1], context[9] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[6] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[14] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseState\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected bracketed state expression, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "Expected bracketed state expression, but got ", 45 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseState_L1(func_gen_ParseState_L1, "ParseState\\1");
refalrts::RefalFunction& gen_ParseState_L1 = descr_gen_ParseState_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseState {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseState_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseState/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseState\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseState

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseState(
  "ParseState",
  scope_ParseState::raa,
  scope_ParseState::functions,
  scope_ParseState::idents,
  scope_ParseState::numbers,
  scope_ParseState::strings,
  scope_ParseState::filename
);
refalrts::RefalFunction& ParseState = descr_ParseState;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseState(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseState/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseState\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseState_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseState(func_ParseState, "ParseState");
refalrts::RefalFunction& ParseState = descr_ParseState;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseNameOpt_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & MoveNext,
      & CurrentAttr
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TName<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 8, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseNameOpt\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +14, 0, 0},
      // # TName
      // </0 & ParseNameOpt\1/4 # TName/5 >/1
      {refalrts::icIdentTerm, 0, 0, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: </1 } & CurrentAttr/6 >/7 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 1, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 7},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 7, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseNameOpt\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseNameOpt\1/4 s.Other#2/5 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ ]] }
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseNameOpt_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseNameOpt_L1(
  "ParseNameOpt\\1",
  scope_gen_ParseNameOpt_L1::raa,
  scope_gen_ParseNameOpt_L1::functions,
  scope_gen_ParseNameOpt_L1::idents,
  scope_gen_ParseNameOpt_L1::numbers,
  scope_gen_ParseNameOpt_L1::strings,
  scope_gen_ParseNameOpt_L1::filename
);
refalrts::RefalFunction& gen_ParseNameOpt_L1 = descr_gen_ParseNameOpt_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseNameOpt_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseNameOpt\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TName
    // </0 & ParseNameOpt\1/4 # TName/5 >/1
    if( ! refalrts::ident_term(  & ident_TName<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: </1 } & CurrentAttr/6 >/7 Tile{ ]] }
    if( ! refalrts::alloc_name( context[6], & CurrentAttr ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[7] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & MoveNext );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_open_call( context[1] );
    refalrts::push_stack( context[7] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseNameOpt\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ParseNameOpt\1/4 s.Other#2/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseNameOpt_L1(func_gen_ParseNameOpt_L1, "ParseNameOpt\\1");
refalrts::RefalFunction& gen_ParseNameOpt_L1 = descr_gen_ParseNameOpt_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseNameOpt {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseNameOpt_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseNameOpt/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseNameOpt\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseNameOpt

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseNameOpt(
  "ParseNameOpt",
  scope_ParseNameOpt::raa,
  scope_ParseNameOpt::functions,
  scope_ParseNameOpt::idents,
  scope_ParseNameOpt::numbers,
  scope_ParseNameOpt::strings,
  scope_ParseNameOpt::filename
);
refalrts::RefalFunction& ParseNameOpt = descr_ParseNameOpt;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseNameOpt(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseNameOpt/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseNameOpt\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseNameOpt_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseNameOpt(func_ParseNameOpt, "ParseNameOpt");
refalrts::RefalFunction& ParseNameOpt = descr_ParseNameOpt;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseRegexp_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & MoveNext,
      & Expect,
      & ParseAlt
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TEndRegexp<int>::name,
      & ident_Regexp<int>::name,
      & ident_TStartRegexp<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Expected bracketed regular expression or <<EOF>>, but got ", 58}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 16, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseRegexp\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +25, 0, 0},
      // # TStartRegexp
      // </0 & ParseRegexp\1/4 # TStartRegexp/5 >/1
      {refalrts::icIdentTerm, 0, 2, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: (/1 } # Regexp/6 </7 & ParseAlt/8 >/9 )/10 </11 & Expect/12 # TEndRegexp/13 '/'/14 >/15 Tile{ ]] }
      {refalrts::icAllocIdent, 0, 1, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 7},
      {refalrts::icAllocFunc, 0, 5, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 10},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 11},
      {refalrts::icAllocFunc, 0, 4, 12},
      {refalrts::icAllocIdent, 0, 0, 13},
      {refalrts::icAllocChar, 0, '/', 14},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 15},
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 1},
      {refalrts::icPushStack, 0, 0, 15},
      {refalrts::icPushStack, 0, 0, 11},
      {refalrts::icLinkBrackets, 1, 10, 0},
      {refalrts::icPushStack, 0, 0, 9},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 15, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseRegexp\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected bracketed regular expression or <<EOF>>, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 0, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseRegexp_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseRegexp_L1(
  "ParseRegexp\\1",
  scope_gen_ParseRegexp_L1::raa,
  scope_gen_ParseRegexp_L1::functions,
  scope_gen_ParseRegexp_L1::idents,
  scope_gen_ParseRegexp_L1::numbers,
  scope_gen_ParseRegexp_L1::strings,
  scope_gen_ParseRegexp_L1::filename
);
refalrts::RefalFunction& gen_ParseRegexp_L1 = descr_gen_ParseRegexp_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseRegexp_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseRegexp\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TStartRegexp
    // </0 & ParseRegexp\1/4 # TStartRegexp/5 >/1
    if( ! refalrts::ident_term(  & ident_TStartRegexp<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: (/1 } # Regexp/6 </7 & ParseAlt/8 >/9 )/10 </11 & Expect/12 # TEndRegexp/13 '/'/14 >/15 Tile{ ]] }
    if( ! refalrts::alloc_ident( context[6], & ident_Regexp<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[7] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[8], & ParseAlt ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[12], & Expect ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[13], & ident_TEndRegexp<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[14], '/' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[15] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & MoveNext );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_open_bracket( context[1] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[11] );
    refalrts::link_brackets( context[1], context[10] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[7] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[15] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseRegexp\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected bracketed regular expression or <<EOF>>, but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "Expected bracketed regular expression or <<EOF>>, but got ", 58 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseRegexp_L1(func_gen_ParseRegexp_L1, "ParseRegexp\\1");
refalrts::RefalFunction& gen_ParseRegexp_L1 = descr_gen_ParseRegexp_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseRegexp {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseRegexp_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseRegexp/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseRegexp\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseRegexp

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseRegexp(
  "ParseRegexp",
  scope_ParseRegexp::raa,
  scope_ParseRegexp::functions,
  scope_ParseRegexp::idents,
  scope_ParseRegexp::numbers,
  scope_ParseRegexp::strings,
  scope_ParseRegexp::filename
);
refalrts::RefalFunction& ParseRegexp = descr_ParseRegexp;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseRegexp(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseRegexp/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseRegexp\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseRegexp_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseRegexp(func_ParseRegexp, "ParseRegexp");
refalrts::RefalFunction& ParseRegexp = descr_ParseRegexp;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseComplexTerm_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & ParseTerm,
      & ParseComplexTerm
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_ComplexTermSYMBOL<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 8, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseComplexTerm\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +14, 0, 0},
      // # ComplexTermSYMBOL
      // </0 & ParseComplexTerm\1/4 # ComplexTermSYMBOL/5 >/1
      {refalrts::icIdentTerm, 0, 0, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseTerm/4 HalfReuse: >/5 HalfReuse: </1 } & ParseComplexTerm/6 >/7 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 1, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 7},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 7, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseComplexTerm\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseComplexTerm\1/4 s.Other#2/5 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ ]] }
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseComplexTerm_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseComplexTerm_L1(
  "ParseComplexTerm\\1",
  scope_gen_ParseComplexTerm_L1::raa,
  scope_gen_ParseComplexTerm_L1::functions,
  scope_gen_ParseComplexTerm_L1::idents,
  scope_gen_ParseComplexTerm_L1::numbers,
  scope_gen_ParseComplexTerm_L1::strings,
  scope_gen_ParseComplexTerm_L1::filename
);
refalrts::RefalFunction& gen_ParseComplexTerm_L1 = descr_gen_ParseComplexTerm_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseComplexTerm_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseComplexTerm\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # ComplexTermSYMBOL
    // </0 & ParseComplexTerm\1/4 # ComplexTermSYMBOL/5 >/1
    if( ! refalrts::ident_term(  & ident_ComplexTermSYMBOL<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseTerm/4 HalfReuse: >/5 HalfReuse: </1 } & ParseComplexTerm/6 >/7 Tile{ ]] }
    if( ! refalrts::alloc_name( context[6], & ParseComplexTerm ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[7] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ParseTerm );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_open_call( context[1] );
    refalrts::push_stack( context[7] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseComplexTerm\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ParseComplexTerm\1/4 s.Other#2/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseComplexTerm_L1(func_gen_ParseComplexTerm_L1, "ParseComplexTerm\\1");
refalrts::RefalFunction& gen_ParseComplexTerm_L1 = descr_gen_ParseComplexTerm_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseComplexTerm {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseComplexTerm_L1,
      & CurrentTag,
      & Generalize
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TOpenBracket<int>::name,
      & ident_TChar<int>::name,
      & ident_TInclude<int>::name,
      & ident_TStartGroup<int>::name,
      & ident_TAny<int>::name,
      & ident_ComplexTermSYMBOL<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 20, 0, 0},
      // </0 & ParseComplexTerm/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & Generalize/5 </6 & CurrentTag/7 >/8 (/9 # ComplexTermSYMBOL/10 # TAny/11 # TStartGroup/12 # TInclude/13 # TChar/14 # TOpenBracket/15 )/16 >/17 & ParseComplexTerm\1/18 >/19 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 3, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 6},
      {refalrts::icAllocFunc, 0, 2, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 9},
      {refalrts::icAllocIdent, 0, 5, 10},
      {refalrts::icAllocIdent, 0, 4, 11},
      {refalrts::icAllocIdent, 0, 3, 12},
      {refalrts::icAllocIdent, 0, 2, 13},
      {refalrts::icAllocIdent, 0, 1, 14},
      {refalrts::icAllocIdent, 0, 0, 15},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 16},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 17},
      {refalrts::icAllocFunc, 0, 1, 18},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 19},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 19},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 17},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icLinkBrackets, 9, 16, 0},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 19, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseComplexTerm

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseComplexTerm(
  "ParseComplexTerm",
  scope_ParseComplexTerm::raa,
  scope_ParseComplexTerm::functions,
  scope_ParseComplexTerm::idents,
  scope_ParseComplexTerm::numbers,
  scope_ParseComplexTerm::strings,
  scope_ParseComplexTerm::filename
);
refalrts::RefalFunction& ParseComplexTerm = descr_ParseComplexTerm;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseComplexTerm(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 20 elems
  refalrts::Iter context[20];
  refalrts::zeros( context, 20 );
  // </0 & ParseComplexTerm/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & Generalize/5 </6 & CurrentTag/7 >/8 (/9 # ComplexTermSYMBOL/10 # TAny/11 # TStartGroup/12 # TInclude/13 # TChar/14 # TOpenBracket/15 )/16 >/17 & ParseComplexTerm\1/18 >/19 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & Generalize ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[10], & ident_ComplexTermSYMBOL<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[11], & ident_TAny<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[12], & ident_TStartGroup<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[13], & ident_TInclude<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[14], & ident_TChar<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[15], & ident_TOpenBracket<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[18], & gen_ParseComplexTerm_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[19] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[19] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[1] );
  refalrts::link_brackets( context[9], context[16] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[6] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[19] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseComplexTerm(func_ParseComplexTerm, "ParseComplexTerm");
refalrts::RefalFunction& ParseComplexTerm = descr_ParseComplexTerm;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseTerm_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & ParseRepeater,
      & ParseSimpleTerm
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_Term<int>::name,
      & ident_TermSYMBOL<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Expected a symbol, starting group, include, open bracket expression but got ", 76}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 14, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseTerm\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +18, 0, 0},
      // # TermSYMBOL
      // </0 & ParseTerm\1/4 # TermSYMBOL/5 >/1
      {refalrts::icIdentTerm, 0, 1, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } (/6 # Term/7 </8 & ParseSimpleTerm/9 >/10 Tile{ AsIs: </0 Reuse: & ParseRepeater/4 HalfReuse: >/5 HalfReuse: )/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 6},
      {refalrts::icAllocIdent, 0, 0, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 4, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 10},
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 1},
      {refalrts::icLinkBrackets, 6, 1, 0},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icSetRes, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 10, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseTerm\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected a symbol, starting group, include, open bracket expression but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 0, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseTerm_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseTerm_L1(
  "ParseTerm\\1",
  scope_gen_ParseTerm_L1::raa,
  scope_gen_ParseTerm_L1::functions,
  scope_gen_ParseTerm_L1::idents,
  scope_gen_ParseTerm_L1::numbers,
  scope_gen_ParseTerm_L1::strings,
  scope_gen_ParseTerm_L1::filename
);
refalrts::RefalFunction& gen_ParseTerm_L1 = descr_gen_ParseTerm_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseTerm_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseTerm\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TermSYMBOL
    // </0 & ParseTerm\1/4 # TermSYMBOL/5 >/1
    if( ! refalrts::ident_term(  & ident_TermSYMBOL<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/6 # Term/7 </8 & ParseSimpleTerm/9 >/10 Tile{ AsIs: </0 Reuse: & ParseRepeater/4 HalfReuse: >/5 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[7], & ident_Term<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[9], & ParseSimpleTerm ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[10] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ParseRepeater );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[6], context[1] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[10] );
    refalrts::push_stack( context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[6], context[10] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseTerm\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected a symbol, starting group, include, open bracket expression but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "Expected a symbol, starting group, include, open bracket expression but got ", 76 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseTerm_L1(func_gen_ParseTerm_L1, "ParseTerm\\1");
refalrts::RefalFunction& gen_ParseTerm_L1 = descr_gen_ParseTerm_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseTerm {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseTerm_L1,
      & CurrentTag,
      & Generalize
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TOpenBracket<int>::name,
      & ident_TChar<int>::name,
      & ident_TInclude<int>::name,
      & ident_TStartGroup<int>::name,
      & ident_TAny<int>::name,
      & ident_TermSYMBOL<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 20, 0, 0},
      // </0 & ParseTerm/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & Generalize/5 </6 & CurrentTag/7 >/8 (/9 # TermSYMBOL/10 # TAny/11 # TStartGroup/12 # TInclude/13 # TChar/14 # TOpenBracket/15 )/16 >/17 & ParseTerm\1/18 >/19 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 3, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 6},
      {refalrts::icAllocFunc, 0, 2, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 9},
      {refalrts::icAllocIdent, 0, 5, 10},
      {refalrts::icAllocIdent, 0, 4, 11},
      {refalrts::icAllocIdent, 0, 3, 12},
      {refalrts::icAllocIdent, 0, 2, 13},
      {refalrts::icAllocIdent, 0, 1, 14},
      {refalrts::icAllocIdent, 0, 0, 15},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 16},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 17},
      {refalrts::icAllocFunc, 0, 1, 18},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 19},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 19},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 17},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icLinkBrackets, 9, 16, 0},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 19, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseTerm

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseTerm(
  "ParseTerm",
  scope_ParseTerm::raa,
  scope_ParseTerm::functions,
  scope_ParseTerm::idents,
  scope_ParseTerm::numbers,
  scope_ParseTerm::strings,
  scope_ParseTerm::filename
);
refalrts::RefalFunction& ParseTerm = descr_ParseTerm;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseTerm(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 20 elems
  refalrts::Iter context[20];
  refalrts::zeros( context, 20 );
  // </0 & ParseTerm/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & Generalize/5 </6 & CurrentTag/7 >/8 (/9 # TermSYMBOL/10 # TAny/11 # TStartGroup/12 # TInclude/13 # TChar/14 # TOpenBracket/15 )/16 >/17 & ParseTerm\1/18 >/19 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & Generalize ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[10], & ident_TermSYMBOL<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[11], & ident_TAny<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[12], & ident_TStartGroup<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[13], & ident_TInclude<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[14], & ident_TChar<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[15], & ident_TOpenBracket<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[18], & gen_ParseTerm_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[19] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[19] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[1] );
  refalrts::link_brackets( context[9], context[16] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[6] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[19] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseTerm(func_ParseTerm, "ParseTerm");
refalrts::RefalFunction& ParseTerm = descr_ParseTerm;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseRepeater_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & MoveNext
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_Optional<int>::name,
      & ident_TOptional<int>::name,
      & ident_ManyOne<int>::name,
      & ident_TOneMany<int>::name,
      & ident_ManyZero<int>::name,
      & ident_TZeroMany<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 3, 0, 0},
      {refalrts::icIssueMemory, 6, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseRepeater\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +8, 0, 0},
      // # TZeroMany
      // </0 & ParseRepeater\1/4 # TZeroMany/5 >/1
      {refalrts::icIdentTerm, 0, 5, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: # ManyZero/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
      {refalrts::icReinitIdent, 0, 4, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 4},
      {refalrts::icReinitFunc, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +8, 0, 0},
      // # TOneMany
      // </0 & ParseRepeater\1/4 # TOneMany/5 >/1
      {refalrts::icIdentTerm, 0, 3, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: # ManyOne/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
      {refalrts::icReinitIdent, 0, 2, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 4},
      {refalrts::icReinitFunc, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +8, 0, 0},
      // # TOptional
      // </0 & ParseRepeater\1/4 # TOptional/5 >/1
      {refalrts::icIdentTerm, 0, 1, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: # Optional/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
      {refalrts::icReinitIdent, 0, 0, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 4},
      {refalrts::icReinitFunc, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseRepeater\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseRepeater\1/4 s.Other#2/5 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ ]] }
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseRepeater_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseRepeater_L1(
  "ParseRepeater\\1",
  scope_gen_ParseRepeater_L1::raa,
  scope_gen_ParseRepeater_L1::functions,
  scope_gen_ParseRepeater_L1::idents,
  scope_gen_ParseRepeater_L1::numbers,
  scope_gen_ParseRepeater_L1::strings,
  scope_gen_ParseRepeater_L1::filename
);
refalrts::RefalFunction& gen_ParseRepeater_L1 = descr_gen_ParseRepeater_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseRepeater_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseRepeater\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TZeroMany
    // </0 & ParseRepeater\1/4 # TZeroMany/5 >/1
    if( ! refalrts::ident_term(  & ident_TZeroMany<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: # ManyZero/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
    refalrts::reinit_ident( context[0], & ident_ManyZero<int>::name );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & MoveNext );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TOneMany
    // </0 & ParseRepeater\1/4 # TOneMany/5 >/1
    if( ! refalrts::ident_term(  & ident_TOneMany<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: # ManyOne/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
    refalrts::reinit_ident( context[0], & ident_ManyOne<int>::name );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & MoveNext );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TOptional
    // </0 & ParseRepeater\1/4 # TOptional/5 >/1
    if( ! refalrts::ident_term(  & ident_TOptional<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: # Optional/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
    refalrts::reinit_ident( context[0], & ident_Optional<int>::name );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & MoveNext );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseRepeater\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ParseRepeater\1/4 s.Other#2/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseRepeater_L1(func_gen_ParseRepeater_L1, "ParseRepeater\\1");
refalrts::RefalFunction& gen_ParseRepeater_L1 = descr_gen_ParseRepeater_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseRepeater {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseRepeater_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseRepeater/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseRepeater\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseRepeater

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseRepeater(
  "ParseRepeater",
  scope_ParseRepeater::raa,
  scope_ParseRepeater::functions,
  scope_ParseRepeater::idents,
  scope_ParseRepeater::numbers,
  scope_ParseRepeater::strings,
  scope_ParseRepeater::filename
);
refalrts::RefalFunction& ParseRepeater = descr_ParseRepeater;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseRepeater(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseRepeater/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseRepeater\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseRepeater_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseRepeater(func_ParseRepeater, "ParseRepeater");
refalrts::RefalFunction& ParseRepeater = descr_ParseRepeater;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseSimpleTerm_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & MoveNext,
      & Expect,
      & ParseAlt,
      & CurrentAttr,
      & ParseSet
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TCloseBracket<int>::name,
      & ident_Alt<int>::name,
      & ident_TOpenBracket<int>::name,
      & ident_Char<int>::name,
      & ident_TChar<int>::name,
      & ident_NamedRegexp<int>::name,
      & ident_TInclude<int>::name,
      & ident_TStartGroup<int>::name,
      & ident_AnyChar<int>::name,
      & ident_TAny<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Expected any symbol, set of symbols, expression in brackets but got ", 68}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 5, 0, 0},
      {refalrts::icIssueMemory, 16, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseSimpleTerm\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +8, 0, 0},
      // # TAny
      // </0 & ParseSimpleTerm\1/4 # TAny/5 >/1
      {refalrts::icIdentTerm, 0, 9, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: # AnyChar/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
      {refalrts::icReinitIdent, 0, 8, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 4},
      {refalrts::icReinitFunc, 0, 3, 5},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +9, 0, 0},
      // # TStartGroup
      // </0 & ParseSimpleTerm\1/4 # TStartGroup/5 >/1
      {refalrts::icIdentTerm, 0, 7, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseSet/4 HalfReuse: >/5 } Tile{ ]] }
      {refalrts::icUpdateFunc, 0, 7, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrash, 0, 0, 5},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +18, 0, 0},
      // # TInclude
      // </0 & ParseSimpleTerm\1/4 # TInclude/5 >/1
      {refalrts::icIdentTerm, 0, 6, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } (/6 # NamedRegexp/7 </8 & CurrentAttr/9 >/10 Tile{ HalfReuse: )/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 6},
      {refalrts::icAllocIdent, 0, 5, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 6, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 10},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 4},
      {refalrts::icReinitFunc, 0, 3, 5},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icLinkBrackets, 6, 0, 0},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icSetRes, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 10, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +18, 0, 0},
      // # TChar
      // </0 & ParseSimpleTerm\1/4 # TChar/5 >/1
      {refalrts::icIdentTerm, 0, 4, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } (/6 # Char/7 </8 & CurrentAttr/9 >/10 Tile{ HalfReuse: )/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 6},
      {refalrts::icAllocIdent, 0, 3, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 6, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 10},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 4},
      {refalrts::icReinitFunc, 0, 3, 5},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icLinkBrackets, 6, 0, 0},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icSetRes, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 10, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      {refalrts::icOnFailGoTo, +25, 0, 0},
      // # TOpenBracket
      // </0 & ParseSimpleTerm\1/4 # TOpenBracket/5 >/1
      {refalrts::icIdentTerm, 0, 2, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: (/1 } # Alt/6 </7 & ParseAlt/8 >/9 )/10 </11 & Expect/12 # TCloseBracket/13 ')'/14 >/15 Tile{ ]] }
      {refalrts::icAllocIdent, 0, 1, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 7},
      {refalrts::icAllocFunc, 0, 5, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 10},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 11},
      {refalrts::icAllocFunc, 0, 4, 12},
      {refalrts::icAllocIdent, 0, 0, 13},
      {refalrts::icAllocChar, 0, ')', 14},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 15},
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 1},
      {refalrts::icPushStack, 0, 0, 15},
      {refalrts::icPushStack, 0, 0, 11},
      {refalrts::icLinkBrackets, 1, 10, 0},
      {refalrts::icPushStack, 0, 0, 9},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 15, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseSimpleTerm\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected any symbol, set of symbols, expression in brackets but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 0, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseSimpleTerm_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseSimpleTerm_L1(
  "ParseSimpleTerm\\1",
  scope_gen_ParseSimpleTerm_L1::raa,
  scope_gen_ParseSimpleTerm_L1::functions,
  scope_gen_ParseSimpleTerm_L1::idents,
  scope_gen_ParseSimpleTerm_L1::numbers,
  scope_gen_ParseSimpleTerm_L1::strings,
  scope_gen_ParseSimpleTerm_L1::filename
);
refalrts::RefalFunction& gen_ParseSimpleTerm_L1 = descr_gen_ParseSimpleTerm_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseSimpleTerm_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseSimpleTerm\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TAny
    // </0 & ParseSimpleTerm\1/4 # TAny/5 >/1
    if( ! refalrts::ident_term(  & ident_TAny<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: # AnyChar/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
    refalrts::reinit_ident( context[0], & ident_AnyChar<int>::name );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & MoveNext );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TStartGroup
    // </0 & ParseSimpleTerm\1/4 # TStartGroup/5 >/1
    if( ! refalrts::ident_term(  & ident_TStartGroup<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseSet/4 HalfReuse: >/5 } Tile{ ]] }
    refalrts::update_name( context[4], & ParseSet );
    refalrts::reinit_close_call( context[5] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[5], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TInclude
    // </0 & ParseSimpleTerm\1/4 # TInclude/5 >/1
    if( ! refalrts::ident_term(  & ident_TInclude<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/6 # NamedRegexp/7 </8 & CurrentAttr/9 >/10 Tile{ HalfReuse: )/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[7], & ident_NamedRegexp<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[9], & CurrentAttr ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[10] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_close_bracket( context[0] );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & MoveNext );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[6], context[0] );
    refalrts::push_stack( context[10] );
    refalrts::push_stack( context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[6], context[10] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TChar
    // </0 & ParseSimpleTerm\1/4 # TChar/5 >/1
    if( ! refalrts::ident_term(  & ident_TChar<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/6 # Char/7 </8 & CurrentAttr/9 >/10 Tile{ HalfReuse: )/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[7], & ident_Char<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[9], & CurrentAttr ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[10] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_close_bracket( context[0] );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & MoveNext );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[6], context[0] );
    refalrts::push_stack( context[10] );
    refalrts::push_stack( context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[6], context[10] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # TOpenBracket
    // </0 & ParseSimpleTerm\1/4 # TOpenBracket/5 >/1
    if( ! refalrts::ident_term(  & ident_TOpenBracket<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: (/1 } # Alt/6 </7 & ParseAlt/8 >/9 )/10 </11 & Expect/12 # TCloseBracket/13 ')'/14 >/15 Tile{ ]] }
    if( ! refalrts::alloc_ident( context[6], & ident_Alt<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[7] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[8], & ParseAlt ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[12], & Expect ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[13], & ident_TCloseBracket<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[14], ')' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[15] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & MoveNext );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_open_bracket( context[1] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[11] );
    refalrts::link_brackets( context[1], context[10] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[7] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[15] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseSimpleTerm\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected any symbol, set of symbols, expression in brackets but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "Expected any symbol, set of symbols, expression in brackets but got ", 68 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseSimpleTerm_L1(func_gen_ParseSimpleTerm_L1, "ParseSimpleTerm\\1");
refalrts::RefalFunction& gen_ParseSimpleTerm_L1 = descr_gen_ParseSimpleTerm_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseSimpleTerm {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseSimpleTerm_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseSimpleTerm/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseSimpleTerm\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseSimpleTerm

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseSimpleTerm(
  "ParseSimpleTerm",
  scope_ParseSimpleTerm::raa,
  scope_ParseSimpleTerm::functions,
  scope_ParseSimpleTerm::idents,
  scope_ParseSimpleTerm::numbers,
  scope_ParseSimpleTerm::strings,
  scope_ParseSimpleTerm::filename
);
refalrts::RefalFunction& ParseSimpleTerm = descr_ParseSimpleTerm;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseSimpleTerm(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseSimpleTerm/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseSimpleTerm\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseSimpleTerm_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseSimpleTerm(func_ParseSimpleTerm, "ParseSimpleTerm");
refalrts::RefalFunction& ParseSimpleTerm = descr_ParseSimpleTerm;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseSet_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & MoveNext,
      & Expect,
      & ParseComplexSYMBOLSETS,
      & ParseComplexSYMBOLSET,
      & ParseInvertOpt
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TEndGroup<int>::name,
      & ident_NamedGroup<int>::name,
      & ident_TStartGroup<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Expected expression in square brackets but got ", 47}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 22, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseSet\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +35, 0, 0},
      // # TStartGroup
      // </0 & ParseSet\1/4 # TStartGroup/5 >/1
      {refalrts::icIdentTerm, 0, 2, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: (/1 } # NamedGroup/6 </7 & ParseInvertOpt/8 >/9 </10 & ParseComplexSYMBOLSET/11 >/12 </13 & ParseComplexSYMBOLSETS/14 >/15 </16 & Expect/17 # TEndGroup/18 ']'/19 >/20 )/21 Tile{ ]] }
      {refalrts::icAllocIdent, 0, 1, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 7},
      {refalrts::icAllocFunc, 0, 7, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 6, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 13},
      {refalrts::icAllocFunc, 0, 5, 14},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 15},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 16},
      {refalrts::icAllocFunc, 0, 4, 17},
      {refalrts::icAllocIdent, 0, 0, 18},
      {refalrts::icAllocChar, 0, ']', 19},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 20},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 21},
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 1},
      {refalrts::icLinkBrackets, 1, 21, 0},
      {refalrts::icPushStack, 0, 0, 20},
      {refalrts::icPushStack, 0, 0, 16},
      {refalrts::icPushStack, 0, 0, 15},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icPushStack, 0, 0, 9},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 21, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseSet\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected expression in square brackets but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 0, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseSet_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseSet_L1(
  "ParseSet\\1",
  scope_gen_ParseSet_L1::raa,
  scope_gen_ParseSet_L1::functions,
  scope_gen_ParseSet_L1::idents,
  scope_gen_ParseSet_L1::numbers,
  scope_gen_ParseSet_L1::strings,
  scope_gen_ParseSet_L1::filename
);
refalrts::RefalFunction& gen_ParseSet_L1 = descr_gen_ParseSet_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseSet_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 22 elems
  refalrts::Iter context[22];
  refalrts::zeros( context, 22 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseSet\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TStartGroup
    // </0 & ParseSet\1/4 # TStartGroup/5 >/1
    if( ! refalrts::ident_term(  & ident_TStartGroup<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: (/1 } # NamedGroup/6 </7 & ParseInvertOpt/8 >/9 </10 & ParseComplexSYMBOLSET/11 >/12 </13 & ParseComplexSYMBOLSETS/14 >/15 </16 & Expect/17 # TEndGroup/18 ']'/19 >/20 )/21 Tile{ ]] }
    if( ! refalrts::alloc_ident( context[6], & ident_NamedGroup<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[7] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[8], & ParseInvertOpt ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[11], & ParseComplexSYMBOLSET ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[14], & ParseComplexSYMBOLSETS ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[17], & Expect ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[18], & ident_TEndGroup<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[19], ']' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & MoveNext );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_open_bracket( context[1] );
    refalrts::link_brackets( context[1], context[21] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[10] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[7] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[21] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseSet\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected expression in square brackets but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "Expected expression in square brackets but got ", 47 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseSet_L1(func_gen_ParseSet_L1, "ParseSet\\1");
refalrts::RefalFunction& gen_ParseSet_L1 = descr_gen_ParseSet_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseSet {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseSet_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseSet/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseSet\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseSet

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseSet(
  "ParseSet",
  scope_ParseSet::raa,
  scope_ParseSet::functions,
  scope_ParseSet::idents,
  scope_ParseSet::numbers,
  scope_ParseSet::strings,
  scope_ParseSet::filename
);
refalrts::RefalFunction& ParseSet = descr_ParseSet;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseSet(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseSet/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseSet\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseSet_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseSet(func_ParseSet, "ParseSet");
refalrts::RefalFunction& ParseSet = descr_ParseSet;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseInvertOpt_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & MoveNext
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_Direct<int>::name,
      & ident_Inverted<int>::name,
      & ident_TInvertGroup<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 6, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseInvertOpt\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +8, 0, 0},
      // # TInvertGroup
      // </0 & ParseInvertOpt\1/4 # TInvertGroup/5 >/1
      {refalrts::icIdentTerm, 0, 2, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: # Inverted/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
      {refalrts::icReinitIdent, 0, 1, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 4},
      {refalrts::icReinitFunc, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseInvertOpt\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseInvertOpt\1/4 s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: # Direct/1 ]] }
      {refalrts::icReinitIdent, 0, 0, 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseInvertOpt_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseInvertOpt_L1(
  "ParseInvertOpt\\1",
  scope_gen_ParseInvertOpt_L1::raa,
  scope_gen_ParseInvertOpt_L1::functions,
  scope_gen_ParseInvertOpt_L1::idents,
  scope_gen_ParseInvertOpt_L1::numbers,
  scope_gen_ParseInvertOpt_L1::strings,
  scope_gen_ParseInvertOpt_L1::filename
);
refalrts::RefalFunction& gen_ParseInvertOpt_L1 = descr_gen_ParseInvertOpt_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseInvertOpt_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseInvertOpt\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TInvertGroup
    // </0 & ParseInvertOpt\1/4 # TInvertGroup/5 >/1
    if( ! refalrts::ident_term(  & ident_TInvertGroup<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: # Inverted/0 HalfReuse: </4 HalfReuse: & MoveNext/5 AsIs: >/1 ]] }
    refalrts::reinit_ident( context[0], & ident_Inverted<int>::name );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & MoveNext );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseInvertOpt\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ParseInvertOpt\1/4 s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: # Direct/1 ]] }
  refalrts::reinit_ident( context[1], & ident_Direct<int>::name );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseInvertOpt_L1(func_gen_ParseInvertOpt_L1, "ParseInvertOpt\\1");
refalrts::RefalFunction& gen_ParseInvertOpt_L1 = descr_gen_ParseInvertOpt_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseInvertOpt {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseInvertOpt_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseInvertOpt/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseInvertOpt\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseInvertOpt

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseInvertOpt(
  "ParseInvertOpt",
  scope_ParseInvertOpt::raa,
  scope_ParseInvertOpt::functions,
  scope_ParseInvertOpt::idents,
  scope_ParseInvertOpt::numbers,
  scope_ParseInvertOpt::strings,
  scope_ParseInvertOpt::filename
);
refalrts::RefalFunction& ParseInvertOpt = descr_ParseInvertOpt;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseInvertOpt(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseInvertOpt/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseInvertOpt\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseInvertOpt_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseInvertOpt(func_ParseInvertOpt, "ParseInvertOpt");
refalrts::RefalFunction& ParseInvertOpt = descr_ParseInvertOpt;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseComplexSYMBOLSETS_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & ParseComplexSYMBOLSET,
      & ParseComplexSYMBOLSETS
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TChar<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 8, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseComplexSYMBOLSETS\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +14, 0, 0},
      // # TChar
      // </0 & ParseComplexSYMBOLSETS\1/4 # TChar/5 >/1
      {refalrts::icIdentTerm, 0, 0, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseComplexSYMBOLSET/4 HalfReuse: >/5 HalfReuse: </1 } & ParseComplexSYMBOLSETS/6 >/7 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 1, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 7},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 7, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseComplexSYMBOLSETS\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseComplexSYMBOLSETS\1/4 s.Other#2/5 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ ]] }
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseComplexSYMBOLSETS_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseComplexSYMBOLSETS_L1(
  "ParseComplexSYMBOLSETS\\1",
  scope_gen_ParseComplexSYMBOLSETS_L1::raa,
  scope_gen_ParseComplexSYMBOLSETS_L1::functions,
  scope_gen_ParseComplexSYMBOLSETS_L1::idents,
  scope_gen_ParseComplexSYMBOLSETS_L1::numbers,
  scope_gen_ParseComplexSYMBOLSETS_L1::strings,
  scope_gen_ParseComplexSYMBOLSETS_L1::filename
);
refalrts::RefalFunction& gen_ParseComplexSYMBOLSETS_L1 = descr_gen_ParseComplexSYMBOLSETS_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseComplexSYMBOLSETS_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseComplexSYMBOLSETS\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TChar
    // </0 & ParseComplexSYMBOLSETS\1/4 # TChar/5 >/1
    if( ! refalrts::ident_term(  & ident_TChar<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseComplexSYMBOLSET/4 HalfReuse: >/5 HalfReuse: </1 } & ParseComplexSYMBOLSETS/6 >/7 Tile{ ]] }
    if( ! refalrts::alloc_name( context[6], & ParseComplexSYMBOLSETS ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[7] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ParseComplexSYMBOLSET );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_open_call( context[1] );
    refalrts::push_stack( context[7] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseComplexSYMBOLSETS\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ParseComplexSYMBOLSETS\1/4 s.Other#2/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseComplexSYMBOLSETS_L1(func_gen_ParseComplexSYMBOLSETS_L1, "ParseComplexSYMBOLSETS\\1");
refalrts::RefalFunction& gen_ParseComplexSYMBOLSETS_L1 = descr_gen_ParseComplexSYMBOLSETS_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseComplexSYMBOLSETS {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseComplexSYMBOLSETS_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseComplexSYMBOLSETS/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseComplexSYMBOLSETS\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseComplexSYMBOLSETS

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseComplexSYMBOLSETS(
  "ParseComplexSYMBOLSETS",
  scope_ParseComplexSYMBOLSETS::raa,
  scope_ParseComplexSYMBOLSETS::functions,
  scope_ParseComplexSYMBOLSETS::idents,
  scope_ParseComplexSYMBOLSETS::numbers,
  scope_ParseComplexSYMBOLSETS::strings,
  scope_ParseComplexSYMBOLSETS::filename
);
refalrts::RefalFunction& ParseComplexSYMBOLSETS = descr_ParseComplexSYMBOLSETS;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseComplexSYMBOLSETS(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseComplexSYMBOLSETS/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseComplexSYMBOLSETS\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseComplexSYMBOLSETS_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseComplexSYMBOLSETS(func_ParseComplexSYMBOLSETS, "ParseComplexSYMBOLSETS");
refalrts::RefalFunction& ParseComplexSYMBOLSETS = descr_ParseComplexSYMBOLSETS;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseComplexSYMBOLSET_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & ParseOptSYMBOL,
      & MoveNext,
      & CurrentAttr
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TChar<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Expected symbol or pair of symbols but got ", 43}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 14, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseComplexSYMBOLSET\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +22, 0, 0},
      // # TChar
      // </0 & ParseComplexSYMBOLSET\1/4 # TChar/5 >/1
      {refalrts::icIdentTerm, 0, 0, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } (/6 </7 & CurrentAttr/8 >/9 </10 & MoveNext/11 >/12 Tile{ AsIs: </0 Reuse: & ParseOptSYMBOL/4 HalfReuse: >/5 HalfReuse: )/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 7},
      {refalrts::icAllocFunc, 0, 5, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 4, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 1},
      {refalrts::icLinkBrackets, 6, 1, 0},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icPushStack, 0, 0, 9},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icSetRes, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 12, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseComplexSYMBOLSET\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected symbol or pair of symbols but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 0, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseComplexSYMBOLSET_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseComplexSYMBOLSET_L1(
  "ParseComplexSYMBOLSET\\1",
  scope_gen_ParseComplexSYMBOLSET_L1::raa,
  scope_gen_ParseComplexSYMBOLSET_L1::functions,
  scope_gen_ParseComplexSYMBOLSET_L1::idents,
  scope_gen_ParseComplexSYMBOLSET_L1::numbers,
  scope_gen_ParseComplexSYMBOLSET_L1::strings,
  scope_gen_ParseComplexSYMBOLSET_L1::filename
);
refalrts::RefalFunction& gen_ParseComplexSYMBOLSET_L1 = descr_gen_ParseComplexSYMBOLSET_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseComplexSYMBOLSET_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseComplexSYMBOLSET\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TChar
    // </0 & ParseComplexSYMBOLSET\1/4 # TChar/5 >/1
    if( ! refalrts::ident_term(  & ident_TChar<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/6 </7 & CurrentAttr/8 >/9 </10 & MoveNext/11 >/12 Tile{ AsIs: </0 Reuse: & ParseOptSYMBOL/4 HalfReuse: >/5 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[7] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[8], & CurrentAttr ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[11], & MoveNext ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[12] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ParseOptSYMBOL );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[6], context[1] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[10] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[7] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[6], context[12] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseComplexSYMBOLSET\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected symbol or pair of symbols but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "Expected symbol or pair of symbols but got ", 43 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseComplexSYMBOLSET_L1(func_gen_ParseComplexSYMBOLSET_L1, "ParseComplexSYMBOLSET\\1");
refalrts::RefalFunction& gen_ParseComplexSYMBOLSET_L1 = descr_gen_ParseComplexSYMBOLSET_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseComplexSYMBOLSET {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseComplexSYMBOLSET_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseComplexSYMBOLSET/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseComplexSYMBOLSET\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseComplexSYMBOLSET

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseComplexSYMBOLSET(
  "ParseComplexSYMBOLSET",
  scope_ParseComplexSYMBOLSET::raa,
  scope_ParseComplexSYMBOLSET::functions,
  scope_ParseComplexSYMBOLSET::idents,
  scope_ParseComplexSYMBOLSET::numbers,
  scope_ParseComplexSYMBOLSET::strings,
  scope_ParseComplexSYMBOLSET::filename
);
refalrts::RefalFunction& ParseComplexSYMBOLSET = descr_ParseComplexSYMBOLSET;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseComplexSYMBOLSET(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseComplexSYMBOLSET/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseComplexSYMBOLSET\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseComplexSYMBOLSET_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseComplexSYMBOLSET(func_ParseComplexSYMBOLSET, "ParseComplexSYMBOLSET");
refalrts::RefalFunction& ParseComplexSYMBOLSET = descr_ParseComplexSYMBOLSET;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseOptSYMBOL_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Expect,
      & CurrentAttr,
      & MoveNext
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TChar<int>::name,
      & ident_TGroupRange<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 12, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseOptSYMBOL\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +19, 0, 0},
      // # TGroupRange
      // </0 & ParseOptSYMBOL\1/4 # TGroupRange/5 >/1
      {refalrts::icIdentTerm, 0, 1, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </6 & MoveNext/7 >/8 </9 & CurrentAttr/10 >/11 Tile{ AsIs: </0 Reuse: & Expect/4 Reuse: # TChar/5 AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 6},
      {refalrts::icAllocFunc, 0, 2, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 9},
      {refalrts::icAllocFunc, 0, 1, 10},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 11},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icUpdateIdent, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 11},
      {refalrts::icPushStack, 0, 0, 9},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icSetRes, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 11, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseOptSYMBOL\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseOptSYMBOL\1/4 s.Other#2/5 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ ]] }
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseOptSYMBOL_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseOptSYMBOL_L1(
  "ParseOptSYMBOL\\1",
  scope_gen_ParseOptSYMBOL_L1::raa,
  scope_gen_ParseOptSYMBOL_L1::functions,
  scope_gen_ParseOptSYMBOL_L1::idents,
  scope_gen_ParseOptSYMBOL_L1::numbers,
  scope_gen_ParseOptSYMBOL_L1::strings,
  scope_gen_ParseOptSYMBOL_L1::filename
);
refalrts::RefalFunction& gen_ParseOptSYMBOL_L1 = descr_gen_ParseOptSYMBOL_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseOptSYMBOL_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseOptSYMBOL\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TGroupRange
    // </0 & ParseOptSYMBOL\1/4 # TGroupRange/5 >/1
    if( ! refalrts::ident_term(  & ident_TGroupRange<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </6 & MoveNext/7 >/8 </9 & CurrentAttr/10 >/11 Tile{ AsIs: </0 Reuse: & Expect/4 Reuse: # TChar/5 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[7], & MoveNext ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], & CurrentAttr ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[11] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & Expect );
    refalrts::update_ident( context[5], & ident_TChar<int>::name );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[6] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[6], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseOptSYMBOL\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ParseOptSYMBOL\1/4 s.Other#2/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseOptSYMBOL_L1(func_gen_ParseOptSYMBOL_L1, "ParseOptSYMBOL\\1");
refalrts::RefalFunction& gen_ParseOptSYMBOL_L1 = descr_gen_ParseOptSYMBOL_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseOptSYMBOL {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseOptSYMBOL_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseOptSYMBOL/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseOptSYMBOL\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseOptSYMBOL

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseOptSYMBOL(
  "ParseOptSYMBOL",
  scope_ParseOptSYMBOL::raa,
  scope_ParseOptSYMBOL::functions,
  scope_ParseOptSYMBOL::idents,
  scope_ParseOptSYMBOL::numbers,
  scope_ParseOptSYMBOL::strings,
  scope_ParseOptSYMBOL::filename
);
refalrts::RefalFunction& ParseOptSYMBOL = descr_ParseOptSYMBOL;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseOptSYMBOL(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseOptSYMBOL/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseOptSYMBOL\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseOptSYMBOL_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseOptSYMBOL(func_ParseOptSYMBOL, "ParseOptSYMBOL");
refalrts::RefalFunction& ParseOptSYMBOL = descr_ParseOptSYMBOL;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseStates_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & MoveNext,
      & Expect,
      & ParseStateNames
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TStateEnd<int>::name,
      & ident_TStateStart<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Expected state names surrounded by brackets but got ", 52}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 15, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseStates\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +24, 0, 0},
      // # TStateStart
      // </0 & ParseStates\1/4 # TStateStart/5 >/1
      {refalrts::icIdentTerm, 0, 1, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: (/1 } </6 & ParseStateNames/7 >/8 )/9 </10 & Expect/11 # TStateEnd/12 '>'/13 >/14 Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 6},
      {refalrts::icAllocFunc, 0, 5, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 4, 11},
      {refalrts::icAllocIdent, 0, 0, 12},
      {refalrts::icAllocChar, 0, '>', 13},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 14},
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 1},
      {refalrts::icPushStack, 0, 0, 14},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icLinkBrackets, 1, 9, 0},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 14, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseStates\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected state names surrounded by brackets but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 0, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseStates_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseStates_L1(
  "ParseStates\\1",
  scope_gen_ParseStates_L1::raa,
  scope_gen_ParseStates_L1::functions,
  scope_gen_ParseStates_L1::idents,
  scope_gen_ParseStates_L1::numbers,
  scope_gen_ParseStates_L1::strings,
  scope_gen_ParseStates_L1::filename
);
refalrts::RefalFunction& gen_ParseStates_L1 = descr_gen_ParseStates_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseStates_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseStates\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TStateStart
    // </0 & ParseStates\1/4 # TStateStart/5 >/1
    if( ! refalrts::ident_term(  & ident_TStateStart<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: (/1 } </6 & ParseStateNames/7 >/8 )/9 </10 & Expect/11 # TStateEnd/12 '>'/13 >/14 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[7], & ParseStateNames ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[11], & Expect ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[12], & ident_TStateEnd<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[13], '>' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[14] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & MoveNext );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_open_bracket( context[1] );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[10] );
    refalrts::link_brackets( context[1], context[9] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[6] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[14] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseStates\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected state names surrounded by brackets but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "Expected state names surrounded by brackets but got ", 52 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseStates_L1(func_gen_ParseStates_L1, "ParseStates\\1");
refalrts::RefalFunction& gen_ParseStates_L1 = descr_gen_ParseStates_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseStates {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseStates_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseStates/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseStates\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseStates

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseStates(
  "ParseStates",
  scope_ParseStates::raa,
  scope_ParseStates::functions,
  scope_ParseStates::idents,
  scope_ParseStates::numbers,
  scope_ParseStates::strings,
  scope_ParseStates::filename
);
refalrts::RefalFunction& ParseStates = descr_ParseStates;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseStates(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseStates/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseStates\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseStates_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseStates(func_ParseStates, "ParseStates");
refalrts::RefalFunction& ParseStates = descr_ParseStates;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseStateNames_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & ParseNextName,
      & MoveNext,
      & CurrentAttr
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_Name<int>::name,
      & ident_TName<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 16, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseStateNames\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +26, 0, 0},
      // # TName
      // </0 & ParseStateNames\1/4 # TName/5 >/1
      {refalrts::icIdentTerm, 0, 1, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } (/6 # Name/7 </8 & CurrentAttr/9 >/10 )/11 </12 & MoveNext/13 >/14 (/15 Tile{ AsIs: </0 Reuse: & ParseNextName/4 HalfReuse: >/5 HalfReuse: )/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 6},
      {refalrts::icAllocIdent, 0, 0, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 10},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 12},
      {refalrts::icAllocFunc, 0, 1, 13},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 14},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 15},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 1},
      {refalrts::icLinkBrackets, 15, 1, 0},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 14},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icLinkBrackets, 6, 11, 0},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icSetRes, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 15, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseStateNames\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseStateNames\1/4 s.Other#2/5 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ ]] }
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseStateNames_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseStateNames_L1(
  "ParseStateNames\\1",
  scope_gen_ParseStateNames_L1::raa,
  scope_gen_ParseStateNames_L1::functions,
  scope_gen_ParseStateNames_L1::idents,
  scope_gen_ParseStateNames_L1::numbers,
  scope_gen_ParseStateNames_L1::strings,
  scope_gen_ParseStateNames_L1::filename
);
refalrts::RefalFunction& gen_ParseStateNames_L1 = descr_gen_ParseStateNames_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseStateNames_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseStateNames\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TName
    // </0 & ParseStateNames\1/4 # TName/5 >/1
    if( ! refalrts::ident_term(  & ident_TName<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/6 # Name/7 </8 & CurrentAttr/9 >/10 )/11 </12 & MoveNext/13 >/14 (/15 Tile{ AsIs: </0 Reuse: & ParseNextName/4 HalfReuse: >/5 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[7], & ident_Name<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[9], & CurrentAttr ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[13], & MoveNext ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[15] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ParseNextName );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[15], context[1] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[12] );
    refalrts::link_brackets( context[6], context[11] );
    refalrts::push_stack( context[10] );
    refalrts::push_stack( context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[6], context[15] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseStateNames\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ParseStateNames\1/4 s.Other#2/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseStateNames_L1(func_gen_ParseStateNames_L1, "ParseStateNames\\1");
refalrts::RefalFunction& gen_ParseStateNames_L1 = descr_gen_ParseStateNames_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseStateNames {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseStateNames_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseStateNames/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseStateNames\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseStateNames

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseStateNames(
  "ParseStateNames",
  scope_ParseStateNames::raa,
  scope_ParseStateNames::functions,
  scope_ParseStateNames::idents,
  scope_ParseStateNames::numbers,
  scope_ParseStateNames::strings,
  scope_ParseStateNames::filename
);
refalrts::RefalFunction& ParseStateNames = descr_ParseStateNames;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseStateNames(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseStateNames/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseStateNames\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseStateNames_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseStateNames(func_ParseStateNames, "ParseStateNames");
refalrts::RefalFunction& ParseStateNames = descr_ParseStateNames;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseNextName_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & MoveNext,
      & ParseNextName,
      & Expect
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TName<int>::name,
      & ident_TComma<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 14, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseNextName\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +23, 0, 0},
      // # TComma
      // </0 & ParseNextName\1/4 # TComma/5 >/1
      {refalrts::icIdentTerm, 0, 1, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: </1 } & Expect/6 # TName/7 >/8 (/9 </10 & ParseNextName/11 >/12 )/13 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 6},
      {refalrts::icAllocIdent, 0, 0, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icLinkBrackets, 9, 13, 0},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseNextName\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseNextName\1/4 s.Other#2/5 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ ]] }
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseNextName_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseNextName_L1(
  "ParseNextName\\1",
  scope_gen_ParseNextName_L1::raa,
  scope_gen_ParseNextName_L1::functions,
  scope_gen_ParseNextName_L1::idents,
  scope_gen_ParseNextName_L1::numbers,
  scope_gen_ParseNextName_L1::strings,
  scope_gen_ParseNextName_L1::filename
);
refalrts::RefalFunction& gen_ParseNextName_L1 = descr_gen_ParseNextName_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseNextName_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseNextName\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TComma
    // </0 & ParseNextName\1/4 # TComma/5 >/1
    if( ! refalrts::ident_term(  & ident_TComma<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: </1 } & Expect/6 # TName/7 >/8 (/9 </10 & ParseNextName/11 >/12 )/13 Tile{ ]] }
    if( ! refalrts::alloc_name( context[6], & Expect ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[7], & ident_TName<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[11], & ParseNextName ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[13] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & MoveNext );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_open_call( context[1] );
    refalrts::link_brackets( context[9], context[13] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[10] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseNextName\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ParseNextName\1/4 s.Other#2/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseNextName_L1(func_gen_ParseNextName_L1, "ParseNextName\\1");
refalrts::RefalFunction& gen_ParseNextName_L1 = descr_gen_ParseNextName_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseNextName {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseNextName_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseNextName/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseNextName\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseNextName

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseNextName(
  "ParseNextName",
  scope_ParseNextName::raa,
  scope_ParseNextName::functions,
  scope_ParseNextName::idents,
  scope_ParseNextName::numbers,
  scope_ParseNextName::strings,
  scope_ParseNextName::filename
);
refalrts::RefalFunction& ParseNextName = descr_ParseNextName;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseNextName(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseNextName/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseNextName\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseNextName_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseNextName(func_ParseNextName, "ParseNextName");
refalrts::RefalFunction& ParseNextName = descr_ParseNextName;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseAlt_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Error,
      & Current,
      & Flex_TextFromToken,
      & ParseComplexTerm,
      & ParseAltTail
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_ComplexTermSYMBOL<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Expected regular expression but got ", 36}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 14, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseAlt\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +17, 0, 0},
      // # ComplexTermSYMBOL
      // </0 & ParseAlt\1/4 # ComplexTermSYMBOL/5 >/1
      {refalrts::icIdentTerm, 0, 0, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: </4 HalfReuse: & ParseComplexTerm/5 AsIs: >/1 } )/6 </7 & ParseAltTail/8 >/9 Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 7},
      {refalrts::icAllocFunc, 0, 4, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 9},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 4},
      {refalrts::icReinitFunc, 0, 3, 5},
      {refalrts::icPushStack, 0, 0, 9},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icLinkBrackets, 0, 6, 0},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 9, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseAlt\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected regular expression but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocString, 0, 0, 6},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icAllocFunc, 0, 2, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 6, 13, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseAlt_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseAlt_L1(
  "ParseAlt\\1",
  scope_gen_ParseAlt_L1::raa,
  scope_gen_ParseAlt_L1::functions,
  scope_gen_ParseAlt_L1::idents,
  scope_gen_ParseAlt_L1::numbers,
  scope_gen_ParseAlt_L1::strings,
  scope_gen_ParseAlt_L1::filename
);
refalrts::RefalFunction& gen_ParseAlt_L1 = descr_gen_ParseAlt_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseAlt_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseAlt\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # ComplexTermSYMBOL
    // </0 & ParseAlt\1/4 # ComplexTermSYMBOL/5 >/1
    if( ! refalrts::ident_term(  & ident_ComplexTermSYMBOL<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: </4 HalfReuse: & ParseComplexTerm/5 AsIs: >/1 } )/6 </7 & ParseAltTail/8 >/9 Tile{ ]] }
    if( ! refalrts::alloc_close_bracket( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[7] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[8], & ParseAltTail ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[9] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[0] );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & ParseComplexTerm );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[7] );
    refalrts::link_brackets( context[0], context[6] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[9] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseAlt\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Other#2/5 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Error/4 }"Expected regular expression but got "/6 </8 & Flex-TextFromToken/9 </10 & Current/11 >/12 >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "Expected regular expression but got ", 36 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & Flex_TextFromToken ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & Current ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Error );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseAlt_L1(func_gen_ParseAlt_L1, "ParseAlt\\1");
refalrts::RefalFunction& gen_ParseAlt_L1 = descr_gen_ParseAlt_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseAlt {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseAlt_L1,
      & CurrentTag,
      & Generalize
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TAlt<int>::name,
      & ident_TOpenBracket<int>::name,
      & ident_TChar<int>::name,
      & ident_TInclude<int>::name,
      & ident_TStartGroup<int>::name,
      & ident_TAny<int>::name,
      & ident_ComplexTermSYMBOL<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 21, 0, 0},
      // </0 & ParseAlt/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & Generalize/5 </6 & CurrentTag/7 >/8 (/9 # ComplexTermSYMBOL/10 # TAny/11 # TStartGroup/12 # TInclude/13 # TChar/14 # TOpenBracket/15 # TAlt/16 )/17 >/18 & ParseAlt\1/19 >/20 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 3, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 6},
      {refalrts::icAllocFunc, 0, 2, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 9},
      {refalrts::icAllocIdent, 0, 6, 10},
      {refalrts::icAllocIdent, 0, 5, 11},
      {refalrts::icAllocIdent, 0, 4, 12},
      {refalrts::icAllocIdent, 0, 3, 13},
      {refalrts::icAllocIdent, 0, 2, 14},
      {refalrts::icAllocIdent, 0, 1, 15},
      {refalrts::icAllocIdent, 0, 0, 16},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 17},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 18},
      {refalrts::icAllocFunc, 0, 1, 19},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 20},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 20},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 18},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icLinkBrackets, 9, 17, 0},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 20, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseAlt

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseAlt(
  "ParseAlt",
  scope_ParseAlt::raa,
  scope_ParseAlt::functions,
  scope_ParseAlt::idents,
  scope_ParseAlt::numbers,
  scope_ParseAlt::strings,
  scope_ParseAlt::filename
);
refalrts::RefalFunction& ParseAlt = descr_ParseAlt;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseAlt(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & ParseAlt/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & Generalize/5 </6 & CurrentTag/7 >/8 (/9 # ComplexTermSYMBOL/10 # TAny/11 # TStartGroup/12 # TInclude/13 # TChar/14 # TOpenBracket/15 # TAlt/16 )/17 >/18 & ParseAlt\1/19 >/20 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & Generalize ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[10], & ident_ComplexTermSYMBOL<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[11], & ident_TAny<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[12], & ident_TStartGroup<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[13], & ident_TInclude<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[14], & ident_TChar<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[15], & ident_TOpenBracket<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[16], & ident_TAlt<int>::name ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], & gen_ParseAlt_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[1] );
  refalrts::link_brackets( context[9], context[17] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[6] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[20] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseAlt(func_ParseAlt, "ParseAlt");
refalrts::RefalFunction& ParseAlt = descr_ParseAlt;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseAltTail_L1 {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & MoveNext,
      & ParseAltTail,
      & ParseComplexTerm
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TAlt<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 13, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseAltTail\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +22, 0, 0},
      // # TAlt
      // </0 & ParseAltTail\1/4 # TAlt/5 >/1
      {refalrts::icIdentTerm, 0, 0, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: (/1 } </6 & ParseComplexTerm/7 >/8 )/9 </10 & ParseAltTail/11 >/12 Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 6},
      {refalrts::icAllocFunc, 0, 2, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 5},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 1},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icLinkBrackets, 1, 9, 0},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 5},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 6, 12, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icProfilerStopSentence, 0, 0, 0},
      // s.idx
      // </0 & ParseAltTail\1/4 s.Other#2/5 >/1
      //DEBUG: s.Other#2: 5
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseAltTail\1/4 s.Other#2/5 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ ]] }
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseAltTail_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseAltTail_L1(
  "ParseAltTail\\1",
  scope_gen_ParseAltTail_L1::raa,
  scope_gen_ParseAltTail_L1::functions,
  scope_gen_ParseAltTail_L1::idents,
  scope_gen_ParseAltTail_L1::numbers,
  scope_gen_ParseAltTail_L1::strings,
  scope_gen_ParseAltTail_L1::filename
);
refalrts::RefalFunction& gen_ParseAltTail_L1 = descr_gen_ParseAltTail_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseAltTail_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseAltTail\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # TAlt
    // </0 & ParseAltTail\1/4 # TAlt/5 >/1
    if( ! refalrts::ident_term(  & ident_TAlt<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & MoveNext/4 HalfReuse: >/5 HalfReuse: (/1 } </6 & ParseComplexTerm/7 >/8 )/9 </10 & ParseAltTail/11 >/12 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[7], & ParseComplexTerm ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[11], & ParseAltTail ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[12] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & MoveNext );
    refalrts::reinit_close_call( context[5] );
    refalrts::reinit_open_bracket( context[1] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[10] );
    refalrts::link_brackets( context[1], context[9] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[6] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[12] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & ParseAltTail\1/4 s.Other#2/5 >/1
  //DEBUG: s.Other#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ParseAltTail\1/4 s.Other#2/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_gen_ParseAltTail_L1(func_gen_ParseAltTail_L1, "ParseAltTail\\1");
refalrts::RefalFunction& gen_ParseAltTail_L1 = descr_gen_ParseAltTail_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseAltTail {
    static const char *filename = "Flex-Parser.cpp";
    static refalrts::RefalFunction *functions[] = {
      & Fetch,
      & gen_ParseAltTail_L1,
      & CurrentTag
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icThisIsGeneratedFunction, 0, 0, 0},
      {refalrts::icLoadConstants, 0, 0, 0},
      {refalrts::icIssueMemory, 9, 0, 0},
      // </0 & ParseAltTail/4 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseAltTail\1/7 >/8 Tile{ ]] }
      {refalrts::icAllocFunc, 0, 2, 5},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 6},
      {refalrts::icAllocFunc, 0, 1, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 1},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 6},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 8, 0},
      {refalrts::icNextStep, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseAltTail

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseAltTail(
  "ParseAltTail",
  scope_ParseAltTail::raa,
  scope_ParseAltTail::functions,
  scope_ParseAltTail::idents,
  scope_ParseAltTail::numbers,
  scope_ParseAltTail::strings,
  scope_ParseAltTail::filename
);
refalrts::RefalFunction& ParseAltTail = descr_ParseAltTail;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseAltTail(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ParseAltTail/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 HalfReuse: </1 } & CurrentTag/5 >/6 & ParseAltTail\1/7 >/8 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & CurrentTag ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & gen_ParseAltTail_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalNativeFunction descr_ParseAltTail(func_ParseAltTail, "ParseAltTail");
refalrts::RefalFunction& ParseAltTail = descr_ParseAltTail;

} // unnamed namespace

#endif

//End of file
