// Automatically generated file. Don't edit!
#include "refalrts.h"


const refalrts::RefalIdentifier ident_ARG_BEGIN = refalrts::ident_from_static("ARG-BEGIN");
const refalrts::RefalIdentifier ident_AlgLeft = refalrts::ident_from_static("AlgLeft");
const refalrts::RefalIdentifier ident_AlgRight = refalrts::ident_from_static("AlgRight");
const refalrts::RefalIdentifier ident_AlgTerm = refalrts::ident_from_static("AlgTerm");
const refalrts::RefalIdentifier ident_Allocate = refalrts::ident_from_static("Allocate");
const refalrts::RefalIdentifier ident_CmdADT = refalrts::ident_from_static("CmdADT");
const refalrts::RefalIdentifier ident_CmdADTSave = refalrts::ident_from_static("CmdADTSave");
const refalrts::RefalIdentifier ident_CmdBrackets = refalrts::ident_from_static("CmdBrackets");
const refalrts::RefalIdentifier ident_CmdBracketsSave = refalrts::ident_from_static("CmdBracketsSave");
const refalrts::RefalIdentifier ident_CmdCallSave = refalrts::ident_from_static("CmdCallSave");
const refalrts::RefalIdentifier ident_CmdChar = refalrts::ident_from_static("CmdChar");
const refalrts::RefalIdentifier ident_CmdCharSave = refalrts::ident_from_static("CmdCharSave");
const refalrts::RefalIdentifier ident_CmdComment = refalrts::ident_from_static("CmdComment");
const refalrts::RefalIdentifier ident_CmdCopyVar = refalrts::ident_from_static("CmdCopyVar");
const refalrts::RefalIdentifier ident_CmdCreateElem = refalrts::ident_from_static("CmdCreateElem");
const refalrts::RefalIdentifier ident_CmdDeclaration = refalrts::ident_from_static("CmdDeclaration");
const refalrts::RefalIdentifier ident_CmdDefineIdent = refalrts::ident_from_static("CmdDefineIdent");
const refalrts::RefalIdentifier ident_CmdEPrepare = refalrts::ident_from_static("CmdEPrepare");
const refalrts::RefalIdentifier ident_CmdEStart = refalrts::ident_from_static("CmdEStart");
const refalrts::RefalIdentifier ident_CmdEmitNativeCode = refalrts::ident_from_static("CmdEmitNativeCode");
const refalrts::RefalIdentifier ident_CmdEmpty = refalrts::ident_from_static("CmdEmpty");
const refalrts::RefalIdentifier ident_CmdEndSentence = refalrts::ident_from_static("CmdEndSentence");
const refalrts::RefalIdentifier ident_CmdEnumDescr = refalrts::ident_from_static("CmdEnumDescr");
const refalrts::RefalIdentifier ident_CmdExtern = refalrts::ident_from_static("CmdExtern");
const refalrts::RefalIdentifier ident_CmdFail = refalrts::ident_from_static("CmdFail");
const refalrts::RefalIdentifier ident_CmdFinRAA = refalrts::ident_from_static("CmdFinRAA");
const refalrts::RefalIdentifier ident_CmdFnEnd = refalrts::ident_from_static("CmdFnEnd");
const refalrts::RefalIdentifier ident_CmdFnStart = refalrts::ident_from_static("CmdFnStart");
const refalrts::RefalIdentifier ident_CmdFuncArray = refalrts::ident_from_static("CmdFuncArray");
const refalrts::RefalIdentifier ident_CmdHugeNum = refalrts::ident_from_static("CmdHugeNum");
const refalrts::RefalIdentifier ident_CmdHugeNumSave = refalrts::ident_from_static("CmdHugeNumSave");
const refalrts::RefalIdentifier ident_CmdIdent = refalrts::ident_from_static("CmdIdent");
const refalrts::RefalIdentifier ident_CmdIdentSave = refalrts::ident_from_static("CmdIdentSave");
const refalrts::RefalIdentifier ident_CmdInitB0 = refalrts::ident_from_static("CmdInitB0");
const refalrts::RefalIdentifier ident_CmdInitB0_Lite = refalrts::ident_from_static("CmdInitB0-Lite");
const refalrts::RefalIdentifier ident_CmdInitRAA = refalrts::ident_from_static("CmdInitRAA");
const refalrts::RefalIdentifier ident_CmdInsertElem = refalrts::ident_from_static("CmdInsertElem");
const refalrts::RefalIdentifier ident_CmdInsertRange = refalrts::ident_from_static("CmdInsertRange");
const refalrts::RefalIdentifier ident_CmdInsertTile = refalrts::ident_from_static("CmdInsertTile");
const refalrts::RefalIdentifier ident_CmdInsertVar = refalrts::ident_from_static("CmdInsertVar");
const refalrts::RefalIdentifier ident_CmdInterpretFuncDescr = refalrts::ident_from_static("CmdInterpretFuncDescr");
const refalrts::RefalIdentifier ident_CmdIssueMem = refalrts::ident_from_static("CmdIssueMem");
const refalrts::RefalIdentifier ident_CmdLabelArray = refalrts::ident_from_static("CmdLabelArray");
const refalrts::RefalIdentifier ident_CmdLinkBrackets = refalrts::ident_from_static("CmdLinkBrackets");
const refalrts::RefalIdentifier ident_CmdLoadConstants = refalrts::ident_from_static("CmdLoadConstants");
const refalrts::RefalIdentifier ident_CmdName = refalrts::ident_from_static("CmdName");
const refalrts::RefalIdentifier ident_CmdNameSave = refalrts::ident_from_static("CmdNameSave");
const refalrts::RefalIdentifier ident_CmdNativeFuncDescr = refalrts::ident_from_static("CmdNativeFuncDescr");
const refalrts::RefalIdentifier ident_CmdNextStep = refalrts::ident_from_static("CmdNextStep");
const refalrts::RefalIdentifier ident_CmdNum = refalrts::ident_from_static("CmdNum");
const refalrts::RefalIdentifier ident_CmdNumSave = refalrts::ident_from_static("CmdNumSave");
const refalrts::RefalIdentifier ident_CmdNumber = refalrts::ident_from_static("CmdNumber");
const refalrts::RefalIdentifier ident_CmdNumberArray = refalrts::ident_from_static("CmdNumberArray");
const refalrts::RefalIdentifier ident_CmdNumberSave = refalrts::ident_from_static("CmdNumberSave");
const refalrts::RefalIdentifier ident_CmdOnFailGoTo = refalrts::ident_from_static("CmdOnFailGoTo");
const refalrts::RefalIdentifier ident_CmdOpenedE_End = refalrts::ident_from_static("CmdOpenedE-End");
const refalrts::RefalIdentifier ident_CmdOpenedE_Start = refalrts::ident_from_static("CmdOpenedE-Start");
const refalrts::RefalIdentifier ident_CmdProfileFunction = refalrts::ident_from_static("CmdProfileFunction");
const refalrts::RefalIdentifier ident_CmdProfilerStopSentence = refalrts::ident_from_static("CmdProfilerStopSentence");
const refalrts::RefalIdentifier ident_CmdPushStack = refalrts::ident_from_static("CmdPushStack");
const refalrts::RefalIdentifier ident_CmdReinitSVar = refalrts::ident_from_static("CmdReinitSVar");
const refalrts::RefalIdentifier ident_CmdRepeated = refalrts::ident_from_static("CmdRepeated");
const refalrts::RefalIdentifier ident_CmdRepeatedTVarSave = refalrts::ident_from_static("CmdRepeatedTVarSave");
const refalrts::RefalIdentifier ident_CmdReserveStack = refalrts::ident_from_static("CmdReserveStack");
const refalrts::RefalIdentifier ident_CmdResetAllocator = refalrts::ident_from_static("CmdResetAllocator");
const refalrts::RefalIdentifier ident_CmdSave = refalrts::ident_from_static("CmdSave");
const refalrts::RefalIdentifier ident_CmdSeparator = refalrts::ident_from_static("CmdSeparator");
const refalrts::RefalIdentifier ident_CmdSetRes = refalrts::ident_from_static("CmdSetRes");
const refalrts::RefalIdentifier ident_CmdSpliceToFreeList = refalrts::ident_from_static("CmdSpliceToFreeList");
const refalrts::RefalIdentifier ident_CmdStartSentence = refalrts::ident_from_static("CmdStartSentence");
const refalrts::RefalIdentifier ident_CmdStringArray = refalrts::ident_from_static("CmdStringArray");
const refalrts::RefalIdentifier ident_CmdSwapDescr = refalrts::ident_from_static("CmdSwapDescr");
const refalrts::RefalIdentifier ident_CmdTrash = refalrts::ident_from_static("CmdTrash");
const refalrts::RefalIdentifier ident_CmdUseRes = refalrts::ident_from_static("CmdUseRes");
const refalrts::RefalIdentifier ident_CmdVar = refalrts::ident_from_static("CmdVar");
const refalrts::RefalIdentifier ident_CmdVarSave = refalrts::ident_from_static("CmdVarSave");
const refalrts::RefalIdentifier ident_CreateClosure = refalrts::ident_from_static("CreateClosure");
const refalrts::RefalIdentifier ident_ElChar = refalrts::ident_from_static("ElChar");
const refalrts::RefalIdentifier ident_ElCloseADT = refalrts::ident_from_static("ElCloseADT");
const refalrts::RefalIdentifier ident_ElCloseBracket = refalrts::ident_from_static("ElCloseBracket");
const refalrts::RefalIdentifier ident_ElCloseCall = refalrts::ident_from_static("ElCloseCall");
const refalrts::RefalIdentifier ident_ElHugeNumber = refalrts::ident_from_static("ElHugeNumber");
const refalrts::RefalIdentifier ident_ElIdent = refalrts::ident_from_static("ElIdent");
const refalrts::RefalIdentifier ident_ElName = refalrts::ident_from_static("ElName");
const refalrts::RefalIdentifier ident_ElNumber = refalrts::ident_from_static("ElNumber");
const refalrts::RefalIdentifier ident_ElOpenADT = refalrts::ident_from_static("ElOpenADT");
const refalrts::RefalIdentifier ident_ElOpenBracket = refalrts::ident_from_static("ElOpenBracket");
const refalrts::RefalIdentifier ident_ElOpenCall = refalrts::ident_from_static("ElOpenCall");
const refalrts::RefalIdentifier ident_ElString = refalrts::ident_from_static("ElString");
const refalrts::RefalIdentifier ident_Hash = refalrts::ident_from_static("Hash");
const refalrts::RefalIdentifier ident_LEFT_EDGE = refalrts::ident_from_static("LEFT-EDGE");
const refalrts::RefalIdentifier ident_NativeInsertBegin = refalrts::ident_from_static("NativeInsertBegin");
const refalrts::RefalIdentifier ident_NativeInsertEnd = refalrts::ident_from_static("NativeInsertEnd");
const refalrts::RefalIdentifier ident_RIGHT_EDGE = refalrts::ident_from_static("RIGHT-EDGE");
const refalrts::RefalIdentifier ident_Reinit = refalrts::ident_from_static("Reinit");
const refalrts::RefalIdentifier ident_Update = refalrts::ident_from_static("Update");
extern refalrts::RefalFunction& Fetch_0_0;
#define Fetch_alias Fetch_0_0
#define Fetch_str "Fetch#0:0"

extern refalrts::RefalFunction& Seq_0_0;
#define Seq_alias Seq_0_0
#define Seq_str "Seq#0:0"

extern refalrts::RefalFunction& MapReduce_0_0;
#define MapReduce_alias MapReduce_0_0
#define MapReduce_str "MapReduce#0:0"

extern refalrts::RefalFunction& Inc_0_0;
#define Inc_alias Inc_0_0
#define Inc_str "Inc#0:0"

extern refalrts::RefalFunction& Map_0_0;
#define Map_alias Map_0_0
#define Map_str "Map#0:0"

extern refalrts::RefalFunction& DisplayName_0_0;
#define DisplayName_alias DisplayName_0_0
#define DisplayName_str "DisplayName#0:0"

extern refalrts::RefalFunction& DisplayCName_0_0;
#define DisplayCName_alias DisplayCName_0_0
#define DisplayCName_str "DisplayCName#0:0"

extern refalrts::RefalFunction& CName_0_0;
#define CName_alias CName_0_0
#define CName_str "CName#0:0"

extern refalrts::RefalFunction& StrFromInt_0_0;
#define StrFromInt_alias StrFromInt_0_0
#define StrFromInt_str "StrFromInt#0:0"

extern refalrts::RefalFunction& Add_0_0;
#define Add_alias Add_0_0
#define Add_str "Add#0:0"

extern refalrts::RefalFunction& EscapeChar_0_0;
#define EscapeChar_alias EscapeChar_0_0
#define EscapeChar_str "EscapeChar#0:0"

extern refalrts::RefalFunction& EscapeString_0_0;
#define EscapeString_alias EscapeString_0_0
#define EscapeString_str "EscapeString#0:0"

extern refalrts::RefalFunction& FuncArguments_2881595569_337745613;
#define FuncArguments_alias FuncArguments_2881595569_337745613

extern refalrts::RefalFunction& FuncReference_2881595569_337745613;
#define FuncReference_alias FuncReference_2881595569_337745613

extern refalrts::RefalFunction& FuncAlias_2881595569_337745613;
#define FuncAlias_alias FuncAlias_2881595569_337745613

extern refalrts::RefalFunction& GenCommonHeaders_2881595569_337745613;
#define GenCommonHeaders_alias GenCommonHeaders_2881595569_337745613

extern refalrts::RefalFunction& GenCommonTailer_2881595569_337745613;
#define GenCommonTailer_alias GenCommonTailer_2881595569_337745613

extern refalrts::RefalFunction& gen_GenProgram_RASL_L1_2881595569_337745613;
#define gen_GenProgram_RASL_L1_alias gen_GenProgram_RASL_L1_2881595569_337745613

extern refalrts::RefalFunction& GenProgram_RASL_0_0;
#define GenProgram_RASL_alias GenProgram_RASL_0_0

extern refalrts::RefalFunction& gen_GenProgram_Native_L1_2881595569_337745613;
#define gen_GenProgram_Native_L1_alias gen_GenProgram_Native_L1_2881595569_337745613

extern refalrts::RefalFunction& gen_GenProgram_Native_L2_2881595569_337745613;
#define gen_GenProgram_Native_L2_alias gen_GenProgram_Native_L2_2881595569_337745613

extern refalrts::RefalFunction& GenProgram_Native_0_0;
#define GenProgram_Native_alias GenProgram_Native_0_0

extern refalrts::RefalFunction& SetLineNumbers_2881595569_337745613;
#define SetLineNumbers_alias SetLineNumbers_2881595569_337745613

extern refalrts::RefalFunction& ContextRange_B_2881595569_337745613;
#define ContextRange_B_alias ContextRange_B_2881595569_337745613

extern refalrts::RefalFunction& ContextRange_E_2881595569_337745613;
#define ContextRange_E_alias ContextRange_E_2881595569_337745613

extern refalrts::RefalFunction& ContextRange_2881595569_337745613;
#define ContextRange_alias ContextRange_2881595569_337745613

extern refalrts::RefalFunction& ContextItem_2881595569_337745613;
#define ContextItem_alias ContextItem_2881595569_337745613

extern refalrts::RefalFunction& PrintBracketsVarInit_2881595569_337745613;
#define PrintBracketsVarInit_alias PrintBracketsVarInit_2881595569_337745613

extern refalrts::RefalFunction& PrintDirection_2881595569_337745613;
#define PrintDirection_alias PrintDirection_2881595569_337745613

extern refalrts::RefalFunction& CNameAlias_2881595569_337745613;
#define CNameAlias_alias CNameAlias_2881595569_337745613

extern refalrts::RefalFunction& BaseCName_2881595569_337745613;
#define BaseCName_alias BaseCName_2881595569_337745613

extern refalrts::RefalFunction& GenCommand_Common_2881595569_337745613;
#define GenCommand_Common_alias GenCommand_Common_2881595569_337745613

extern refalrts::RefalFunction& gen_GenCommand_Native_S37L1_2881595569_337745613;
#define gen_GenCommand_Native_S37L1_alias gen_GenCommand_Native_S37L1_2881595569_337745613

extern refalrts::RefalFunction& gen_GenCommand_Native_S53L1_2881595569_337745613;
#define gen_GenCommand_Native_S53L1_alias gen_GenCommand_Native_S53L1_2881595569_337745613

extern refalrts::RefalFunction& GenCommand_Native_2881595569_337745613;
#define GenCommand_Native_alias GenCommand_Native_2881595569_337745613

extern refalrts::RefalFunction& gen_GenCommand_RASL_S6L1_2881595569_337745613;
#define gen_GenCommand_RASL_S6L1_alias gen_GenCommand_RASL_S6L1_2881595569_337745613

extern refalrts::RefalFunction& gen_GenCommand_RASL_S8L1_2881595569_337745613;
#define gen_GenCommand_RASL_S8L1_alias gen_GenCommand_RASL_S8L1_2881595569_337745613

extern refalrts::RefalFunction& gen_GenCommand_RASL_S10L1_2881595569_337745613;
#define gen_GenCommand_RASL_S10L1_alias gen_GenCommand_RASL_S10L1_2881595569_337745613

extern refalrts::RefalFunction& gen_GenCommand_RASL_S12L1_2881595569_337745613;
#define gen_GenCommand_RASL_S12L1_alias gen_GenCommand_RASL_S12L1_2881595569_337745613

extern refalrts::RefalFunction& gen_GenCommand_RASL_S48L1_2881595569_337745613;
#define gen_GenCommand_RASL_S48L1_alias gen_GenCommand_RASL_S48L1_2881595569_337745613

extern refalrts::RefalFunction& gen_GenCommand_RASL_S62L1_2881595569_337745613;
#define gen_GenCommand_RASL_S62L1_alias gen_GenCommand_RASL_S62L1_2881595569_337745613

extern refalrts::RefalFunction& GenCommand_RASL_2881595569_337745613;
#define GenCommand_RASL_alias GenCommand_RASL_2881595569_337745613

extern refalrts::RefalFunction& PrintLength_2881595569_337745613;
#define PrintLength_alias PrintLength_2881595569_337745613

extern refalrts::RefalFunction& DoPrintLength_2881595569_337745613;
#define DoPrintLength_alias DoPrintLength_2881595569_337745613

extern refalrts::RefalFunction& PrintString_2881595569_337745613;
#define PrintString_alias PrintString_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchChar_2881595569_337745613;
#define PrintMatchChar_alias PrintMatchChar_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchCharSave_2881595569_337745613;
#define PrintMatchCharSave_alias PrintMatchCharSave_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchNumber_2881595569_337745613;
#define PrintMatchNumber_alias PrintMatchNumber_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchNumberSave_2881595569_337745613;
#define PrintMatchNumberSave_alias PrintMatchNumberSave_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchName_2881595569_337745613;
#define PrintMatchName_alias PrintMatchName_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchNameSave_2881595569_337745613;
#define PrintMatchNameSave_alias PrintMatchNameSave_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchIdent_2881595569_337745613;
#define PrintMatchIdent_alias PrintMatchIdent_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchIdentSave_2881595569_337745613;
#define PrintMatchIdentSave_alias PrintMatchIdentSave_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchBrackets_2881595569_337745613;
#define PrintMatchBrackets_alias PrintMatchBrackets_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchBracketsSave_2881595569_337745613;
#define PrintMatchBracketsSave_alias PrintMatchBracketsSave_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchADT_2881595569_337745613;
#define PrintMatchADT_alias PrintMatchADT_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchADTSave_2881595569_337745613;
#define PrintMatchADTSave_alias PrintMatchADTSave_2881595569_337745613

extern refalrts::RefalFunction& BreakerFromIndent_2881595569_337745613;
#define BreakerFromIndent_alias BreakerFromIndent_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchEmpty_2881595569_337745613;
#define PrintMatchEmpty_alias PrintMatchEmpty_2881595569_337745613

extern refalrts::RefalFunction& StrFromDirection_2881595569_337745613;
#define StrFromDirection_alias StrFromDirection_2881595569_337745613

extern refalrts::RefalFunction& VarMatchFunction_2881595569_337745613;
#define VarMatchFunction_alias VarMatchFunction_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchSTVar_2881595569_337745613;
#define PrintMatchSTVar_alias PrintMatchSTVar_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchSTVarSave_2881595569_337745613;
#define PrintMatchSTVarSave_alias PrintMatchSTVarSave_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchRepeated_2881595569_337745613;
#define PrintMatchRepeated_alias PrintMatchRepeated_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchRepeatedTVarSave_2881595569_337745613;
#define PrintMatchRepeatedTVarSave_alias PrintMatchRepeatedTVarSave_2881595569_337745613

extern refalrts::RefalFunction& PrintMatch_2881595569_337745613;
#define PrintMatch_alias PrintMatch_2881595569_337745613

extern refalrts::RefalFunction& PrintMatchSave_2881595569_337745613;
#define PrintMatchSave_alias PrintMatchSave_2881595569_337745613

extern refalrts::RefalFunction& PrintCreateElem_2881595569_337745613;
#define PrintCreateElem_alias PrintCreateElem_2881595569_337745613

extern refalrts::RefalFunction& AllocatorMode_2881595569_337745613;
#define AllocatorMode_alias AllocatorMode_2881595569_337745613

extern refalrts::RefalFunction& AllocatorFuncName_2881595569_337745613;
#define AllocatorFuncName_alias AllocatorFuncName_2881595569_337745613

extern refalrts::RefalFunction& AllocatorFuncArgument_2881595569_337745613;
#define AllocatorFuncArgument_alias AllocatorFuncArgument_2881595569_337745613

extern refalrts::RefalFunction& PrintInterpretCreateElem_2881595569_337745613;
#define PrintInterpretCreateElem_alias PrintInterpretCreateElem_2881595569_337745613

extern refalrts::RefalFunction& CreateMode_2881595569_337745613;
#define CreateMode_alias CreateMode_2881595569_337745613

extern refalrts::RefalFunction& CreateCommandTag_2881595569_337745613;
#define CreateCommandTag_alias CreateCommandTag_2881595569_337745613

extern refalrts::RefalFunction& CreateCommandInfo_2881595569_337745613;
#define CreateCommandInfo_alias CreateCommandInfo_2881595569_337745613


static refalrts::FnResult func_FuncArguments(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 7 elems
  refalrts::Iter context[7];
  refalrts::zeros( context, 7 );
  // </0 & FuncArguments/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: '('/0 HalfReuse: 'r'/4 HalfReuse: 'e'/1 }"falrts::Iter arg_begin, refalrts::Iter arg_end)"/5 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[5], context[6], "falrts::Iter arg_begin, refalrts::Iter arg_end)", 47 ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[0], '(' );
  refalrts::reinit_char( context[4], 'r' );
  refalrts::reinit_char( context[1], 'e' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_FuncArguments(func_FuncArguments, "FuncArguments#2881595569:337745613");
refalrts::RefalFunction& FuncArguments_2881595569_337745613 = descr_FuncArguments;

static refalrts::FnResult func_FuncReference(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 17 elems
  refalrts::Iter context[17];
  refalrts::zeros( context, 17 );
  // </0 & FuncReference/4 e.Name#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Name#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } (/5"refalrts::RefalFunction& "/6 Tile{ AsIs: </0 Reuse: & CName/4 AsIs: e.Name#1/2 AsIs: >/1 }" = descr_"/8 </10 & BaseCName/11 e.Name#1/2/12 >/14 ';'/15 )/16 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[6], context[7], "refalrts::RefalFunction& ", 25 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[8], context[9], " = descr_", 9 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & BaseCName_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[12], context[13], context[2], context[3]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[15], ';' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[16] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & CName_alias );
  refalrts::link_brackets( context[5], context[16] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[8], context[16] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[5], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_FuncReference(func_FuncReference, "FuncReference#2881595569:337745613");
refalrts::RefalFunction& FuncReference_2881595569_337745613 = descr_FuncReference;

static refalrts::FnResult func_FuncAlias(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  // </0 & FuncAlias/4 e.Name#1/2 # Hash/7 s.Cookie1#1/6 s.Cookie2#1/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_right( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_right( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[7] = refalrts::ident_right(  ident_Hash, context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  // closed e.Name#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } (/8"#define "/9 </11 & CName/12 e.Name#1/2/13 >/15"_alias "/16 Tile{ AsIs: </0 Reuse: & CName/4 AsIs: e.Name#1/2 AsIs: # Hash/7 AsIs: s.Cookie1#1/6 AsIs: s.Cookie2#1/5 AsIs: >/1 } )/18 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[9], context[10], "#define ", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[12], & CName_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[13], context[14], context[2], context[3]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[16], context[17], "_alias ", 7 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[18] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & CName_alias );
  refalrts::link_brackets( context[8], context[18] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[11] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[18], context[18] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[8], context[17] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_FuncAlias(func_FuncAlias, "FuncAlias#2881595569:337745613");
refalrts::RefalFunction& FuncAlias_2881595569_337745613 = descr_FuncAlias;

static refalrts::FnResult func_GenCommonHeaders(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  // </0 & GenCommonHeaders/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: '/'/4 HalfReuse: '/'/1 }" Automatically generated file. Don\'t edit!"/5 )/7 (/8"#include \"refalrts.h\""/9 )/11 (/12 )/13 (/14 )/15 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[5], context[6], " Automatically generated file. Don\'t edit!", 42 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[9], context[10], "#include \"refalrts.h\"", 21 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_char( context[4], '/' );
  refalrts::reinit_char( context[1], '/' );
  refalrts::link_brackets( context[14], context[15] );
  refalrts::link_brackets( context[12], context[13] );
  refalrts::link_brackets( context[8], context[11] );
  refalrts::link_brackets( context[0], context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[15] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_GenCommonHeaders(func_GenCommonHeaders, "GenCommonHeaders#2881595569:337745613");
refalrts::RefalFunction& GenCommonHeaders_2881595569_337745613 = descr_GenCommonHeaders;

static refalrts::FnResult func_GenCommonTailer(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  // </0 & GenCommonTailer/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: )/4 HalfReuse: (/1 }"//End of file"/5 )/7 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[5], context[6], "//End of file", 13 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[7] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::reinit_open_bracket( context[1] );
  refalrts::link_brackets( context[1], context[7] );
  refalrts::link_brackets( context[0], context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_GenCommonTailer(func_GenCommonTailer, "GenCommonTailer#2881595569:337745613");
refalrts::RefalFunction& GenCommonTailer_2881595569_337745613 = descr_GenCommonTailer;

static refalrts::FnResult func_gen_GenProgram_RASL_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  // </0 & GenProgram-RASL\1/4 (/7 )/8 e.Generated#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  if( ! refalrts::empty_seq( context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Generated#2 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & GenCommonHeaders/4 HalfReuse: >/7 } Tile{ AsIs: e.Generated#2/2 } Tile{ HalfReuse: </8 } & GenCommonTailer/9 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_name( context[9], & GenCommonTailer_alias ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & GenCommonHeaders_alias );
  refalrts::reinit_close_call( context[7] );
  refalrts::reinit_open_call( context[8] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[8], context[8] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_gen_GenProgram_RASL_L1(func_gen_GenProgram_RASL_L1, "GenProgram-RASL\\1#2881595569:337745613");
refalrts::RefalFunction& gen_GenProgram_RASL_L1_2881595569_337745613 = descr_gen_GenProgram_RASL_L1;

static refalrts::FnResult func_GenProgram_RASL(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & GenProgram-RASL/4 e.RASL#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.RASL#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 AsIs: e.RASL#1/2 HalfReuse: </1 } & Seq/5 (/6 & MapReduce/7 & GenCommand-RASL/8 (/9 )/10 )/11 & GenProgram-RASL\1/12 >/13 >/14 Tile{ ]] }
  if( ! refalrts::alloc_name( context[5], & Seq_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & MapReduce_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], & GenCommand_RASL_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[12], & gen_GenProgram_RASL_L1_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Fetch_alias );
  refalrts::reinit_open_call( context[1] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[1] );
  refalrts::link_brackets( context[6], context[11] );
  refalrts::link_brackets( context[9], context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[14] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_GenProgram_RASL(func_GenProgram_RASL, "GenProgram-RASL#0:0");
refalrts::RefalFunction& GenProgram_RASL_0_0 = descr_GenProgram_RASL;

static refalrts::FnResult func_gen_GenProgram_Native_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  // </0 & GenProgram-Native\1/4 (/7 )/8 e.Generated#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  if( ! refalrts::empty_seq( context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Generated#2 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & GenCommonHeaders/4 HalfReuse: >/7 } Tile{ AsIs: e.Generated#2/2 } Tile{ HalfReuse: </8 } & GenCommonTailer/9 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_name( context[9], & GenCommonTailer_alias ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & GenCommonHeaders_alias );
  refalrts::reinit_close_call( context[7] );
  refalrts::reinit_open_call( context[8] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[8], context[8] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_gen_GenProgram_Native_L1(func_gen_GenProgram_Native_L1, "GenProgram-Native\\1#2881595569:337745613");
refalrts::RefalFunction& gen_GenProgram_Native_L1_2881595569_337745613 = descr_gen_GenProgram_Native_L1;

static refalrts::FnResult func_gen_GenProgram_Native_L2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 26 elems
  refalrts::Iter context[26];
  refalrts::zeros( context, 26 );
  //FAST GEN: ( e.$ ) ( e.$ ) e.$
  //GLOBAL GEN: ( e.$ ) ( e.$ ) e.$
  // </0 & GenProgram-Native\2/4 (/7 e.idxB#0/5 )/8 (/11 e.idxTB#0/9 )/12 e.idxTT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.idxB#0 as range 5
  // closed e.idxTB#0 as range 9
  // closed e.idxTT#0 as range 2
  do {
    // ( e.idx ) ( e.idx ) e.idx
    // </0 & GenProgram-Native\2/4 (/7 e.SourceFileName#1/5 )/8 (/11 e.TargetFileName#1/9 )/12 e.Lines-B#2/13 (/17 # NativeInsertBegin/19 s.SrcLineNum#2/20 )/18 e.Lines-E#2/2 >/1
    // closed e.SourceFileName#1 as range 5
    // closed e.TargetFileName#1 as range 9
    context[22] = context[2];
    context[23] = context[3];
    context[13] = 0;
    context[14] = 0;
    refalrts::start_e_loop();
    do {
      context[24] = context[22];
      context[25] = context[23];
      context[15] = 0;
      context[16] = 0;
      context[17] = refalrts::brackets_left( context[15], context[16], context[24], context[25] );
      if( ! context[17] )
        continue;
      refalrts::bracket_pointers(context[17], context[18]);
      context[19] = refalrts::ident_left(  ident_NativeInsertBegin, context[15], context[16] );
      if( ! context[19] )
        continue;
      // closed e.Lines-E#2 as range 24(2)
      if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
        continue;
      if( ! refalrts::empty_seq( context[15], context[16] ) )
        continue;

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & SetLineNumbers/4 AsIs: (/7 AsIs: e.SourceFileName#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.TargetFileName#1/9 AsIs: )/12 } 1/21 Tile{ AsIs: e.Lines-B#2/13 } Tile{ AsIs: (/17 AsIs: # NativeInsertBegin/19 AsIs: s.SrcLineNum#2/20 AsIs: )/18 AsIs: e.Lines-E#2/24(2) AsIs: >/1 ]] }
      if( ! refalrts::alloc_number( context[21], 1UL ) )
        return refalrts::cNoMemory;
      refalrts::update_name( context[4], & SetLineNumbers_alias );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[17], context[18] );
      refalrts::link_brackets( context[11], context[12] );
      refalrts::link_brackets( context[7], context[8] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[17];
      res = refalrts::splice_evar( res, context[13], context[14] );
      res = refalrts::splice_evar( res, context[21], context[21] );
      refalrts::use( res );
      return refalrts::cSuccess;
    } while ( refalrts::open_evar_advance( context[13], context[14], context[22], context[23] ) );
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) ( e.idx ) e.idx
  // </0 & GenProgram-Native\2/4 (/7 e.SourceFileName#1/5 )/8 (/11 e.TargetFileName#1/9 )/12 e.Lines#2/2 >/1
  // closed e.SourceFileName#1 as range 5
  // closed e.TargetFileName#1 as range 9
  // closed e.Lines#2 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & GenProgram-Native\2/4 (/7 e.SourceFileName#1/5 )/8 (/11 e.TargetFileName#1/9 )/12 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.Lines#2/2 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_gen_GenProgram_Native_L2(func_gen_GenProgram_Native_L2, "GenProgram-Native\\2#2881595569:337745613");
refalrts::RefalFunction& gen_GenProgram_Native_L2_2881595569_337745613 = descr_gen_GenProgram_Native_L2;

static refalrts::FnResult func_GenProgram_Native(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 27 elems
  refalrts::Iter context[27];
  refalrts::zeros( context, 27 );
  // </0 & GenProgram-Native/4 (/7 e.SourceFileName#1/5 )/8 (/11 e.TargetFileName#1/9 )/12 e.RASL#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.SourceFileName#1 as range 5
  // closed e.TargetFileName#1 as range 9
  // closed e.RASL#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </13 & Fetch/14 Tile{ AsIs: e.RASL#1/2 } </15 & Seq/16 (/17 & MapReduce/18 & GenCommand-Native/19 (/20 )/21 )/22 & GenProgram-Native\1/23 </24 Tile{ HalfReuse: & @create_closure@/0 Reuse: & GenProgram-Native\2/4 AsIs: (/7 AsIs: e.SourceFileName#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.TargetFileName#1/9 AsIs: )/12 } >/25 >/26 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], & Fetch_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[16], & Seq_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[18], & MapReduce_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], & GenCommand_Native_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[23], & gen_GenProgram_Native_L1_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[24] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[25] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[26] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[0], & refalrts::create_closure );
  refalrts::update_name( context[4], & gen_GenProgram_Native_L2_alias );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[26] );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[25] );
  refalrts::push_stack( context[24] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::link_brackets( context[17], context[22] );
  refalrts::link_brackets( context[20], context[21] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[25], context[26] );
  res = refalrts::splice_evar( res, context[0], context[12] );
  res = refalrts::splice_evar( res, context[15], context[24] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[13], context[14] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_GenProgram_Native(func_GenProgram_Native, "GenProgram-Native#0:0");
refalrts::RefalFunction& GenProgram_Native_0_0 = descr_GenProgram_Native;

static refalrts::FnResult func_SetLineNumbers(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 40 elems
  refalrts::Iter context[40];
  refalrts::zeros( context, 40 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) ( e.$ ) s.$ e.$
  // </0 & SetLineNumbers/4 (/7 e.idxB#0/5 )/8 (/11 e.idxTB#0/9 )/12 s.idxTT#0/13 e.idxTTV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.idxB#0 as range 5
  // closed e.idxTB#0 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTTV#0 as range 2
  do {
    // ( e.idx ) ( e.idx ) s.idx ( # NativeInsertBegin s.idx ) e.idx
    // </0 & SetLineNumbers/4 (/7 e.Source#1/5 )/8 (/11 e.Target#1/9 )/12 s.LineNum#1/13 (/16 # NativeInsertBegin/18 s.SrcLineNum#1/19 )/17 e.Lines#1/2 >/1
    context[38] = context[2];
    context[39] = context[3];
    context[14] = 0;
    context[15] = 0;
    context[16] = refalrts::brackets_left( context[14], context[15], context[38], context[39] );
    if( ! context[16] )
      continue;
    refalrts::bracket_pointers(context[16], context[17]);
    context[18] = refalrts::ident_left(  ident_NativeInsertBegin, context[14], context[15] );
    if( ! context[18] )
      continue;
    // closed e.Source#1 as range 5
    // closed e.Target#1 as range 9
    // closed e.Lines#1 as range 38(2)
    if( ! refalrts::svar_left( context[19], context[14], context[15] ) )
      continue;
    if( ! refalrts::empty_seq( context[14], context[15] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/20"#line "/21 Tile{ HalfReuse: </16 HalfReuse: & StrFromInt/18 AsIs: s.SrcLineNum#1/19 } >/23" \""/24 </26 & EscapeString/27 e.Source#1/5/28 >/30 '\"'/31 )/32 Tile{ AsIs: </0 AsIs: & SetLineNumbers/4 AsIs: (/7 AsIs: e.Source#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.Target#1/9 AsIs: )/12 } </33 & Inc/34 Tile{ AsIs: s.LineNum#1/13 } Tile{ HalfReuse: >/17 AsIs: e.Lines#1/38(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "#line ", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], " \"", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & EscapeString_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[28], context[29], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[31], '\"' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[33] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[34], & Inc_alias ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[16] );
    refalrts::reinit_name( context[18], & StrFromInt_alias );
    refalrts::reinit_close_call( context[17] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[17] );
    refalrts::push_stack( context[33] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[20], context[32] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[16] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[17];
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[33], context[34] );
    res = refalrts::splice_evar( res, context[0], context[12] );
    res = refalrts::splice_evar( res, context[23], context[32] );
    res = refalrts::splice_evar( res, context[16], context[19] );
    res = refalrts::splice_evar( res, context[20], context[22] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( e.idx ) s.idx ( # NativeInsertEnd ) e.idx
    // </0 & SetLineNumbers/4 (/7 e.Source#1/5 )/8 (/11 e.Target#1/9 )/12 s.LineNum#1/13 (/16 # NativeInsertEnd/18 )/17 e.Lines#1/2 >/1
    context[38] = context[2];
    context[39] = context[3];
    context[14] = 0;
    context[15] = 0;
    context[16] = refalrts::brackets_left( context[14], context[15], context[38], context[39] );
    if( ! context[16] )
      continue;
    refalrts::bracket_pointers(context[16], context[17]);
    context[18] = refalrts::ident_left(  ident_NativeInsertEnd, context[14], context[15] );
    if( ! context[18] )
      continue;
    if( ! refalrts::empty_seq( context[14], context[15] ) )
      continue;
    // closed e.Source#1 as range 5
    // closed e.Target#1 as range 9
    // closed e.Lines#1 as range 38(2)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/19"#line "/20 </22 & StrFromInt/23 </24 & Inc/25 Tile{ AsIs: s.LineNum#1/13 } >/26 >/27" \""/28 </30 & EscapeString/31 e.Target#1/9/32 >/34 '\"'/35 )/36 Tile{ AsIs: </0 AsIs: & SetLineNumbers/4 AsIs: (/7 AsIs: e.Source#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.Target#1/9 AsIs: )/12 } </37 Tile{ HalfReuse: & Inc/16 HalfReuse: s.LineNum1 #13/18 HalfReuse: >/17 AsIs: e.Lines#1/38(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "#line ", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[23], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[25], & Inc_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[28], context[29], " \"", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[31], & EscapeString_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[32], context[33], context[9], context[10]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[34] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[35], '\"' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[36] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[37] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_name( context[16], & Inc_alias );
    refalrts::reinit_svar( context[18], context[13] );
    refalrts::reinit_close_call( context[17] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[17] );
    refalrts::push_stack( context[37] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[19], context[36] );
    refalrts::push_stack( context[34] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[24] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[16];
    res = refalrts::splice_evar( res, context[37], context[37] );
    res = refalrts::splice_evar( res, context[0], context[12] );
    res = refalrts::splice_evar( res, context[26], context[36] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[19], context[25] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( e.idx ) s.idx ( e.idx ) e.idx
    // </0 & SetLineNumbers/4 (/7 e.Source#1/5 )/8 (/11 e.Target#1/9 )/12 s.LineNum#1/13 (/16 e.OtherLine#1/14 )/17 e.Lines#1/2 >/1
    context[38] = context[2];
    context[39] = context[3];
    context[14] = 0;
    context[15] = 0;
    context[16] = refalrts::brackets_left( context[14], context[15], context[38], context[39] );
    if( ! context[16] )
      continue;
    refalrts::bracket_pointers(context[16], context[17]);
    // closed e.Source#1 as range 5
    // closed e.Target#1 as range 9
    // closed e.OtherLine#1 as range 14
    // closed e.Lines#1 as range 38(2)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/16 } Tile{ AsIs: e.OtherLine#1/14 } )/18 Tile{ AsIs: </0 AsIs: & SetLineNumbers/4 AsIs: (/7 AsIs: e.Source#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.Target#1/9 AsIs: )/12 } </19 & Inc/20 Tile{ AsIs: s.LineNum#1/13 } Tile{ HalfReuse: >/17 AsIs: e.Lines#1/38(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[20], & Inc_alias ) )
      return refalrts::cNoMemory;
    refalrts::reinit_close_call( context[17] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[17] );
    refalrts::push_stack( context[19] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[16], context[18] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[17];
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[0], context[12] );
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) ( e.idx ) s.idx
  // </0 & SetLineNumbers/4 (/7 e.Source#1/5 )/8 (/11 e.Target#1/9 )/12 s.LineNum#1/13 >/1
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Source#1 as range 5
  // closed e.Target#1 as range 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & SetLineNumbers/4 (/7 e.Source#1/5 )/8 (/11 e.Target#1/9 )/12 s.LineNum#1/13 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_SetLineNumbers(func_SetLineNumbers, "SetLineNumbers#2881595569:337745613");
refalrts::RefalFunction& SetLineNumbers_2881595569_337745613 = descr_SetLineNumbers;

static refalrts::FnResult func_ContextRange_B(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ContextRange-B/4 s.RangeOffset#1/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ }"context["/6 Tile{ AsIs: </0 Reuse: & StrFromInt/4 AsIs: s.RangeOffset#1/5 AsIs: >/1 } ']'/8 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "context[", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[8], ']' ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & StrFromInt_alias );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[8], context[8] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_ContextRange_B(func_ContextRange_B, "ContextRange-B#2881595569:337745613");
refalrts::RefalFunction& ContextRange_B_2881595569_337745613 = descr_ContextRange_B;

static refalrts::FnResult func_ContextRange_E(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & ContextRange-E/4 s.RangeOffset#1/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ }"context["/6 </8 & StrFromInt/9 Tile{ AsIs: </0 Reuse: & Inc/4 AsIs: s.RangeOffset#1/5 AsIs: >/1 } >/10 ']'/11 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "context[", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & StrFromInt_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[11], ']' ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & Inc_alias );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[10], context[11] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[6], context[9] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_ContextRange_E(func_ContextRange_E, "ContextRange-E#2881595569:337745613");
refalrts::RefalFunction& ContextRange_E_2881595569_337745613 = descr_ContextRange_E;

static refalrts::FnResult func_ContextRange(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & ContextRange/4 s.RangeOffset#1/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & ContextRange-B/4 AsIs: s.RangeOffset#1/5 AsIs: >/1 }", "/6 </8 & ContextRange-E/9 s.RangeOffset#1/5/10 >/11 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], & ContextRange_E_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[10], context[5]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & ContextRange_B_alias );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_ContextRange(func_ContextRange, "ContextRange#2881595569:337745613");
refalrts::RefalFunction& ContextRange_2881595569_337745613 = descr_ContextRange;

static refalrts::FnResult func_ContextItem(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ContextItem/4 s.ItemNumber#1/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ }"context["/6 Tile{ AsIs: </0 Reuse: & StrFromInt/4 AsIs: s.ItemNumber#1/5 AsIs: >/1 } ']'/8 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "context[", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[8], ']' ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & StrFromInt_alias );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[8], context[8] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_ContextItem(func_ContextItem, "ContextItem#2881595569:337745613");
refalrts::RefalFunction& ContextItem_2881595569_337745613 = descr_ContextItem;

static refalrts::FnResult func_PrintBracketsVarInit(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 20 elems
  refalrts::Iter context[20];
  refalrts::zeros( context, 20 );
  // </0 & PrintBracketsVarInit/4 e.Indent#1/2 s.InnerBrackets#1/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_right( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Indent#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } (/6 Tile{ AsIs: e.Indent#1/2 } Tile{ AsIs: </0 Reuse: & ContextRange-B/4 } Tile{ AsIs: s.InnerBrackets#1/5 AsIs: >/1 }" = 0;"/7 )/9 (/10 e.Indent#1/2/11 </13 & ContextRange-E/14 s.InnerBrackets#1/5/15 >/16" = 0;"/17 )/19 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[7], context[8], " = 0;", 5 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[11], context[12], context[2], context[3]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], & ContextRange_E_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[15], context[5]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[17], context[18], " = 0;", 5 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[19] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & ContextRange_B_alias );
  refalrts::link_brackets( context[10], context[19] );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[13] );
  refalrts::link_brackets( context[6], context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[7], context[19] );
  res = refalrts::splice_evar( res, context[5], context[1] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[6], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintBracketsVarInit(func_PrintBracketsVarInit, "PrintBracketsVarInit#2881595569:337745613");
refalrts::RefalFunction& PrintBracketsVarInit_2881595569_337745613 = descr_PrintBracketsVarInit;

static refalrts::FnResult func_PrintDirection(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 7 elems
  refalrts::Iter context[7];
  refalrts::zeros( context, 7 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & PrintDirection/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # AlgLeft
    // </0 & PrintDirection/4 # AlgLeft/5 >/1
    if( ! refalrts::ident_term(  ident_AlgLeft, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'L'/0 HalfReuse: 'e'/4 HalfReuse: 'f'/5 HalfReuse: 't'/1 ]] }
    refalrts::reinit_char( context[0], 'L' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[5], 'f' );
    refalrts::reinit_char( context[1], 't' );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # AlgRight
    // </0 & PrintDirection/4 # AlgRight/5 >/1
    if( ! refalrts::ident_term(  ident_AlgRight, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'R'/0 HalfReuse: 'i'/4 HalfReuse: 'g'/5 HalfReuse: 'h'/1 } 't'/6 Tile{ ]] }
    if( ! refalrts::alloc_char( context[6], 't' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'R' );
    refalrts::reinit_char( context[4], 'i' );
    refalrts::reinit_char( context[5], 'g' );
    refalrts::reinit_char( context[1], 'h' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[6] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // # AlgTerm
  // </0 & PrintDirection/4 # AlgTerm/5 >/1
  if( ! refalrts::ident_term(  ident_AlgTerm, context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 'T'/0 HalfReuse: 'e'/4 HalfReuse: 'r'/5 HalfReuse: 'm'/1 ]] }
  refalrts::reinit_char( context[0], 'T' );
  refalrts::reinit_char( context[4], 'e' );
  refalrts::reinit_char( context[5], 'r' );
  refalrts::reinit_char( context[1], 'm' );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintDirection(func_PrintDirection, "PrintDirection#2881595569:337745613");
refalrts::RefalFunction& PrintDirection_2881595569_337745613 = descr_PrintDirection;

static refalrts::FnResult func_CNameAlias(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & CNameAlias/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // # CreateClosure
    // </0 & CNameAlias/4 # CreateClosure/5 >/1
    context[7] = context[2];
    context[8] = context[3];
    context[5] = refalrts::ident_left(  ident_CreateClosure, context[7], context[8] );
    if( ! context[5] )
      continue;
    if( ! refalrts::empty_seq( context[7], context[8] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & CName/4 AsIs: # CreateClosure/5 AsIs: >/1 ]] }
    refalrts::update_name( context[4], & CName_alias );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & CNameAlias/4 e.RegularName#1/2 >/1
  // closed e.RegularName#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & CName/4 AsIs: e.RegularName#1/2 AsIs: >/1 }"_alias"/5 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[5], context[6], "_alias", 6 ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & CName_alias );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_CNameAlias(func_CNameAlias, "CNameAlias#2881595569:337745613");
refalrts::RefalFunction& CNameAlias_2881595569_337745613 = descr_CNameAlias;

static refalrts::FnResult func_BaseCName(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & BaseCName/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // e.idx # Hash s.idx s.idx
    // </0 & BaseCName/4 e.Name#1/2 # Hash/7 s.Cookie1#1/6 s.Cookie2#1/5 >/1
    context[8] = context[2];
    context[9] = context[3];
    if( ! refalrts::svar_right( context[5], context[8], context[9] ) )
      continue;
    if( ! refalrts::svar_right( context[6], context[8], context[9] ) )
      continue;
    context[7] = refalrts::ident_right(  ident_Hash, context[8], context[9] );
    if( ! context[7] )
      continue;
    // closed e.Name#1 as range 8(2)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.Cookie1#1/6 s.Cookie2#1/5 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & CName/4 AsIs: e.Name#1/8(2) HalfReuse: >/7 } Tile{ ]] }
    refalrts::update_name( context[4], & CName_alias );
    refalrts::reinit_close_call( context[7] );
    refalrts::push_stack( context[7] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & BaseCName/4 e.Name#1/2 >/1
  // closed e.Name#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & CName/4 AsIs: e.Name#1/2 AsIs: >/1 ]] }
  refalrts::update_name( context[4], & CName_alias );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_BaseCName(func_BaseCName, "BaseCName#2881595569:337745613");
refalrts::RefalFunction& BaseCName_2881595569_337745613 = descr_BaseCName;

static refalrts::FnResult func_GenCommand_Common(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  //FAST GEN: ( e.$ ) ( e.$ )
  //GLOBAL GEN: ( e.$ ) ( s.$ e.$ )
  // </0 & GenCommand-Common/4 (/7 e.idxB#0/5 )/8 (/11 s.idxTB#0/13 e.idxTBV#0/9 )/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[13], context[9], context[10] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTBV#0 as range 9
  do {
    // ( e.idx ) ( # CmdComment e.idx )
    // </0 & GenCommand-Common/4 (/7 e.Indent#1/5 )/8 (/11 # CmdComment/13 e.Text#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdComment, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    // closed e.Text#1 as range 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & GenCommand-Common/4 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: '/'/1 } Tile{ HalfReuse: '/'/13 AsIs: e.Text#1/9 AsIs: )/12 } Tile{ ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[1], '/' );
    refalrts::reinit_char( context[13], '/' );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[13], context[12] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) ( # CmdSeparator )
  // </0 & GenCommand-Common/4 (/7 e.Indent#1/5 )/8 (/11 # CmdSeparator/13 )/12 >/1
  if( ! refalrts::ident_term(  ident_CmdSeparator, context[13] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[9], context[10] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Indent#1 as range 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & GenCommand-Common/4 {REMOVED TILE} )/12 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 HalfReuse: )/13 } Tile{ ]] }
  refalrts::reinit_close_bracket( context[13] );
  refalrts::link_brackets( context[11], context[13] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[7], context[13] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_GenCommand_Common(func_GenCommand_Common, "GenCommand-Common#2881595569:337745613");
refalrts::RefalFunction& GenCommand_Common_2881595569_337745613 = descr_GenCommand_Common;

static refalrts::FnResult func_gen_GenCommand_Native_S37L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  //FAST GEN: ( e.$ ) s.$
  //GLOBAL GEN: ( e.$ ) s.$
  // </0 & GenCommand-Native$37\1/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // ( e.idx ) # RIGHT-EDGE
    // </0 & GenCommand-Native$37\1/4 (/7 e.Indent#1/5 )/8 # RIGHT-EDGE/9 >/1
    if( ! refalrts::ident_term(  ident_RIGHT_EDGE, context[9] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: 'r'/8 HalfReuse: 'e'/9 HalfReuse: 'f'/1 } 'a'/10 Tile{ HalfReuse: 'l'/0 HalfReuse: 'r'/4 }"ts::Iter res = arg_end->next;"/11 )/13 Tile{ ]] }
    if( ! refalrts::alloc_char( context[10], 'a' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[11], context[12], "ts::Iter res = arg_end->next;", 29 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[13] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[8], 'r' );
    refalrts::reinit_char( context[9], 'e' );
    refalrts::reinit_char( context[1], 'f' );
    refalrts::reinit_char( context[0], 'l' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::link_brackets( context[7], context[13] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[11], context[13] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[7], context[1] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx
  // </0 & GenCommand-Native$37\1/4 (/7 e.Indent#1/5 )/8 s.Offset#2/9 >/1
  // closed e.Indent#1 as range 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: 'r'/8 }"efalrts::Iter res = "/10 Tile{ AsIs: </0 Reuse: & ContextItem/4 } Tile{ AsIs: s.Offset#2/9 AsIs: >/1 } ';'/12 )/13 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[10], context[11], "efalrts::Iter res = ", 20 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[12], ';' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[8], 'r' );
  refalrts::update_name( context[4], & ContextItem_alias );
  refalrts::link_brackets( context[7], context[13] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[12], context[13] );
  res = refalrts::splice_evar( res, context[9], context[1] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_gen_GenCommand_Native_S37L1(func_gen_GenCommand_Native_S37L1, "GenCommand-Native$37\\1#2881595569:337745613");
refalrts::RefalFunction& gen_GenCommand_Native_S37L1_2881595569_337745613 = descr_gen_GenCommand_Native_S37L1;

static refalrts::FnResult func_gen_GenCommand_Native_S53L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  //FAST GEN: ( e.$ ) s.$
  //GLOBAL GEN: ( e.$ ) s.$
  // </0 & GenCommand-Native$53\1/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // ( e.idx ) # LEFT-EDGE
    // </0 & GenCommand-Native$53\1/4 (/7 e.Indent#1/5 )/8 # LEFT-EDGE/9 >/1
    if( ! refalrts::ident_term(  ident_LEFT_EDGE, context[9] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: 'r'/8 HalfReuse: 'e'/9 HalfReuse: 'f'/1 } 'a'/10 Tile{ HalfReuse: 'l'/0 HalfReuse: 'r'/4 }"ts::splice_to_freelist_open( trash_prev, res );"/11 )/13 Tile{ ]] }
    if( ! refalrts::alloc_char( context[10], 'a' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[11], context[12], "ts::splice_to_freelist_open( trash_prev, res );", 47 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[13] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[8], 'r' );
    refalrts::reinit_char( context[9], 'e' );
    refalrts::reinit_char( context[1], 'f' );
    refalrts::reinit_char( context[0], 'l' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::link_brackets( context[7], context[13] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[11], context[13] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[7], context[1] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx
  // </0 & GenCommand-Native$53\1/4 (/7 e.Indent#1/5 )/8 s.Offset#2/9 >/1
  // closed e.Indent#1 as range 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: 'r'/8 }"efalrts::splice_to_freelist_open( "/10 Tile{ AsIs: </0 Reuse: & ContextItem/4 } Tile{ AsIs: s.Offset#2/9 AsIs: >/1 }", res );"/12 )/14 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[10], context[11], "efalrts::splice_to_freelist_open( ", 34 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[12], context[13], ", res );", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[8], 'r' );
  refalrts::update_name( context[4], & ContextItem_alias );
  refalrts::link_brackets( context[7], context[14] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[12], context[14] );
  res = refalrts::splice_evar( res, context[9], context[1] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_gen_GenCommand_Native_S53L1(func_gen_GenCommand_Native_S53L1, "GenCommand-Native$53\\1#2881595569:337745613");
refalrts::RefalFunction& gen_GenCommand_Native_S53L1_2881595569_337745613 = descr_gen_GenCommand_Native_S53L1;

static refalrts::FnResult func_GenCommand_Native(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 70 elems
  refalrts::Iter context[70];
  refalrts::zeros( context, 70 );
  //FAST GEN: ( e.$ ) ( e.$ )
  //GLOBAL GEN: ( e.$ ) ( s.$ e.$ )
  // </0 & GenCommand-Native/4 (/7 e.idxB#0/5 )/8 (/11 s.idxTB#0/13 e.idxTBV#0/9 )/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[13], context[9], context[10] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTBV#0 as range 9
  do {
    // ( e.idx ) ( # CmdDefineIdent e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdDefineIdent/13 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdDefineIdent, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    // closed e.Name#1 as range 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 HalfReuse: 'c'/13 }"onst refalrts::RefalIdentifier ident_"/14 Tile{ AsIs: </0 Reuse: & CName/4 } Tile{ AsIs: e.Name#1/9 } >/16" = refalrts::ident_from_static(\""/17 </19 & DisplayCName/20 e.Name#1/9/21 >/23"\")"/24 Tile{ HalfReuse: ';'/12 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_chars( context[14], context[15], "onst refalrts::RefalIdentifier ident_", 37 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], " = refalrts::ident_from_static(\"", 32 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[20], & DisplayCName_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[21], context[22], context[9], context[10]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "\")", 2 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'c' );
    refalrts::update_name( context[4], & CName_alias );
    refalrts::reinit_char( context[12], ';' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[16], context[25] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdExtern e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdExtern/13 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdExtern, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    // closed e.Name#1 as range 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 HalfReuse: 'e'/13 }"xtern refalrts::RefalFunction& "/14 Tile{ AsIs: </0 Reuse: & CName/4 } Tile{ AsIs: e.Name#1/9 } >/16 ';'/17 )/18 </19 & FuncAlias/20 e.Name#1/9/21 >/23 Tile{ HalfReuse: (/12 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_chars( context[14], context[15], "xtern refalrts::RefalFunction& ", 31 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[17], ';' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[20], & FuncAlias_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[21], context[22], context[9], context[10]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'e' );
    refalrts::update_name( context[4], & CName_alias );
    refalrts::reinit_open_bracket( context[12] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[12], context[1] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[19] );
    refalrts::link_brackets( context[11], context[18] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[16], context[23] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdDeclaration e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdDeclaration/13 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdDeclaration, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    // closed e.Name#1 as range 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 HalfReuse: 'e'/13 }"xtern refalrts::RefalFunction& "/14 Tile{ AsIs: </0 Reuse: & CName/4 } Tile{ AsIs: e.Name#1/9 } >/16 ';'/17 )/18 </19 & FuncAlias/20 e.Name#1/9/21 >/23 (/24"#define "/25 </27 & BaseCName/28 e.Name#1/9/29 >/31"_str \""/32 </34 & DisplayCName/35 e.Name#1/9/36 >/38 '\"'/39 )/40 Tile{ HalfReuse: (/12 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_chars( context[14], context[15], "xtern refalrts::RefalFunction& ", 31 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[17], ';' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[20], & FuncAlias_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[21], context[22], context[9], context[10]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "#define ", 8 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[28], & BaseCName_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[29], context[30], context[9], context[10]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[32], context[33], "_str \"", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[34] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[35], & DisplayCName_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[36], context[37], context[9], context[10]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[38] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[39], '\"' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[40] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'e' );
    refalrts::update_name( context[4], & CName_alias );
    refalrts::reinit_open_bracket( context[12] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[12], context[1] );
    refalrts::link_brackets( context[24], context[40] );
    refalrts::push_stack( context[38] );
    refalrts::push_stack( context[34] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[19] );
    refalrts::link_brackets( context[11], context[18] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[16], context[40] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNativeFuncDescr e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdNativeFuncDescr/13 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdNativeFuncDescr, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    // closed e.Name#1 as range 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 HalfReuse: 's'/13 }"tatic refalrts::RefalNativeFunction descr_"/14 Tile{ AsIs: </0 Reuse: & BaseCName/4 } Tile{ AsIs: e.Name#1/9 } >/16"(func_"/17 </19 & BaseCName/20 e.Name#1/9/21 >/23", \""/24 </26 & DisplayCName/27 e.Name#1/9/28 >/30"\");"/31 )/33 </34 & FuncReference/35 e.Name#1/9/36 >/38 Tile{ HalfReuse: (/12 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_chars( context[14], context[15], "tatic refalrts::RefalNativeFunction descr_", 42 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "(func_", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[20], & BaseCName_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[21], context[22], context[9], context[10]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], ", \"", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & DisplayCName_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[28], context[29], context[9], context[10]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[31], context[32], "\");", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[33] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[34] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[35], & FuncReference_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[36], context[37], context[9], context[10]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[38] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 's' );
    refalrts::update_name( context[4], & BaseCName_alias );
    refalrts::reinit_open_bracket( context[12] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[12], context[1] );
    refalrts::push_stack( context[38] );
    refalrts::push_stack( context[34] );
    refalrts::link_brackets( context[11], context[33] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[16], context[38] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdFnStart e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdFnStart/13 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdFnStart, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    // closed e.Name#1 as range 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: ' '/8 HalfReuse: ' '/11 HalfReuse: )/13 } (/14"static refalrts::FnResult func_"/15 Tile{ AsIs: </0 Reuse: & BaseCName/4 } Tile{ AsIs: e.Name#1/9 } >/17 </18 & FuncArguments/19 >/20 ' '/21 Tile{ HalfReuse: '{'/12 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[15], context[16], "static refalrts::FnResult func_", 31 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[19], & FuncArguments_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[21], ' ' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[8], ' ' );
    refalrts::reinit_char( context[11], ' ' );
    refalrts::reinit_close_bracket( context[13] );
    refalrts::update_name( context[4], & BaseCName_alias );
    refalrts::reinit_char( context[12], '{' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[14], context[1] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[17] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[13] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[17], context[21] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[16] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx '  ' ) ( # CmdFnEnd )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 ' '/15 ' '/14 )/8 (/11 # CmdFnEnd/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdFnEnd, context[13] ) )
      continue;
    context[66] = context[5];
    context[67] = context[6];
    context[14] = refalrts::char_right( ' ', context[66], context[67] );
    if( ! context[14] )
      continue;
    context[15] = refalrts::char_right( ' ', context[66], context[67] );
    if( ! context[15] )
      continue;
    context[68] = context[9];
    context[69] = context[10];
    if( ! refalrts::empty_seq( context[68], context[69] ) )
      continue;
    // closed e.Indent#1 as range 66(5)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & GenCommand-Native/4 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/66(5) HalfReuse: )/15 HalfReuse: (/14 HalfReuse: '}'/8 HalfReuse: )/11 HalfReuse: (/13 AsIs: )/12 } Tile{ ]] }
    refalrts::reinit_close_bracket( context[15] );
    refalrts::reinit_open_bracket( context[14] );
    refalrts::reinit_char( context[8], '}' );
    refalrts::reinit_close_bracket( context[11] );
    refalrts::reinit_open_bracket( context[13] );
    refalrts::link_brackets( context[13], context[12] );
    refalrts::link_brackets( context[14], context[11] );
    refalrts::link_brackets( context[7], context[15] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[7], context[12] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdEmitNativeCode s.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdEmitNativeCode/13 s.LineNumber#1/14 e.Code#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdEmitNativeCode, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    // closed e.Code#1 as range 66(9)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 Reuse: # NativeInsertBegin/13 AsIs: s.LineNumber#1/14 } Tile{ HalfReuse: )/4 } Tile{ AsIs: e.Code#1/66(9) } Tile{ HalfReuse: (/0 } Tile{ HalfReuse: # NativeInsertEnd/12 HalfReuse: )/1 ]] }
    refalrts::update_ident( context[13], ident_NativeInsertBegin );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_open_bracket( context[0] );
    refalrts::reinit_ident( context[12], ident_NativeInsertEnd );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[0], context[1] );
    refalrts::link_brackets( context[11], context[4] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[66], context[67] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[7], context[14] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdProfileFunction )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdProfileFunction/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdProfileFunction, context[13] ) )
      continue;
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: 'r'/0 HalfReuse: 'e'/4 }"falrts::this_is_generated_function("/16 Tile{ HalfReuse: ')'/13 HalfReuse: ';'/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "falrts::this_is_generated_function(", 35 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[13], ')' );
    refalrts::reinit_char( context[12], ';' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdIssueMem s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdIssueMem/13 s.Number#1/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdIssueMem, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/15"// issue here memory for vars with "/17 </19 Tile{ HalfReuse: & StrFromInt/13 AsIs: s.Number#1/14 HalfReuse: >/12 HalfReuse: ' '/1 }"elems"/20 )/22 (/23 e.Indent#1/5/24"refalrts::Iter context["/26 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } s.Number#1/14/28 >/29"];"/30 )/32 (/33 e.Indent#1/5/34"refalrts::zeros( context, "/36 </38 & StrFromInt/39 s.Number#1/14/40 >/41" );"/42 )/44 Tile{ ]] }
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "// issue here memory for vars with ", 35 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "elems", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[23] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[24], context[25], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[26], context[27], "refalrts::Iter context[", 23 ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[28], context[14]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[30], context[31], "];", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[33] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[34], context[35], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[36], context[37], "refalrts::zeros( context, ", 26 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[38] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[39], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[40], context[14]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[41] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[42], context[43], " );", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[44] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_name( context[13], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::update_name( context[4], & StrFromInt_alias );
    refalrts::link_brackets( context[33], context[44] );
    refalrts::push_stack( context[41] );
    refalrts::push_stack( context[38] );
    refalrts::link_brackets( context[23], context[32] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[11], context[22] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[19] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[28], context[44] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[20], context[27] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[17], context[19] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdStartSentence )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdStartSentence/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdStartSentence, context[13] ) )
      continue;
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/14 e.Indent#1/5/15 ' '/17 Tile{ HalfReuse: ' '/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: 'd'/8 HalfReuse: 'o'/11 HalfReuse: ' '/13 HalfReuse: '{'/12 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[14] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[17], ' ' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ' ' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], 'd' );
    refalrts::reinit_char( context[11], 'o' );
    refalrts::reinit_char( context[13], ' ' );
    refalrts::reinit_char( context[12], '{' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[7], context[1] );
    refalrts::link_brackets( context[14], context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[14], context[17] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx '  ' ) ( # CmdEndSentence )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 ' '/15 ' '/14 )/8 (/11 # CmdEndSentence/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdEndSentence, context[13] ) )
      continue;
    context[66] = context[5];
    context[67] = context[6];
    context[14] = refalrts::char_right( ' ', context[66], context[67] );
    if( ! context[14] )
      continue;
    context[15] = refalrts::char_right( ' ', context[66], context[67] );
    if( ! context[15] )
      continue;
    context[68] = context[9];
    context[69] = context[10];
    if( ! refalrts::empty_seq( context[68], context[69] ) )
      continue;
    // closed e.Indent#1 as range 66(5)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: (/0 } e.Indent#1/66(5)/16 Tile{ HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/66(5) Reuse: '}'/15 AsIs: ' '/14 HalfReuse: 'w'/8 HalfReuse: 'h'/11 HalfReuse: 'i'/13 HalfReuse: 'l'/12 HalfReuse: 'e'/1 }" ( 0 );"/18 )/20 (/21 e.Indent#1/66(5)/22"refalrts::stop_sentence();"/24 )/26 (/27 )/28 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[66], context[67]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], " ( 0 );", 7 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[66], context[67]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "refalrts::stop_sentence();", 26 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[28] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[0] );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::update_char( context[15], '}' );
    refalrts::reinit_char( context[8], 'w' );
    refalrts::reinit_char( context[11], 'h' );
    refalrts::reinit_char( context[13], 'i' );
    refalrts::reinit_char( context[12], 'l' );
    refalrts::reinit_char( context[1], 'e' );
    refalrts::link_brackets( context[27], context[28] );
    refalrts::link_brackets( context[21], context[26] );
    refalrts::link_brackets( context[7], context[20] );
    refalrts::link_brackets( context[0], context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[18], context[28] );
    res = refalrts::splice_evar( res, context[4], context[1] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInitB0 )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInitB0/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInitB0, context[13] ) )
      continue;
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/14 e.Indent#1/5/15 )/17 (/18 e.Indent#1/5/19 </21 & ContextRange-B/22 0/23 >/24" = arg_begin"/25 Tile{ HalfReuse: ';'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: </8 HalfReuse: & ContextRange-E/11 HalfReuse: 0/13 HalfReuse: >/12 HalfReuse: ' '/1 }"= arg_end;"/27 )/29 (/30 e.Indent#1/5/31"refalrts::move_left( "/33 </35 & ContextRange/36 0/37 >/38" );"/39 )/41 (/42 e.Indent#1/5/43"refalrts::move_left( "/45 </47 & ContextRange/48 0/49 >/50" );"/51 )/53 (/54 e.Indent#1/5/55"refalrts::move_right( "/57 </59 & ContextRange/60 0/61 >/62" );"/63 )/65 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[14] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[19], context[20], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], & ContextRange_B_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[23], 0UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], " = arg_begin", 12 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], "= arg_end;", 10 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[30] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[31], context[32], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[33], context[34], "refalrts::move_left( ", 21 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[36], & ContextRange_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[37], 0UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[38] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[39], context[40], " );", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[41] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[42] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[43], context[44], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[45], context[46], "refalrts::move_left( ", 21 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[47] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[48], & ContextRange_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[49], 0UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[50] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[51], context[52], " );", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[53] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[54] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[55], context[56], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[57], context[58], "refalrts::move_right( ", 22 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[59] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[60], & ContextRange_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[61], 0UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[62] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[63], context[64], " );", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[65] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ';' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_open_call( context[8] );
    refalrts::reinit_name( context[11], & ContextRange_E_alias );
    refalrts::reinit_number( context[13], 0UL );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[54], context[65] );
    refalrts::push_stack( context[62] );
    refalrts::push_stack( context[59] );
    refalrts::link_brackets( context[42], context[53] );
    refalrts::push_stack( context[50] );
    refalrts::push_stack( context[47] );
    refalrts::link_brackets( context[30], context[41] );
    refalrts::push_stack( context[38] );
    refalrts::push_stack( context[35] );
    refalrts::link_brackets( context[7], context[29] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[8] );
    refalrts::link_brackets( context[18], context[4] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[21] );
    refalrts::link_brackets( context[14], context[17] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[27], context[65] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[14], context[26] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInitB0-Lite )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInitB0-Lite/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInitB0_Lite, context[13] ) )
      continue;
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/14 e.Indent#1/5/15 )/17 (/18 e.Indent#1/5/19 </21 & ContextRange-B/22 0/23 >/24" = arg_begin"/25 Tile{ HalfReuse: ';'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: </8 HalfReuse: & ContextRange-E/11 HalfReuse: 0/13 HalfReuse: >/12 HalfReuse: ' '/1 }"= arg_end;"/27 )/29 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[14] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[19], context[20], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], & ContextRange_B_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[23], 0UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], " = arg_begin", 12 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], "= arg_end;", 10 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[29] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ';' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_open_call( context[8] );
    refalrts::reinit_name( context[11], & ContextRange_E_alias );
    refalrts::reinit_number( context[13], 0UL );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[7], context[29] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[8] );
    refalrts::link_brackets( context[18], context[4] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[21] );
    refalrts::link_brackets( context[14], context[17] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[27], context[29] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[14], context[26] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdChar s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdChar/13 s.Direction#1/14 s.BracketNumber#1/15 s.Char#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdChar, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 s.BracketNumber#1/15 s.Char#1/16 {REMOVED TILE}
    //RESULT: Tile{ [[ } (/17 e.Indent#1/5/18 )/20 Tile{ AsIs: </0 Reuse: & PrintMatchChar/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.Direction1 #14/11 HalfReuse: s.BracketNumber1 #15/13 } Tile{ HalfReuse: s.Char1 #16/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[20] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatchChar_alias );
    refalrts::reinit_svar( context[11], context[14] );
    refalrts::reinit_svar( context[13], context[15] );
    refalrts::reinit_svar( context[12], context[16] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[17], context[20] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[17], context[20] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCharSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdCharSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.Offset#1/16 s.Char#1/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdCharSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 {REMOVED TILE} s.Offset#1/16 s.Char#1/17 {REMOVED TILE}
    //RESULT: Tile{ [[ } (/18 e.Indent#1/5/19 )/21 Tile{ AsIs: </0 Reuse: & PrintMatchCharSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.Offset1 #16/11 HalfReuse: s.Direction1 #14/13 } Tile{ AsIs: s.BracketNumber#1/15 } Tile{ HalfReuse: s.Char1 #17/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[19], context[20], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatchCharSave_alias );
    refalrts::reinit_svar( context[11], context[16] );
    refalrts::reinit_svar( context[13], context[14] );
    refalrts::reinit_svar( context[12], context[17] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[18], context[21] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[18], context[21] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNumber s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdNumber/13 s.Direction#1/14 s.BracketNumber#1/15 s.Number#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdNumber, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 s.BracketNumber#1/15 s.Number#1/16 {REMOVED TILE}
    //RESULT: Tile{ [[ } (/17 e.Indent#1/5/18 )/20 Tile{ AsIs: </0 Reuse: & PrintMatchNumber/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.Direction1 #14/11 HalfReuse: s.BracketNumber1 #15/13 } Tile{ HalfReuse: s.Number1 #16/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[20] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatchNumber_alias );
    refalrts::reinit_svar( context[11], context[14] );
    refalrts::reinit_svar( context[13], context[15] );
    refalrts::reinit_svar( context[12], context[16] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[17], context[20] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[17], context[20] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNumberSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdNumberSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.Offset#1/16 s.Number#1/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdNumberSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 {REMOVED TILE} s.Offset#1/16 s.Number#1/17 {REMOVED TILE}
    //RESULT: Tile{ [[ } (/18 e.Indent#1/5/19 )/21 Tile{ AsIs: </0 Reuse: & PrintMatchNumberSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.Offset1 #16/11 HalfReuse: s.Direction1 #14/13 } Tile{ AsIs: s.BracketNumber#1/15 } Tile{ HalfReuse: s.Number1 #17/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[19], context[20], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatchNumberSave_alias );
    refalrts::reinit_svar( context[11], context[16] );
    refalrts::reinit_svar( context[13], context[14] );
    refalrts::reinit_svar( context[12], context[17] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[18], context[21] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[18], context[21] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdName s.idx s.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdName/13 s.Direction#1/14 s.BracketNumber#1/15 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdName, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    // closed e.Name#1 as range 66(9)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 s.BracketNumber#1/15 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/16 e.Indent#1/5/17 Tile{ AsIs: )/12 } Tile{ AsIs: </0 Reuse: & PrintMatchName/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.Direction1 #14/11 HalfReuse: s.BracketNumber1 #15/13 } Tile{ AsIs: e.Name#1/66(9) } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatchName_alias );
    refalrts::reinit_svar( context[11], context[14] );
    refalrts::reinit_svar( context[13], context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[16], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[66], context[67] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNameSave s.idx s.idx s.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdNameSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.Offset#1/16 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdNameSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    // closed e.Name#1 as range 66(9)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 {REMOVED TILE} s.Offset#1/16 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/17 e.Indent#1/5/18 Tile{ AsIs: )/12 } Tile{ AsIs: </0 Reuse: & PrintMatchNameSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.Offset1 #16/11 HalfReuse: s.Direction1 #14/13 } Tile{ AsIs: s.BracketNumber#1/15 } Tile{ AsIs: e.Name#1/66(9) } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatchNameSave_alias );
    refalrts::reinit_svar( context[11], context[16] );
    refalrts::reinit_svar( context[13], context[14] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[17], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[66], context[67] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[17], context[17] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdIdent s.idx s.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdIdent/13 s.Direction#1/14 s.BracketNumber#1/15 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdIdent, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    // closed e.Name#1 as range 66(9)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 s.BracketNumber#1/15 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/16 e.Indent#1/5/17 Tile{ AsIs: )/12 } Tile{ AsIs: </0 Reuse: & PrintMatchIdent/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.Direction1 #14/11 HalfReuse: s.BracketNumber1 #15/13 } Tile{ AsIs: e.Name#1/66(9) } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatchIdent_alias );
    refalrts::reinit_svar( context[11], context[14] );
    refalrts::reinit_svar( context[13], context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[16], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[66], context[67] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdIdentSave s.idx s.idx s.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdIdentSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.Offset#1/16 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdIdentSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    // closed e.Name#1 as range 66(9)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 {REMOVED TILE} s.Offset#1/16 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/17 e.Indent#1/5/18 Tile{ AsIs: )/12 } Tile{ AsIs: </0 Reuse: & PrintMatchIdentSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.Offset1 #16/11 HalfReuse: s.Direction1 #14/13 } Tile{ AsIs: s.BracketNumber#1/15 } Tile{ AsIs: e.Name#1/66(9) } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatchIdentSave_alias );
    refalrts::reinit_svar( context[11], context[16] );
    refalrts::reinit_svar( context[13], context[14] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[17], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[66], context[67] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[17], context[17] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdBrackets s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdBrackets/13 s.Direction#1/14 s.BracketNumber#1/15 s.InnerBrackets#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdBrackets, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 s.BracketNumber#1/15 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/17 e.Indent#1/5/18 )/20 </21 & PrintBracketsVarInit/22 e.Indent#1/5/23 Tile{ AsIs: s.InnerBrackets#1/16 } >/25 Tile{ AsIs: </0 Reuse: & PrintMatchBrackets/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.Direction1 #14/11 HalfReuse: s.BracketNumber1 #15/13 } Tile{ HalfReuse: s.InnerBrackets1 #16/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], & PrintBracketsVarInit_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[23], context[24], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[25] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatchBrackets_alias );
    refalrts::reinit_svar( context[11], context[14] );
    refalrts::reinit_svar( context[13], context[15] );
    refalrts::reinit_svar( context[12], context[16] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::push_stack( context[25] );
    refalrts::push_stack( context[21] );
    refalrts::link_brackets( context[17], context[20] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[25], context[25] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[17], context[22] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdBracketsSave s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdBracketsSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.InnerBrackets#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdBracketsSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 s.BracketNumber#1/15 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/17 e.Indent#1/5/18 )/20 </21 & PrintBracketsVarInit/22 e.Indent#1/5/23 Tile{ AsIs: s.InnerBrackets#1/16 } >/25 Tile{ AsIs: </0 Reuse: & PrintMatchBracketsSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.Direction1 #14/11 HalfReuse: s.BracketNumber1 #15/13 } Tile{ HalfReuse: s.InnerBrackets1 #16/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], & PrintBracketsVarInit_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[23], context[24], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[25] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatchBracketsSave_alias );
    refalrts::reinit_svar( context[11], context[14] );
    refalrts::reinit_svar( context[13], context[15] );
    refalrts::reinit_svar( context[12], context[16] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::push_stack( context[25] );
    refalrts::push_stack( context[21] );
    refalrts::link_brackets( context[17], context[20] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[25], context[25] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[17], context[22] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdADT s.idx s.idx s.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdADT/13 s.Direction#1/14 s.BracketNumber#1/15 s.InnerBrackets#1/16 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdADT, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    // closed e.Name#1 as range 66(9)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 s.BracketNumber#1/15 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/17 e.Indent#1/5/18 )/20 </21 & PrintBracketsVarInit/22 e.Indent#1/5/23 s.InnerBrackets#1/16/25 Tile{ AsIs: >/1 } Tile{ AsIs: </0 Reuse: & PrintMatchADT/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.Direction1 #14/11 HalfReuse: s.BracketNumber1 #15/13 } Tile{ AsIs: s.InnerBrackets#1/16 AsIs: e.Name#1/66(9) HalfReuse: >/12 } Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], & PrintBracketsVarInit_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[23], context[24], context[5], context[6]))
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[25], context[16]))
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatchADT_alias );
    refalrts::reinit_svar( context[11], context[14] );
    refalrts::reinit_svar( context[13], context[15] );
    refalrts::reinit_close_call( context[12] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[21] );
    refalrts::link_brackets( context[17], context[20] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[16], context[12] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    res = refalrts::splice_evar( res, context[17], context[25] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdADTSave s.idx s.idx s.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdADTSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.InnerBrackets#1/16 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdADTSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    // closed e.Name#1 as range 66(9)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 s.BracketNumber#1/15 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/17 e.Indent#1/5/18 )/20 </21 & PrintBracketsVarInit/22 e.Indent#1/5/23 s.InnerBrackets#1/16/25 Tile{ AsIs: >/1 } Tile{ AsIs: </0 Reuse: & PrintMatchADTSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.Direction1 #14/11 HalfReuse: s.BracketNumber1 #15/13 } Tile{ AsIs: s.InnerBrackets#1/16 AsIs: e.Name#1/66(9) HalfReuse: >/12 } Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], & PrintBracketsVarInit_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[23], context[24], context[5], context[6]))
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[25], context[16]))
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatchADTSave_alias );
    refalrts::reinit_svar( context[11], context[14] );
    refalrts::reinit_svar( context[13], context[15] );
    refalrts::reinit_close_call( context[12] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[21] );
    refalrts::link_brackets( context[17], context[20] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[16], context[12] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    res = refalrts::splice_evar( res, context[17], context[25] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCallSave s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdCallSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.InnerBrackets#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdCallSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: </11 HalfReuse: & PrintBracketsVarInit/13 } e.Indent#1/5/17 s.InnerBrackets#1/16/19 >/20 (/21 e.Indent#1/5/22 Tile{ AsIs: </0 Reuse: & ContextItem/4 } </24 & Add/25 2/26 Tile{ AsIs: s.InnerBrackets#1/16 HalfReuse: >/12 AsIs: >/1 }" = refalrts::call_"/27 </29 & StrFromDirection/30 Tile{ AsIs: s.Direction#1/14 } >/31"( "/32 </34 & ContextRange/35 s.InnerBrackets#1/16/36 >/37", "/38 </40 & ContextRange/41 Tile{ AsIs: s.BracketNumber#1/15 } >/42" );"/43 )/45 Tile{ ]] }
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[19], context[16]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[25], & Add_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[26], 2UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], " = refalrts::call_", 18 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], & StrFromDirection_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[32], context[33], "( ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[34] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[35], & ContextRange_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[36], context[16]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[37] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[38], context[39], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[40] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[41], & ContextRange_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[42] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[43], context[44], " );", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[45] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[11] );
    refalrts::reinit_name( context[13], & PrintBracketsVarInit_alias );
    refalrts::update_name( context[4], & ContextItem_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::link_brackets( context[21], context[45] );
    refalrts::push_stack( context[42] );
    refalrts::push_stack( context[40] );
    refalrts::push_stack( context[37] );
    refalrts::push_stack( context[34] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[11] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[42], context[45] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[31], context[41] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[27], context[30] );
    res = refalrts::splice_evar( res, context[16], context[1] );
    res = refalrts::splice_evar( res, context[24], context[26] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[19], context[21] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdEmpty s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdEmpty/13 s.Direction#1/14 s.BracketNumber#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdEmpty, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 s.BracketNumber#1/15 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: (/1 } e.Indent#1/5/16 Tile{ AsIs: )/12 } Tile{ AsIs: </0 Reuse: & PrintMatchEmpty/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.BracketNumber1 #15/11 HalfReuse: >/13 } Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[1] );
    refalrts::update_name( context[4], & PrintMatchEmpty_alias );
    refalrts::reinit_svar( context[11], context[15] );
    refalrts::reinit_close_call( context[13] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[1], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdVar s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdVar/13 s.Direction#1/14 s.BracketNumber#1/15 s.Mode#1/16 s.VarNumber#1/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdVar, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 s.BracketNumber#1/15 {REMOVED TILE} s.VarNumber#1/17 {REMOVED TILE}
    //RESULT: Tile{ [[ } (/18 e.Indent#1/5/19 )/21 Tile{ AsIs: </0 Reuse: & PrintMatchSTVar/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.Direction1 #14/11 HalfReuse: s.BracketNumber1 #15/13 } Tile{ AsIs: s.Mode#1/16 } Tile{ HalfReuse: s.VarNumber1 #17/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[19], context[20], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatchSTVar_alias );
    refalrts::reinit_svar( context[11], context[14] );
    refalrts::reinit_svar( context[13], context[15] );
    refalrts::reinit_svar( context[12], context[17] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[18], context[21] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[18], context[21] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdVarSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdVarSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.Mode#1/16 s.VarNumber#1/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdVarSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 s.BracketNumber#1/15 {REMOVED TILE} s.VarNumber#1/17 {REMOVED TILE}
    //RESULT: Tile{ [[ } (/18 e.Indent#1/5/19 )/21 Tile{ AsIs: </0 Reuse: & PrintMatchSTVarSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.Direction1 #14/11 HalfReuse: s.BracketNumber1 #15/13 } Tile{ AsIs: s.Mode#1/16 } Tile{ HalfReuse: s.VarNumber1 #17/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[19], context[20], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatchSTVarSave_alias );
    refalrts::reinit_svar( context[11], context[14] );
    refalrts::reinit_svar( context[13], context[15] );
    refalrts::reinit_svar( context[12], context[17] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[18], context[21] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[18], context[21] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdRepeated s.idx s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdRepeated/13 s.Direction#1/14 s.BracketNumber#1/15 s.Mode#1/16 s.Var#1/17 s.Sample#1/18 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdRepeated, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[18], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: </11 } Tile{ Reuse: & PrintMatchRepeated/4 } Tile{ HalfReuse: (/1 } e.Indent#1/5/19 Tile{ HalfReuse: )/13 AsIs: s.Direction#1/14 AsIs: s.BracketNumber#1/15 AsIs: s.Mode#1/16 AsIs: s.Var#1/17 AsIs: s.Sample#1/18 HalfReuse: >/12 } Tile{ ]] }
    if (! refalrts::copy_evar(context[19], context[20], context[5], context[6]))
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[11] );
    refalrts::update_name( context[4], & PrintMatchRepeated_alias );
    refalrts::reinit_open_bracket( context[1] );
    refalrts::reinit_close_bracket( context[13] );
    refalrts::reinit_close_call( context[12] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[11] );
    refalrts::link_brackets( context[1], context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[13], context[12] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdRepeatedTVarSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdRepeatedTVarSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.Var#1/16 s.Sample#1/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdRepeatedTVarSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 s.BracketNumber#1/15 {REMOVED TILE} s.Sample#1/17 {REMOVED TILE}
    //RESULT: Tile{ [[ } (/18 e.Indent#1/5/19 )/21 Tile{ AsIs: </0 Reuse: & PrintMatchRepeatedTVarSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.Direction1 #14/11 HalfReuse: s.BracketNumber1 #15/13 } Tile{ AsIs: s.Var#1/16 } Tile{ HalfReuse: s.Sample1 #17/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[19], context[20], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatchRepeatedTVarSave_alias );
    refalrts::reinit_svar( context[11], context[14] );
    refalrts::reinit_svar( context[13], context[15] );
    refalrts::reinit_svar( context[12], context[17] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[18], context[21] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[18], context[21] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdOpenedE-Start # AlgLeft s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdOpenedE-Start/13 # AlgLeft/14 s.BracketNumber#1/15 s.VarNumber#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdOpenedE_Start, context[13] ) )
      continue;
    context[66] = context[9];
    context[67] = context[10];
    context[14] = refalrts::ident_left(  ident_AlgLeft, context[66], context[67] );
    if( ! context[14] )
      continue;
    // closed e.Indent#1 as range 5
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.BracketNumber#1/15 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/17 e.Indent#1/5/18 ' '/20 Tile{ HalfReuse: ' '/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: </8 HalfReuse: & ContextRange-B/11 HalfReuse: s.VarNumber1 #16/13 HalfReuse: >/14 }" = 0;"/21 )/23 (/24 e.Indent#1/5/25 </27 & ContextRange-E/28 Tile{ AsIs: s.VarNumber#1/16 HalfReuse: >/12 HalfReuse: ' '/1 }"= 0;"/29 )/31 (/32 e.Indent#1/5/33"refalrts::start_e_loop();"/35 )/37 (/38 e.Indent#1/5/39"do {"/41 )/43 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[20], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], " = 0;", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[24] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[25], context[26], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[28], & ContextRange_E_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[29], context[30], "= 0;", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[32] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[33], context[34], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[35], context[36], "refalrts::start_e_loop();", 25 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[37] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[38] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[39], context[40], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[41], context[42], "do {", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[43] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ' ' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_open_call( context[8] );
    refalrts::reinit_name( context[11], & ContextRange_B_alias );
    refalrts::reinit_svar( context[13], context[16] );
    refalrts::reinit_close_call( context[14] );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[38], context[43] );
    refalrts::link_brackets( context[32], context[37] );
    refalrts::link_brackets( context[24], context[31] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[27] );
    refalrts::link_brackets( context[7], context[23] );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[8] );
    refalrts::link_brackets( context[17], context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[29], context[43] );
    res = refalrts::splice_evar( res, context[16], context[1] );
    res = refalrts::splice_evar( res, context[21], context[28] );
    res = refalrts::splice_evar( res, context[0], context[14] );
    res = refalrts::splice_evar( res, context[17], context[20] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx '  ' ) ( # CmdOpenedE-End # AlgLeft s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 ' '/16 ' '/15 )/8 (/11 # CmdOpenedE-End/13 # AlgLeft/14 s.BracketNumber#1/17 s.VarNumber#1/18 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdOpenedE_End, context[13] ) )
      continue;
    context[66] = context[9];
    context[67] = context[10];
    context[14] = refalrts::ident_left(  ident_AlgLeft, context[66], context[67] );
    if( ! context[14] )
      continue;
    context[68] = context[5];
    context[69] = context[6];
    context[15] = refalrts::char_right( ' ', context[68], context[69] );
    if( ! context[15] )
      continue;
    context[16] = refalrts::char_right( ' ', context[68], context[69] );
    if( ! context[16] )
      continue;
    // closed e.Indent#1 as range 68(5)
    if( ! refalrts::svar_left( context[17], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[18], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: (/0 } e.Indent#1/68(5)/19 Tile{ HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/68(5) Reuse: '}'/16 AsIs: ' '/15 HalfReuse: 'w'/8 HalfReuse: 'h'/11 HalfReuse: 'i'/13 HalfReuse: 'l'/14 }"e ( refalrts::open_evar_advance( "/21 </23 & ContextRange/24 Tile{ AsIs: s.VarNumber#1/18 HalfReuse: >/12 HalfReuse: ','/1 } ' '/25 </26 & ContextRange/27 Tile{ AsIs: s.BracketNumber#1/17 } >/28" ) );"/29 )/31 Tile{ ]] }
    if (! refalrts::copy_evar(context[19], context[20], context[68], context[69]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "e ( refalrts::open_evar_advance( ", 33 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[24], & ContextRange_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[25], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & ContextRange_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[29], context[30], " ) );", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[31] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[0] );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::update_char( context[16], '}' );
    refalrts::reinit_char( context[8], 'w' );
    refalrts::reinit_char( context[11], 'h' );
    refalrts::reinit_char( context[13], 'i' );
    refalrts::reinit_char( context[14], 'l' );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[7], context[31] );
    refalrts::push_stack( context[28] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[23] );
    refalrts::link_brackets( context[0], context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[28], context[31] );
    res = refalrts::splice_evar( res, context[17], context[17] );
    res = refalrts::splice_evar( res, context[25], context[27] );
    res = refalrts::splice_evar( res, context[18], context[1] );
    res = refalrts::splice_evar( res, context[21], context[24] );
    res = refalrts::splice_evar( res, context[4], context[14] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdSave s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdSave/13 s.OldBracketNumber#1/14 s.NewBracketNumber#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/16 Tile{ AsIs: </0 Reuse: & ContextRange-B/4 } Tile{ AsIs: s.NewBracketNumber#1/15 HalfReuse: >/12 HalfReuse: ' '/1 }"= "/18 </20 Tile{ HalfReuse: & ContextRange-B/13 AsIs: s.OldBracketNumber#1/14 } >/21 ';'/22 )/23 (/24 e.Indent#1/5/25 </27 & ContextRange-E/28 s.NewBracketNumber#1/15/29 >/30" = "/31 </33 & ContextRange-E/34 s.OldBracketNumber#1/14/35 >/36 ';'/37 )/38 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "= ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[22], ';' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[24] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[25], context[26], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[28], & ContextRange_E_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[29], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[31], context[32], " = ", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[33] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[34], & ContextRange_E_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[35], context[14]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[36] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[37], ';' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[38] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ContextRange_B_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::reinit_name( context[13], & ContextRange_B_alias );
    refalrts::link_brackets( context[24], context[38] );
    refalrts::push_stack( context[36] );
    refalrts::push_stack( context[33] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[27] );
    refalrts::link_brackets( context[11], context[23] );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[21], context[38] );
    res = refalrts::splice_evar( res, context[13], context[14] );
    res = refalrts::splice_evar( res, context[18], context[20] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdResetAllocator )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdResetAllocator/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdResetAllocator, context[13] ) )
      continue;
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 HalfReuse: )/13 HalfReuse: (/12 } e.Indent#1/5/14 'r'/16 Tile{ HalfReuse: 'e'/0 HalfReuse: 'f'/4 }"alrts::reset_allocator();"/17 Tile{ HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[16], 'r' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "alrts::reset_allocator();", 25 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_close_bracket( context[13] );
    refalrts::reinit_open_bracket( context[12] );
    refalrts::reinit_char( context[0], 'e' );
    refalrts::reinit_char( context[4], 'f' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[12], context[1] );
    refalrts::link_brackets( context[11], context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[12] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdSetRes # ARG-BEGIN )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdSetRes/13 # ARG-BEGIN/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdSetRes, context[13] ) )
      continue;
    context[66] = context[9];
    context[67] = context[10];
    context[14] = refalrts::ident_left(  ident_ARG_BEGIN, context[66], context[67] );
    if( ! context[14] )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: (/0 } e.Indent#1/5/15 Tile{ HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: 'r'/8 HalfReuse: 'e'/11 HalfReuse: 'f'/13 HalfReuse: 'a'/14 HalfReuse: 'l'/12 HalfReuse: 'r'/1 }"ts::Iter res = arg_begin;"/17 )/19 Tile{ ]] }
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "ts::Iter res = arg_begin;", 25 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[19] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[0] );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], 'r' );
    refalrts::reinit_char( context[11], 'e' );
    refalrts::reinit_char( context[13], 'f' );
    refalrts::reinit_char( context[14], 'a' );
    refalrts::reinit_char( context[12], 'l' );
    refalrts::reinit_char( context[1], 'r' );
    refalrts::link_brackets( context[7], context[19] );
    refalrts::link_brackets( context[0], context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[17], context[19] );
    res = refalrts::splice_evar( res, context[4], context[1] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdSetRes s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdSetRes/13 s.Offset#1/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdSetRes, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/15 e.Indent#1/5/16 Tile{ AsIs: )/12 HalfReuse: (/1 } e.Indent#1/5/18"refalrts::Iter trash_prev = arg_begin->prev;"/20 )/22 (/23 e.Indent#1/5/24"refalrts::use(trash_prev);"/26 )/28 </29 & Fetch/30 Tile{ AsIs: s.Offset#1/14 } </31 Tile{ HalfReuse: & @create_closure@/0 Reuse: & GenCommand-Native$37\1/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: >/11 HalfReuse: >/13 } Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[15] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "refalrts::Iter trash_prev = arg_begin->prev;", 44 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[23] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[24], context[25], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[26], context[27], "refalrts::use(trash_prev);", 26 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], & Fetch_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[31] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[1] );
    refalrts::reinit_name( context[0], & refalrts::create_closure );
    refalrts::update_name( context[4], & gen_GenCommand_Native_S37L1_alias );
    refalrts::reinit_close_call( context[11] );
    refalrts::reinit_close_call( context[13] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[31] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[23], context[28] );
    refalrts::link_brackets( context[1], context[22] );
    refalrts::link_brackets( context[15], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[31], context[31] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[20], context[30] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[12], context[1] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCopyVar 'e' s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdCopyVar/13 'e'/14 s.Target#1/15 s.Sample#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdCopyVar, context[13] ) )
      continue;
    context[66] = context[9];
    context[67] = context[10];
    context[14] = refalrts::char_left( 'e', context[66], context[67] );
    if( ! context[14] )
      continue;
    // closed e.Indent#1 as range 5
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/17 e.Indent#1/5/18 )/20 (/21 e.Indent#1/5/22"if (! refalrts::copy_evar("/24 </26 & ContextRange/27 Tile{ AsIs: s.Target#1/15 } >/28", "/29 </31 & ContextRange/32 Tile{ AsIs: s.Sample#1/16 HalfReuse: >/12 HalfReuse: ')'/1 } Tile{ HalfReuse: ')'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: ' '/8 HalfReuse: ' '/11 HalfReuse: 'r'/13 AsIs: 'e'/14 }"turn refalrts::cNoMemory;"/33 )/35 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "if (! refalrts::copy_evar(", 26 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & ContextRange_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[29], context[30], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[32], & ContextRange_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[33], context[34], "turn refalrts::cNoMemory;", 25 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[35] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ')' );
    refalrts::reinit_char( context[0], ')' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], ' ' );
    refalrts::reinit_char( context[11], ' ' );
    refalrts::reinit_char( context[13], 'r' );
    refalrts::link_brackets( context[7], context[35] );
    refalrts::link_brackets( context[21], context[4] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[28] );
    refalrts::push_stack( context[26] );
    refalrts::link_brackets( context[17], context[20] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[33], context[35] );
    res = refalrts::splice_evar( res, context[0], context[14] );
    res = refalrts::splice_evar( res, context[16], context[1] );
    res = refalrts::splice_evar( res, context[28], context[32] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[17], context[27] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCopyVar s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdCopyVar/13 s.Mode#1/14 s.Target#1/15 s.Sample#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdCopyVar, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.Mode#1/14 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/17"if ("/19 Tile{ HalfReuse: '!'/13 }" refalrts::copy_stvar("/21 Tile{ AsIs: </0 Reuse: & ContextItem/4 } Tile{ AsIs: s.Target#1/15 } >/23", "/24 </26 & ContextItem/27 Tile{ AsIs: s.Sample#1/16 HalfReuse: >/12 HalfReuse: ')'/1 } ')'/28 )/29 (/30 e.Indent#1/5/31"  return refalrts::cNoMemory;"/33 )/35 Tile{ ]] }
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "if (", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], " refalrts::copy_stvar(", 22 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & ContextItem_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[28], ')' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[30] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[31], context[32], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[33], context[34], "  return refalrts::cNoMemory;", 29 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[35] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], '!' );
    refalrts::update_name( context[4], & ContextItem_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ')' );
    refalrts::link_brackets( context[30], context[35] );
    refalrts::link_brackets( context[11], context[29] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[28], context[35] );
    res = refalrts::splice_evar( res, context[16], context[1] );
    res = refalrts::splice_evar( res, context[23], context[27] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdReinitSVar s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdReinitSVar/13 s.Offset#1/14 s.Sample#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdReinitSVar, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/16"ref"/18 Tile{ HalfReuse: 'a'/13 }"lrts::reinit_svar( "/20 Tile{ AsIs: </0 Reuse: & ContextItem/4 } Tile{ AsIs: s.Offset#1/14 } >/22", "/23 </25 & ContextItem/26 Tile{ AsIs: s.Sample#1/15 HalfReuse: >/12 HalfReuse: ' '/1 }");"/27 )/29 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "ref", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "lrts::reinit_svar( ", 19 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], & ContextItem_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[29] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'a' );
    refalrts::update_name( context[4], & ContextItem_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[11], context[29] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[25] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[27], context[29] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[22], context[26] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCreateElem # Allocate s.idx # ElString e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdCreateElem/13 # Allocate/14 s.ElemNumber#1/15 # ElString/16 e.String#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdCreateElem, context[13] ) )
      continue;
    context[66] = context[9];
    context[67] = context[10];
    context[14] = refalrts::ident_left(  ident_Allocate, context[66], context[67] );
    if( ! context[14] )
      continue;
    // closed e.Indent#1 as range 5
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    context[16] = refalrts::ident_left(  ident_ElString, context[66], context[67] );
    if( ! context[16] )
      continue;
    // closed e.String#1 as range 66(9)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/17"if( ! refalrts::alloc_chars( "/19 Tile{ HalfReuse: </13 HalfReuse: & ContextItem/14 AsIs: s.ElemNumber#1/15 HalfReuse: >/16 }", "/21 Tile{ AsIs: </0 Reuse: & ContextItem/4 } </23 & Inc/24 s.ElemNumber#1/15/25 >/26 >/27", "/28 </30 & PrintString/31 Tile{ AsIs: e.String#1/66(9) } >/32" ) )"/33 )/35 (/36 e.Indent#1/5/37"  return refalrts::cNoMemory"/39 Tile{ HalfReuse: ';'/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "if( ! refalrts::alloc_chars( ", 29 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[24], & Inc_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[25], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[28], context[29], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[31], & PrintString_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[33], context[34], " ) )", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[36] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[37], context[38], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[39], context[40], "  return refalrts::cNoMemory", 28 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[13] );
    refalrts::reinit_name( context[14], & ContextItem_alias );
    refalrts::reinit_close_call( context[16] );
    refalrts::update_name( context[4], & ContextItem_alias );
    refalrts::reinit_char( context[12], ';' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[36], context[1] );
    refalrts::link_brackets( context[11], context[35] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[32], context[40] );
    res = refalrts::splice_evar( res, context[66], context[67] );
    res = refalrts::splice_evar( res, context[23], context[31] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[13], context[16] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCreateElem s.idx s.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdCreateElem/13 s.CreateMode#1/14 s.ElemNumber#1/15 e.ElemInfo#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdCreateElem, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    // closed e.ElemInfo#1 as range 66(9)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.CreateMode#1/14 s.ElemNumber#1/15 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/16 e.Indent#1/5/17 Tile{ AsIs: )/12 } Tile{ AsIs: </0 Reuse: & PrintCreateElem/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.CreateMode1 #14/11 HalfReuse: s.ElemNumber1 #15/13 } Tile{ AsIs: e.ElemInfo#1/66(9) } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintCreateElem_alias );
    refalrts::reinit_svar( context[11], context[14] );
    refalrts::reinit_svar( context[13], context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[16], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[66], context[67] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdLinkBrackets s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdLinkBrackets/13 s.Left#1/14 s.Right#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdLinkBrackets, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/16"ref"/18 Tile{ HalfReuse: 'a'/13 }"lrts::link_brackets( "/20 Tile{ AsIs: </0 Reuse: & ContextItem/4 } Tile{ AsIs: s.Left#1/14 } >/22", "/23 </25 & ContextItem/26 Tile{ AsIs: s.Right#1/15 HalfReuse: >/12 HalfReuse: ' '/1 }");"/27 )/29 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "ref", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "lrts::link_brackets( ", 21 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], & ContextItem_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[29] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'a' );
    refalrts::update_name( context[4], & ContextItem_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[11], context[29] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[25] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[27], context[29] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[22], context[26] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdPushStack s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdPushStack/13 s.ElemNumber#1/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdPushStack, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/15 Tile{ HalfReuse: 'r'/4 }"efalrts::push_stack( "/17 Tile{ AsIs: </0 } Tile{ HalfReuse: & ContextItem/13 AsIs: s.ElemNumber#1/14 HalfReuse: >/12 HalfReuse: ' '/1 }");"/19 )/21 Tile{ ]] }
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "efalrts::push_stack( ", 21 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_name( context[13], & ContextItem_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[11], context[21] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[19], context[21] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInsertElem s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInsertElem/13 s.ElemNumber#1/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInsertElem, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/15 Tile{ HalfReuse: 'r'/4 }"es = refalrts::splice_elem( res, "/17 Tile{ AsIs: </0 } Tile{ HalfReuse: & ContextItem/13 AsIs: s.ElemNumber#1/14 HalfReuse: >/12 HalfReuse: ' '/1 }");"/19 )/21 Tile{ ]] }
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "es = refalrts::splice_elem( res, ", 33 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_name( context[13], & ContextItem_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[11], context[21] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[19], context[21] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInsertVar 'e' s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInsertVar/13 'e'/14 s.Number#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInsertVar, context[13] ) )
      continue;
    context[66] = context[9];
    context[67] = context[10];
    context[14] = refalrts::char_left( 'e', context[66], context[67] );
    if( ! context[14] )
      continue;
    // closed e.Indent#1 as range 5
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/16 'r'/18 Tile{ HalfReuse: 'e'/0 HalfReuse: 's'/4 }" = refalrts::splice_evar( res, "/19 Tile{ HalfReuse: </13 HalfReuse: & ContextRange/14 AsIs: s.Number#1/15 HalfReuse: >/12 HalfReuse: ' '/1 }");"/21 )/23 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[18], 'r' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], " = refalrts::splice_evar( res, ", 31 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[23] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'e' );
    refalrts::reinit_char( context[4], 's' );
    refalrts::reinit_open_call( context[13] );
    refalrts::reinit_name( context[14], & ContextRange_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[11], context[23] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[21], context[23] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInsertVar s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInsertVar/13 s.Mode#1/14 s.Number#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInsertVar, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.Mode#1/14 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/16"res"/18 Tile{ HalfReuse: ' '/13 }"= refalrts::splice_stvar( res, "/20 Tile{ AsIs: </0 Reuse: & ContextItem/4 } Tile{ AsIs: s.Number#1/15 HalfReuse: >/12 HalfReuse: ' '/1 }");"/22 )/24 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "res", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "= refalrts::splice_stvar( res, ", 31 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[24] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], ' ' );
    refalrts::update_name( context[4], & ContextItem_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[11], context[24] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[22], context[24] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInsertRange s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInsertRange/13 s.Number#1/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInsertRange, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/15"res = refalrts::splice_evar( res, "/17 Tile{ AsIs: </0 Reuse: & ContextItem/4 } s.Number#1/14/19 >/20", "/21 </23 & ContextItem/24 </25 Tile{ HalfReuse: & Inc/13 AsIs: s.Number#1/14 HalfReuse: >/12 AsIs: >/1 }" );"/26 )/28 Tile{ ]] }
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "res = refalrts::splice_evar( res, ", 34 ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[19], context[14]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[24], & ContextItem_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[26], context[27], " );", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[28] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ContextItem_alias );
    refalrts::reinit_name( context[13], & Inc_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::link_brackets( context[11], context[28] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[25] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[26], context[28] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[19], context[25] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInsertTile s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInsertTile/13 s.BeginOffset#1/14 s.EndOffset#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInsertTile, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/16"res"/18 Tile{ HalfReuse: ' '/13 }"= refalrts::splice_evar( res, "/20 Tile{ AsIs: </0 Reuse: & ContextItem/4 } Tile{ AsIs: s.BeginOffset#1/14 } >/22", "/23 </25 & ContextItem/26 Tile{ AsIs: s.EndOffset#1/15 HalfReuse: >/12 HalfReuse: ' '/1 }");"/27 )/29 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "res", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "= refalrts::splice_evar( res, ", 30 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], & ContextItem_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[29] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], ' ' );
    refalrts::update_name( context[4], & ContextItem_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[11], context[29] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[25] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[27], context[29] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[22], context[26] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdUseRes )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdUseRes/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdUseRes, context[13] ) )
      continue;
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: 'r'/0 HalfReuse: 'e'/4 }"falrts::use( res "/16 Tile{ HalfReuse: ')'/13 HalfReuse: ';'/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "falrts::use( res ", 17 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[13], ')' );
    refalrts::reinit_char( context[12], ';' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdSpliceToFreeList )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdSpliceToFreeList/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdSpliceToFreeList, context[13] ) )
      continue;
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: 'r'/0 HalfReuse: 'e'/4 }"falrts::splice_to_freelist( arg_begin, arg_end "/16 Tile{ HalfReuse: ')'/13 HalfReuse: ';'/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "falrts::splice_to_freelist( arg_begin, arg_end ", 47 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[13], ')' );
    refalrts::reinit_char( context[12], ';' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNextStep )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdNextStep/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdNextStep, context[13] ) )
      continue;
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: 'r'/0 HalfReuse: 'e'/4 }"turn refalrts::cSucces"/16 Tile{ HalfReuse: 's'/13 HalfReuse: ';'/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "turn refalrts::cSucces", 22 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[13], 's' );
    refalrts::reinit_char( context[12], ';' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdTrash s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdTrash/13 s.Offset#1/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdTrash, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::svar_left( context[14], context[66], context[67] ) )
      continue;
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: </11 HalfReuse: & Fetch/13 AsIs: s.Offset#1/14 HalfReuse: </12 HalfReuse: & @create_closure@/1 } Tile{ Reuse: & GenCommand-Native$53\1/4 } Tile{ HalfReuse: (/0 } e.Indent#1/5/15 )/17 >/18 >/19 Tile{ ]] }
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[19] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[11] );
    refalrts::reinit_name( context[13], & Fetch_alias );
    refalrts::reinit_open_call( context[12] );
    refalrts::reinit_name( context[1], & refalrts::create_closure );
    refalrts::update_name( context[4], & gen_GenCommand_Native_S53L1_alias );
    refalrts::reinit_open_bracket( context[0] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[12] );
    refalrts::link_brackets( context[0], context[17] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[17], context[19] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[7], context[1] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdFail )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 # CmdFail/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdFail, context[13] ) )
      continue;
    context[66] = context[9];
    context[67] = context[10];
    if( ! refalrts::empty_seq( context[66], context[67] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: 'r'/0 HalfReuse: 'e'/4 }"turn refalrts::cRecognitionImpossibl"/16 Tile{ HalfReuse: 'e'/13 HalfReuse: ';'/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "turn refalrts::cRecognitionImpossibl", 36 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[13], 'e' );
    refalrts::reinit_char( context[12], ';' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) ( s.idx e.idx )
  // </0 & GenCommand-Native/4 (/7 e.Indent#1/5 )/8 (/11 s.CommonCommand#1/13 e.Args#1/9 )/12 >/1
  // closed e.Indent#1 as range 5
  // closed e.Args#1 as range 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & GenCommand-Common/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 AsIs: s.CommonCommand#1/13 AsIs: e.Args#1/9 AsIs: )/12 AsIs: >/1 ]] }
  refalrts::update_name( context[4], & GenCommand_Common_alias );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_GenCommand_Native(func_GenCommand_Native, "GenCommand-Native#2881595569:337745613");
refalrts::RefalFunction& GenCommand_Native_2881595569_337745613 = descr_GenCommand_Native;

static refalrts::FnResult func_gen_GenCommand_RASL_S6L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  // </0 & GenCommand-RASL$6\1/4 (/7 e.Indent#1/5 )/8 (/11 e.Name#2/9 )/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Indent#1 as range 5
  // closed e.Name#2 as range 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: ' '/8 HalfReuse: ' '/11 }"& "/13 Tile{ AsIs: </0 Reuse: & CName/4 } Tile{ AsIs: e.Name#2/9 } >/15 Tile{ HalfReuse: ','/12 HalfReuse: )/1 ]] }
  if( ! refalrts::alloc_chars( context[13], context[14], "& ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[15] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[8], ' ' );
  refalrts::reinit_char( context[11], ' ' );
  refalrts::update_name( context[4], & CName_alias );
  refalrts::reinit_char( context[12], ',' );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[7], context[1] );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[12];
  res = refalrts::splice_evar( res, context[15], context[15] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[7], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_gen_GenCommand_RASL_S6L1(func_gen_GenCommand_RASL_S6L1, "GenCommand-RASL$6\\1#2881595569:337745613");
refalrts::RefalFunction& gen_GenCommand_RASL_S6L1_2881595569_337745613 = descr_gen_GenCommand_RASL_S6L1;

static refalrts::FnResult func_gen_GenCommand_RASL_S8L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 18 elems
  refalrts::Iter context[18];
  refalrts::zeros( context, 18 );
  // </0 & GenCommand-RASL$8\1/4 (/7 e.Indent#1/5 )/8 (/11 e.Name#2/9 )/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Indent#1 as range 5
  // closed e.Name#2 as range 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: ' '/8 HalfReuse: ' '/11 }"refalrts::ident_from_static(\""/13 Tile{ AsIs: </0 Reuse: & DisplayCName/4 } Tile{ AsIs: e.Name#2/9 } >/15"\")"/16 Tile{ HalfReuse: ','/12 HalfReuse: )/1 ]] }
  if( ! refalrts::alloc_chars( context[13], context[14], "refalrts::ident_from_static(\"", 29 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[16], context[17], "\")", 2 ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[8], ' ' );
  refalrts::reinit_char( context[11], ' ' );
  refalrts::update_name( context[4], & DisplayCName_alias );
  refalrts::reinit_char( context[12], ',' );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[7], context[1] );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[12];
  res = refalrts::splice_evar( res, context[15], context[17] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[7], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_gen_GenCommand_RASL_S8L1(func_gen_GenCommand_RASL_S8L1, "GenCommand-RASL$8\\1#2881595569:337745613");
refalrts::RefalFunction& gen_GenCommand_RASL_S8L1_2881595569_337745613 = descr_gen_GenCommand_RASL_S8L1;

static refalrts::FnResult func_gen_GenCommand_RASL_S10L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  // </0 & GenCommand-RASL$10\1/4 (/7 e.Indent#1/5 )/8 s.Number#2/9 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: ' '/8 } ' '/10 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } Tile{ AsIs: s.Number#2/9 AsIs: >/1 }"UL,"/11 )/13 Tile{ ]] }
  if( ! refalrts::alloc_char( context[10], ' ' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[11], context[12], "UL,", 3 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[8], ' ' );
  refalrts::update_name( context[4], & StrFromInt_alias );
  refalrts::link_brackets( context[7], context[13] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[11], context[13] );
  res = refalrts::splice_evar( res, context[9], context[1] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_gen_GenCommand_RASL_S10L1(func_gen_GenCommand_RASL_S10L1, "GenCommand-RASL$10\\1#2881595569:337745613");
refalrts::RefalFunction& gen_GenCommand_RASL_S10L1_2881595569_337745613 = descr_gen_GenCommand_RASL_S10L1;

static refalrts::FnResult func_gen_GenCommand_RASL_S12L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  // </0 & GenCommand-RASL$12\1/4 (/7 e.Indent#1/5 )/8 (/11 e.String#2/9 )/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Indent#1 as range 5
  // closed e.String#2 as range 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: ' '/8 HalfReuse: ' '/11 } '{'/13 Tile{ AsIs: </0 Reuse: & PrintString/4 } Tile{ AsIs: e.String#2/9 } >/14 '}'/15 Tile{ HalfReuse: ','/12 HalfReuse: )/1 ]] }
  if( ! refalrts::alloc_char( context[13], '{' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[15], '}' ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[8], ' ' );
  refalrts::reinit_char( context[11], ' ' );
  refalrts::update_name( context[4], & PrintString_alias );
  refalrts::reinit_char( context[12], ',' );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[7], context[1] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[12];
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[13], context[13] );
  res = refalrts::splice_evar( res, context[7], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_gen_GenCommand_RASL_S12L1(func_gen_GenCommand_RASL_S12L1, "GenCommand-RASL$12\\1#2881595569:337745613");
refalrts::RefalFunction& gen_GenCommand_RASL_S12L1_2881595569_337745613 = descr_gen_GenCommand_RASL_S12L1;

static refalrts::FnResult func_gen_GenCommand_RASL_S48L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  //FAST GEN: ( e.$ ) s.$
  //GLOBAL GEN: ( e.$ ) s.$
  // </0 & GenCommand-RASL$48\1/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // ( e.idx ) # ARG-BEGIN
    // </0 & GenCommand-RASL$48\1/4 (/7 e.Indent#1/5 )/8 # ARG-BEGIN/9 >/1
    if( ! refalrts::ident_term(  ident_ARG_BEGIN, context[9] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: '{'/8 HalfReuse: 'r'/9 HalfReuse: 'e'/1 } 'f'/10 Tile{ HalfReuse: 'a'/0 HalfReuse: 'l'/4 }"rts::icSetResArgBegin, 0, 0, 0},"/11 )/13 Tile{ ]] }
    if( ! refalrts::alloc_char( context[10], 'f' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[11], context[12], "rts::icSetResArgBegin, 0, 0, 0},", 32 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[13] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[8], '{' );
    refalrts::reinit_char( context[9], 'r' );
    refalrts::reinit_char( context[1], 'e' );
    refalrts::reinit_char( context[0], 'a' );
    refalrts::reinit_char( context[4], 'l' );
    refalrts::link_brackets( context[7], context[13] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[11], context[13] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[7], context[1] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) # RIGHT-EDGE
    // </0 & GenCommand-RASL$48\1/4 (/7 e.Indent#1/5 )/8 # RIGHT-EDGE/9 >/1
    if( ! refalrts::ident_term(  ident_RIGHT_EDGE, context[9] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: '{'/8 HalfReuse: 'r'/9 HalfReuse: 'e'/1 } 'f'/10 Tile{ HalfReuse: 'a'/0 HalfReuse: 'l'/4 }"rts::icSetResRightEdge, 0, 0, 0},"/11 )/13 Tile{ ]] }
    if( ! refalrts::alloc_char( context[10], 'f' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[11], context[12], "rts::icSetResRightEdge, 0, 0, 0},", 33 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[13] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[8], '{' );
    refalrts::reinit_char( context[9], 'r' );
    refalrts::reinit_char( context[1], 'e' );
    refalrts::reinit_char( context[0], 'a' );
    refalrts::reinit_char( context[4], 'l' );
    refalrts::link_brackets( context[7], context[13] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[11], context[13] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[7], context[1] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx
  // </0 & GenCommand-RASL$48\1/4 (/7 e.Indent#1/5 )/8 s.Offset#2/9 >/1
  // closed e.Indent#1 as range 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: '{'/8 }"refalrts::icSetRes, 0, 0, "/10 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } Tile{ AsIs: s.Offset#2/9 AsIs: >/1 }"},"/12 )/14 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[10], context[11], "refalrts::icSetRes, 0, 0, ", 26 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[12], context[13], "},", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[8], '{' );
  refalrts::update_name( context[4], & StrFromInt_alias );
  refalrts::link_brackets( context[7], context[14] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[12], context[14] );
  res = refalrts::splice_evar( res, context[9], context[1] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_gen_GenCommand_RASL_S48L1(func_gen_GenCommand_RASL_S48L1, "GenCommand-RASL$48\\1#2881595569:337745613");
refalrts::RefalFunction& gen_GenCommand_RASL_S48L1_2881595569_337745613 = descr_gen_GenCommand_RASL_S48L1;

static refalrts::FnResult func_gen_GenCommand_RASL_S62L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  //FAST GEN: ( e.$ ) s.$
  //GLOBAL GEN: ( e.$ ) s.$
  // </0 & GenCommand-RASL$62\1/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // ( e.idx ) # LEFT-EDGE
    // </0 & GenCommand-RASL$62\1/4 (/7 e.Indent#1/5 )/8 # LEFT-EDGE/9 >/1
    if( ! refalrts::ident_term(  ident_LEFT_EDGE, context[9] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: '{'/8 HalfReuse: 'r'/9 HalfReuse: 'e'/1 } 'f'/10 Tile{ HalfReuse: 'a'/0 HalfReuse: 'l'/4 }"rts::icTrashLeftEdge, 0, 0, 0},"/11 )/13 Tile{ ]] }
    if( ! refalrts::alloc_char( context[10], 'f' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[11], context[12], "rts::icTrashLeftEdge, 0, 0, 0},", 31 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[13] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[8], '{' );
    refalrts::reinit_char( context[9], 'r' );
    refalrts::reinit_char( context[1], 'e' );
    refalrts::reinit_char( context[0], 'a' );
    refalrts::reinit_char( context[4], 'l' );
    refalrts::link_brackets( context[7], context[13] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[11], context[13] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[7], context[1] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx
  // </0 & GenCommand-RASL$62\1/4 (/7 e.Indent#1/5 )/8 s.Offset#2/9 >/1
  // closed e.Indent#1 as range 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: '{'/8 }"refalrts::icTrash, 0, 0, "/10 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } Tile{ AsIs: s.Offset#2/9 AsIs: >/1 }"},"/12 )/14 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[10], context[11], "refalrts::icTrash, 0, 0, ", 25 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[12], context[13], "},", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[8], '{' );
  refalrts::update_name( context[4], & StrFromInt_alias );
  refalrts::link_brackets( context[7], context[14] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[12], context[14] );
  res = refalrts::splice_evar( res, context[9], context[1] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_gen_GenCommand_RASL_S62L1(func_gen_GenCommand_RASL_S62L1, "GenCommand-RASL$62\\1#2881595569:337745613");
refalrts::RefalFunction& gen_GenCommand_RASL_S62L1_2881595569_337745613 = descr_gen_GenCommand_RASL_S62L1;

static refalrts::FnResult func_GenCommand_RASL(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 69 elems
  refalrts::Iter context[69];
  refalrts::zeros( context, 69 );
  //FAST GEN: ( e.$ ) ( e.$ )
  //GLOBAL GEN: ( e.$ ) ( s.$ e.$ )
  // </0 & GenCommand-RASL/4 (/7 e.idxB#0/5 )/8 (/11 s.idxTB#0/13 e.idxTBV#0/9 )/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[13], context[9], context[10] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTBV#0 as range 9
  do {
    // ( e.idx ) ( # CmdExtern e.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdExtern/13 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdExtern, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    // closed e.Name#1 as range 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 HalfReuse: 'e'/13 }"xtern refalrts::RefalFunction& "/14 Tile{ AsIs: </0 Reuse: & CName/4 } Tile{ AsIs: e.Name#1/9 } >/16 Tile{ HalfReuse: ';'/12 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_chars( context[14], context[15], "xtern refalrts::RefalFunction& ", 31 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'e' );
    refalrts::update_name( context[4], & CName_alias );
    refalrts::reinit_char( context[12], ';' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdEnumDescr e.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdEnumDescr/13 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdEnumDescr, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    // closed e.Name#1 as range 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 HalfReuse: 's'/13 }"tatic refalrts::RefalEmptyFunction descr_"/14 </16 & BaseCName/17 e.Name#1/9/18 >/20"(\""/21 Tile{ AsIs: </0 Reuse: & DisplayCName/4 } Tile{ AsIs: e.Name#1/9 } >/23"\");"/24 Tile{ AsIs: )/12 } </26 & FuncReference/27 e.Name#1/9/28 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_chars( context[14], context[15], "tatic refalrts::RefalEmptyFunction descr_", 41 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[17], & BaseCName_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[18], context[19], context[9], context[10]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "(\"", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "\");", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & FuncReference_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[28], context[29], context[9], context[10]))
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 's' );
    refalrts::update_name( context[4], & DisplayCName_alias );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[26] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[16] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[28], context[29] );
    res = refalrts::splice_evar( res, context[26], context[27] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[23], context[25] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[22] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInterpretFuncDescr e.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInterpretFuncDescr/13 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInterpretFuncDescr, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    // closed e.Name#1 as range 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 HalfReuse: 's'/13 }"tatic refalrts::RASLFunction descr_"/14 Tile{ AsIs: </0 Reuse: & BaseCName/4 } Tile{ AsIs: e.Name#1/9 } >/16 '('/17 )/18 (/19"  \""/20 </22 & DisplayCName/23 e.Name#1/9/24 >/26"\","/27 )/29 (/30"  raa_"/31 </33 & BaseCName/34 e.Name#1/9/35 >/37 ','/38 )/39 (/40"  functions,"/41 )/43 (/44"  idents,"/45 )/47 (/48"  numbers,"/49 )/51 (/52"  strings"/53 )/55 (/56");"/57 )/59 </60 & FuncReference/61 e.Name#1/9/62 >/64 Tile{ HalfReuse: (/12 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_chars( context[14], context[15], "tatic refalrts::RASLFunction descr_", 35 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[17], '(' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "  \"", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[23], & DisplayCName_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[24], context[25], context[9], context[10]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], "\",", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[31], context[32], "  raa_", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[33] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[34], & BaseCName_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[35], context[36], context[9], context[10]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[37] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[38], ',' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[39] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[40] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[41], context[42], "  functions,", 12 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[43] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[44] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[45], context[46], "  idents,", 9 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[47] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[48] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[49], context[50], "  numbers,", 10 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[51] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[52] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[53], context[54], "  strings", 9 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[55] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[56] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[57], context[58], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[59] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[60] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[61], & FuncReference_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[62], context[63], context[9], context[10]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[64] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 's' );
    refalrts::update_name( context[4], & BaseCName_alias );
    refalrts::reinit_open_bracket( context[12] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[12], context[1] );
    refalrts::push_stack( context[64] );
    refalrts::push_stack( context[60] );
    refalrts::link_brackets( context[56], context[59] );
    refalrts::link_brackets( context[52], context[55] );
    refalrts::link_brackets( context[48], context[51] );
    refalrts::link_brackets( context[44], context[47] );
    refalrts::link_brackets( context[40], context[43] );
    refalrts::link_brackets( context[30], context[39] );
    refalrts::push_stack( context[37] );
    refalrts::push_stack( context[33] );
    refalrts::link_brackets( context[19], context[29] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[22] );
    refalrts::link_brackets( context[11], context[18] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[16], context[64] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdSwapDescr e.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdSwapDescr/13 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdSwapDescr, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    // closed e.Name#1 as range 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 HalfReuse: 's'/13 }"tatic refalrts::RefalSwap descr_"/14 </16 & BaseCName/17 e.Name#1/9/18 >/20"(\""/21 Tile{ AsIs: </0 Reuse: & DisplayCName/4 } Tile{ AsIs: e.Name#1/9 } >/23"\");"/24 Tile{ AsIs: )/12 } </26 & FuncReference/27 e.Name#1/9/28 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_chars( context[14], context[15], "tatic refalrts::RefalSwap descr_", 32 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[17], & BaseCName_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[18], context[19], context[9], context[10]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "(\"", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "\");", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & FuncReference_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[28], context[29], context[9], context[10]))
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 's' );
    refalrts::update_name( context[4], & DisplayCName_alias );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[26] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[16] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[28], context[29] );
    res = refalrts::splice_evar( res, context[26], context[27] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[23], context[25] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[22] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdFuncArray )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdFuncArray/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdFuncArray, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: 'u'/0 HalfReuse: 's'/4 }"ing refalrts::functions;"/16 Tile{ HalfReuse: )/13 HalfReuse: (/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "ing refalrts::functions;", 24 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'u' );
    refalrts::reinit_char( context[4], 's' );
    refalrts::reinit_close_bracket( context[13] );
    refalrts::reinit_open_bracket( context[12] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[12], context[1] );
    refalrts::link_brackets( context[11], context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdFuncArray e.idx ( e.idx ) )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdFuncArray/13 e.FuncNames#1/9 (/16 e.LastName#1/14 )/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdFuncArray, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    context[14] = 0;
    context[15] = 0;
    context[16] = refalrts::brackets_right( context[14], context[15], context[65], context[66] );
    if( ! context[16] )
      continue;
    refalrts::bracket_pointers(context[16], context[17]);
    // closed e.Indent#1 as range 5
    // closed e.FuncNames#1 as range 65(9)
    // closed e.LastName#1 as range 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/18 e.Indent#1/5/19 )/21 (/22 e.Indent#1/5/23 Tile{ HalfReuse: 's'/13 }"tatic refalrts::RefalFunction *functions[] = {"/25 )/27 </28 & Map/29 </30 Tile{ HalfReuse: & @create_closure@/0 Reuse: & GenCommand-RASL$6\1/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: >/11 } Tile{ AsIs: e.FuncNames#1/65(9) } >/31 (/32 e.Indent#1/5/33"  & "/35 </37 Tile{ HalfReuse: & CName/16 AsIs: e.LastName#1/14 HalfReuse: >/17 AsIs: )/12 HalfReuse: (/1 } e.Indent#1/5/38"};"/40 )/42 (/43 )/44 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[19], context[20], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[22] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[23], context[24], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "tatic refalrts::RefalFunction *functions[] = {", 46 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[29], & Map_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[32] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[33], context[34], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[35], context[36], "  & ", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[37] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[38], context[39], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[40], context[41], "};", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[42] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[43] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[44] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 's' );
    refalrts::reinit_name( context[0], & refalrts::create_closure );
    refalrts::update_name( context[4], & gen_GenCommand_RASL_S6L1_alias );
    refalrts::reinit_close_call( context[11] );
    refalrts::reinit_name( context[16], & CName_alias );
    refalrts::reinit_close_call( context[17] );
    refalrts::reinit_open_bracket( context[1] );
    refalrts::link_brackets( context[43], context[44] );
    refalrts::link_brackets( context[1], context[42] );
    refalrts::link_brackets( context[32], context[12] );
    refalrts::push_stack( context[17] );
    refalrts::push_stack( context[37] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[28] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[30] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[22], context[27] );
    refalrts::link_brackets( context[18], context[21] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[40], context[44] );
    res = refalrts::splice_evar( res, context[38], context[39] );
    res = refalrts::splice_evar( res, context[16], context[1] );
    res = refalrts::splice_evar( res, context[31], context[37] );
    res = refalrts::splice_evar( res, context[65], context[66] );
    res = refalrts::splice_evar( res, context[0], context[11] );
    res = refalrts::splice_evar( res, context[25], context[30] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[18], context[22] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdLabelArray )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdLabelArray/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdLabelArray, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: 'u'/0 HalfReuse: 's'/4 }"ing refalrts::idents;"/16 Tile{ HalfReuse: )/13 HalfReuse: (/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "ing refalrts::idents;", 21 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'u' );
    refalrts::reinit_char( context[4], 's' );
    refalrts::reinit_close_bracket( context[13] );
    refalrts::reinit_open_bracket( context[12] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[12], context[1] );
    refalrts::link_brackets( context[11], context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdLabelArray e.idx ( e.idx ) )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdLabelArray/13 e.LabelNames#1/9 (/16 e.LastName#1/14 )/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdLabelArray, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    context[14] = 0;
    context[15] = 0;
    context[16] = refalrts::brackets_right( context[14], context[15], context[65], context[66] );
    if( ! context[16] )
      continue;
    refalrts::bracket_pointers(context[16], context[17]);
    // closed e.Indent#1 as range 5
    // closed e.LabelNames#1 as range 65(9)
    // closed e.LastName#1 as range 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/16 } e.Indent#1/5/18 Tile{ HalfReuse: )/13 } (/20 e.Indent#1/5/21"static const refalrts::RefalIdentifier idents[] = {"/23 )/25 </26 & Map/27 </28 Tile{ HalfReuse: & @create_closure@/0 Reuse: & GenCommand-RASL$8\1/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: >/11 } Tile{ AsIs: e.LabelNames#1/65(9) } >/29 (/30 e.Indent#1/5/31"  refalrts::ident_from_static(\""/33 </35 & DisplayCName/36 Tile{ AsIs: e.LastName#1/14 } >/37"\"),"/38 )/40 (/41 e.Indent#1/5/42"};"/44 Tile{ AsIs: )/17 HalfReuse: (/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[21], context[22], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], "static const refalrts::RefalIdentifier idents[] = {", 51 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & Map_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[30] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[31], context[32], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[33], context[34], "  refalrts::ident_from_static(\"", 31 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[36], & DisplayCName_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[37] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[38], context[39], "\"),", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[40] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[41] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[42], context[43], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[44], context[45], "};", 2 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_close_bracket( context[13] );
    refalrts::reinit_name( context[0], & refalrts::create_closure );
    refalrts::update_name( context[4], & gen_GenCommand_RASL_S8L1_alias );
    refalrts::reinit_close_call( context[11] );
    refalrts::reinit_open_bracket( context[12] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[12], context[1] );
    refalrts::link_brackets( context[41], context[17] );
    refalrts::link_brackets( context[30], context[40] );
    refalrts::push_stack( context[37] );
    refalrts::push_stack( context[35] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[28] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[20], context[25] );
    refalrts::link_brackets( context[16], context[13] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[17];
    res = refalrts::splice_evar( res, context[37], context[45] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[29], context[36] );
    res = refalrts::splice_evar( res, context[65], context[66] );
    res = refalrts::splice_evar( res, context[0], context[11] );
    res = refalrts::splice_evar( res, context[20], context[28] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNumberArray )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdNumberArray/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdNumberArray, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: 'u'/0 HalfReuse: 's'/4 }"ing refalrts::numbers;"/16 Tile{ HalfReuse: )/13 HalfReuse: (/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "ing refalrts::numbers;", 22 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'u' );
    refalrts::reinit_char( context[4], 's' );
    refalrts::reinit_close_bracket( context[13] );
    refalrts::reinit_open_bracket( context[12] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[12], context[1] );
    refalrts::link_brackets( context[11], context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNumberArray e.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdNumberArray/13 e.Numbers#1/9 s.LastNumber#1/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdNumberArray, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_right( context[14], context[65], context[66] ) )
      continue;
    // closed e.Numbers#1 as range 65(9)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/15 e.Indent#1/5/16 )/18 (/19 e.Indent#1/5/20 Tile{ HalfReuse: 's'/13 }"tatic const refalrts::RefalNumber numbers[] = {"/22 )/24 </25 & Map/26 </27 Tile{ HalfReuse: & @create_closure@/0 Reuse: & GenCommand-RASL$10\1/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: >/11 } Tile{ AsIs: e.Numbers#1/65(9) } >/28 (/29 e.Indent#1/5/30"  "/32 </34 & StrFromInt/35 Tile{ AsIs: s.LastNumber#1/14 HalfReuse: >/12 HalfReuse: 'U'/1 } 'L'/36 )/37 (/38 e.Indent#1/5/39"};"/41 )/43 (/44 )/45 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[15] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[19] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[20], context[21], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "tatic const refalrts::RefalNumber numbers[] = {", 47 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], & Map_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[29] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[30], context[31], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[32], context[33], "  ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[34] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[35], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[36], 'L' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[37] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[38] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[39], context[40], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[41], context[42], "};", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[43] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[44] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[45] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 's' );
    refalrts::reinit_name( context[0], & refalrts::create_closure );
    refalrts::update_name( context[4], & gen_GenCommand_RASL_S10L1_alias );
    refalrts::reinit_close_call( context[11] );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], 'U' );
    refalrts::link_brackets( context[44], context[45] );
    refalrts::link_brackets( context[38], context[43] );
    refalrts::link_brackets( context[29], context[37] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[34] );
    refalrts::push_stack( context[28] );
    refalrts::push_stack( context[25] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[27] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[19], context[24] );
    refalrts::link_brackets( context[15], context[18] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[36], context[45] );
    res = refalrts::splice_evar( res, context[14], context[1] );
    res = refalrts::splice_evar( res, context[28], context[35] );
    res = refalrts::splice_evar( res, context[65], context[66] );
    res = refalrts::splice_evar( res, context[0], context[11] );
    res = refalrts::splice_evar( res, context[22], context[27] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[15], context[19] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdStringArray )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdStringArray/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdStringArray, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: 'u'/0 HalfReuse: 's'/4 }"ing refalrts::strings;"/16 Tile{ HalfReuse: )/13 HalfReuse: (/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "ing refalrts::strings;", 22 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'u' );
    refalrts::reinit_char( context[4], 's' );
    refalrts::reinit_close_bracket( context[13] );
    refalrts::reinit_open_bracket( context[12] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[12], context[1] );
    refalrts::link_brackets( context[11], context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdStringArray e.idx ( e.idx ) )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdStringArray/13 e.Strings#1/9 (/16 e.LastString#1/14 )/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdStringArray, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    context[14] = 0;
    context[15] = 0;
    context[16] = refalrts::brackets_right( context[14], context[15], context[65], context[66] );
    if( ! context[16] )
      continue;
    refalrts::bracket_pointers(context[16], context[17]);
    // closed e.Indent#1 as range 5
    // closed e.Strings#1 as range 65(9)
    // closed e.LastString#1 as range 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/16 } e.Indent#1/5/18 Tile{ HalfReuse: )/13 } (/20 e.Indent#1/5/21"static const refalrts::StringItem strings[] = {"/23 )/25 </26 & Map/27 </28 Tile{ HalfReuse: & @create_closure@/0 Reuse: & GenCommand-RASL$12\1/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: >/11 } Tile{ AsIs: e.Strings#1/65(9) } >/29 (/30 e.Indent#1/5/31"  {"/33 </35 & PrintString/36 Tile{ AsIs: e.LastString#1/14 } >/37 '}'/38 )/39 (/40 e.Indent#1/5/41"};"/43 Tile{ AsIs: )/17 HalfReuse: (/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[21], context[22], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], "static const refalrts::StringItem strings[] = {", 47 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & Map_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[30] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[31], context[32], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[33], context[34], "  {", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[36], & PrintString_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[37] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[38], '}' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[39] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[40] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[41], context[42], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[43], context[44], "};", 2 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_close_bracket( context[13] );
    refalrts::reinit_name( context[0], & refalrts::create_closure );
    refalrts::update_name( context[4], & gen_GenCommand_RASL_S12L1_alias );
    refalrts::reinit_close_call( context[11] );
    refalrts::reinit_open_bracket( context[12] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[12], context[1] );
    refalrts::link_brackets( context[40], context[17] );
    refalrts::link_brackets( context[30], context[39] );
    refalrts::push_stack( context[37] );
    refalrts::push_stack( context[35] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[28] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[20], context[25] );
    refalrts::link_brackets( context[16], context[13] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[17];
    res = refalrts::splice_evar( res, context[37], context[44] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[29], context[36] );
    res = refalrts::splice_evar( res, context[65], context[66] );
    res = refalrts::splice_evar( res, context[0], context[11] );
    res = refalrts::splice_evar( res, context[20], context[28] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInitRAA e.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInitRAA/13 e.Name#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInitRAA, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    // closed e.Name#1 as range 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/14 e.Indent#1/5/15 ' '/17 Tile{ HalfReuse: ' '/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: 's'/8 HalfReuse: 't'/11 HalfReuse: 'a'/13 }"tic const refalrts::RASLCommand raa_"/18 </20 & BaseCName/21 Tile{ AsIs: e.Name#1/9 } >/22"[] = "/23 Tile{ HalfReuse: '{'/12 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[14] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[17], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "tic const refalrts::RASLCommand raa_", 36 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[21], & BaseCName_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], "[] = ", 5 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ' ' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], 's' );
    refalrts::reinit_char( context[11], 't' );
    refalrts::reinit_char( context[13], 'a' );
    refalrts::reinit_char( context[12], '{' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[7], context[1] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[20] );
    refalrts::link_brackets( context[14], context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[22], context[24] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[18], context[21] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[14], context[17] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx '  ' ) ( # CmdFinRAA )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 ' '/15 ' '/14 )/8 (/11 # CmdFinRAA/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdFinRAA, context[13] ) )
      continue;
    context[65] = context[5];
    context[66] = context[6];
    context[14] = refalrts::char_right( ' ', context[65], context[66] );
    if( ! context[14] )
      continue;
    context[15] = refalrts::char_right( ' ', context[65], context[66] );
    if( ! context[15] )
      continue;
    context[67] = context[9];
    context[68] = context[10];
    if( ! refalrts::empty_seq( context[67], context[68] ) )
      continue;
    // closed e.Indent#1 as range 65(5)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: (/0 } e.Indent#1/65(5)/16 Tile{ HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/65(5) AsIs: ' '/15 AsIs: ' '/14 HalfReuse: '{'/8 HalfReuse: 'r'/11 HalfReuse: 'e'/13 HalfReuse: 'f'/12 HalfReuse: 'a'/1 }"lrts::icEnd, 0, 0, 0}"/18 )/20 (/21 e.Indent#1/65(5)/22"};"/24 )/26 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[65], context[66]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "lrts::icEnd, 0, 0, 0}", 21 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[65], context[66]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "};", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[26] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[0] );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], '{' );
    refalrts::reinit_char( context[11], 'r' );
    refalrts::reinit_char( context[13], 'e' );
    refalrts::reinit_char( context[12], 'f' );
    refalrts::reinit_char( context[1], 'a' );
    refalrts::link_brackets( context[21], context[26] );
    refalrts::link_brackets( context[7], context[20] );
    refalrts::link_brackets( context[0], context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[18], context[26] );
    res = refalrts::splice_evar( res, context[4], context[1] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdProfileFunction )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdProfileFunction/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdProfileFunction, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: '{'/0 HalfReuse: 'r'/4 }"efalrts::icThisIsGeneratedFunction, 0, 0, 0"/16 Tile{ HalfReuse: '}'/13 HalfReuse: ','/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "efalrts::icThisIsGeneratedFunction, 0, 0, 0", 43 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], '{' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_char( context[13], '}' );
    refalrts::reinit_char( context[12], ',' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdLoadConstants )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdLoadConstants/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdLoadConstants, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: '{'/0 HalfReuse: 'r'/4 }"efalrts::icLoadConstants, 0, 0, 0"/16 Tile{ HalfReuse: '}'/13 HalfReuse: ','/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "efalrts::icLoadConstants, 0, 0, 0", 33 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], '{' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_char( context[13], '}' );
    refalrts::reinit_char( context[12], ',' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdIssueMem s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdIssueMem/13 s.Memory#1/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdIssueMem, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/15"{re"/17 Tile{ HalfReuse: 'f'/4 }"alrts::icIssueMemory, "/19 Tile{ AsIs: </0 } Tile{ HalfReuse: & StrFromInt/13 AsIs: s.Memory#1/14 HalfReuse: >/12 HalfReuse: ','/1 }" 0, 0},"/21 )/23 Tile{ ]] }
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "{re", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "alrts::icIssueMemory, ", 22 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], " 0, 0},", 7 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[23] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[4], 'f' );
    refalrts::reinit_name( context[13], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[23] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[21], context[23] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdReserveStack 0 )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdReserveStack/13 0/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdReserveStack, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    context[14] = refalrts::number_left( 0UL, context[65], context[66] );
    if( ! context[14] )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & GenCommand-RASL/4 {REMOVED TILE} (/11 # CmdReserveStack/13 0/14 )/12 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 } Tile{ ]] }
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[7], context[8] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdReserveStack s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdReserveStack/13 s.Depth#1/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdReserveStack, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/15"{re"/17 Tile{ HalfReuse: 'f'/4 }"alrts::icReserveBacktrackStack, "/19 Tile{ AsIs: </0 } Tile{ HalfReuse: & StrFromInt/13 AsIs: s.Depth#1/14 HalfReuse: >/12 HalfReuse: ','/1 }" 0, 0},"/21 )/23 Tile{ ]] }
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "{re", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "alrts::icReserveBacktrackStack, ", 32 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], " 0, 0},", 7 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[23] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[4], 'f' );
    refalrts::reinit_name( context[13], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[23] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[21], context[23] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdOnFailGoTo s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdOnFailGoTo/13 s.Offset#1/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdOnFailGoTo, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/15"{re"/17 Tile{ HalfReuse: 'f'/4 }"alrts::icOnFailGoTo, +"/19 Tile{ AsIs: </0 } Tile{ HalfReuse: & StrFromInt/13 AsIs: s.Offset#1/14 HalfReuse: >/12 HalfReuse: ','/1 }" 0, 0},"/21 )/23 Tile{ ]] }
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "{re", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "alrts::icOnFailGoTo, +", 22 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], " 0, 0},", 7 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[23] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[4], 'f' );
    refalrts::reinit_name( context[13], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[23] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[21], context[23] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdProfilerStopSentence )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdProfilerStopSentence/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdProfilerStopSentence, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: '{'/0 HalfReuse: 'r'/4 }"efalrts::icProfilerStopSentence, 0, 0, 0"/16 Tile{ HalfReuse: '}'/13 HalfReuse: ','/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "efalrts::icProfilerStopSentence, 0, 0, 0", 40 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], '{' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_char( context[13], '}' );
    refalrts::reinit_char( context[12], ',' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInitB0 )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInitB0/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInitB0, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: '{'/0 HalfReuse: 'r'/4 }"efalrts::icInitB0, 0, 0, 0"/16 Tile{ HalfReuse: '}'/13 HalfReuse: ','/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "efalrts::icInitB0, 0, 0, 0", 26 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], '{' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_char( context[13], '}' );
    refalrts::reinit_char( context[12], ',' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInitB0-Lite )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInitB0-Lite/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInitB0_Lite, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: '{'/0 HalfReuse: 'r'/4 }"efalrts::icInitB0_Lite, 0, 0, 0"/16 Tile{ HalfReuse: '}'/13 HalfReuse: ','/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "efalrts::icInitB0_Lite, 0, 0, 0", 31 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], '{' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_char( context[13], '}' );
    refalrts::reinit_char( context[12], ',' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdChar s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdChar/13 s.Direction#1/14 s.BracketNumber#1/15 s.Char#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdChar, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/17"{ref"/19 Tile{ HalfReuse: 'a'/13 }"lrts::icChar"/21 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/23", 0, static_cast<unsigned char>(\'"/24 </26 & EscapeChar/27 Tile{ AsIs: s.Char#1/16 HalfReuse: >/12 HalfReuse: '\''/1 }"), "/28 </30 & StrFromInt/31 Tile{ AsIs: s.BracketNumber#1/15 } >/32"},"/33 )/35 Tile{ ]] }
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "{ref", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "lrts::icChar", 12 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], ", 0, static_cast<unsigned char>(\'", 33 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & EscapeChar_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[28], context[29], "), ", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[31], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[33], context[34], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[35] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'a' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], '\'' );
    refalrts::link_brackets( context[11], context[35] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[32], context[35] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[28], context[31] );
    res = refalrts::splice_evar( res, context[16], context[1] );
    res = refalrts::splice_evar( res, context[23], context[27] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCharSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdCharSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.SaveOffset#1/16 s.Char#1/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdCharSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/18"{refa"/20 Tile{ HalfReuse: 'l'/13 }"rts::icChar"/22 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/24"Save, "/25 </27 & StrFromInt/28 Tile{ AsIs: s.SaveOffset#1/16 } >/29", static_cast<unsigned char>(\'"/30 </32 & EscapeChar/33 Tile{ AsIs: s.Char#1/17 HalfReuse: >/12 HalfReuse: '\''/1 }"), "/34 </36 & StrFromInt/37 Tile{ AsIs: s.BracketNumber#1/15 } >/38"},"/39 )/41 Tile{ ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "{refa", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "rts::icChar", 11 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "Save, ", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[28], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[30], context[31], ", static_cast<unsigned char>(\'", 30 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[33], & EscapeChar_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[34], context[35], "), ", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[36] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[37], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[38] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[39], context[40], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[41] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'l' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], '\'' );
    refalrts::link_brackets( context[11], context[41] );
    refalrts::push_stack( context[38] );
    refalrts::push_stack( context[36] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[38], context[41] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[34], context[37] );
    res = refalrts::splice_evar( res, context[17], context[1] );
    res = refalrts::splice_evar( res, context[29], context[33] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[24], context[28] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNum s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdNum/13 s.Direction#1/14 s.BracketNumber#1/15 s.Number#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdNum, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/17"{ref"/19 Tile{ HalfReuse: 'a'/13 }"lrts::icNum"/21 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/23", 0, "/24 </26 & StrFromInt/27 Tile{ AsIs: s.Number#1/16 HalfReuse: >/12 HalfReuse: ','/1 } ' '/28 </29 & StrFromInt/30 Tile{ AsIs: s.BracketNumber#1/15 } >/31"},"/32 )/34 Tile{ ]] }
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "{ref", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "lrts::icNum", 11 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], ", 0, ", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[28], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[32], context[33], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[34] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'a' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[34] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[31], context[34] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[28], context[30] );
    res = refalrts::splice_evar( res, context[16], context[1] );
    res = refalrts::splice_evar( res, context[23], context[27] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNumSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdNumSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.SaveOffset#1/16 s.Number#1/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdNumSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/18"{refa"/20 Tile{ HalfReuse: 'l'/13 }"rts::icNum"/22 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/24"Save, "/25 </27 & StrFromInt/28 Tile{ AsIs: s.SaveOffset#1/16 } >/29", "/30 </32 & StrFromInt/33 Tile{ AsIs: s.Number#1/17 HalfReuse: >/12 HalfReuse: ','/1 } ' '/34 </35 & StrFromInt/36 Tile{ AsIs: s.BracketNumber#1/15 } >/37"},"/38 )/40 Tile{ ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "{refa", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "rts::icNum", 10 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "Save, ", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[28], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[30], context[31], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[33], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[34], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[36], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[37] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[38], context[39], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[40] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'l' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[40] );
    refalrts::push_stack( context[37] );
    refalrts::push_stack( context[35] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[37], context[40] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[34], context[36] );
    res = refalrts::splice_evar( res, context[17], context[1] );
    res = refalrts::splice_evar( res, context[29], context[33] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[24], context[28] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdHugeNum s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdHugeNum/13 s.Direction#1/14 s.BracketNumber#1/15 s.Number#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdHugeNum, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/17"{ref"/19 Tile{ HalfReuse: 'a'/13 }"lrts::icHugeNum"/21 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/23", 0, "/24 </26 & StrFromInt/27 Tile{ AsIs: s.Number#1/16 HalfReuse: >/12 HalfReuse: ','/1 } ' '/28 </29 & StrFromInt/30 Tile{ AsIs: s.BracketNumber#1/15 } >/31"},"/32 )/34 Tile{ ]] }
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "{ref", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "lrts::icHugeNum", 15 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], ", 0, ", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[28], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[32], context[33], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[34] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'a' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[34] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[31], context[34] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[28], context[30] );
    res = refalrts::splice_evar( res, context[16], context[1] );
    res = refalrts::splice_evar( res, context[23], context[27] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdHugeNumSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdHugeNumSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.SaveOffset#1/16 s.Number#1/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdHugeNumSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/18"{refa"/20 Tile{ HalfReuse: 'l'/13 }"rts::icHugeNum"/22 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/24"Save, "/25 </27 & StrFromInt/28 Tile{ AsIs: s.SaveOffset#1/16 } >/29", "/30 </32 & StrFromInt/33 Tile{ AsIs: s.Number#1/17 HalfReuse: >/12 HalfReuse: ','/1 } ' '/34 </35 & StrFromInt/36 Tile{ AsIs: s.BracketNumber#1/15 } >/37"},"/38 )/40 Tile{ ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "{refa", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "rts::icHugeNum", 14 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "Save, ", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[28], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[30], context[31], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[33], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[34], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[36], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[37] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[38], context[39], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[40] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'l' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[40] );
    refalrts::push_stack( context[37] );
    refalrts::push_stack( context[35] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[37], context[40] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[34], context[36] );
    res = refalrts::splice_evar( res, context[17], context[1] );
    res = refalrts::splice_evar( res, context[29], context[33] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[24], context[28] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdName s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdName/13 s.Direction#1/14 s.BracketNumber#1/15 s.NameId#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdName, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/17"{ref"/19 Tile{ HalfReuse: 'a'/13 }"lrts::icFunc"/21 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/23", 0, "/24 </26 & StrFromInt/27 Tile{ AsIs: s.NameId#1/16 HalfReuse: >/12 HalfReuse: ','/1 } ' '/28 </29 & StrFromInt/30 Tile{ AsIs: s.BracketNumber#1/15 } >/31"},"/32 )/34 Tile{ ]] }
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "{ref", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "lrts::icFunc", 12 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], ", 0, ", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[28], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[32], context[33], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[34] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'a' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[34] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[31], context[34] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[28], context[30] );
    res = refalrts::splice_evar( res, context[16], context[1] );
    res = refalrts::splice_evar( res, context[23], context[27] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNameSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdNameSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.SaveOffset#1/16 s.NameId#1/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdNameSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/18"{refa"/20 Tile{ HalfReuse: 'l'/13 }"rts::icFunc"/22 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/24"Save, "/25 </27 & StrFromInt/28 Tile{ AsIs: s.SaveOffset#1/16 } >/29", "/30 </32 & StrFromInt/33 Tile{ AsIs: s.NameId#1/17 HalfReuse: >/12 HalfReuse: ','/1 } ' '/34 </35 & StrFromInt/36 Tile{ AsIs: s.BracketNumber#1/15 } >/37"},"/38 )/40 Tile{ ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "{refa", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "rts::icFunc", 11 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "Save, ", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[28], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[30], context[31], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[33], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[34], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[36], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[37] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[38], context[39], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[40] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'l' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[40] );
    refalrts::push_stack( context[37] );
    refalrts::push_stack( context[35] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[37], context[40] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[34], context[36] );
    res = refalrts::splice_evar( res, context[17], context[1] );
    res = refalrts::splice_evar( res, context[29], context[33] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[24], context[28] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdIdent s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdIdent/13 s.Direction#1/14 s.BracketNumber#1/15 s.NameId#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdIdent, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/17"{ref"/19 Tile{ HalfReuse: 'a'/13 }"lrts::icIdent"/21 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/23", 0, "/24 </26 & StrFromInt/27 Tile{ AsIs: s.NameId#1/16 HalfReuse: >/12 HalfReuse: ','/1 } ' '/28 </29 & StrFromInt/30 Tile{ AsIs: s.BracketNumber#1/15 } >/31"},"/32 )/34 Tile{ ]] }
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "{ref", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "lrts::icIdent", 13 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], ", 0, ", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[28], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[32], context[33], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[34] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'a' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[34] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[31], context[34] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[28], context[30] );
    res = refalrts::splice_evar( res, context[16], context[1] );
    res = refalrts::splice_evar( res, context[23], context[27] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdIdentSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdIdentSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.SaveOffset#1/16 s.NameId#1/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdIdentSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/18"{refa"/20 Tile{ HalfReuse: 'l'/13 }"rts::icIdent"/22 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/24"Save, "/25 </27 & StrFromInt/28 Tile{ AsIs: s.SaveOffset#1/16 } >/29", "/30 </32 & StrFromInt/33 Tile{ AsIs: s.NameId#1/17 HalfReuse: >/12 HalfReuse: ','/1 } ' '/34 </35 & StrFromInt/36 Tile{ AsIs: s.BracketNumber#1/15 } >/37"},"/38 )/40 Tile{ ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "{refa", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "rts::icIdent", 12 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "Save, ", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[28], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[30], context[31], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[33], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[34], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[36], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[37] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[38], context[39], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[40] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'l' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[40] );
    refalrts::push_stack( context[37] );
    refalrts::push_stack( context[35] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[37], context[40] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[34], context[36] );
    res = refalrts::splice_evar( res, context[17], context[1] );
    res = refalrts::splice_evar( res, context[29], context[33] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[24], context[28] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdBrackets s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdBrackets/13 s.Direction#1/14 s.Num#1/15 s.NumRanges#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdBrackets, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/17"{ref"/19 Tile{ HalfReuse: 'a'/13 }"lrts::icBracket"/21 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/23", 0, "/24 </26 & StrFromInt/27 Tile{ AsIs: s.NumRanges#1/16 HalfReuse: >/12 HalfReuse: ','/1 } ' '/28 </29 & StrFromInt/30 Tile{ AsIs: s.Num#1/15 } >/31"},"/32 )/34 Tile{ ]] }
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "{ref", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "lrts::icBracket", 15 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], ", 0, ", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[28], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[32], context[33], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[34] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'a' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[34] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[31], context[34] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[28], context[30] );
    res = refalrts::splice_evar( res, context[16], context[1] );
    res = refalrts::splice_evar( res, context[23], context[27] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdBracketsSave s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdBracketsSave/13 s.Direction#1/14 s.Num#1/15 s.NumRanges#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdBracketsSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/17"{ref"/19 Tile{ HalfReuse: 'a'/13 }"lrts::icBracket"/21 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/23"Save, 0, "/24 </26 & StrFromInt/27 Tile{ AsIs: s.NumRanges#1/16 HalfReuse: >/12 HalfReuse: ','/1 } ' '/28 </29 & StrFromInt/30 Tile{ AsIs: s.Num#1/15 } >/31"},"/32 )/34 Tile{ ]] }
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "{ref", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "lrts::icBracket", 15 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "Save, 0, ", 9 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[28], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[32], context[33], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[34] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'a' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[34] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[31], context[34] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[28], context[30] );
    res = refalrts::splice_evar( res, context[16], context[1] );
    res = refalrts::splice_evar( res, context[23], context[27] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdADT s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdADT/13 s.Direction#1/14 s.BracketNumber#1/15 s.InnerBrackets#1/16 s.NameId#1/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdADT, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/18 Tile{ HalfReuse: '{'/13 }"refalrts::icADT"/20 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/22", "/23 </25 & StrFromInt/26 Tile{ AsIs: s.NameId#1/17 HalfReuse: >/12 HalfReuse: ','/1 } ' '/27 </28 & StrFromInt/29 Tile{ AsIs: s.InnerBrackets#1/16 } >/30", "/31 </33 & StrFromInt/34 Tile{ AsIs: s.BracketNumber#1/15 } >/35"},"/36 )/38 Tile{ ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "refalrts::icADT", 15 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[27], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[29], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[31], context[32], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[33] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[34], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[36], context[37], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[38] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], '{' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[38] );
    refalrts::push_stack( context[35] );
    refalrts::push_stack( context[33] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[28] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[25] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[35], context[38] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[30], context[34] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[27], context[29] );
    res = refalrts::splice_evar( res, context[17], context[1] );
    res = refalrts::splice_evar( res, context[22], context[26] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdADTSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdADTSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.InnerBrackets#1/16 s.NameId#1/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdADTSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/18"{refa"/20 Tile{ HalfReuse: 'l'/13 }"rts::icADT"/22 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/24"Save, "/25 </27 & StrFromInt/28 Tile{ AsIs: s.NameId#1/17 HalfReuse: >/12 HalfReuse: ','/1 } ' '/29 </30 & StrFromInt/31 Tile{ AsIs: s.InnerBrackets#1/16 } >/32", "/33 </35 & StrFromInt/36 Tile{ AsIs: s.BracketNumber#1/15 } >/37"},"/38 )/40 Tile{ ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "{refa", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "rts::icADT", 10 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "Save, ", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[28], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[29], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[31], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[33], context[34], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[36], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[37] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[38], context[39], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[40] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'l' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[40] );
    refalrts::push_stack( context[37] );
    refalrts::push_stack( context[35] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[37], context[40] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[32], context[36] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[29], context[31] );
    res = refalrts::splice_evar( res, context[17], context[1] );
    res = refalrts::splice_evar( res, context[24], context[28] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCallSave s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdCallSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.InnerBrackets#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdCallSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/17"{ref"/19 Tile{ HalfReuse: 'a'/13 }"lrts::icCallSave"/21 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/23", 0, "/24 </26 & StrFromInt/27 Tile{ AsIs: s.InnerBrackets#1/16 HalfReuse: >/12 HalfReuse: ','/1 } ' '/28 </29 & StrFromInt/30 Tile{ AsIs: s.BracketNumber#1/15 } >/31"},"/32 )/34 Tile{ ]] }
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "{ref", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "lrts::icCallSave", 16 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], ", 0, ", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[28], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[32], context[33], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[34] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'a' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[34] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[31], context[34] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[28], context[30] );
    res = refalrts::splice_evar( res, context[16], context[1] );
    res = refalrts::splice_evar( res, context[23], context[27] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdEmpty s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdEmpty/13 s.Direction#1/14 s.Num#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdEmpty, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.Direction#1/14 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/16"{re"/18 Tile{ HalfReuse: 'f'/13 }"alrts::icEmpty, 0, 0, "/20 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } Tile{ AsIs: s.Num#1/15 HalfReuse: >/12 HalfReuse: '}'/1 } ','/22 )/23 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "{re", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "alrts::icEmpty, 0, 0, ", 22 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[22], ',' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[23] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'f' );
    refalrts::update_name( context[4], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], '}' );
    refalrts::link_brackets( context[11], context[23] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdVar s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdVar/13 s.Direction#1/14 s.BracketNumber#1/15 s.Mode#1/16 s.VarNumber#1/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdVar, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/18"{refa"/20 Tile{ HalfReuse: 'l'/13 }"rts::ic"/22 Tile{ AsIs: s.Mode#1/16 }"Var"/24 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/26", 0, "/27 </29 & StrFromInt/30 Tile{ AsIs: s.VarNumber#1/17 HalfReuse: >/12 HalfReuse: ','/1 } ' '/31 </32 & StrFromInt/33 Tile{ AsIs: s.BracketNumber#1/15 } >/34"},"/35 )/37 Tile{ ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "{refa", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "rts::ic", 7 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "Var", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], ", 0, ", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[31], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[33], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[34] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[35], context[36], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[37] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'l' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[37] );
    refalrts::push_stack( context[34] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[34], context[37] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[31], context[33] );
    res = refalrts::splice_evar( res, context[17], context[1] );
    res = refalrts::splice_evar( res, context[26], context[30] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[24], context[25] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdVarSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdVarSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.Mode#1/16 s.VarNumber#1/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdVarSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/18"{refa"/20 Tile{ HalfReuse: 'l'/13 }"rts::ic"/22 Tile{ AsIs: s.Mode#1/16 }"Var"/24 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/26"Save, 0, "/27 </29 & StrFromInt/30 Tile{ AsIs: s.VarNumber#1/17 HalfReuse: >/12 HalfReuse: ','/1 } ' '/31 </32 & StrFromInt/33 Tile{ AsIs: s.BracketNumber#1/15 } >/34"},"/35 )/37 Tile{ ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "{refa", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "rts::ic", 7 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "Var", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], "Save, 0, ", 9 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[31], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[33], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[34] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[35], context[36], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[37] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'l' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[37] );
    refalrts::push_stack( context[34] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[34], context[37] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[31], context[33] );
    res = refalrts::splice_evar( res, context[17], context[1] );
    res = refalrts::splice_evar( res, context[26], context[30] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[24], context[25] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdRepeated s.idx s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdRepeated/13 s.Direction#1/14 s.BracketNumber#1/15 s.Mode#1/16 s.VarNumber#1/17 s.SampleNumber#1/18 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdRepeated, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[18], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/19"{refal"/21 Tile{ HalfReuse: 'r'/13 }"ts::ic"/23 Tile{ AsIs: s.Mode#1/16 }"Repeat"/25 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/27", "/28 </30 & StrFromInt/31 Tile{ AsIs: s.VarNumber#1/17 } >/32", "/33 </35 & StrFromInt/36 Tile{ AsIs: s.SampleNumber#1/18 HalfReuse: >/12 HalfReuse: ','/1 } ' '/37 </38 & StrFromInt/39 Tile{ AsIs: s.BracketNumber#1/15 } >/40"},"/41 )/43 Tile{ ]] }
    if (! refalrts::copy_evar(context[19], context[20], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "{refal", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], "ts::ic", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "Repeat", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[28], context[29], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[31], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[33], context[34], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[36], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[37], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[38] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[39], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[40] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[41], context[42], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[43] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'r' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[43] );
    refalrts::push_stack( context[40] );
    refalrts::push_stack( context[38] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[35] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[40], context[43] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[37], context[39] );
    res = refalrts::splice_evar( res, context[18], context[1] );
    res = refalrts::splice_evar( res, context[32], context[36] );
    res = refalrts::splice_evar( res, context[17], context[17] );
    res = refalrts::splice_evar( res, context[27], context[31] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[25], context[26] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdRepeatedTVarSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdRepeatedTVarSave/13 s.Direction#1/14 s.BracketNumber#1/15 s.VarNumber#1/16 s.SampleNumber#1/17 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdRepeatedTVarSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/18"{refa"/20 Tile{ HalfReuse: 'l'/13 }"rts::ictRepeat"/22 Tile{ AsIs: </0 Reuse: & PrintDirection/4 } Tile{ AsIs: s.Direction#1/14 } >/24"Save, "/25 </27 & StrFromInt/28 Tile{ AsIs: s.VarNumber#1/16 } >/29", "/30 </32 & StrFromInt/33 Tile{ AsIs: s.SampleNumber#1/17 HalfReuse: >/12 HalfReuse: ','/1 } ' '/34 </35 & StrFromInt/36 Tile{ AsIs: s.BracketNumber#1/15 } >/37"},"/38 )/40 Tile{ ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "{refa", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "rts::ictRepeat", 14 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "Save, ", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[28], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[30], context[31], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[33], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[34], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[36], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[37] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[38], context[39], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[40] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'l' );
    refalrts::update_name( context[4], & PrintDirection_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[40] );
    refalrts::push_stack( context[37] );
    refalrts::push_stack( context[35] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[37], context[40] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[34], context[36] );
    res = refalrts::splice_evar( res, context[17], context[1] );
    res = refalrts::splice_evar( res, context[29], context[33] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[24], context[28] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdEPrepare s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdEPrepare/13 s.BracketNumber#1/14 s.VarNumber#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdEPrepare, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/16"{refalrts::icEPrepare, 0, "/18 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } Tile{ AsIs: s.VarNumber#1/15 HalfReuse: >/12 HalfReuse: ','/1 } ' '/20 </21 Tile{ HalfReuse: & StrFromInt/13 AsIs: s.BracketNumber#1/14 } >/22"},"/23 )/25 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "{refalrts::icEPrepare, 0, ", 26 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[20], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[25] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::reinit_name( context[13], & StrFromInt_alias );
    refalrts::link_brackets( context[11], context[25] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[22], context[25] );
    res = refalrts::splice_evar( res, context[13], context[14] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdEStart s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdEStart/13 s.BracketNumber#1/14 s.VarNumber#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdEStart, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/16"{refalrts::icEStart, 0, "/18 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } Tile{ AsIs: s.VarNumber#1/15 HalfReuse: >/12 HalfReuse: ','/1 } ' '/20 </21 Tile{ HalfReuse: & StrFromInt/13 AsIs: s.BracketNumber#1/14 } >/22"},"/23 )/25 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "{refalrts::icEStart, 0, ", 24 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[20], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[25] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::reinit_name( context[13], & StrFromInt_alias );
    refalrts::link_brackets( context[11], context[25] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[22], context[25] );
    res = refalrts::splice_evar( res, context[13], context[14] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdSave s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdSave/13 s.OldBracketNumber#1/14 s.NewBracketNumber#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/16"{refalrts::icSave, 0, "/18 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } Tile{ AsIs: s.NewBracketNumber#1/15 HalfReuse: >/12 HalfReuse: ','/1 } ' '/20 </21 Tile{ HalfReuse: & StrFromInt/13 AsIs: s.OldBracketNumber#1/14 } >/22"},"/23 )/25 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "{refalrts::icSave, 0, ", 22 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[20], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[25] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::reinit_name( context[13], & StrFromInt_alias );
    refalrts::link_brackets( context[11], context[25] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[22], context[25] );
    res = refalrts::splice_evar( res, context[13], context[14] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdResetAllocator )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdResetAllocator/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdResetAllocator, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: '{'/0 HalfReuse: 'r'/4 }"efalrts::icResetAllocator, 0, 0, 0"/16 Tile{ HalfReuse: '}'/13 HalfReuse: ','/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "efalrts::icResetAllocator, 0, 0, 0", 34 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], '{' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_char( context[13], '}' );
    refalrts::reinit_char( context[12], ',' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdSetRes s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdSetRes/13 s.Offset#1/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdSetRes, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: </11 HalfReuse: & Fetch/13 AsIs: s.Offset#1/14 HalfReuse: </12 HalfReuse: & @create_closure@/1 } Tile{ Reuse: & GenCommand-RASL$48\1/4 } Tile{ HalfReuse: (/0 } e.Indent#1/5/15 )/17 >/18 >/19 Tile{ ]] }
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[19] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[11] );
    refalrts::reinit_name( context[13], & Fetch_alias );
    refalrts::reinit_open_call( context[12] );
    refalrts::reinit_name( context[1], & refalrts::create_closure );
    refalrts::update_name( context[4], & gen_GenCommand_RASL_S48L1_alias );
    refalrts::reinit_open_bracket( context[0] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[12] );
    refalrts::link_brackets( context[0], context[17] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[17], context[19] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[7], context[1] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCopyVar 'e' s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdCopyVar/13 'e'/14 s.Target#1/15 s.Sample#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdCopyVar, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    context[14] = refalrts::char_left( 'e', context[65], context[66] );
    if( ! context[14] )
      continue;
    // closed e.Indent#1 as range 5
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/17"{refalrts::icCopyEVar, "/19 Tile{ HalfReuse: </13 HalfReuse: & StrFromInt/14 AsIs: s.Target#1/15 } >/21", "/22 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } Tile{ AsIs: s.Sample#1/16 HalfReuse: >/12 HalfReuse: ','/1 }" 0},"/24 )/26 Tile{ ]] }
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "{refalrts::icCopyEVar, ", 23 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], " 0},", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[26] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[13] );
    refalrts::reinit_name( context[14], & StrFromInt_alias );
    refalrts::update_name( context[4], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[26] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[24], context[26] );
    res = refalrts::splice_evar( res, context[16], context[1] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[21], context[23] );
    res = refalrts::splice_evar( res, context[13], context[15] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCopyVar s.idx s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdCopyVar/13 s.Mode#1/14 s.Target#1/15 s.Sample#1/16 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdCopyVar, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.Mode#1/14 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/17"{ref"/19 Tile{ HalfReuse: 'a'/13 }"lrts::icCopySTVar, "/21 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } Tile{ AsIs: s.Target#1/15 } >/23", "/24 </26 & StrFromInt/27 Tile{ AsIs: s.Sample#1/16 HalfReuse: >/12 HalfReuse: ','/1 }" 0},"/28 )/30 Tile{ ]] }
    if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "{ref", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "lrts::icCopySTVar, ", 19 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[28], context[29], " 0},", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[30] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'a' );
    refalrts::update_name( context[4], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[30] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[28], context[30] );
    res = refalrts::splice_evar( res, context[16], context[1] );
    res = refalrts::splice_evar( res, context[23], context[27] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdReinitSVar s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdReinitSVar/13 s.Offset#1/14 s.Sample#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdReinitSVar, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/16"{refalrts::icReinitSVar, 0, "/18 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } Tile{ AsIs: s.Sample#1/15 HalfReuse: >/12 HalfReuse: ','/1 } ' '/20 </21 Tile{ HalfReuse: & StrFromInt/13 AsIs: s.Offset#1/14 } >/22"},"/23 )/25 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "{refalrts::icReinitSVar, 0, ", 28 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[20], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], "},", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[25] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::reinit_name( context[13], & StrFromInt_alias );
    refalrts::link_brackets( context[11], context[25] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[22], context[25] );
    res = refalrts::splice_evar( res, context[13], context[14] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCreateElem s.idx s.idx s.idx e.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdCreateElem/13 s.CreateMode#1/14 s.ElemNumber#1/15 s.Type#1/16 e.Info#1/9 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdCreateElem, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[16], context[65], context[66] ) )
      continue;
    // closed e.Info#1 as range 65(9)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.CreateMode#1/14 s.ElemNumber#1/15 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/17 e.Indent#1/5/18 Tile{ HalfReuse: )/1 } Tile{ AsIs: </0 Reuse: & PrintInterpretCreateElem/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: s.CreateMode1 #14/11 HalfReuse: s.ElemNumber1 #15/13 } Tile{ AsIs: s.Type#1/16 AsIs: e.Info#1/65(9) HalfReuse: >/12 } Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
      return refalrts::cNoMemory;
    refalrts::reinit_close_bracket( context[1] );
    refalrts::update_name( context[4], & PrintInterpretCreateElem_alias );
    refalrts::reinit_svar( context[11], context[14] );
    refalrts::reinit_svar( context[13], context[15] );
    refalrts::reinit_close_call( context[12] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[17], context[1] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[16], context[12] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[17], context[17] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdLinkBrackets s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdLinkBrackets/13 s.Left#1/14 s.Right#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdLinkBrackets, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/16"{re"/18 Tile{ HalfReuse: 'f'/13 }"alrts::icLinkBrackets, "/20 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } Tile{ AsIs: s.Left#1/14 } >/22", "/23 </25 & StrFromInt/26 Tile{ AsIs: s.Right#1/15 HalfReuse: >/12 HalfReuse: ','/1 }" 0},"/27 )/29 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "{re", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "alrts::icLinkBrackets, ", 23 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], " 0},", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[29] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'f' );
    refalrts::update_name( context[4], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[29] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[25] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[27], context[29] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[22], context[26] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdPushStack s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdPushStack/13 s.ElemNumber#1/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdPushStack, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/15 Tile{ HalfReuse: '{'/4 }"refalrts::icPushStack, 0, 0, "/17 Tile{ AsIs: </0 } Tile{ HalfReuse: & StrFromInt/13 AsIs: s.ElemNumber#1/14 HalfReuse: >/12 HalfReuse: '}'/1 } ','/19 )/20 Tile{ ]] }
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "refalrts::icPushStack, 0, 0, ", 29 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[19], ',' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[20] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[4], '{' );
    refalrts::reinit_name( context[13], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], '}' );
    refalrts::link_brackets( context[11], context[20] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInsertElem s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInsertElem/13 s.ElemNumber#1/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInsertElem, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/15 Tile{ HalfReuse: '{'/4 }"refalrts::icSpliceElem, 0, 0, "/17 Tile{ AsIs: </0 } Tile{ HalfReuse: & StrFromInt/13 AsIs: s.ElemNumber#1/14 HalfReuse: >/12 HalfReuse: '}'/1 } ','/19 )/20 Tile{ ]] }
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "refalrts::icSpliceElem, 0, 0, ", 30 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[19], ',' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[20] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[4], '{' );
    refalrts::reinit_name( context[13], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], '}' );
    refalrts::link_brackets( context[11], context[20] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInsertVar 'e' s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInsertVar/13 'e'/14 s.Offset#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInsertVar, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    context[14] = refalrts::char_left( 'e', context[65], context[66] );
    if( ! context[14] )
      continue;
    // closed e.Indent#1 as range 5
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/16 '{'/18 Tile{ HalfReuse: 'r'/0 HalfReuse: 'e'/4 }"falrts::icSpliceEVar, 0, 0, "/19 Tile{ HalfReuse: </13 HalfReuse: & StrFromInt/14 AsIs: s.Offset#1/15 HalfReuse: >/12 HalfReuse: '}'/1 } ','/21 )/22 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[18], '{' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "falrts::icSpliceEVar, 0, 0, ", 28 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[21], ',' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[22] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_open_call( context[13] );
    refalrts::reinit_name( context[14], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], '}' );
    refalrts::link_brackets( context[11], context[22] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInsertVar s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInsertVar/13 s.Mode#1/14 s.Offset#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInsertVar, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.Mode#1/14 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/16"{re"/18 Tile{ HalfReuse: 'f'/13 }"alrts::icSpliceSTVar, 0, 0, "/20 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } Tile{ AsIs: s.Offset#1/15 HalfReuse: >/12 HalfReuse: '}'/1 } ','/22 )/23 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "{re", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "alrts::icSpliceSTVar, 0, 0, ", 28 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[22], ',' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[23] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'f' );
    refalrts::update_name( context[4], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], '}' );
    refalrts::link_brackets( context[11], context[23] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInsertRange s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInsertRange/13 s.ElemNumber#1/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInsertRange, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/15 Tile{ HalfReuse: '{'/4 }"refalrts::icSpliceRange, 0, 0, "/17 Tile{ AsIs: </0 } Tile{ HalfReuse: & StrFromInt/13 AsIs: s.ElemNumber#1/14 HalfReuse: >/12 HalfReuse: '}'/1 } ','/19 )/20 Tile{ ]] }
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "refalrts::icSpliceRange, 0, 0, ", 31 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[19], ',' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[20] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[4], '{' );
    refalrts::reinit_name( context[13], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], '}' );
    refalrts::link_brackets( context[11], context[20] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInsertTile s.idx s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdInsertTile/13 s.BeginOffset#1/14 s.EndOffset#1/15 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdInsertTile, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/16"{re"/18 Tile{ HalfReuse: 'f'/13 }"alrts::icSpliceTile, "/20 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } Tile{ AsIs: s.BeginOffset#1/14 } >/22", "/23 </25 & StrFromInt/26 Tile{ AsIs: s.EndOffset#1/15 HalfReuse: >/12 HalfReuse: ','/1 }" 0},"/27 )/29 Tile{ ]] }
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "{re", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "alrts::icSpliceTile, ", 21 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], & StrFromInt_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], " 0},", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[29] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'f' );
    refalrts::update_name( context[4], & StrFromInt_alias );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[11], context[29] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[25] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[27], context[29] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[22], context[26] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdSpliceToFreeList )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdSpliceToFreeList/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdSpliceToFreeList, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: '{'/0 HalfReuse: 'r'/4 }"efalrts::icSpliceToFreeList, 0, 0, 0"/16 Tile{ HalfReuse: '}'/13 HalfReuse: ','/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "efalrts::icSpliceToFreeList, 0, 0, 0", 36 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], '{' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_char( context[13], '}' );
    refalrts::reinit_char( context[12], ',' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNextStep )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdNextStep/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdNextStep, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: '{'/0 HalfReuse: 'r'/4 }"efalrts::icNextStep, 0, 0, 0"/16 Tile{ HalfReuse: '}'/13 HalfReuse: ','/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "efalrts::icNextStep, 0, 0, 0", 28 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], '{' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_char( context[13], '}' );
    refalrts::reinit_char( context[12], ',' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdTrash s.idx )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdTrash/13 s.Offset#1/14 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdTrash, context[13] ) )
      continue;
    // closed e.Indent#1 as range 5
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::svar_left( context[14], context[65], context[66] ) )
      continue;
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 HalfReuse: </11 HalfReuse: & Fetch/13 AsIs: s.Offset#1/14 HalfReuse: </12 HalfReuse: & @create_closure@/1 } Tile{ Reuse: & GenCommand-RASL$62\1/4 } Tile{ HalfReuse: (/0 } e.Indent#1/5/15 )/17 >/18 >/19 Tile{ ]] }
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[19] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[11] );
    refalrts::reinit_name( context[13], & Fetch_alias );
    refalrts::reinit_open_call( context[12] );
    refalrts::reinit_name( context[1], & refalrts::create_closure );
    refalrts::update_name( context[4], & gen_GenCommand_RASL_S62L1_alias );
    refalrts::reinit_open_bracket( context[0] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[12] );
    refalrts::link_brackets( context[0], context[17] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[17], context[19] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[7], context[1] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdFail )
    // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 # CmdFail/13 )/12 >/1
    if( ! refalrts::ident_term(  ident_CmdFail, context[13] ) )
      continue;
    context[65] = context[9];
    context[66] = context[10];
    if( ! refalrts::empty_seq( context[65], context[66] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 } e.Indent#1/5/14 Tile{ HalfReuse: '{'/0 HalfReuse: 'r'/4 }"efalrts::icFail, 0, 0, 0"/16 Tile{ HalfReuse: '}'/13 HalfReuse: ','/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[16], context[17], "efalrts::icFail, 0, 0, 0", 24 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], '{' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_char( context[13], '}' );
    refalrts::reinit_char( context[12], ',' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) ( s.idx e.idx )
  // </0 & GenCommand-RASL/4 (/7 e.Indent#1/5 )/8 (/11 s.CommonCommand#1/13 e.Args#1/9 )/12 >/1
  // closed e.Indent#1 as range 5
  // closed e.Args#1 as range 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & GenCommand-Common/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: (/11 AsIs: s.CommonCommand#1/13 AsIs: e.Args#1/9 AsIs: )/12 AsIs: >/1 ]] }
  refalrts::update_name( context[4], & GenCommand_Common_alias );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_GenCommand_RASL(func_GenCommand_RASL, "GenCommand-RASL#2881595569:337745613");
refalrts::RefalFunction& GenCommand_RASL_2881595569_337745613 = descr_GenCommand_RASL;

static refalrts::FnResult func_PrintLength(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  // </0 & PrintLength/4 e.String#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.String#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 Tile{ HalfReuse: & DoPrintLength/0 HalfReuse: 0/4 AsIs: e.String#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[0], & DoPrintLength_alias );
  refalrts::reinit_number( context[4], 0UL );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[5] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[0];
  res = refalrts::splice_evar( res, context[5], context[5] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintLength(func_PrintLength, "PrintLength#2881595569:337745613");
refalrts::RefalFunction& PrintLength_2881595569_337745613 = descr_PrintLength;

static refalrts::FnResult func_DoPrintLength(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  //FAST GEN: e.$
  //GLOBAL GEN: s.$ e.$
  // </0 & DoPrintLength/4 s.idx#0/5 e.idxV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxV#0 as range 2
  do {
    // s.idx s.idx e.idx
    // </0 & DoPrintLength/4 s.Length#1/5 s.Char#1/6 e.Tail#1/2 >/1
    context[10] = context[2];
    context[11] = context[3];
    if( ! refalrts::svar_left( context[6], context[10], context[11] ) )
      continue;
    // closed e.Tail#1 as range 10(2)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Char#1/6 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoPrintLength/4 } </7 & Inc/8 Tile{ AsIs: s.Length#1/5 } >/9 Tile{ AsIs: e.Tail#1/10(2) } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[7] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[8], & Inc_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[9] ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[7] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[10], context[11] );
    res = refalrts::splice_evar( res, context[9], context[9] );
    res = refalrts::splice_evar( res, context[5], context[5] );
    res = refalrts::splice_evar( res, context[7], context[8] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & DoPrintLength/4 s.Length#1/5 >/1
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & StrFromInt/4 AsIs: s.Length#1/5 AsIs: >/1 ]] }
  refalrts::update_name( context[4], & StrFromInt_alias );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_DoPrintLength(func_DoPrintLength, "DoPrintLength#2881595569:337745613");
refalrts::RefalFunction& DoPrintLength_2881595569_337745613 = descr_DoPrintLength;

static refalrts::FnResult func_PrintString(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  // </0 & PrintString/4 e.String#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.String#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } '\"'/5 </6 & EscapeString/7 e.String#1/2/8 >/10"\", "/11 Tile{ AsIs: </0 Reuse: & PrintLength/4 AsIs: e.String#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_char( context[5], '\"' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], & EscapeString_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[8], context[9], context[2], context[3]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[11], context[12], "\", ", 3 ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintLength_alias );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[6] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[0];
  res = refalrts::splice_evar( res, context[5], context[12] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintString(func_PrintString, "PrintString#2881595569:337745613");
refalrts::RefalFunction& PrintString_2881595569_337745613 = descr_PrintString;

static refalrts::FnResult func_PrintMatchChar(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & PrintMatchChar/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.Char#1/11 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/12"char"/13 )/15 '\''/16 </17 & EscapeChar/18 Tile{ AsIs: s.Char#1/11 AsIs: >/1 } '\''/19 >/20 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[13], context[14], "char", 4 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[16], '\'' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[18], & EscapeChar_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[19], '\'' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatch_alias );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[17] );
  refalrts::link_brackets( context[12], context[15] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[19], context[20] );
  res = refalrts::splice_evar( res, context[11], context[1] );
  res = refalrts::splice_evar( res, context[12], context[18] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchChar(func_PrintMatchChar, "PrintMatchChar#2881595569:337745613");
refalrts::RefalFunction& PrintMatchChar_2881595569_337745613 = descr_PrintMatchChar;

static refalrts::FnResult func_PrintMatchCharSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 22 elems
  refalrts::Iter context[22];
  refalrts::zeros( context, 22 );
  // </0 & PrintMatchCharSave/4 (/7 e.Indent#1/5 )/8 s.Offset#1/9 s.Direction#1/10 s.BracketNumber#1/11 s.Char#1/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Offset#1/9 AsIs: s.Direction#1/10 AsIs: s.BracketNumber#1/11 } (/13"char"/14 )/16 '\''/17 </18 & EscapeChar/19 Tile{ AsIs: s.Char#1/12 AsIs: >/1 } '\''/20 >/21 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[14], context[15], "char", 4 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[17], '\'' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], & EscapeChar_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[20], '\'' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[21] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatchSave_alias );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[18] );
  refalrts::link_brackets( context[13], context[16] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[20], context[21] );
  res = refalrts::splice_evar( res, context[12], context[1] );
  res = refalrts::splice_evar( res, context[13], context[19] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchCharSave(func_PrintMatchCharSave, "PrintMatchCharSave#2881595569:337745613");
refalrts::RefalFunction& PrintMatchCharSave_2881595569_337745613 = descr_PrintMatchCharSave;

static refalrts::FnResult func_PrintMatchNumber(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & PrintMatchNumber/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.Number#1/11 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/12"number"/13 )/15 </16 & StrFromInt/17 Tile{ AsIs: s.Number#1/11 AsIs: >/1 }"UL"/18 >/20 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[13], context[14], "number", 6 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[17], & StrFromInt_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[18], context[19], "UL", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatch_alias );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[16] );
  refalrts::link_brackets( context[12], context[15] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[18], context[20] );
  res = refalrts::splice_evar( res, context[11], context[1] );
  res = refalrts::splice_evar( res, context[12], context[17] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchNumber(func_PrintMatchNumber, "PrintMatchNumber#2881595569:337745613");
refalrts::RefalFunction& PrintMatchNumber_2881595569_337745613 = descr_PrintMatchNumber;

static refalrts::FnResult func_PrintMatchNumberSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 22 elems
  refalrts::Iter context[22];
  refalrts::zeros( context, 22 );
  // </0 & PrintMatchNumberSave/4 (/7 e.Indent#1/5 )/8 s.Offset#1/9 s.Direction#1/10 s.BracketNumber#1/11 s.Number#1/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Offset#1/9 AsIs: s.Direction#1/10 AsIs: s.BracketNumber#1/11 } (/13"number"/14 )/16 </17 & StrFromInt/18 Tile{ AsIs: s.Number#1/12 AsIs: >/1 }"UL"/19 >/21 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[14], context[15], "number", 6 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[18], & StrFromInt_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[19], context[20], "UL", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[21] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatchSave_alias );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[17] );
  refalrts::link_brackets( context[13], context[16] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[19], context[21] );
  res = refalrts::splice_evar( res, context[12], context[1] );
  res = refalrts::splice_evar( res, context[13], context[18] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchNumberSave(func_PrintMatchNumberSave, "PrintMatchNumberSave#2881595569:337745613");
refalrts::RefalFunction& PrintMatchNumberSave_2881595569_337745613 = descr_PrintMatchNumberSave;

static refalrts::FnResult func_PrintMatchName(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 20 elems
  refalrts::Iter context[20];
  refalrts::zeros( context, 20 );
  // </0 & PrintMatchName/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 e.Name#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Name#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/11"function"/12 )/14"& "/15 </17 & CNameAlias/18 Tile{ AsIs: e.Name#1/2 } >/19 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[12], context[13], "function", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[15], context[16], "& ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[18], & CNameAlias_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[19] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatch_alias );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[19] );
  refalrts::push_stack( context[17] );
  refalrts::link_brackets( context[11], context[14] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[19], context[19] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[11], context[18] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchName(func_PrintMatchName, "PrintMatchName#2881595569:337745613");
refalrts::RefalFunction& PrintMatchName_2881595569_337745613 = descr_PrintMatchName;

static refalrts::FnResult func_PrintMatchNameSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & PrintMatchNameSave/4 (/7 e.Indent#1/5 )/8 s.Offset#1/9 s.Direction#1/10 s.BracketNumber#1/11 e.Name#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Name#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Offset#1/9 AsIs: s.Direction#1/10 AsIs: s.BracketNumber#1/11 } (/12"function"/13 )/15"& "/16 </18 & CNameAlias/19 Tile{ AsIs: e.Name#1/2 } >/20 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[13], context[14], "function", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[16], context[17], "& ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], & CNameAlias_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatchSave_alias );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[18] );
  refalrts::link_brackets( context[12], context[15] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[20], context[20] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[12], context[19] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchNameSave(func_PrintMatchNameSave, "PrintMatchNameSave#2881595569:337745613");
refalrts::RefalFunction& PrintMatchNameSave_2881595569_337745613 = descr_PrintMatchNameSave;

static refalrts::FnResult func_PrintMatchIdent(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 20 elems
  refalrts::Iter context[20];
  refalrts::zeros( context, 20 );
  // </0 & PrintMatchIdent/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 e.Name#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Name#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/11"ident"/12 )/14" ident_"/15 </17 & CName/18 Tile{ AsIs: e.Name#1/2 } >/19 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[12], context[13], "ident", 5 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[15], context[16], " ident_", 7 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[18], & CName_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[19] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatch_alias );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[19] );
  refalrts::push_stack( context[17] );
  refalrts::link_brackets( context[11], context[14] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[19], context[19] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[11], context[18] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchIdent(func_PrintMatchIdent, "PrintMatchIdent#2881595569:337745613");
refalrts::RefalFunction& PrintMatchIdent_2881595569_337745613 = descr_PrintMatchIdent;

static refalrts::FnResult func_PrintMatchIdentSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & PrintMatchIdentSave/4 (/7 e.Indent#1/5 )/8 s.Offset#1/9 s.Direction#1/10 s.BracketNumber#1/11 e.Name#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Name#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Offset#1/9 AsIs: s.Direction#1/10 AsIs: s.BracketNumber#1/11 } (/12"ident"/13 )/15" ident_"/16 </18 & CName/19 Tile{ AsIs: e.Name#1/2 } >/20 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[13], context[14], "ident", 5 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[16], context[17], " ident_", 7 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], & CName_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatchSave_alias );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[18] );
  refalrts::link_brackets( context[12], context[15] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[20], context[20] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[12], context[19] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchIdentSave(func_PrintMatchIdentSave, "PrintMatchIdentSave#2881595569:337745613");
refalrts::RefalFunction& PrintMatchIdentSave_2881595569_337745613 = descr_PrintMatchIdentSave;

static refalrts::FnResult func_PrintMatchBrackets(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  // </0 & PrintMatchBrackets/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.InnerNum#1/11 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/12"brackets"/13 )/15 </16 & ContextRange/17 Tile{ AsIs: s.InnerNum#1/11 AsIs: >/1 } >/18 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[13], context[14], "brackets", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[17], & ContextRange_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatch_alias );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[16] );
  refalrts::link_brackets( context[12], context[15] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[18], context[18] );
  res = refalrts::splice_evar( res, context[11], context[1] );
  res = refalrts::splice_evar( res, context[12], context[17] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchBrackets(func_PrintMatchBrackets, "PrintMatchBrackets#2881595569:337745613");
refalrts::RefalFunction& PrintMatchBrackets_2881595569_337745613 = descr_PrintMatchBrackets;

static refalrts::FnResult func_PrintMatchBracketsSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 50 elems
  refalrts::Iter context[50];
  refalrts::zeros( context, 50 );
  // </0 & PrintMatchBracketsSave/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.InnerNum#1/11 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 } </12 & Add/13 2/14 Tile{ AsIs: s.InnerNum#1/11 AsIs: >/1 } Tile{ AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/15"brackets"/16 )/18 </19 & ContextRange/20 s.InnerNum#1/11/21 >/22 >/23 (/24 e.Indent#1/5/25"refalrts::bracket_pointers("/27 </29 & ContextItem/30 </31 & Add/32 s.InnerNum#1/11/33 2/34 >/35 >/36", "/37 </39 & ContextItem/40 </41 & Add/42 s.InnerNum#1/11/43 3/44 >/45 >/46");"/47 )/49 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[13], & Add_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[14], 2UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[16], context[17], "brackets", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[20], & ContextRange_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[21], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[23] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[24] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[25], context[26], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[27], context[28], "refalrts::bracket_pointers(", 27 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[29] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[30], & ContextItem_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[31] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[32], & Add_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[33], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[34], 2UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[35] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[36] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[37], context[38], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[39] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[40], & ContextItem_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[41] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[42], & Add_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[43], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[44], 3UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[45] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[46] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[47], context[48], ");", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[49] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatchSave_alias );
  refalrts::link_brackets( context[24], context[49] );
  refalrts::push_stack( context[46] );
  refalrts::push_stack( context[39] );
  refalrts::push_stack( context[45] );
  refalrts::push_stack( context[41] );
  refalrts::push_stack( context[36] );
  refalrts::push_stack( context[29] );
  refalrts::push_stack( context[35] );
  refalrts::push_stack( context[31] );
  refalrts::push_stack( context[23] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[22] );
  refalrts::push_stack( context[19] );
  refalrts::link_brackets( context[15], context[18] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[15], context[49] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[11], context[1] );
  res = refalrts::splice_evar( res, context[12], context[14] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchBracketsSave(func_PrintMatchBracketsSave, "PrintMatchBracketsSave#2881595569:337745613");
refalrts::RefalFunction& PrintMatchBracketsSave_2881595569_337745613 = descr_PrintMatchBracketsSave;

static refalrts::FnResult func_PrintMatchADT(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 24 elems
  refalrts::Iter context[24];
  refalrts::zeros( context, 24 );
  // </0 & PrintMatchADT/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.InnerNum#1/11 e.Name#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Name#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/12"adt"/13 )/15 </16 & ContextRange/17 Tile{ AsIs: s.InnerNum#1/11 } >/18", & "/19 </21 & CNameAlias/22 Tile{ AsIs: e.Name#1/2 } >/23 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[13], context[14], "adt", 3 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[17], & ContextRange_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[19], context[20], ", & ", 4 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[22], & CNameAlias_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[23] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatch_alias );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[23] );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[16] );
  refalrts::link_brackets( context[12], context[15] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[23], context[23] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[18], context[22] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[12], context[17] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchADT(func_PrintMatchADT, "PrintMatchADT#2881595569:337745613");
refalrts::RefalFunction& PrintMatchADT_2881595569_337745613 = descr_PrintMatchADT;

static refalrts::FnResult func_PrintMatchADTSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 65 elems
  refalrts::Iter context[65];
  refalrts::zeros( context, 65 );
  //FAST GEN: ( e.$ ) s.$ s.$ s.$ e.$
  //GLOBAL GEN: ( e.$ ) s.$ s.$ s.$ e.$
  // </0 & PrintMatchADTSave/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 s.idxTV#0/10 s.idxTVV#0/11 e.idxTVVV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTVVV#0 as range 2
  do {
    // ( e.idx ) # AlgTerm s.idx s.idx e.idx
    // </0 & PrintMatchADTSave/4 (/7 e.Indent#1/5 )/8 # AlgTerm/9 s.Offset#1/10 s.InnerNum#1/11 e.Name#1/2 >/1
    if( ! refalrts::ident_term(  ident_AlgTerm, context[9] ) )
      continue;
    // closed e.Indent#1 as range 5
    // closed e.Name#1 as range 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/12 e.Indent#1/5/13 </15 & ContextItem/16 </17 & Add/18 s.InnerNum#1/11/19 2/20 >/21 >/22" = refalrts::adt_term("/23 </25 & ContextRange/26 Tile{ AsIs: s.InnerNum#1/11 } >/27", & "/28 </30 & CNameAlias/31 Tile{ AsIs: e.Name#1/2 } >/32", "/33 </35 & ContextItem/36 Tile{ AsIs: s.Offset#1/10 } >/37 ')'/38 Tile{ HalfReuse: ';'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: 'i'/8 HalfReuse: 'f'/9 }"( ! "/39 </41 & ContextItem/42 </43 & Add/44 s.InnerNum#1/11/45 2/46 >/47 >/48" )"/49 )/51 (/52 e.Indent#1/5/53"  "/55 </57 & BreakerFromIndent/58 e.Indent#1/5/59 >/61 Tile{ HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[12] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[13], context[14], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[16], & ContextItem_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[18], & Add_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[19], context[11]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[20], 2UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], " = refalrts::adt_term(", 22 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], & ContextRange_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[28], context[29], ", & ", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[31], & CNameAlias_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[33], context[34], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[36], & ContextItem_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[37] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[38], ')' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[39], context[40], "( ! ", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[41] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[42], & ContextItem_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[43] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[44], & Add_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[45], context[11]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[46], 2UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[47] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[48] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[49], context[50], " )", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[51] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[52] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[53], context[54], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[55], context[56], "  ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[57] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[58], & BreakerFromIndent_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[59], context[60], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[61] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ';' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], 'i' );
    refalrts::reinit_char( context[9], 'f' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[52], context[1] );
    refalrts::push_stack( context[61] );
    refalrts::push_stack( context[57] );
    refalrts::link_brackets( context[7], context[51] );
    refalrts::push_stack( context[48] );
    refalrts::push_stack( context[41] );
    refalrts::push_stack( context[47] );
    refalrts::push_stack( context[43] );
    refalrts::link_brackets( context[12], context[4] );
    refalrts::push_stack( context[37] );
    refalrts::push_stack( context[35] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[25] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[17] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[39], context[61] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[37], context[38] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[32], context[36] );
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[27], context[31] );
    res = refalrts::splice_evar( res, context[11], context[11] );
    res = refalrts::splice_evar( res, context[12], context[26] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx s.idx s.idx e.idx
  // </0 & PrintMatchADTSave/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.InnerNum#1/11 e.Name#1/2 >/1
  // closed e.Indent#1 as range 5
  // closed e.Name#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 } </12 & Add/13 2/14 s.InnerNum#1/11/15 >/16 Tile{ AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/17"adt"/18 )/20 </21 & ContextRange/22 Tile{ AsIs: s.InnerNum#1/11 } >/23", & "/24 </26 & CNameAlias/27 Tile{ AsIs: e.Name#1/2 } >/28 >/29 (/30 e.Indent#1/5/31"refalrts::adt_pointers("/33 </35 & ContextItem/36 </37 & Add/38 s.InnerNum#1/11/39 2/40 >/41 >/42", "/43 </45 & ContextItem/46 </47 & Add/48 s.InnerNum#1/11/49 3/50 >/51 >/52", "/53 </55 & ContextItem/56 </57 & Add/58 s.InnerNum#1/11/59 4/60 >/61 >/62");"/63 Tile{ HalfReuse: )/1 ]] }
  if( ! refalrts::alloc_open_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[13], & Add_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[14], 2UL ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[15], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[18], context[19], "adt", 3 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[22], & ContextRange_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[23] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[24], context[25], ", & ", 4 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[26] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[27], & CNameAlias_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[28] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[29] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[30] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[31], context[32], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[33], context[34], "refalrts::adt_pointers(", 23 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[35] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[36], & ContextItem_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[37] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[38], & Add_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[39], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[40], 2UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[41] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[42] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[43], context[44], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[45] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[46], & ContextItem_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[47] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[48], & Add_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[49], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[50], 3UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[51] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[52] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[53], context[54], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[55] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[56], & ContextItem_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[57] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[58], & Add_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[59], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[60], 4UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[61] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[62] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[63], context[64], ");", 2 ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatchSave_alias );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[30], context[1] );
  refalrts::push_stack( context[62] );
  refalrts::push_stack( context[55] );
  refalrts::push_stack( context[61] );
  refalrts::push_stack( context[57] );
  refalrts::push_stack( context[52] );
  refalrts::push_stack( context[45] );
  refalrts::push_stack( context[51] );
  refalrts::push_stack( context[47] );
  refalrts::push_stack( context[42] );
  refalrts::push_stack( context[35] );
  refalrts::push_stack( context[41] );
  refalrts::push_stack( context[37] );
  refalrts::push_stack( context[29] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[28] );
  refalrts::push_stack( context[26] );
  refalrts::push_stack( context[23] );
  refalrts::push_stack( context[21] );
  refalrts::link_brackets( context[17], context[20] );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[28], context[64] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[23], context[27] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[17], context[22] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[12], context[16] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchADTSave(func_PrintMatchADTSave, "PrintMatchADTSave#2881595569:337745613");
refalrts::RefalFunction& PrintMatchADTSave_2881595569_337745613 = descr_PrintMatchADTSave;

static refalrts::FnResult func_BreakerFromIndent(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & BreakerFromIndent/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // '  '
    // </0 & BreakerFromIndent/4 ' '/5 ' '/6 >/1
    context[9] = context[2];
    context[10] = context[3];
    context[5] = refalrts::char_left( ' ', context[9], context[10] );
    if( ! context[5] )
      continue;
    context[6] = refalrts::char_left( ' ', context[9], context[10] );
    if( ! context[6] )
      continue;
    if( ! refalrts::empty_seq( context[9], context[10] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'r'/0 HalfReuse: 'e'/4 Reuse: 't'/5 Reuse: 'u'/6 HalfReuse: 'r'/1 }"n refalrts::cRecognitionImpossible;"/7 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[7], context[8], "n refalrts::cRecognitionImpossible;", 35 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::update_char( context[5], 't' );
    refalrts::update_char( context[6], 'u' );
    refalrts::reinit_char( context[1], 'r' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[7], context[8] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & BreakerFromIndent/4 e.OtherIndent#1/2 >/1
  // closed e.OtherIndent#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} e.OtherIndent#1/2 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 'c'/0 HalfReuse: 'o'/4 }"ntinue"/5 Tile{ HalfReuse: ';'/1 ]] }
  if( ! refalrts::alloc_chars( context[5], context[6], "ntinue", 6 ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[0], 'c' );
  refalrts::reinit_char( context[4], 'o' );
  refalrts::reinit_char( context[1], ';' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_BreakerFromIndent(func_BreakerFromIndent, "BreakerFromIndent#2881595569:337745613");
refalrts::RefalFunction& BreakerFromIndent_2881595569_337745613 = descr_BreakerFromIndent;

static refalrts::FnResult func_PrintMatchEmpty(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 26 elems
  refalrts::Iter context[26];
  refalrts::zeros( context, 26 );
  // </0 & PrintMatchEmpty/4 (/7 e.Indent#1/5 )/8 s.BracketNumber#1/9 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } (/10 e.Indent#1/5/11"if( ! refalrts::empty_seq( "/13 </15 & ContextRange/16 Tile{ AsIs: s.BracketNumber#1/9 AsIs: >/1 }" ) "/17 Tile{ HalfReuse: ')'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: ' '/8 } ' '/19 </20 & BreakerFromIndent/21 e.Indent#1/5/22 >/24 )/25 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[11], context[12], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[13], context[14], "if( ! refalrts::empty_seq( ", 27 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[16], & ContextRange_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[17], context[18], " ) ", 3 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[19], ' ' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[21], & BreakerFromIndent_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[22], context[23], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[24] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[25] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[0], ')' );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::reinit_char( context[8], ' ' );
  refalrts::link_brackets( context[7], context[25] );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[20] );
  refalrts::link_brackets( context[10], context[4] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[15] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[19], context[25] );
  res = refalrts::splice_evar( res, context[0], context[8] );
  res = refalrts::splice_evar( res, context[17], context[18] );
  res = refalrts::splice_evar( res, context[9], context[1] );
  res = refalrts::splice_evar( res, context[10], context[16] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchEmpty(func_PrintMatchEmpty, "PrintMatchEmpty#2881595569:337745613");
refalrts::RefalFunction& PrintMatchEmpty_2881595569_337745613 = descr_PrintMatchEmpty;

static refalrts::FnResult func_StrFromDirection(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 7 elems
  refalrts::Iter context[7];
  refalrts::zeros( context, 7 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & StrFromDirection/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # AlgLeft
    // </0 & StrFromDirection/4 # AlgLeft/5 >/1
    if( ! refalrts::ident_term(  ident_AlgLeft, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'l'/0 HalfReuse: 'e'/4 HalfReuse: 'f'/5 HalfReuse: 't'/1 ]] }
    refalrts::reinit_char( context[0], 'l' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[5], 'f' );
    refalrts::reinit_char( context[1], 't' );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // # AlgRight
  // </0 & StrFromDirection/4 # AlgRight/5 >/1
  if( ! refalrts::ident_term(  ident_AlgRight, context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 'r'/0 HalfReuse: 'i'/4 HalfReuse: 'g'/5 HalfReuse: 'h'/1 } 't'/6 Tile{ ]] }
  if( ! refalrts::alloc_char( context[6], 't' ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[0], 'r' );
  refalrts::reinit_char( context[4], 'i' );
  refalrts::reinit_char( context[5], 'g' );
  refalrts::reinit_char( context[1], 'h' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_StrFromDirection(func_StrFromDirection, "StrFromDirection#2881595569:337745613");
refalrts::RefalFunction& StrFromDirection_2881595569_337745613 = descr_StrFromDirection;

static refalrts::FnResult func_VarMatchFunction(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & VarMatchFunction/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // 's'
    // </0 & VarMatchFunction/4 's'/5 >/1
    if( ! refalrts::char_term( 's', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 's'/0 HalfReuse: 'v'/4 Reuse: 'a'/5 HalfReuse: 'r'/1 ]] }
    refalrts::reinit_char( context[0], 's' );
    refalrts::reinit_char( context[4], 'v' );
    refalrts::update_char( context[5], 'a' );
    refalrts::reinit_char( context[1], 'r' );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // 't'
  // </0 & VarMatchFunction/4 't'/5 >/1
  if( ! refalrts::char_term( 't', context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 't'/0 HalfReuse: 'v'/4 Reuse: 'a'/5 HalfReuse: 'r'/1 ]] }
  refalrts::reinit_char( context[0], 't' );
  refalrts::reinit_char( context[4], 'v' );
  refalrts::update_char( context[5], 'a' );
  refalrts::reinit_char( context[1], 'r' );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_VarMatchFunction(func_VarMatchFunction, "VarMatchFunction#2881595569:337745613");
refalrts::RefalFunction& VarMatchFunction_2881595569_337745613 = descr_VarMatchFunction;

static refalrts::FnResult func_PrintMatchSTVar(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & PrintMatchSTVar/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.Mode#1/11 s.VarNumber#1/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/13 </14 & VarMatchFunction/15 Tile{ AsIs: s.Mode#1/11 } >/16 )/17 </18 & ContextItem/19 Tile{ AsIs: s.VarNumber#1/12 AsIs: >/1 } >/20 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[15], & VarMatchFunction_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], & ContextItem_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatch_alias );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[18] );
  refalrts::link_brackets( context[13], context[17] );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[14] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[20], context[20] );
  res = refalrts::splice_evar( res, context[12], context[1] );
  res = refalrts::splice_evar( res, context[16], context[19] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[13], context[15] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchSTVar(func_PrintMatchSTVar, "PrintMatchSTVar#2881595569:337745613");
refalrts::RefalFunction& PrintMatchSTVar_2881595569_337745613 = descr_PrintMatchSTVar;

static refalrts::FnResult func_PrintMatchSTVarSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 25 elems
  refalrts::Iter context[25];
  refalrts::zeros( context, 25 );
  // </0 & PrintMatchSTVarSave/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 't'/11 s.VarNumber#1/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[11] = refalrts::char_left( 't', context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 } </13 Tile{ HalfReuse: & Inc/11 AsIs: s.VarNumber#1/12 AsIs: >/1 } Tile{ AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/14 </15 & VarMatchFunction/16 't'/17 >/18 )/19 </20 & ContextItem/21 s.VarNumber#1/12/22 >/23 >/24 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[16], & VarMatchFunction_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[17], 't' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[21], & ContextItem_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[22], context[12]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[23] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[24] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatchSave_alias );
  refalrts::reinit_name( context[11], & Inc_alias );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[23] );
  refalrts::push_stack( context[20] );
  refalrts::link_brackets( context[14], context[19] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[13] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[14], context[24] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[11], context[1] );
  res = refalrts::splice_evar( res, context[13], context[13] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchSTVarSave(func_PrintMatchSTVarSave, "PrintMatchSTVarSave#2881595569:337745613");
refalrts::RefalFunction& PrintMatchSTVarSave_2881595569_337745613 = descr_PrintMatchSTVarSave;

static refalrts::FnResult func_PrintMatchRepeated(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 34 elems
  refalrts::Iter context[34];
  refalrts::zeros( context, 34 );
  //FAST GEN: ( e.$ ) s.$ s.$ s.$ s.$ s.$
  //GLOBAL GEN: ( e.$ ) s.$ s.$ s.$ s.$ s.$
  // </0 & PrintMatchRepeated/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 s.idxTV#0/10 s.idxTVV#0/11 s.idxTVVV#0/12 s.idxTVVVV#0/13 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // ( e.idx ) s.idx s.idx 'e' s.idx s.idx
    // </0 & PrintMatchRepeated/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 'e'/11 s.VarNumber#1/12 s.SampleNumber#1/13 >/1
    if( ! refalrts::char_term( 'e', context[11] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 HalfReuse: (/11 }"repeated_evar"/14 )/16 </17 & ContextRange/18 Tile{ AsIs: s.VarNumber#1/12 } >/19", "/20 </22 & ContextRange/23 Tile{ AsIs: s.SampleNumber#1/13 AsIs: >/1 } >/24 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[14], context[15], "repeated_evar", 13 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[18], & ContextRange_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[23], & ContextRange_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[24] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & PrintMatch_alias );
    refalrts::reinit_open_bracket( context[11] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[17] );
    refalrts::link_brackets( context[11], context[16] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[24], context[24] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[19], context[23] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[14], context[18] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) # AlgTerm s.idx s.idx s.idx s.idx
    // </0 & PrintMatchRepeated/4 (/7 e.Indent#1/5 )/8 # AlgTerm/9 s.BracketNumber#1/10 s.Mode#1/11 s.VarNumber#1/12 s.SampleNumber#1/13 >/1
    if( ! refalrts::ident_term(  ident_AlgTerm, context[9] ) )
      continue;
    // closed e.Indent#1 as range 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.BracketNumber#1/10 s.Mode#1/11 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/14 e.Indent#1/5/15"if( ! refalrts::repeated_stvar_term( "/17 </19 & ContextItem/20 Tile{ AsIs: s.VarNumber#1/12 } >/21", "/22 </24 & ContextItem/25 Tile{ AsIs: s.SampleNumber#1/13 AsIs: >/1 }" ) "/26 Tile{ HalfReuse: ')'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: ' '/8 HalfReuse: ' '/9 } </28 & BreakerFromIndent/29 e.Indent#1/5/30 >/32 )/33 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[14] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[15], context[16], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[17], context[18], "if( ! refalrts::repeated_stvar_term( ", 37 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[20], & ContextItem_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[25], & ContextItem_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[26], context[27], " ) ", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[29], & BreakerFromIndent_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[30], context[31], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[33] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ')' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], ' ' );
    refalrts::reinit_char( context[9], ' ' );
    refalrts::link_brackets( context[7], context[33] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[28] );
    refalrts::link_brackets( context[14], context[4] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[19] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[28], context[33] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[26], context[27] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[21], context[25] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[14], context[20] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx s.idx s.idx s.idx s.idx
  // </0 & PrintMatchRepeated/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.Mode#1/11 s.VarNumber#1/12 s.SampleNumber#1/13 >/1
  // closed e.Indent#1 as range 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Mode#1/11 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/14"repeated_stvar"/15 )/17 </18 & ContextItem/19 Tile{ AsIs: s.VarNumber#1/12 } >/20", "/21 </23 & ContextItem/24 Tile{ AsIs: s.SampleNumber#1/13 AsIs: >/1 } >/25 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[15], context[16], "repeated_stvar", 14 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], & ContextItem_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[21], context[22], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[23] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[24], & ContextItem_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[25] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatch_alias );
  refalrts::push_stack( context[25] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[23] );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[18] );
  refalrts::link_brackets( context[14], context[17] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[25], context[25] );
  res = refalrts::splice_evar( res, context[13], context[1] );
  res = refalrts::splice_evar( res, context[20], context[24] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[14], context[19] );
  refalrts::splice_to_freelist_open( context[10], res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchRepeated(func_PrintMatchRepeated, "PrintMatchRepeated#2881595569:337745613");
refalrts::RefalFunction& PrintMatchRepeated_2881595569_337745613 = descr_PrintMatchRepeated;

static refalrts::FnResult func_PrintMatchRepeatedTVarSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 29 elems
  refalrts::Iter context[29];
  refalrts::zeros( context, 29 );
  // </0 & PrintMatchRepeatedTVarSave/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.VarNumber#1/11 s.SampleNumber#1/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 } </13 & Inc/14 s.VarNumber#1/11/15 >/16 Tile{ AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/17"repeated_stvar"/18 )/20 </21 & ContextItem/22 Tile{ AsIs: s.VarNumber#1/11 } >/23", "/24 </26 & ContextItem/27 Tile{ AsIs: s.SampleNumber#1/12 AsIs: >/1 } >/28 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], & Inc_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[15], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[18], context[19], "repeated_stvar", 14 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[22], & ContextItem_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[23] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[24], context[25], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[26] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[27], & ContextItem_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[28] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & PrintMatchSave_alias );
  refalrts::push_stack( context[28] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[26] );
  refalrts::push_stack( context[23] );
  refalrts::push_stack( context[21] );
  refalrts::link_brackets( context[17], context[20] );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[13] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[28], context[28] );
  res = refalrts::splice_evar( res, context[12], context[1] );
  res = refalrts::splice_evar( res, context[23], context[27] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[17], context[22] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[13], context[16] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchRepeatedTVarSave(func_PrintMatchRepeatedTVarSave, "PrintMatchRepeatedTVarSave#2881595569:337745613");
refalrts::RefalFunction& PrintMatchRepeatedTVarSave_2881595569_337745613 = descr_PrintMatchRepeatedTVarSave;

static refalrts::FnResult func_PrintMatch(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 38 elems
  refalrts::Iter context[38];
  refalrts::zeros( context, 38 );
  //FAST GEN: ( e.$ ) s.$ s.$ ( e.$ ) e.$
  //GLOBAL GEN: ( e.$ ) s.$ s.$ ( e.$ ) e.$
  // </0 & PrintMatch/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 s.idxTV#0/10 (/13 e.idxTVVB#0/11 )/14 e.idxTVVT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[11] = 0;
  context[12] = 0;
  context[13] = refalrts::brackets_left( context[11], context[12], context[2], context[3] );
  if( ! context[13] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[13], context[14]);
  // closed e.idxTVVB#0 as range 11
  // closed e.idxTVVT#0 as range 2
  do {
    // ( e.idx ) # AlgTerm s.idx ( e.idx ) e.idx
    // </0 & PrintMatch/4 (/7 e.Indent#1/5 )/8 # AlgTerm/9 s.Offset#1/10 (/13 e.Function#1/11 )/14 e.TextRep#1/2 >/1
    if( ! refalrts::ident_term(  ident_AlgTerm, context[9] ) )
      continue;
    // closed e.Indent#1 as range 5
    // closed e.Function#1 as range 11
    // closed e.TextRep#1 as range 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/15 e.Indent#1/5/16"if( ! refalrts:"/18 Tile{ HalfReuse: ':'/13 AsIs: e.Function#1/11 HalfReuse: '_'/14 }"term( "/20 Tile{ AsIs: e.TextRep#1/2 }", "/22 </24 & ContextItem/25 Tile{ AsIs: s.Offset#1/10 } >/26" ) "/27 Tile{ HalfReuse: ')'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: ' '/8 HalfReuse: ' '/9 } </29 & BreakerFromIndent/30 e.Indent#1/5/31 >/33 Tile{ HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[15] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "if( ! refalrts:", 15 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "term( ", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[25], & ContextItem_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], " ) ", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], & BreakerFromIndent_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[31], context[32], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[33] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], ':' );
    refalrts::reinit_char( context[14], '_' );
    refalrts::reinit_char( context[0], ')' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], ' ' );
    refalrts::reinit_char( context[9], ' ' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[7], context[1] );
    refalrts::push_stack( context[33] );
    refalrts::push_stack( context[29] );
    refalrts::link_brackets( context[15], context[4] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[24] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[29], context[33] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[26], context[28] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[22], context[25] );
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[13], context[14] );
    res = refalrts::splice_evar( res, context[15], context[19] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx s.idx ( e.idx ) e.idx
  // </0 & PrintMatch/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 (/13 e.Function#1/11 )/14 e.TextRep#1/2 >/1
  // closed e.Indent#1 as range 5
  // closed e.Function#1 as range 11
  // closed e.TextRep#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } (/15 e.Indent#1/5/16"if( ! refalrts:"/18 Tile{ HalfReuse: ':'/13 AsIs: e.Function#1/11 HalfReuse: '_'/14 } </20 & StrFromDirection/21 Tile{ AsIs: s.Direction#1/9 } >/22"( "/23 Tile{ AsIs: e.TextRep#1/2 }", "/25 </27 & ContextRange/28 Tile{ AsIs: s.BracketNumber#1/10 } >/29" ) "/30 Tile{ HalfReuse: ')'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: ' '/8 } ' '/32 </33 & BreakerFromIndent/34 e.Indent#1/5/35 >/37 Tile{ HalfReuse: )/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[16], context[17], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[18], context[19], "if( ! refalrts:", 15 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[21], & StrFromDirection_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[23], context[24], "( ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[25], context[26], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[27] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[28], & ContextRange_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[29] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[30], context[31], " ) ", 3 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[32], ' ' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[33] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[34], & BreakerFromIndent_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[35], context[36], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[37] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[13], ':' );
  refalrts::reinit_char( context[14], '_' );
  refalrts::reinit_char( context[0], ')' );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::reinit_char( context[8], ' ' );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[7], context[1] );
  refalrts::push_stack( context[37] );
  refalrts::push_stack( context[33] );
  refalrts::link_brackets( context[15], context[4] );
  refalrts::push_stack( context[29] );
  refalrts::push_stack( context[27] );
  refalrts::push_stack( context[22] );
  refalrts::push_stack( context[20] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[32], context[37] );
  res = refalrts::splice_evar( res, context[0], context[8] );
  res = refalrts::splice_evar( res, context[29], context[31] );
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[25], context[28] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[22], context[24] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[20], context[21] );
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[15], context[19] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatch(func_PrintMatch, "PrintMatch#2881595569:337745613");
refalrts::RefalFunction& PrintMatch_2881595569_337745613 = descr_PrintMatch;

static refalrts::FnResult func_PrintMatchSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 55 elems
  refalrts::Iter context[55];
  refalrts::zeros( context, 55 );
  // </0 & PrintMatchSave/4 (/7 e.Indent#1/5 )/8 s.Offset#1/9 s.Direction#1/10 s.BracketNumber#1/11 (/14 e.Function#1/12 )/15 e.TextRep#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[12] = 0;
  context[13] = 0;
  context[14] = refalrts::brackets_left( context[12], context[13], context[2], context[3] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[14], context[15]);
  // closed e.Function#1 as range 12
  // closed e.TextRep#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } (/16 e.Indent#1/5/17 </19 & ContextItem/20 s.Offset#1/9/21 >/22" = refalrts:"/23 Tile{ HalfReuse: ':'/14 AsIs: e.Function#1/12 HalfReuse: '_'/15 } </25 & StrFromDirection/26 Tile{ AsIs: s.Direction#1/10 } >/27"( "/28 Tile{ AsIs: e.TextRep#1/2 }", "/30 </32 & ContextRange/33 Tile{ AsIs: s.BracketNumber#1/11 } >/34" )"/35 Tile{ HalfReuse: ';'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: 'i'/8 }"f( ! "/37 </39 & ContextItem/40 Tile{ AsIs: s.Offset#1/9 } >/41" )"/42 )/44 (/45 e.Indent#1/5/46"  "/48 </50 & BreakerFromIndent/51 e.Indent#1/5/52 >/54 Tile{ HalfReuse: )/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[20], & ContextItem_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[21], context[9]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[23], context[24], " = refalrts:", 12 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[25] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[26], & StrFromDirection_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[27] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[28], context[29], "( ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[30], context[31], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[32] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[33], & ContextRange_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[34] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[35], context[36], " )", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[37], context[38], "f( ! ", 5 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[39] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[40], & ContextItem_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[41] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[42], context[43], " )", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[44] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[45] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[46], context[47], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[48], context[49], "  ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[50] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[51], & BreakerFromIndent_alias ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[52], context[53], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[54] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[14], ':' );
  refalrts::reinit_char( context[15], '_' );
  refalrts::reinit_char( context[0], ';' );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::reinit_char( context[8], 'i' );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[45], context[1] );
  refalrts::push_stack( context[54] );
  refalrts::push_stack( context[50] );
  refalrts::link_brackets( context[7], context[44] );
  refalrts::push_stack( context[41] );
  refalrts::push_stack( context[39] );
  refalrts::link_brackets( context[16], context[4] );
  refalrts::push_stack( context[34] );
  refalrts::push_stack( context[32] );
  refalrts::push_stack( context[27] );
  refalrts::push_stack( context[25] );
  refalrts::push_stack( context[22] );
  refalrts::push_stack( context[19] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[41], context[54] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[37], context[40] );
  res = refalrts::splice_evar( res, context[0], context[8] );
  res = refalrts::splice_evar( res, context[34], context[36] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[30], context[33] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[27], context[29] );
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[25], context[26] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[16], context[24] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintMatchSave(func_PrintMatchSave, "PrintMatchSave#2881595569:337745613");
refalrts::RefalFunction& PrintMatchSave_2881595569_337745613 = descr_PrintMatchSave;

static refalrts::FnResult func_PrintCreateElem(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 33 elems
  refalrts::Iter context[33];
  refalrts::zeros( context, 33 );
  //FAST GEN: ( e.$ ) s.$ s.$ s.$ e.$
  //GLOBAL GEN: ( e.$ ) s.$ s.$ s.$ e.$
  // </0 & PrintCreateElem/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 s.idxTV#0/10 s.idxTVV#0/11 e.idxTVVV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTVVV#0 as range 2
  do {
    // ( e.idx ) # Allocate s.idx s.idx e.idx
    // </0 & PrintCreateElem/4 (/7 e.Indent#1/5 )/8 # Allocate/9 s.ElemNumber#1/10 s.ElementType#1/11 e.Info#1/2 >/1
    if( ! refalrts::ident_term(  ident_Allocate, context[9] ) )
      continue;
    // closed e.Indent#1 as range 5
    // closed e.Info#1 as range 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/12 e.Indent#1/5/13"if( ! refalrts::alloc_"/15 </17 & AllocatorFuncName/18 s.ElementType#1/11/19 >/20"( "/21 </23 & ContextItem/24 Tile{ AsIs: s.ElemNumber#1/10 } >/25 </26 & AllocatorFuncArgument/27 Tile{ AsIs: s.ElementType#1/11 AsIs: e.Info#1/2 AsIs: >/1 }" ) "/28 Tile{ HalfReuse: ')'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: ' '/8 HalfReuse: ' '/9 }"return refalrts::cNoMemory;"/30 )/32 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[12] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[13], context[14], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[15], context[16], "if( ! refalrts::alloc_", 22 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[18], & AllocatorFuncName_alias ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[19], context[11]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "( ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[24], & ContextItem_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & AllocatorFuncArgument_alias ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[28], context[29], " ) ", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[30], context[31], "return refalrts::cNoMemory;", 27 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[32] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ')' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], ' ' );
    refalrts::reinit_char( context[9], ' ' );
    refalrts::link_brackets( context[7], context[32] );
    refalrts::link_brackets( context[12], context[4] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[25] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[17] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[30], context[32] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[28], context[29] );
    res = refalrts::splice_evar( res, context[11], context[1] );
    res = refalrts::splice_evar( res, context[25], context[27] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[12], context[24] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx s.idx s.idx e.idx
  // </0 & PrintCreateElem/4 (/7 e.Indent#1/5 )/8 s.CreateMode#1/9 s.ElemNumber#1/10 s.ElementType#1/11 e.Info#1/2 >/1
  // closed e.Indent#1 as range 5
  // closed e.Info#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: 'r'/8 }"efalrts::"/12 </14 & AllocatorMode/15 Tile{ AsIs: s.CreateMode#1/9 } >/16 '_'/17 Tile{ AsIs: </0 Reuse: & AllocatorFuncName/4 } s.ElementType#1/11/18 >/19"( "/20 </22 & ContextItem/23 Tile{ AsIs: s.ElemNumber#1/10 } >/24 </25 & AllocatorFuncArgument/26 Tile{ AsIs: s.ElementType#1/11 AsIs: e.Info#1/2 AsIs: >/1 }" );"/27 )/29 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[12], context[13], "efalrts::", 9 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[15], & AllocatorMode_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[17], '_' ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[18], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[20], context[21], "( ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[23], & ContextItem_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[24] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[25] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[26], & AllocatorFuncArgument_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[27], context[28], " );", 3 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[29] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[8], 'r' );
  refalrts::update_name( context[4], & AllocatorFuncName_alias );
  refalrts::link_brackets( context[7], context[29] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[25] );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[22] );
  refalrts::push_stack( context[19] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[14] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[27], context[29] );
  res = refalrts::splice_evar( res, context[11], context[1] );
  res = refalrts::splice_evar( res, context[24], context[26] );
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[18], context[23] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[16], context[17] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[12], context[15] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintCreateElem(func_PrintCreateElem, "PrintCreateElem#2881595569:337745613");
refalrts::RefalFunction& PrintCreateElem_2881595569_337745613 = descr_PrintCreateElem;

static refalrts::FnResult func_AllocatorMode(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & AllocatorMode/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # Reinit
    // </0 & AllocatorMode/4 # Reinit/5 >/1
    if( ! refalrts::ident_term(  ident_Reinit, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'r'/0 HalfReuse: 'e'/4 HalfReuse: 'i'/5 HalfReuse: 'n'/1 }"it"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "it", 2 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[5], 'i' );
    refalrts::reinit_char( context[1], 'n' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // # Update
  // </0 & AllocatorMode/4 # Update/5 >/1
  if( ! refalrts::ident_term(  ident_Update, context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 'u'/0 HalfReuse: 'p'/4 HalfReuse: 'd'/5 HalfReuse: 'a'/1 }"te"/6 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "te", 2 ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[0], 'u' );
  refalrts::reinit_char( context[4], 'p' );
  refalrts::reinit_char( context[5], 'd' );
  refalrts::reinit_char( context[1], 'a' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_AllocatorMode(func_AllocatorMode, "AllocatorMode#2881595569:337745613");
refalrts::RefalFunction& AllocatorMode_2881595569_337745613 = descr_AllocatorMode;

static refalrts::FnResult func_AllocatorFuncName(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & AllocatorFuncName/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # ElChar
    // </0 & AllocatorFuncName/4 # ElChar/5 >/1
    if( ! refalrts::ident_term(  ident_ElChar, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'c'/0 HalfReuse: 'h'/4 HalfReuse: 'a'/5 HalfReuse: 'r'/1 ]] }
    refalrts::reinit_char( context[0], 'c' );
    refalrts::reinit_char( context[4], 'h' );
    refalrts::reinit_char( context[5], 'a' );
    refalrts::reinit_char( context[1], 'r' );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElName
    // </0 & AllocatorFuncName/4 # ElName/5 >/1
    if( ! refalrts::ident_term(  ident_ElName, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'n'/0 HalfReuse: 'a'/4 HalfReuse: 'm'/5 HalfReuse: 'e'/1 ]] }
    refalrts::reinit_char( context[0], 'n' );
    refalrts::reinit_char( context[4], 'a' );
    refalrts::reinit_char( context[5], 'm' );
    refalrts::reinit_char( context[1], 'e' );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElNumber
    // </0 & AllocatorFuncName/4 # ElNumber/5 >/1
    if( ! refalrts::ident_term(  ident_ElNumber, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'n'/0 HalfReuse: 'u'/4 HalfReuse: 'm'/5 HalfReuse: 'b'/1 }"er"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "er", 2 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'n' );
    refalrts::reinit_char( context[4], 'u' );
    refalrts::reinit_char( context[5], 'm' );
    refalrts::reinit_char( context[1], 'b' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElIdent
    // </0 & AllocatorFuncName/4 # ElIdent/5 >/1
    if( ! refalrts::ident_term(  ident_ElIdent, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'i'/0 HalfReuse: 'd'/4 HalfReuse: 'e'/5 HalfReuse: 'n'/1 } 't'/6 Tile{ ]] }
    if( ! refalrts::alloc_char( context[6], 't' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'i' );
    refalrts::reinit_char( context[4], 'd' );
    refalrts::reinit_char( context[5], 'e' );
    refalrts::reinit_char( context[1], 'n' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[6] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElOpenADT
    // </0 & AllocatorFuncName/4 # ElOpenADT/5 >/1
    if( ! refalrts::ident_term(  ident_ElOpenADT, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'o'/0 HalfReuse: 'p'/4 HalfReuse: 'e'/5 HalfReuse: 'n'/1 }"_adt"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "_adt", 4 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'o' );
    refalrts::reinit_char( context[4], 'p' );
    refalrts::reinit_char( context[5], 'e' );
    refalrts::reinit_char( context[1], 'n' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElCloseADT
    // </0 & AllocatorFuncName/4 # ElCloseADT/5 >/1
    if( ! refalrts::ident_term(  ident_ElCloseADT, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'c'/0 HalfReuse: 'l'/4 HalfReuse: 'o'/5 HalfReuse: 's'/1 }"e_adt"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "e_adt", 5 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'c' );
    refalrts::reinit_char( context[4], 'l' );
    refalrts::reinit_char( context[5], 'o' );
    refalrts::reinit_char( context[1], 's' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElOpenBracket
    // </0 & AllocatorFuncName/4 # ElOpenBracket/5 >/1
    if( ! refalrts::ident_term(  ident_ElOpenBracket, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'o'/0 HalfReuse: 'p'/4 HalfReuse: 'e'/5 HalfReuse: 'n'/1 }"_bracket"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "_bracket", 8 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'o' );
    refalrts::reinit_char( context[4], 'p' );
    refalrts::reinit_char( context[5], 'e' );
    refalrts::reinit_char( context[1], 'n' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElCloseBracket
    // </0 & AllocatorFuncName/4 # ElCloseBracket/5 >/1
    if( ! refalrts::ident_term(  ident_ElCloseBracket, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'c'/0 HalfReuse: 'l'/4 HalfReuse: 'o'/5 HalfReuse: 's'/1 }"e_bracket"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "e_bracket", 9 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'c' );
    refalrts::reinit_char( context[4], 'l' );
    refalrts::reinit_char( context[5], 'o' );
    refalrts::reinit_char( context[1], 's' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElOpenCall
    // </0 & AllocatorFuncName/4 # ElOpenCall/5 >/1
    if( ! refalrts::ident_term(  ident_ElOpenCall, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'o'/0 HalfReuse: 'p'/4 HalfReuse: 'e'/5 HalfReuse: 'n'/1 }"_call"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "_call", 5 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'o' );
    refalrts::reinit_char( context[4], 'p' );
    refalrts::reinit_char( context[5], 'e' );
    refalrts::reinit_char( context[1], 'n' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // # ElCloseCall
  // </0 & AllocatorFuncName/4 # ElCloseCall/5 >/1
  if( ! refalrts::ident_term(  ident_ElCloseCall, context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 'c'/0 HalfReuse: 'l'/4 HalfReuse: 'o'/5 HalfReuse: 's'/1 }"e_call"/6 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "e_call", 6 ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[0], 'c' );
  refalrts::reinit_char( context[4], 'l' );
  refalrts::reinit_char( context[5], 'o' );
  refalrts::reinit_char( context[1], 's' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_AllocatorFuncName(func_AllocatorFuncName, "AllocatorFuncName#2881595569:337745613");
refalrts::RefalFunction& AllocatorFuncName_2881595569_337745613 = descr_AllocatorFuncName;

static refalrts::FnResult func_AllocatorFuncArgument(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  //FAST GEN: e.$
  //GLOBAL GEN: s.$ e.$
  // </0 & AllocatorFuncArgument/4 s.idx#0/5 e.idxV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxV#0 as range 2
  do {
    // # ElChar s.idx
    // </0 & AllocatorFuncArgument/4 # ElChar/5 s.Char#1/6 >/1
    if( ! refalrts::ident_term(  ident_ElChar, context[5] ) )
      continue;
    context[10] = context[2];
    context[11] = context[3];
    if( ! refalrts::svar_left( context[6], context[10], context[11] ) )
      continue;
    if( ! refalrts::empty_seq( context[10], context[11] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ }", "/7 Tile{ HalfReuse: '\''/0 HalfReuse: </4 HalfReuse: & EscapeChar/5 AsIs: s.Char#1/6 AsIs: >/1 } '\''/9 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[7], context[8], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[9], '\'' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], '\'' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & EscapeChar_alias );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[9], context[9] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[7], context[8] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElName e.idx
    // </0 & AllocatorFuncArgument/4 # ElName/5 e.Name#1/2 >/1
    if( ! refalrts::ident_term(  ident_ElName, context[5] ) )
      continue;
    // closed e.Name#1 as range 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ }", &"/6 Tile{ HalfReuse: ' '/0 HalfReuse: </4 HalfReuse: & CNameAlias/5 AsIs: e.Name#1/2 AsIs: >/1 ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], ", &", 3 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ' ' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & CNameAlias_alias );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElNumber s.idx
    // </0 & AllocatorFuncArgument/4 # ElNumber/5 s.Number#1/6 >/1
    if( ! refalrts::ident_term(  ident_ElNumber, context[5] ) )
      continue;
    context[10] = context[2];
    context[11] = context[3];
    if( ! refalrts::svar_left( context[6], context[10], context[11] ) )
      continue;
    if( ! refalrts::empty_seq( context[10], context[11] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } ','/7 Tile{ HalfReuse: ' '/0 HalfReuse: </4 HalfReuse: & StrFromInt/5 AsIs: s.Number#1/6 AsIs: >/1 }"UL"/8 Tile{ ]] }
    if( ! refalrts::alloc_char( context[7], ',' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[8], context[9], "UL", 2 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ' ' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & StrFromInt_alias );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[8], context[9] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[7], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElIdent e.idx
    // </0 & AllocatorFuncArgument/4 # ElIdent/5 e.Name#1/2 >/1
    if( ! refalrts::ident_term(  ident_ElIdent, context[5] ) )
      continue;
    // closed e.Name#1 as range 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ }", ident"/6 Tile{ HalfReuse: '_'/0 HalfReuse: </4 HalfReuse: & CName/5 AsIs: e.Name#1/2 AsIs: >/1 ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], ", ident", 7 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], '_' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & CName_alias );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & AllocatorFuncArgument/4 s.Other#1/5 >/1
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & AllocatorFuncArgument/4 s.Other#1/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_AllocatorFuncArgument(func_AllocatorFuncArgument, "AllocatorFuncArgument#2881595569:337745613");
refalrts::RefalFunction& AllocatorFuncArgument_2881595569_337745613 = descr_AllocatorFuncArgument;

static refalrts::FnResult func_PrintInterpretCreateElem(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 31 elems
  refalrts::Iter context[31];
  refalrts::zeros( context, 31 );
  // </0 & PrintInterpretCreateElem/4 (/7 e.Indent#1/5 )/8 s.Mode#1/9 s.ElemNumber#1/10 s.ElementType#1/11 e.Info#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Info#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: '{'/8 }"refalrts::ic"/12 </14 & CreateMode/15 Tile{ AsIs: s.Mode#1/9 } >/16 Tile{ AsIs: </0 Reuse: & CreateCommandTag/4 } s.ElementType#1/11/17 >/18", 0, "/19 </21 & CreateCommandInfo/22 Tile{ AsIs: s.ElementType#1/11 AsIs: e.Info#1/2 AsIs: >/1 }", "/23 </25 & StrFromInt/26 Tile{ AsIs: s.ElemNumber#1/10 } >/27"},"/28 )/30 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[12], context[13], "refalrts::ic", 12 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[15], & CreateMode_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[16] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[17], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[19], context[20], ", 0, ", 5 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[22], & CreateCommandInfo_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[23], context[24], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[25] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[26], & StrFromInt_alias ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[27] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[28], context[29], "},", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[30] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[8], '{' );
  refalrts::update_name( context[4], & CreateCommandTag_alias );
  refalrts::link_brackets( context[7], context[30] );
  refalrts::push_stack( context[27] );
  refalrts::push_stack( context[25] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[14] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[27], context[30] );
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[23], context[26] );
  res = refalrts::splice_evar( res, context[11], context[1] );
  res = refalrts::splice_evar( res, context[17], context[22] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[16], context[16] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[12], context[15] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_PrintInterpretCreateElem(func_PrintInterpretCreateElem, "PrintInterpretCreateElem#2881595569:337745613");
refalrts::RefalFunction& PrintInterpretCreateElem_2881595569_337745613 = descr_PrintInterpretCreateElem;

static refalrts::FnResult func_CreateMode(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & CreateMode/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # Allocate
    // </0 & CreateMode/4 # Allocate/5 >/1
    if( ! refalrts::ident_term(  ident_Allocate, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'A'/0 HalfReuse: 'l'/4 HalfReuse: 'l'/5 HalfReuse: 'o'/1 } 'c'/6 Tile{ ]] }
    if( ! refalrts::alloc_char( context[6], 'c' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'A' );
    refalrts::reinit_char( context[4], 'l' );
    refalrts::reinit_char( context[5], 'l' );
    refalrts::reinit_char( context[1], 'o' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[6] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # Reinit
    // </0 & CreateMode/4 # Reinit/5 >/1
    if( ! refalrts::ident_term(  ident_Reinit, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'R'/0 HalfReuse: 'e'/4 HalfReuse: 'i'/5 HalfReuse: 'n'/1 }"it"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "it", 2 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'R' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[5], 'i' );
    refalrts::reinit_char( context[1], 'n' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // # Update
  // </0 & CreateMode/4 # Update/5 >/1
  if( ! refalrts::ident_term(  ident_Update, context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 'U'/0 HalfReuse: 'p'/4 HalfReuse: 'd'/5 HalfReuse: 'a'/1 }"te"/6 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "te", 2 ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[0], 'U' );
  refalrts::reinit_char( context[4], 'p' );
  refalrts::reinit_char( context[5], 'd' );
  refalrts::reinit_char( context[1], 'a' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_CreateMode(func_CreateMode, "CreateMode#2881595569:337745613");
refalrts::RefalFunction& CreateMode_2881595569_337745613 = descr_CreateMode;

static refalrts::FnResult func_CreateCommandTag(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & CreateCommandTag/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # ElChar
    // </0 & CreateCommandTag/4 # ElChar/5 >/1
    if( ! refalrts::ident_term(  ident_ElChar, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'C'/0 HalfReuse: 'h'/4 HalfReuse: 'a'/5 HalfReuse: 'r'/1 ]] }
    refalrts::reinit_char( context[0], 'C' );
    refalrts::reinit_char( context[4], 'h' );
    refalrts::reinit_char( context[5], 'a' );
    refalrts::reinit_char( context[1], 'r' );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElName
    // </0 & CreateCommandTag/4 # ElName/5 >/1
    if( ! refalrts::ident_term(  ident_ElName, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'F'/0 HalfReuse: 'u'/4 HalfReuse: 'n'/5 HalfReuse: 'c'/1 ]] }
    refalrts::reinit_char( context[0], 'F' );
    refalrts::reinit_char( context[4], 'u' );
    refalrts::reinit_char( context[5], 'n' );
    refalrts::reinit_char( context[1], 'c' );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElNumber
    // </0 & CreateCommandTag/4 # ElNumber/5 >/1
    if( ! refalrts::ident_term(  ident_ElNumber, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 'I'/4 HalfReuse: 'n'/5 HalfReuse: 't'/1 ]] }
    refalrts::reinit_char( context[4], 'I' );
    refalrts::reinit_char( context[5], 'n' );
    refalrts::reinit_char( context[1], 't' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[4];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElHugeNumber
    // </0 & CreateCommandTag/4 # ElHugeNumber/5 >/1
    if( ! refalrts::ident_term(  ident_ElHugeNumber, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'H'/0 HalfReuse: 'u'/4 HalfReuse: 'g'/5 HalfReuse: 'e'/1 }"Int"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "Int", 3 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'H' );
    refalrts::reinit_char( context[4], 'u' );
    refalrts::reinit_char( context[5], 'g' );
    refalrts::reinit_char( context[1], 'e' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElIdent
    // </0 & CreateCommandTag/4 # ElIdent/5 >/1
    if( ! refalrts::ident_term(  ident_ElIdent, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'I'/0 HalfReuse: 'd'/4 HalfReuse: 'e'/5 HalfReuse: 'n'/1 } 't'/6 Tile{ ]] }
    if( ! refalrts::alloc_char( context[6], 't' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'I' );
    refalrts::reinit_char( context[4], 'd' );
    refalrts::reinit_char( context[5], 'e' );
    refalrts::reinit_char( context[1], 'n' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[6] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElOpenBracket
    // </0 & CreateCommandTag/4 # ElOpenBracket/5 >/1
    if( ! refalrts::ident_term(  ident_ElOpenBracket, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'B'/0 HalfReuse: 'r'/4 HalfReuse: 'a'/5 HalfReuse: 'c'/1 }"ket"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "ket", 3 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'B' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_char( context[5], 'a' );
    refalrts::reinit_char( context[1], 'c' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElOpenADT
    // </0 & CreateCommandTag/4 # ElOpenADT/5 >/1
    if( ! refalrts::ident_term(  ident_ElOpenADT, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'B'/0 HalfReuse: 'r'/4 HalfReuse: 'a'/5 HalfReuse: 'c'/1 }"ket"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "ket", 3 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'B' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_char( context[5], 'a' );
    refalrts::reinit_char( context[1], 'c' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElOpenCall
    // </0 & CreateCommandTag/4 # ElOpenCall/5 >/1
    if( ! refalrts::ident_term(  ident_ElOpenCall, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'B'/0 HalfReuse: 'r'/4 HalfReuse: 'a'/5 HalfReuse: 'c'/1 }"ket"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "ket", 3 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'B' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_char( context[5], 'a' );
    refalrts::reinit_char( context[1], 'c' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElCloseBracket
    // </0 & CreateCommandTag/4 # ElCloseBracket/5 >/1
    if( ! refalrts::ident_term(  ident_ElCloseBracket, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'B'/0 HalfReuse: 'r'/4 HalfReuse: 'a'/5 HalfReuse: 'c'/1 }"ket"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "ket", 3 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'B' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_char( context[5], 'a' );
    refalrts::reinit_char( context[1], 'c' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElCloseADT
    // </0 & CreateCommandTag/4 # ElCloseADT/5 >/1
    if( ! refalrts::ident_term(  ident_ElCloseADT, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'B'/0 HalfReuse: 'r'/4 HalfReuse: 'a'/5 HalfReuse: 'c'/1 }"ket"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "ket", 3 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'B' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_char( context[5], 'a' );
    refalrts::reinit_char( context[1], 'c' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElCloseCall
    // </0 & CreateCommandTag/4 # ElCloseCall/5 >/1
    if( ! refalrts::ident_term(  ident_ElCloseCall, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'B'/0 HalfReuse: 'r'/4 HalfReuse: 'a'/5 HalfReuse: 'c'/1 }"ket"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "ket", 3 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'B' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_char( context[5], 'a' );
    refalrts::reinit_char( context[1], 'c' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // # ElString
  // </0 & CreateCommandTag/4 # ElString/5 >/1
  if( ! refalrts::ident_term(  ident_ElString, context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 'S'/0 HalfReuse: 't'/4 HalfReuse: 'r'/5 HalfReuse: 'i'/1 }"ng"/6 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "ng", 2 ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[0], 'S' );
  refalrts::reinit_char( context[4], 't' );
  refalrts::reinit_char( context[5], 'r' );
  refalrts::reinit_char( context[1], 'i' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_CreateCommandTag(func_CreateCommandTag, "CreateCommandTag#2881595569:337745613");
refalrts::RefalFunction& CreateCommandTag_2881595569_337745613 = descr_CreateCommandTag;

static refalrts::FnResult func_CreateCommandInfo(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  //FAST GEN: e.$
  //GLOBAL GEN: s.$ e.$
  // </0 & CreateCommandInfo/4 s.idx#0/5 e.idxV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxV#0 as range 2
  do {
    // # ElChar s.idx
    // </0 & CreateCommandInfo/4 # ElChar/5 s.Char#1/6 >/1
    if( ! refalrts::ident_term(  ident_ElChar, context[5] ) )
      continue;
    context[8] = context[2];
    context[9] = context[3];
    if( ! refalrts::svar_left( context[6], context[8], context[9] ) )
      continue;
    if( ! refalrts::empty_seq( context[8], context[9] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: '\''/0 HalfReuse: </4 HalfReuse: & EscapeChar/5 AsIs: s.Char#1/6 AsIs: >/1 } '\''/7 Tile{ ]] }
    if( ! refalrts::alloc_char( context[7], '\'' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], '\'' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & EscapeChar_alias );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[7], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElName s.idx
    // </0 & CreateCommandInfo/4 # ElName/5 s.NameId#1/6 >/1
    if( ! refalrts::ident_term(  ident_ElName, context[5] ) )
      continue;
    context[8] = context[2];
    context[9] = context[3];
    if( ! refalrts::svar_left( context[6], context[8], context[9] ) )
      continue;
    if( ! refalrts::empty_seq( context[8], context[9] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: </4 HalfReuse: & StrFromInt/5 AsIs: s.NameId#1/6 AsIs: >/1 ]] }
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & StrFromInt_alias );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[4];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElNumber s.idx
    // </0 & CreateCommandInfo/4 # ElNumber/5 s.Number#1/6 >/1
    if( ! refalrts::ident_term(  ident_ElNumber, context[5] ) )
      continue;
    context[8] = context[2];
    context[9] = context[3];
    if( ! refalrts::svar_left( context[6], context[8], context[9] ) )
      continue;
    if( ! refalrts::empty_seq( context[8], context[9] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: </4 HalfReuse: & StrFromInt/5 AsIs: s.Number#1/6 AsIs: >/1 ]] }
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & StrFromInt_alias );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[4];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElHugeNumber s.idx
    // </0 & CreateCommandInfo/4 # ElHugeNumber/5 s.NumberId#1/6 >/1
    if( ! refalrts::ident_term(  ident_ElHugeNumber, context[5] ) )
      continue;
    context[8] = context[2];
    context[9] = context[3];
    if( ! refalrts::svar_left( context[6], context[8], context[9] ) )
      continue;
    if( ! refalrts::empty_seq( context[8], context[9] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: </4 HalfReuse: & StrFromInt/5 AsIs: s.NumberId#1/6 AsIs: >/1 ]] }
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & StrFromInt_alias );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[4];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElIdent s.idx
    // </0 & CreateCommandInfo/4 # ElIdent/5 s.NameId#1/6 >/1
    if( ! refalrts::ident_term(  ident_ElIdent, context[5] ) )
      continue;
    context[8] = context[2];
    context[9] = context[3];
    if( ! refalrts::svar_left( context[6], context[8], context[9] ) )
      continue;
    if( ! refalrts::empty_seq( context[8], context[9] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: </4 HalfReuse: & StrFromInt/5 AsIs: s.NameId#1/6 AsIs: >/1 ]] }
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], & StrFromInt_alias );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[4];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElOpenBracket
    // </0 & CreateCommandInfo/4 # ElOpenBracket/5 >/1
    if( ! refalrts::ident_term(  ident_ElOpenBracket, context[5] ) )
      continue;
    context[8] = context[2];
    context[9] = context[3];
    if( ! refalrts::empty_seq( context[8], context[9] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'r'/0 HalfReuse: 'e'/4 HalfReuse: 'f'/5 HalfReuse: 'a'/1 }"lrts::ibOpenBracket"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "lrts::ibOpenBracket", 19 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[5], 'f' );
    refalrts::reinit_char( context[1], 'a' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElOpenADT
    // </0 & CreateCommandInfo/4 # ElOpenADT/5 >/1
    if( ! refalrts::ident_term(  ident_ElOpenADT, context[5] ) )
      continue;
    context[8] = context[2];
    context[9] = context[3];
    if( ! refalrts::empty_seq( context[8], context[9] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'r'/0 HalfReuse: 'e'/4 HalfReuse: 'f'/5 HalfReuse: 'a'/1 }"lrts::ibOpenADT"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "lrts::ibOpenADT", 15 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[5], 'f' );
    refalrts::reinit_char( context[1], 'a' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElOpenCall
    // </0 & CreateCommandInfo/4 # ElOpenCall/5 >/1
    if( ! refalrts::ident_term(  ident_ElOpenCall, context[5] ) )
      continue;
    context[8] = context[2];
    context[9] = context[3];
    if( ! refalrts::empty_seq( context[8], context[9] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'r'/0 HalfReuse: 'e'/4 HalfReuse: 'f'/5 HalfReuse: 'a'/1 }"lrts::ibOpenCall"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "lrts::ibOpenCall", 16 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[5], 'f' );
    refalrts::reinit_char( context[1], 'a' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElCloseBracket
    // </0 & CreateCommandInfo/4 # ElCloseBracket/5 >/1
    if( ! refalrts::ident_term(  ident_ElCloseBracket, context[5] ) )
      continue;
    context[8] = context[2];
    context[9] = context[3];
    if( ! refalrts::empty_seq( context[8], context[9] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'r'/0 HalfReuse: 'e'/4 HalfReuse: 'f'/5 HalfReuse: 'a'/1 }"lrts::ibCloseBracket"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "lrts::ibCloseBracket", 20 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[5], 'f' );
    refalrts::reinit_char( context[1], 'a' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElCloseADT
    // </0 & CreateCommandInfo/4 # ElCloseADT/5 >/1
    if( ! refalrts::ident_term(  ident_ElCloseADT, context[5] ) )
      continue;
    context[8] = context[2];
    context[9] = context[3];
    if( ! refalrts::empty_seq( context[8], context[9] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'r'/0 HalfReuse: 'e'/4 HalfReuse: 'f'/5 HalfReuse: 'a'/1 }"lrts::ibCloseADT"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "lrts::ibCloseADT", 16 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[5], 'f' );
    refalrts::reinit_char( context[1], 'a' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElCloseCall
    // </0 & CreateCommandInfo/4 # ElCloseCall/5 >/1
    if( ! refalrts::ident_term(  ident_ElCloseCall, context[5] ) )
      continue;
    context[8] = context[2];
    context[9] = context[3];
    if( ! refalrts::empty_seq( context[8], context[9] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'r'/0 HalfReuse: 'e'/4 HalfReuse: 'f'/5 HalfReuse: 'a'/1 }"lrts::ibCloseCall"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "lrts::ibCloseCall", 17 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[5], 'f' );
    refalrts::reinit_char( context[1], 'a' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // # ElString s.idx
  // </0 & CreateCommandInfo/4 # ElString/5 s.StringId#1/6 >/1
  if( ! refalrts::ident_term(  ident_ElString, context[5] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: </4 HalfReuse: & StrFromInt/5 AsIs: s.StringId#1/6 AsIs: >/1 ]] }
  refalrts::reinit_open_call( context[4] );
  refalrts::reinit_name( context[5], & StrFromInt_alias );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[4];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::RefalNativeFunction descr_CreateCommandInfo(func_CreateCommandInfo, "CreateCommandInfo#2881595569:337745613");
refalrts::RefalFunction& CreateCommandInfo_2881595569_337745613 = descr_CreateCommandInfo;


//End of file
