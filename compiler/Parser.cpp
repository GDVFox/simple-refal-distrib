// Automatically generated file. Don't edit!
#include "refalrts.h"


// identifier #ADT-Brackets
template <typename SREFAL_PARAM_INT>
struct ident_ADT_Brackets {
  static const char *name() {
    return "ADT-Brackets";
  }
};

// identifier #Brackets
template <typename SREFAL_PARAM_INT>
struct ident_Brackets {
  static const char *name() {
    return "Brackets";
  }
};

// identifier #CallBrackets
template <typename SREFAL_PARAM_INT>
struct ident_CallBrackets {
  static const char *name() {
    return "CallBrackets";
  }
};

// identifier #Close
template <typename SREFAL_PARAM_INT>
struct ident_Close {
  static const char *name() {
    return "Close";
  }
};

// identifier #Closure
template <typename SREFAL_PARAM_INT>
struct ident_Closure {
  static const char *name() {
    return "Closure";
  }
};

// identifier #Declaration
template <typename SREFAL_PARAM_INT>
struct ident_Declaration {
  static const char *name() {
    return "Declaration";
  }
};

// identifier #EEnum
template <typename SREFAL_PARAM_INT>
struct ident_EEnum {
  static const char *name() {
    return "EEnum";
  }
};

// identifier #ESwap
template <typename SREFAL_PARAM_INT>
struct ident_ESwap {
  static const char *name() {
    return "ESwap";
  }
};

// identifier #Entry
template <typename SREFAL_PARAM_INT>
struct ident_Entry {
  static const char *name() {
    return "Entry";
  }
};

// identifier #Enum
template <typename SREFAL_PARAM_INT>
struct ident_Enum {
  static const char *name() {
    return "Enum";
  }
};

// identifier #Extern
template <typename SREFAL_PARAM_INT>
struct ident_Extern {
  static const char *name() {
    return "Extern";
  }
};

// identifier #Forward
template <typename SREFAL_PARAM_INT>
struct ident_Forward {
  static const char *name() {
    return "Forward";
  }
};

// identifier #Function
template <typename SREFAL_PARAM_INT>
struct ident_Function {
  static const char *name() {
    return "Function";
  }
};

// identifier #GN-Entry
template <typename SREFAL_PARAM_INT>
struct ident_GN_Entry {
  static const char *name() {
    return "GN-Entry";
  }
};

// identifier #GN-Local
template <typename SREFAL_PARAM_INT>
struct ident_GN_Local {
  static const char *name() {
    return "GN-Local";
  }
};

// identifier #Ident
template <typename SREFAL_PARAM_INT>
struct ident_Ident {
  static const char *name() {
    return "Ident";
  }
};

// identifier #NativeBlock
template <typename SREFAL_PARAM_INT>
struct ident_NativeBlock {
  static const char *name() {
    return "NativeBlock";
  }
};

// identifier #NativeBody
template <typename SREFAL_PARAM_INT>
struct ident_NativeBody {
  static const char *name() {
    return "NativeBody";
  }
};

// identifier #Open
template <typename SREFAL_PARAM_INT>
struct ident_Open {
  static const char *name() {
    return "Open";
  }
};

// identifier #Sentences
template <typename SREFAL_PARAM_INT>
struct ident_Sentences {
  static const char *name() {
    return "Sentences";
  }
};

// identifier #Swap
template <typename SREFAL_PARAM_INT>
struct ident_Swap {
  static const char *name() {
    return "Swap";
  }
};

// identifier #TkChar
template <typename SREFAL_PARAM_INT>
struct ident_TkChar {
  static const char *name() {
    return "TkChar";
  }
};

// identifier #TkCloseADT
template <typename SREFAL_PARAM_INT>
struct ident_TkCloseADT {
  static const char *name() {
    return "TkCloseADT";
  }
};

// identifier #TkCloseBlock
template <typename SREFAL_PARAM_INT>
struct ident_TkCloseBlock {
  static const char *name() {
    return "TkCloseBlock";
  }
};

// identifier #TkCloseBracket
template <typename SREFAL_PARAM_INT>
struct ident_TkCloseBracket {
  static const char *name() {
    return "TkCloseBracket";
  }
};

// identifier #TkCloseCall
template <typename SREFAL_PARAM_INT>
struct ident_TkCloseCall {
  static const char *name() {
    return "TkCloseCall";
  }
};

// identifier #TkComma
template <typename SREFAL_PARAM_INT>
struct ident_TkComma {
  static const char *name() {
    return "TkComma";
  }
};

// identifier #TkDirective
template <typename SREFAL_PARAM_INT>
struct ident_TkDirective {
  static const char *name() {
    return "TkDirective";
  }
};

// identifier #TkEOF
template <typename SREFAL_PARAM_INT>
struct ident_TkEOF {
  static const char *name() {
    return "TkEOF";
  }
};

// identifier #TkIdentMarker
template <typename SREFAL_PARAM_INT>
struct ident_TkIdentMarker {
  static const char *name() {
    return "TkIdentMarker";
  }
};

// identifier #TkIdentifier
template <typename SREFAL_PARAM_INT>
struct ident_TkIdentifier {
  static const char *name() {
    return "TkIdentifier";
  }
};

// identifier #TkName
template <typename SREFAL_PARAM_INT>
struct ident_TkName {
  static const char *name() {
    return "TkName";
  }
};

// identifier #TkNativeBlock
template <typename SREFAL_PARAM_INT>
struct ident_TkNativeBlock {
  static const char *name() {
    return "TkNativeBlock";
  }
};

// identifier #TkNewVariable
template <typename SREFAL_PARAM_INT>
struct ident_TkNewVariable {
  static const char *name() {
    return "TkNewVariable";
  }
};

// identifier #TkNumber
template <typename SREFAL_PARAM_INT>
struct ident_TkNumber {
  static const char *name() {
    return "TkNumber";
  }
};

// identifier #TkOpenADT
template <typename SREFAL_PARAM_INT>
struct ident_TkOpenADT {
  static const char *name() {
    return "TkOpenADT";
  }
};

// identifier #TkOpenBlock
template <typename SREFAL_PARAM_INT>
struct ident_TkOpenBlock {
  static const char *name() {
    return "TkOpenBlock";
  }
};

// identifier #TkOpenBracket
template <typename SREFAL_PARAM_INT>
struct ident_TkOpenBracket {
  static const char *name() {
    return "TkOpenBracket";
  }
};

// identifier #TkOpenCall
template <typename SREFAL_PARAM_INT>
struct ident_TkOpenCall {
  static const char *name() {
    return "TkOpenCall";
  }
};

// identifier #TkRedefinition
template <typename SREFAL_PARAM_INT>
struct ident_TkRedefinition {
  static const char *name() {
    return "TkRedefinition";
  }
};

// identifier #TkReplace
template <typename SREFAL_PARAM_INT>
struct ident_TkReplace {
  static const char *name() {
    return "TkReplace";
  }
};

// identifier #TkSemicolon
template <typename SREFAL_PARAM_INT>
struct ident_TkSemicolon {
  static const char *name() {
    return "TkSemicolon";
  }
};

// identifier #TkVariable
template <typename SREFAL_PARAM_INT>
struct ident_TkVariable {
  static const char *name() {
    return "TkVariable";
  }
};

// identifier #UnnamedADT
template <typename SREFAL_PARAM_INT>
struct ident_UnnamedADT {
  static const char *name() {
    return "UnnamedADT";
  }
};

extern refalrts::RefalFunction& Fetch;
extern refalrts::RefalFunction& Map;
extern refalrts::RefalFunction& Inc;
extern refalrts::RefalFunction& Seq;
extern refalrts::RefalFunction& Dec;
extern refalrts::RefalFunction& EL_AddUnexpected;
extern refalrts::RefalFunction& EL_AddErrorAt;
#ifdef INTERPRET
extern refalrts::RefalFunction& ParseProgram;
#else
extern refalrts::RefalFunction& ParseProgram;
#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& PrepareBracket;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& PrepareBracket;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseElements_S2L1;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseElements_S2L1;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseElements_S4L1;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseElements_S4L1;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseElements;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseElements;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& ASTItemFromDirective;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& ASTItemFromDirective;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseElement_SwDirective;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseElement_SwDirective;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseNameList;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseNameList;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& Wrap;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& Wrap;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseNameList_Tail;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseNameList_Tail;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseFunction_S1L1;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseFunction_S1L1;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseFunction;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseFunction;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseBlock_S1L1;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseBlock_S1L1;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseBlock;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseBlock;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& DoParseBlock;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& DoParseBlock;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseSentence_L1;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseSentence_L1;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseSentence_L2;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseSentence_L2;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseSentence_L3;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseSentence_L3;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseSentence;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseSentence;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParsePattern;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParsePattern;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& StrFromBracket;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& StrFromBracket;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseResult_S9L1;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseResult_S9L1;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseResult_S9L2;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseResult_S9L2;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseResult_S11L1;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& gen_ParseResult_S11L1;
} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseResult;
} // unnamed namespace

#else
namespace /* unnamed */ {
extern refalrts::RefalFunction& ParseResult;
} // unnamed namespace

#endif

#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseProgram {
    static refalrts::RefalFunction *functions[] = {
      & ParseElements,
      & PrepareBracket,
      & Map
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icIssueMemory, 13, 0, 0},
      // </0 & ParseProgram/4 t.ErrorList#1/5 e.Tokens#1/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::ictVarLeftSave, 0, 5, 2},
      // closed e.Tokens#1 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseElements/4 AsIs: t.ErrorList#1/5 } (/7 )/8 </9 & Map/10 & PrepareBracket/11 Tile{ AsIs: e.Tokens#1/2 } >/12 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 9},
      {refalrts::icAllocFunc, 0, 2, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 9},
      {refalrts::icLinkBrackets, 7, 8, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 12, 12, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 7, 11, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseProgram

} // unnamed namespace

refalrts::RASLFunction descr_ParseProgram(
  "ParseProgram",
  scope_ParseProgram::raa,
  scope_ParseProgram::functions,
  scope_ParseProgram::idents,
  scope_ParseProgram::numbers,
  scope_ParseProgram::strings
);
refalrts::RefalFunction& ParseProgram = descr_ParseProgram;

#else
static refalrts::FnResult func_ParseProgram(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  // </0 & ParseProgram/4 t.ErrorList#1/5 e.Tokens#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  // closed e.Tokens#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseElements/4 AsIs: t.ErrorList#1/5 } (/7 )/8 </9 & Map/10 & PrepareBracket/11 Tile{ AsIs: e.Tokens#1/2 } >/12 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], & Map ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & PrepareBracket ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & ParseElements );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[9] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[7], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

refalrts::RefalFunction descr_ParseProgram(func_ParseProgram, "ParseProgram");
refalrts::RefalFunction& ParseProgram = descr_ParseProgram;

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_PrepareBracket {
    using refalrts::functions;
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TkCloseCall<int>::name,
      & ident_Close<int>::name,
      & ident_TkOpenCall<int>::name,
      & ident_Open<int>::name,
      & ident_TkCloseADT<int>::name,
      & ident_TkOpenADT<int>::name,
      & ident_TkCloseBracket<int>::name,
      & ident_TkOpenBracket<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 6, 0, 0},
      {refalrts::icIssueMemory, 11, 0, 0},
      //FAST GEN: t.$
      //GLOBAL GEN: t.$
      // </0 & PrepareBracket/4 t.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::ictVarLeftSave, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +12, 0, 0},
      // ( # TkOpenBracket s.idx )
      // </0 & PrepareBracket/4 (/5 # TkOpenBracket/9 s.LnNum#1/10 )/6 >/1
      {refalrts::icBracketTerm, 0, 7, 5},
      {refalrts::icIdentLeftSave, 9, 7, 7},
      {refalrts::icsVarLeft, 0, 10, 7},
      {refalrts::icEmpty, 0, 0, 7},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & PrepareBracket/4 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: (/5 Reuse: # Open/9 AsIs: s.LnNum#1/10 HalfReuse: # TkOpenBracket/6 HalfReuse: )/1 ]] }
      {refalrts::icUpdateIdent, 0, 3, 9},
      {refalrts::icReinitIdent, 0, 7, 6},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 1},
      {refalrts::icLinkBrackets, 5, 1, 0},
      {refalrts::icSetRes, 0, 0, 5},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +12, 0, 0},
      // ( # TkCloseBracket s.idx )
      // </0 & PrepareBracket/4 (/5 # TkCloseBracket/9 s.LnNum#1/10 )/6 >/1
      {refalrts::icBracketTerm, 0, 7, 5},
      {refalrts::icIdentLeftSave, 9, 6, 7},
      {refalrts::icsVarLeft, 0, 10, 7},
      {refalrts::icEmpty, 0, 0, 7},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & PrepareBracket/4 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: (/5 Reuse: # Close/9 AsIs: s.LnNum#1/10 HalfReuse: # TkCloseBracket/6 HalfReuse: )/1 ]] }
      {refalrts::icUpdateIdent, 0, 1, 9},
      {refalrts::icReinitIdent, 0, 6, 6},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 1},
      {refalrts::icLinkBrackets, 5, 1, 0},
      {refalrts::icSetRes, 0, 0, 5},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +12, 0, 0},
      // ( # TkOpenADT s.idx )
      // </0 & PrepareBracket/4 (/5 # TkOpenADT/9 s.LnNum#1/10 )/6 >/1
      {refalrts::icBracketTerm, 0, 7, 5},
      {refalrts::icIdentLeftSave, 9, 5, 7},
      {refalrts::icsVarLeft, 0, 10, 7},
      {refalrts::icEmpty, 0, 0, 7},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & PrepareBracket/4 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: (/5 Reuse: # Open/9 AsIs: s.LnNum#1/10 HalfReuse: # TkOpenADT/6 HalfReuse: )/1 ]] }
      {refalrts::icUpdateIdent, 0, 3, 9},
      {refalrts::icReinitIdent, 0, 5, 6},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 1},
      {refalrts::icLinkBrackets, 5, 1, 0},
      {refalrts::icSetRes, 0, 0, 5},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +12, 0, 0},
      // ( # TkCloseADT s.idx )
      // </0 & PrepareBracket/4 (/5 # TkCloseADT/9 s.LnNum#1/10 )/6 >/1
      {refalrts::icBracketTerm, 0, 7, 5},
      {refalrts::icIdentLeftSave, 9, 4, 7},
      {refalrts::icsVarLeft, 0, 10, 7},
      {refalrts::icEmpty, 0, 0, 7},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & PrepareBracket/4 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: (/5 Reuse: # Close/9 AsIs: s.LnNum#1/10 HalfReuse: # TkCloseADT/6 HalfReuse: )/1 ]] }
      {refalrts::icUpdateIdent, 0, 1, 9},
      {refalrts::icReinitIdent, 0, 4, 6},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 1},
      {refalrts::icLinkBrackets, 5, 1, 0},
      {refalrts::icSetRes, 0, 0, 5},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +12, 0, 0},
      // ( # TkOpenCall s.idx )
      // </0 & PrepareBracket/4 (/5 # TkOpenCall/9 s.LnNum#1/10 )/6 >/1
      {refalrts::icBracketTerm, 0, 7, 5},
      {refalrts::icIdentLeftSave, 9, 2, 7},
      {refalrts::icsVarLeft, 0, 10, 7},
      {refalrts::icEmpty, 0, 0, 7},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & PrepareBracket/4 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: (/5 Reuse: # Open/9 AsIs: s.LnNum#1/10 HalfReuse: # TkOpenCall/6 HalfReuse: )/1 ]] }
      {refalrts::icUpdateIdent, 0, 3, 9},
      {refalrts::icReinitIdent, 0, 2, 6},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 1},
      {refalrts::icLinkBrackets, 5, 1, 0},
      {refalrts::icSetRes, 0, 0, 5},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +12, 0, 0},
      // ( # TkCloseCall s.idx )
      // </0 & PrepareBracket/4 (/5 # TkCloseCall/9 s.LnNum#1/10 )/6 >/1
      {refalrts::icBracketTerm, 0, 7, 5},
      {refalrts::icIdentLeftSave, 9, 0, 7},
      {refalrts::icsVarLeft, 0, 10, 7},
      {refalrts::icEmpty, 0, 0, 7},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & PrepareBracket/4 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: (/5 Reuse: # Close/9 AsIs: s.LnNum#1/10 HalfReuse: # TkCloseCall/6 HalfReuse: )/1 ]] }
      {refalrts::icUpdateIdent, 0, 1, 9},
      {refalrts::icReinitIdent, 0, 0, 6},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 1},
      {refalrts::icLinkBrackets, 5, 1, 0},
      {refalrts::icSetRes, 0, 0, 5},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // t.idx
      // </0 & PrepareBracket/4 t.OtherToken#1/5 >/1
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & PrepareBracket/4 {REMOVED TILE} >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: t.OtherToken#1/5 } Tile{ ]] }
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_PrepareBracket

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_PrepareBracket(
  "PrepareBracket",
  scope_PrepareBracket::raa,
  scope_PrepareBracket::functions,
  scope_PrepareBracket::idents,
  scope_PrepareBracket::numbers,
  scope_PrepareBracket::strings
);
refalrts::RefalFunction& PrepareBracket = descr_PrepareBracket;

} // unnamed namespace

#else
static refalrts::FnResult func_PrepareBracket(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  //FAST GEN: t.$
  //GLOBAL GEN: t.$
  // </0 & PrepareBracket/4 t.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    refalrts::start_sentence();
    // ( # TkOpenBracket s.idx )
    // </0 & PrepareBracket/4 (/5 # TkOpenBracket/9 s.LnNum#1/10 )/6 >/1
    context[7] = 0;
    context[8] = 0;
    if( ! refalrts::brackets_term( context[7], context[8], context[5] ) )
      continue;
    context[9] = refalrts::ident_left(  & ident_TkOpenBracket<int>::name, context[7], context[8] );
    if( ! context[9] )
      continue;
    if( ! refalrts::svar_left( context[10], context[7], context[8] ) )
      continue;
    if( ! refalrts::empty_seq( context[7], context[8] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & PrepareBracket/4 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/5 Reuse: # Open/9 AsIs: s.LnNum#1/10 HalfReuse: # TkOpenBracket/6 HalfReuse: )/1 ]] }
    refalrts::update_ident( context[9], & ident_Open<int>::name );
    refalrts::reinit_ident( context[6], & ident_TkOpenBracket<int>::name );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[5], context[1] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[5];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // ( # TkCloseBracket s.idx )
    // </0 & PrepareBracket/4 (/5 # TkCloseBracket/9 s.LnNum#1/10 )/6 >/1
    context[7] = 0;
    context[8] = 0;
    if( ! refalrts::brackets_term( context[7], context[8], context[5] ) )
      continue;
    context[9] = refalrts::ident_left(  & ident_TkCloseBracket<int>::name, context[7], context[8] );
    if( ! context[9] )
      continue;
    if( ! refalrts::svar_left( context[10], context[7], context[8] ) )
      continue;
    if( ! refalrts::empty_seq( context[7], context[8] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & PrepareBracket/4 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/5 Reuse: # Close/9 AsIs: s.LnNum#1/10 HalfReuse: # TkCloseBracket/6 HalfReuse: )/1 ]] }
    refalrts::update_ident( context[9], & ident_Close<int>::name );
    refalrts::reinit_ident( context[6], & ident_TkCloseBracket<int>::name );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[5], context[1] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[5];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // ( # TkOpenADT s.idx )
    // </0 & PrepareBracket/4 (/5 # TkOpenADT/9 s.LnNum#1/10 )/6 >/1
    context[7] = 0;
    context[8] = 0;
    if( ! refalrts::brackets_term( context[7], context[8], context[5] ) )
      continue;
    context[9] = refalrts::ident_left(  & ident_TkOpenADT<int>::name, context[7], context[8] );
    if( ! context[9] )
      continue;
    if( ! refalrts::svar_left( context[10], context[7], context[8] ) )
      continue;
    if( ! refalrts::empty_seq( context[7], context[8] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & PrepareBracket/4 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/5 Reuse: # Open/9 AsIs: s.LnNum#1/10 HalfReuse: # TkOpenADT/6 HalfReuse: )/1 ]] }
    refalrts::update_ident( context[9], & ident_Open<int>::name );
    refalrts::reinit_ident( context[6], & ident_TkOpenADT<int>::name );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[5], context[1] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[5];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // ( # TkCloseADT s.idx )
    // </0 & PrepareBracket/4 (/5 # TkCloseADT/9 s.LnNum#1/10 )/6 >/1
    context[7] = 0;
    context[8] = 0;
    if( ! refalrts::brackets_term( context[7], context[8], context[5] ) )
      continue;
    context[9] = refalrts::ident_left(  & ident_TkCloseADT<int>::name, context[7], context[8] );
    if( ! context[9] )
      continue;
    if( ! refalrts::svar_left( context[10], context[7], context[8] ) )
      continue;
    if( ! refalrts::empty_seq( context[7], context[8] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & PrepareBracket/4 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/5 Reuse: # Close/9 AsIs: s.LnNum#1/10 HalfReuse: # TkCloseADT/6 HalfReuse: )/1 ]] }
    refalrts::update_ident( context[9], & ident_Close<int>::name );
    refalrts::reinit_ident( context[6], & ident_TkCloseADT<int>::name );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[5], context[1] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[5];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // ( # TkOpenCall s.idx )
    // </0 & PrepareBracket/4 (/5 # TkOpenCall/9 s.LnNum#1/10 )/6 >/1
    context[7] = 0;
    context[8] = 0;
    if( ! refalrts::brackets_term( context[7], context[8], context[5] ) )
      continue;
    context[9] = refalrts::ident_left(  & ident_TkOpenCall<int>::name, context[7], context[8] );
    if( ! context[9] )
      continue;
    if( ! refalrts::svar_left( context[10], context[7], context[8] ) )
      continue;
    if( ! refalrts::empty_seq( context[7], context[8] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & PrepareBracket/4 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/5 Reuse: # Open/9 AsIs: s.LnNum#1/10 HalfReuse: # TkOpenCall/6 HalfReuse: )/1 ]] }
    refalrts::update_ident( context[9], & ident_Open<int>::name );
    refalrts::reinit_ident( context[6], & ident_TkOpenCall<int>::name );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[5], context[1] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[5];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // ( # TkCloseCall s.idx )
    // </0 & PrepareBracket/4 (/5 # TkCloseCall/9 s.LnNum#1/10 )/6 >/1
    context[7] = 0;
    context[8] = 0;
    if( ! refalrts::brackets_term( context[7], context[8], context[5] ) )
      continue;
    context[9] = refalrts::ident_left(  & ident_TkCloseCall<int>::name, context[7], context[8] );
    if( ! context[9] )
      continue;
    if( ! refalrts::svar_left( context[10], context[7], context[8] ) )
      continue;
    if( ! refalrts::empty_seq( context[7], context[8] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & PrepareBracket/4 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/5 Reuse: # Close/9 AsIs: s.LnNum#1/10 HalfReuse: # TkCloseCall/6 HalfReuse: )/1 ]] }
    refalrts::update_ident( context[9], & ident_Close<int>::name );
    refalrts::reinit_ident( context[6], & ident_TkCloseCall<int>::name );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[5], context[1] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[5];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  // t.idx
  // </0 & PrepareBracket/4 t.OtherToken#1/5 >/1

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & PrepareBracket/4 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: t.OtherToken#1/5 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_PrepareBracket(func_PrepareBracket, "PrepareBracket");
refalrts::RefalFunction& PrepareBracket = descr_PrepareBracket;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseElements_S2L1 {
    static refalrts::RefalFunction *functions[] = {
      & ParseElements
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icIssueMemory, 15, 0, 0},
      // </0 & ParseElements$2\1/4 (/7 e.AST#1/5 )/8 (/11 e.NewASTItems#2/9 )/12 t.ErrorList#2/13 e.Tail#2/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icBracketLeftSave, 0, 5, 2},
      {refalrts::icBracketLeftSave, 0, 9, 2},
      // closed e.AST#1 as range 5
      // closed e.NewASTItems#2 as range 9
      {refalrts::ictVarLeftSave, 0, 13, 2},
      // closed e.Tail#2 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseElements/4 } Tile{ AsIs: t.ErrorList#2/13 } Tile{ AsIs: (/11 } Tile{ AsIs: e.AST#1/5 } Tile{ AsIs: e.NewASTItems#2/9 } Tile{ AsIs: )/12 } Tile{ AsIs: e.Tail#2/2 } Tile{ AsIs: >/1 ]] }
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 11, 12, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 12, 12, 0},
      {refalrts::icSpliceEVar, 0, 0, 9},
      {refalrts::icSpliceEVar, 0, 0, 5},
      {refalrts::icSpliceTile, 11, 11, 0},
      {refalrts::icSpliceTile, 13, 14, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseElements_S2L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseElements_S2L1(
  "ParseElements$2\\1",
  scope_gen_ParseElements_S2L1::raa,
  scope_gen_ParseElements_S2L1::functions,
  scope_gen_ParseElements_S2L1::idents,
  scope_gen_ParseElements_S2L1::numbers,
  scope_gen_ParseElements_S2L1::strings
);
refalrts::RefalFunction& gen_ParseElements_S2L1 = descr_gen_ParseElements_S2L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseElements_S2L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & ParseElements$2\1/4 (/7 e.AST#1/5 )/8 (/11 e.NewASTItems#2/9 )/12 t.ErrorList#2/13 e.Tail#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.AST#1 as range 5
  // closed e.NewASTItems#2 as range 9
  context[14] = refalrts::tvar_left( context[13], context[2], context[3] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  // closed e.Tail#2 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseElements/4 } Tile{ AsIs: t.ErrorList#2/13 } Tile{ AsIs: (/11 } Tile{ AsIs: e.AST#1/5 } Tile{ AsIs: e.NewASTItems#2/9 } Tile{ AsIs: )/12 } Tile{ AsIs: e.Tail#2/2 } Tile{ AsIs: >/1 ]] }
  refalrts::update_name( context[4], & ParseElements );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[13], context[14] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_gen_ParseElements_S2L1(func_gen_ParseElements_S2L1, "ParseElements$2\\1");
refalrts::RefalFunction& gen_ParseElements_S2L1 = descr_gen_ParseElements_S2L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseElements_S4L1 {
    static refalrts::RefalFunction *functions[] = {
      & ParseElements
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icIssueMemory, 15, 0, 0},
      // </0 & ParseElements$4\1/4 (/7 e.AST#1/5 )/8 (/11 e.NewASTItems#2/9 )/12 t.ErrorList#2/13 e.Tail#2/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icBracketLeftSave, 0, 5, 2},
      {refalrts::icBracketLeftSave, 0, 9, 2},
      // closed e.AST#1 as range 5
      // closed e.NewASTItems#2 as range 9
      {refalrts::ictVarLeftSave, 0, 13, 2},
      // closed e.Tail#2 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseElements/4 } Tile{ AsIs: t.ErrorList#2/13 } Tile{ AsIs: (/11 } Tile{ AsIs: e.AST#1/5 } Tile{ AsIs: e.NewASTItems#2/9 } Tile{ AsIs: )/12 } Tile{ AsIs: e.Tail#2/2 } Tile{ AsIs: >/1 ]] }
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 11, 12, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 12, 12, 0},
      {refalrts::icSpliceEVar, 0, 0, 9},
      {refalrts::icSpliceEVar, 0, 0, 5},
      {refalrts::icSpliceTile, 11, 11, 0},
      {refalrts::icSpliceTile, 13, 14, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseElements_S4L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseElements_S4L1(
  "ParseElements$4\\1",
  scope_gen_ParseElements_S4L1::raa,
  scope_gen_ParseElements_S4L1::functions,
  scope_gen_ParseElements_S4L1::idents,
  scope_gen_ParseElements_S4L1::numbers,
  scope_gen_ParseElements_S4L1::strings
);
refalrts::RefalFunction& gen_ParseElements_S4L1 = descr_gen_ParseElements_S4L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseElements_S4L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & ParseElements$4\1/4 (/7 e.AST#1/5 )/8 (/11 e.NewASTItems#2/9 )/12 t.ErrorList#2/13 e.Tail#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.AST#1 as range 5
  // closed e.NewASTItems#2 as range 9
  context[14] = refalrts::tvar_left( context[13], context[2], context[3] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  // closed e.Tail#2 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseElements/4 } Tile{ AsIs: t.ErrorList#2/13 } Tile{ AsIs: (/11 } Tile{ AsIs: e.AST#1/5 } Tile{ AsIs: e.NewASTItems#2/9 } Tile{ AsIs: )/12 } Tile{ AsIs: e.Tail#2/2 } Tile{ AsIs: >/1 ]] }
  refalrts::update_name( context[4], & ParseElements );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[13], context[14] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_gen_ParseElements_S4L1(func_gen_ParseElements_S4L1, "ParseElements$4\\1");
refalrts::RefalFunction& gen_ParseElements_S4L1 = descr_gen_ParseElements_S4L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseElements {
    static refalrts::RefalFunction *functions[] = {
      & EL_AddUnexpected,
      & Fetch,
      & gen_ParseElements_S4L1,
      & refalrts::create_closure,
      & ParseFunction,
      & gen_ParseElements_S2L1,
      & ParseElement_SwDirective
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TkSemicolon<int>::name,
      & ident_GN_Local<int>::name,
      & ident_TkName<int>::name,
      & ident_NativeBlock<int>::name,
      & ident_TkNativeBlock<int>::name,
      & ident_TkDirective<int>::name,
      & ident_TkEOF<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"directive or name", 17}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 5, 0, 0},
      {refalrts::icIssueMemory, 26, 0, 0},
      //FAST GEN: e.$
      //GLOBAL GEN: t.$ ( e.$ ) t.$ e.$
      // </0 & ParseElements/4 t.idx#0/5 (/9 e.idxVB#0/7 )/10 t.idxVT#0/11 e.idxVTV#0/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::ictVarLeftSave, 0, 5, 2},
      {refalrts::icBracketLeftSave, 0, 7, 2},
      // closed e.idxVB#0 as range 7
      {refalrts::ictVarLeftSave, 0, 11, 2},
      // closed e.idxVTV#0 as range 2
      {refalrts::icOnFailGoTo, +12, 0, 0},
      // t.idx ( e.idx ) ( # TkEOF s.idx )
      // </0 & ParseElements/4 t.ErrorList#1/5 (/9 e.AST#1/7 )/10 (/11 # TkEOF/15 s.LnNum#1/16 )/12 >/1
      {refalrts::icBracketTerm, 0, 13, 11},
      {refalrts::icIdentLeftSave, 15, 6, 13},
      {refalrts::icSave, 0, 24, 2},
      {refalrts::icEmpty, 0, 0, 24},
      // closed e.AST#1 as range 7
      {refalrts::icsVarLeft, 0, 16, 13},
      {refalrts::icEmpty, 0, 0, 13},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseElements/4 {REMOVED TILE} (/9 {REMOVED TILE} )/10 (/11 # TkEOF/15 s.LnNum#1/16 )/12 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: e.AST#1/7 } Tile{ ]] }
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 7},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +30, 0, 0},
      // t.idx ( e.idx ) ( # TkDirective s.idx s.idx ) e.idx
      // </0 & ParseElements/4 t.ErrorList#1/5 (/9 e.AST#1/7 )/10 (/11 # TkDirective/15 s.LnNum#1/16 s.Directive#1/17 )/12 e.Tail#1/2 >/1
      {refalrts::icBracketTerm, 0, 13, 11},
      {refalrts::icIdentLeftSave, 15, 5, 13},
      // closed e.AST#1 as range 7
      // closed e.Tail#1 as range 2
      {refalrts::icsVarLeft, 0, 16, 13},
      {refalrts::icsVarLeft, 0, 17, 13},
      {refalrts::icEmpty, 0, 0, 13},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNum#1/16 s.Directive#1/17 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 } </18 & ParseElement-SwDirective/19 Tile{ AsIs: t.ErrorList#1/5 } Tile{ HalfReuse: s.Directive1 #17/12 AsIs: e.Tail#1/2 AsIs: >/1 } </20 & @create_closure@/21 & ParseElements$2\1/22 Tile{ AsIs: (/9 AsIs: e.AST#1/7 AsIs: )/10 HalfReuse: >/11 HalfReuse: >/15 } Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 18},
      {refalrts::icAllocFunc, 0, 6, 19},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 20},
      {refalrts::icAllocFunc, 0, 3, 21},
      {refalrts::icAllocFunc, 0, 5, 22},
      {refalrts::icUpdateFunc, 0, 1, 4},
      {refalrts::icReinitSVar, 0, 17, 12},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 11},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 15},
      {refalrts::icPushStack, 0, 0, 15},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 11},
      {refalrts::icPushStack, 0, 0, 20},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 18},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 9, 15, 0},
      {refalrts::icSpliceTile, 20, 22, 0},
      {refalrts::icSpliceTile, 12, 1, 0},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icSpliceTile, 18, 19, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +16, 0, 0},
      // t.idx ( e.idx ) ( # TkNativeBlock t.idx e.idx ) e.idx
      // </0 & ParseElements/4 t.ErrorList#1/5 (/9 e.AST#1/7 )/10 (/11 # TkNativeBlock/15 t.SrcPos#1/16 e.Block#1/13 )/12 e.Tail#1/2 >/1
      {refalrts::icBracketTerm, 0, 13, 11},
      {refalrts::icIdentLeftSave, 15, 4, 13},
      // closed e.AST#1 as range 7
      // closed e.Tail#1 as range 2
      {refalrts::ictVarLeftSave, 0, 16, 13},
      // closed e.Block#1 as range 13
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseElements/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.AST#1/7 HalfReuse: (/10 HalfReuse: # NativeBlock/11 } Tile{ AsIs: t.SrcPos#1/16 } Tile{ AsIs: e.Block#1/13 } Tile{ HalfReuse: )/15 } Tile{ AsIs: )/12 AsIs: e.Tail#1/2 AsIs: >/1 ]] }
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 10},
      {refalrts::icReinitIdent, 0, 3, 11},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 15},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 9, 12, 0},
      {refalrts::icLinkBrackets, 10, 15, 0},
      {refalrts::icSetRes, 0, 0, 12},
      {refalrts::icSpliceTile, 15, 15, 0},
      {refalrts::icSpliceEVar, 0, 0, 13},
      {refalrts::icSpliceTile, 16, 17, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +33, 0, 0},
      // t.idx ( e.idx ) ( # TkName s.idx e.idx ) e.idx
      // </0 & ParseElements/4 t.ErrorList#1/5 (/9 e.AST#1/7 )/10 (/11 # TkName/15 s.LnNum#1/16 e.Name#1/13 )/12 e.Tail#1/2 >/1
      {refalrts::icBracketTerm, 0, 13, 11},
      {refalrts::icIdentLeftSave, 15, 2, 13},
      // closed e.AST#1 as range 7
      // closed e.Tail#1 as range 2
      {refalrts::icsVarLeft, 0, 16, 13},
      // closed e.Name#1 as range 13
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNum#1/16 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 } </17 & ParseFunction/18 # GN-Local/19 (/20 Tile{ AsIs: e.Name#1/13 } Tile{ AsIs: )/12 } Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: e.Tail#1/2 } Tile{ AsIs: >/1 } </21 & @create_closure@/22 & ParseElements$4\1/23 Tile{ AsIs: (/9 AsIs: e.AST#1/7 AsIs: )/10 HalfReuse: >/11 HalfReuse: >/15 } Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 17},
      {refalrts::icAllocFunc, 0, 4, 18},
      {refalrts::icAllocIdent, 0, 1, 19},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 20},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 21},
      {refalrts::icAllocFunc, 0, 3, 22},
      {refalrts::icAllocFunc, 0, 2, 23},
      {refalrts::icUpdateFunc, 0, 1, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 11},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 15},
      {refalrts::icPushStack, 0, 0, 15},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 11},
      {refalrts::icPushStack, 0, 0, 21},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 17},
      {refalrts::icLinkBrackets, 20, 12, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 9, 15, 0},
      {refalrts::icSpliceTile, 21, 23, 0},
      {refalrts::icSpliceTile, 1, 1, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icSpliceTile, 12, 12, 0},
      {refalrts::icSpliceEVar, 0, 0, 13},
      {refalrts::icSpliceTile, 17, 20, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +12, 0, 0},
      // t.idx ( e.idx ) ( # TkSemicolon s.idx ) e.idx
      // </0 & ParseElements/4 t.ErrorList#1/5 (/9 e.AST#1/7 )/10 (/11 # TkSemicolon/15 s.LnNum#1/16 )/12 e.Tail#1/2 >/1
      {refalrts::icBracketTerm, 0, 13, 11},
      {refalrts::icIdentLeftSave, 15, 0, 13},
      // closed e.AST#1 as range 7
      // closed e.Tail#1 as range 2
      {refalrts::icsVarLeft, 0, 16, 13},
      {refalrts::icEmpty, 0, 0, 13},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} (/11 # TkSemicolon/15 s.LnNum#1/16 )/12 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseElements/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.AST#1/7 AsIs: )/10 } Tile{ AsIs: e.Tail#1/2 } Tile{ AsIs: >/1 ]] }
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icTrash, 0, 0, 10},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // t.idx ( e.idx ) t.idx e.idx
      // </0 & ParseElements/4 t.ErrorList#1/5 (/9 e.AST#1/7 )/10 t.Unexpected#1/11 e.Tail#1/2 >/1
      // closed e.AST#1 as range 7
      // closed e.Tail#1 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseElements/4 } </13 & EL-AddUnexpected/14 Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: t.Unexpected#1/11 }"directive or name"/15 >/17 Tile{ AsIs: (/9 AsIs: e.AST#1/7 AsIs: )/10 } Tile{ AsIs: e.Tail#1/2 } Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 13},
      {refalrts::icAllocFunc, 0, 0, 14},
      {refalrts::icAllocString, 0, 0, 15},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 17},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icPushStack, 0, 0, 17},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 9, 10, 0},
      {refalrts::icSpliceTile, 15, 17, 0},
      {refalrts::icSpliceTile, 11, 12, 0},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icSpliceTile, 13, 14, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseElements

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseElements(
  "ParseElements",
  scope_ParseElements::raa,
  scope_ParseElements::functions,
  scope_ParseElements::idents,
  scope_ParseElements::numbers,
  scope_ParseElements::strings
);
refalrts::RefalFunction& ParseElements = descr_ParseElements;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseElements(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 26 elems
  refalrts::Iter context[26];
  refalrts::zeros( context, 26 );
  //FAST GEN: e.$
  //GLOBAL GEN: t.$ ( e.$ ) t.$ e.$
  // </0 & ParseElements/4 t.idx#0/5 (/9 e.idxVB#0/7 )/10 t.idxVT#0/11 e.idxVTV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  context[7] = 0;
  context[8] = 0;
  context[9] = refalrts::brackets_left( context[7], context[8], context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[9], context[10]);
  // closed e.idxVB#0 as range 7
  context[12] = refalrts::tvar_left( context[11], context[2], context[3] );
  if( ! context[12] )
    return refalrts::cRecognitionImpossible;
  // closed e.idxVTV#0 as range 2
  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( # TkEOF s.idx )
    // </0 & ParseElements/4 t.ErrorList#1/5 (/9 e.AST#1/7 )/10 (/11 # TkEOF/15 s.LnNum#1/16 )/12 >/1
    context[13] = 0;
    context[14] = 0;
    if( ! refalrts::brackets_term( context[13], context[14], context[11] ) )
      continue;
    context[15] = refalrts::ident_left(  & ident_TkEOF<int>::name, context[13], context[14] );
    if( ! context[15] )
      continue;
    context[24] = context[2];
    context[25] = context[3];
    if( ! refalrts::empty_seq( context[24], context[25] ) )
      continue;
    // closed e.AST#1 as range 7
    if( ! refalrts::svar_left( context[16], context[13], context[14] ) )
      continue;
    if( ! refalrts::empty_seq( context[13], context[14] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & ParseElements/4 {REMOVED TILE} (/9 {REMOVED TILE} )/10 (/11 # TkEOF/15 s.LnNum#1/16 )/12 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: e.AST#1/7 } Tile{ ]] }
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[7], context[8] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( # TkDirective s.idx s.idx ) e.idx
    // </0 & ParseElements/4 t.ErrorList#1/5 (/9 e.AST#1/7 )/10 (/11 # TkDirective/15 s.LnNum#1/16 s.Directive#1/17 )/12 e.Tail#1/2 >/1
    context[13] = 0;
    context[14] = 0;
    if( ! refalrts::brackets_term( context[13], context[14], context[11] ) )
      continue;
    context[15] = refalrts::ident_left(  & ident_TkDirective<int>::name, context[13], context[14] );
    if( ! context[15] )
      continue;
    // closed e.AST#1 as range 7
    // closed e.Tail#1 as range 2
    if( ! refalrts::svar_left( context[16], context[13], context[14] ) )
      continue;
    if( ! refalrts::svar_left( context[17], context[13], context[14] ) )
      continue;
    if( ! refalrts::empty_seq( context[13], context[14] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNum#1/16 s.Directive#1/17 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 } </18 & ParseElement-SwDirective/19 Tile{ AsIs: t.ErrorList#1/5 } Tile{ HalfReuse: s.Directive1 #17/12 AsIs: e.Tail#1/2 AsIs: >/1 } </20 & @create_closure@/21 & ParseElements$2\1/22 Tile{ AsIs: (/9 AsIs: e.AST#1/7 AsIs: )/10 HalfReuse: >/11 HalfReuse: >/15 } Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[19], & ParseElement_SwDirective ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[21], & refalrts::create_closure ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], & gen_ParseElements_S2L1 ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & Fetch );
    refalrts::reinit_svar( context[12], context[17] );
    refalrts::reinit_close_call( context[11] );
    refalrts::reinit_close_call( context[15] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[20] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[18] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[9], context[15] );
    res = refalrts::splice_evar( res, context[20], context[22] );
    res = refalrts::splice_evar( res, context[12], context[1] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( # TkNativeBlock t.idx e.idx ) e.idx
    // </0 & ParseElements/4 t.ErrorList#1/5 (/9 e.AST#1/7 )/10 (/11 # TkNativeBlock/15 t.SrcPos#1/16 e.Block#1/13 )/12 e.Tail#1/2 >/1
    context[13] = 0;
    context[14] = 0;
    if( ! refalrts::brackets_term( context[13], context[14], context[11] ) )
      continue;
    context[15] = refalrts::ident_left(  & ident_TkNativeBlock<int>::name, context[13], context[14] );
    if( ! context[15] )
      continue;
    // closed e.AST#1 as range 7
    // closed e.Tail#1 as range 2
    context[17] = refalrts::tvar_left( context[16], context[13], context[14] );
    if( ! context[17] )
      continue;
    // closed e.Block#1 as range 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseElements/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.AST#1/7 HalfReuse: (/10 HalfReuse: # NativeBlock/11 } Tile{ AsIs: t.SrcPos#1/16 } Tile{ AsIs: e.Block#1/13 } Tile{ HalfReuse: )/15 } Tile{ AsIs: )/12 AsIs: e.Tail#1/2 AsIs: >/1 ]] }
    refalrts::reinit_open_bracket( context[10] );
    refalrts::reinit_ident( context[11], & ident_NativeBlock<int>::name );
    refalrts::reinit_close_bracket( context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[9], context[12] );
    refalrts::link_brackets( context[10], context[15] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[13], context[14] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( # TkName s.idx e.idx ) e.idx
    // </0 & ParseElements/4 t.ErrorList#1/5 (/9 e.AST#1/7 )/10 (/11 # TkName/15 s.LnNum#1/16 e.Name#1/13 )/12 e.Tail#1/2 >/1
    context[13] = 0;
    context[14] = 0;
    if( ! refalrts::brackets_term( context[13], context[14], context[11] ) )
      continue;
    context[15] = refalrts::ident_left(  & ident_TkName<int>::name, context[13], context[14] );
    if( ! context[15] )
      continue;
    // closed e.AST#1 as range 7
    // closed e.Tail#1 as range 2
    if( ! refalrts::svar_left( context[16], context[13], context[14] ) )
      continue;
    // closed e.Name#1 as range 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNum#1/16 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 } </17 & ParseFunction/18 # GN-Local/19 (/20 Tile{ AsIs: e.Name#1/13 } Tile{ AsIs: )/12 } Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: e.Tail#1/2 } Tile{ AsIs: >/1 } </21 & @create_closure@/22 & ParseElements$4\1/23 Tile{ AsIs: (/9 AsIs: e.AST#1/7 AsIs: )/10 HalfReuse: >/11 HalfReuse: >/15 } Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[18], & ParseFunction ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[19], & ident_GN_Local<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], & refalrts::create_closure ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[23], & gen_ParseElements_S4L1 ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & Fetch );
    refalrts::reinit_close_call( context[11] );
    refalrts::reinit_close_call( context[15] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[21] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[17] );
    refalrts::link_brackets( context[20], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[9], context[15] );
    res = refalrts::splice_evar( res, context[21], context[23] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[13], context[14] );
    res = refalrts::splice_evar( res, context[17], context[20] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( # TkSemicolon s.idx ) e.idx
    // </0 & ParseElements/4 t.ErrorList#1/5 (/9 e.AST#1/7 )/10 (/11 # TkSemicolon/15 s.LnNum#1/16 )/12 e.Tail#1/2 >/1
    context[13] = 0;
    context[14] = 0;
    if( ! refalrts::brackets_term( context[13], context[14], context[11] ) )
      continue;
    context[15] = refalrts::ident_left(  & ident_TkSemicolon<int>::name, context[13], context[14] );
    if( ! context[15] )
      continue;
    // closed e.AST#1 as range 7
    // closed e.Tail#1 as range 2
    if( ! refalrts::svar_left( context[16], context[13], context[14] ) )
      continue;
    if( ! refalrts::empty_seq( context[13], context[14] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} (/11 # TkSemicolon/15 s.LnNum#1/16 )/12 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseElements/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.AST#1/7 AsIs: )/10 } Tile{ AsIs: e.Tail#1/2 } Tile{ AsIs: >/1 ]] }
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[2], context[3] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[10], res );
    return refalrts::cSuccess;
  } while ( 0 );

  // t.idx ( e.idx ) t.idx e.idx
  // </0 & ParseElements/4 t.ErrorList#1/5 (/9 e.AST#1/7 )/10 t.Unexpected#1/11 e.Tail#1/2 >/1
  // closed e.AST#1 as range 7
  // closed e.Tail#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseElements/4 } </13 & EL-AddUnexpected/14 Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: t.Unexpected#1/11 }"directive or name"/15 >/17 Tile{ AsIs: (/9 AsIs: e.AST#1/7 AsIs: )/10 } Tile{ AsIs: e.Tail#1/2 } Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], & EL_AddUnexpected ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[15], context[16], "directive or name", 17 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[17] ) )
    return refalrts::cNoMemory;
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[9], context[10] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[13] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[15], context[17] );
  res = refalrts::splice_evar( res, context[11], context[12] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[13], context[14] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_ParseElements(func_ParseElements, "ParseElements");
refalrts::RefalFunction& ParseElements = descr_ParseElements;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ASTItemFromDirective {
    using refalrts::functions;
    static const refalrts::RefalIdentifier idents[] = {
      & ident_GN_Entry<int>::name,
      & ident_Ident<int>::name,
      & ident_GN_Local<int>::name,
      & ident_Declaration<int>::name,
      & ident_Forward<int>::name,
      & ident_Extern<int>::name,
      & ident_Swap<int>::name,
      & ident_ESwap<int>::name,
      & ident_Enum<int>::name,
      & ident_EEnum<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 6, 0, 0},
      {refalrts::icIssueMemory, 6, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ASTItemFromDirective/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +7, 0, 0},
      // # EEnum
      // </0 & ASTItemFromDirective/4 # EEnum/5 >/1
      {refalrts::icIdentTerm, 0, 9, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ASTItemFromDirective/4 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ Reuse: # Enum/5 HalfReuse: # GN-Entry/1 ]] }
      {refalrts::icUpdateIdent, 0, 8, 5},
      {refalrts::icReinitIdent, 0, 0, 1},
      {refalrts::icSetRes, 0, 0, 5},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +6, 0, 0},
      // # Enum
      // </0 & ASTItemFromDirective/4 # Enum/5 >/1
      {refalrts::icIdentTerm, 0, 8, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ASTItemFromDirective/4 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: # Enum/5 HalfReuse: # GN-Local/1 ]] }
      {refalrts::icReinitIdent, 0, 2, 1},
      {refalrts::icSetRes, 0, 0, 5},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +7, 0, 0},
      // # ESwap
      // </0 & ASTItemFromDirective/4 # ESwap/5 >/1
      {refalrts::icIdentTerm, 0, 7, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ASTItemFromDirective/4 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ Reuse: # Swap/5 HalfReuse: # GN-Entry/1 ]] }
      {refalrts::icUpdateIdent, 0, 6, 5},
      {refalrts::icReinitIdent, 0, 0, 1},
      {refalrts::icSetRes, 0, 0, 5},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +6, 0, 0},
      // # Swap
      // </0 & ASTItemFromDirective/4 # Swap/5 >/1
      {refalrts::icIdentTerm, 0, 6, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ASTItemFromDirective/4 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: # Swap/5 HalfReuse: # GN-Local/1 ]] }
      {refalrts::icReinitIdent, 0, 2, 1},
      {refalrts::icSetRes, 0, 0, 5},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +7, 0, 0},
      // # Extern
      // </0 & ASTItemFromDirective/4 # Extern/5 >/1
      {refalrts::icIdentTerm, 0, 5, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ASTItemFromDirective/4 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ Reuse: # Declaration/5 HalfReuse: # GN-Entry/1 ]] }
      {refalrts::icUpdateIdent, 0, 3, 5},
      {refalrts::icReinitIdent, 0, 0, 1},
      {refalrts::icSetRes, 0, 0, 5},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +7, 0, 0},
      // # Forward
      // </0 & ASTItemFromDirective/4 # Forward/5 >/1
      {refalrts::icIdentTerm, 0, 4, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ASTItemFromDirective/4 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ Reuse: # Declaration/5 HalfReuse: # GN-Local/1 ]] }
      {refalrts::icUpdateIdent, 0, 3, 5},
      {refalrts::icReinitIdent, 0, 2, 1},
      {refalrts::icSetRes, 0, 0, 5},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // # Ident
      // </0 & ASTItemFromDirective/4 # Ident/5 >/1
      {refalrts::icIdentTerm, 0, 1, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ASTItemFromDirective/4 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: # Ident/5 HalfReuse: # GN-Entry/1 ]] }
      {refalrts::icReinitIdent, 0, 0, 1},
      {refalrts::icSetRes, 0, 0, 5},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ASTItemFromDirective

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ASTItemFromDirective(
  "ASTItemFromDirective",
  scope_ASTItemFromDirective::raa,
  scope_ASTItemFromDirective::functions,
  scope_ASTItemFromDirective::idents,
  scope_ASTItemFromDirective::numbers,
  scope_ASTItemFromDirective::strings
);
refalrts::RefalFunction& ASTItemFromDirective = descr_ASTItemFromDirective;

} // unnamed namespace

#else
static refalrts::FnResult func_ASTItemFromDirective(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ASTItemFromDirective/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    refalrts::start_sentence();
    // # EEnum
    // </0 & ASTItemFromDirective/4 # EEnum/5 >/1
    if( ! refalrts::ident_term(  & ident_EEnum<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & ASTItemFromDirective/4 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ Reuse: # Enum/5 HalfReuse: # GN-Entry/1 ]] }
    refalrts::update_ident( context[5], & ident_Enum<int>::name );
    refalrts::reinit_ident( context[1], & ident_GN_Entry<int>::name );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[5];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // # Enum
    // </0 & ASTItemFromDirective/4 # Enum/5 >/1
    if( ! refalrts::ident_term(  & ident_Enum<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & ASTItemFromDirective/4 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: # Enum/5 HalfReuse: # GN-Local/1 ]] }
    refalrts::reinit_ident( context[1], & ident_GN_Local<int>::name );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[5];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // # ESwap
    // </0 & ASTItemFromDirective/4 # ESwap/5 >/1
    if( ! refalrts::ident_term(  & ident_ESwap<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & ASTItemFromDirective/4 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ Reuse: # Swap/5 HalfReuse: # GN-Entry/1 ]] }
    refalrts::update_ident( context[5], & ident_Swap<int>::name );
    refalrts::reinit_ident( context[1], & ident_GN_Entry<int>::name );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[5];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // # Swap
    // </0 & ASTItemFromDirective/4 # Swap/5 >/1
    if( ! refalrts::ident_term(  & ident_Swap<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & ASTItemFromDirective/4 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: # Swap/5 HalfReuse: # GN-Local/1 ]] }
    refalrts::reinit_ident( context[1], & ident_GN_Local<int>::name );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[5];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // # Extern
    // </0 & ASTItemFromDirective/4 # Extern/5 >/1
    if( ! refalrts::ident_term(  & ident_Extern<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & ASTItemFromDirective/4 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ Reuse: # Declaration/5 HalfReuse: # GN-Entry/1 ]] }
    refalrts::update_ident( context[5], & ident_Declaration<int>::name );
    refalrts::reinit_ident( context[1], & ident_GN_Entry<int>::name );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[5];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // # Forward
    // </0 & ASTItemFromDirective/4 # Forward/5 >/1
    if( ! refalrts::ident_term(  & ident_Forward<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & ASTItemFromDirective/4 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ Reuse: # Declaration/5 HalfReuse: # GN-Local/1 ]] }
    refalrts::update_ident( context[5], & ident_Declaration<int>::name );
    refalrts::reinit_ident( context[1], & ident_GN_Local<int>::name );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[5];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  // # Ident
  // </0 & ASTItemFromDirective/4 # Ident/5 >/1
  if( ! refalrts::ident_term(  & ident_Ident<int>::name, context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ASTItemFromDirective/4 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: # Ident/5 HalfReuse: # GN-Entry/1 ]] }
  refalrts::reinit_ident( context[1], & ident_GN_Entry<int>::name );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[5];
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_ASTItemFromDirective(func_ASTItemFromDirective, "ASTItemFromDirective");
refalrts::RefalFunction& ASTItemFromDirective = descr_ASTItemFromDirective;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseElement_SwDirective {
    static refalrts::RefalFunction *functions[] = {
      & ParseNameList,
      & ASTItemFromDirective,
      & EL_AddUnexpected,
      & ParseFunction
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_Entry<int>::name,
      & ident_GN_Entry<int>::name,
      & ident_TkName<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"nction name", 11}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 2, 0, 0},
      {refalrts::icIssueMemory, 19, 0, 0},
      //FAST GEN: e.$
      //GLOBAL GEN: t.$ s.$ e.$
      // </0 & ParseElement-SwDirective/4 t.idx#0/5 s.idxV#0/7 e.idxVV#0/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::ictVarLeftSave, 0, 5, 2},
      {refalrts::icsVarLeft, 0, 7, 2},
      // closed e.idxVV#0 as range 2
      {refalrts::icOnFailGoTo, +19, 0, 0},
      // t.idx # Entry ( # TkName s.idx e.idx ) e.idx
      // </0 & ParseElement-SwDirective/4 t.ErrorList#1/5 # Entry/7 (/10 # TkName/12 s.LnNum#1/13 e.Name#1/8 )/11 e.Tail#1/2 >/1
      {refalrts::icIdentTerm, 0, 0, 7},
      {refalrts::icSave, 0, 17, 2},
      {refalrts::icBracketLeftSave, 0, 8, 17},
      {refalrts::icIdentLeftSave, 12, 2, 8},
      // closed e.Tail#1 as range 17(2)
      {refalrts::icsVarLeft, 0, 13, 8},
      // closed e.Name#1 as range 8
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} # TkName/12 s.LnNum#1/13 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseFunction/4 } Tile{ Reuse: # GN-Entry/7 AsIs: (/10 } Tile{ AsIs: e.Name#1/8 } Tile{ AsIs: )/11 } Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: e.Tail#1/17(2) } Tile{ AsIs: >/1 ]] }
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icUpdateIdent, 0, 1, 7},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 10, 11, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 17},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icSpliceTile, 11, 11, 0},
      {refalrts::icSpliceEVar, 0, 0, 8},
      {refalrts::icSpliceTile, 7, 10, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +24, 0, 0},
      // t.idx # Entry t.idx e.idx
      // </0 & ParseElement-SwDirective/4 t.ErrorList#1/5 # Entry/7 t.Unexpected#1/8 e.Tail#1/2 >/1
      {refalrts::icIdentTerm, 0, 0, 7},
      {refalrts::icSave, 0, 17, 2},
      {refalrts::ictVarLeftSave, 0, 8, 17},
      // closed e.Tail#1 as range 17(2)
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } (/10 )/11 Tile{ AsIs: </0 Reuse: & EL-AddUnexpected/4 AsIs: t.ErrorList#1/5 } t.Unexpected#1/8/12 'f'/14 Tile{ HalfReuse: 'u'/1 }"nction name"/15 Tile{ HalfReuse: >/7 AsIs: t.Unexpected#1/8 } Tile{ AsIs: e.Tail#1/17(2) } Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 10},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 11},
      {refalrts::icCopyEVar, 12, 8, 0},
      {refalrts::icAllocChar, 0, 'f', 14},
      {refalrts::icAllocString, 0, 0, 15},
      {refalrts::icUpdateFunc, 0, 2, 4},
      {refalrts::icReinitChar, 0, 'u', 1},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 7},
      {refalrts::icPushStack, 0, 0, 7},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 10, 11, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 17},
      {refalrts::icSpliceTile, 7, 9, 0},
      {refalrts::icSpliceTile, 15, 16, 0},
      {refalrts::icSpliceTile, 1, 1, 0},
      {refalrts::icSpliceTile, 12, 14, 0},
      {refalrts::icSpliceTile, 0, 6, 0},
      {refalrts::icSpliceTile, 10, 11, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // t.idx s.idx e.idx
      // </0 & ParseElement-SwDirective/4 t.ErrorList#1/5 s.Directive#1/7 e.Tail#1/2 >/1
      // closed e.Tail#1 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseNameList/4 } (/8 )/9 Tile{ AsIs: t.ErrorList#1/5 } </10 & ASTItemFromDirective/11 Tile{ AsIs: s.Directive#1/7 } >/12 Tile{ AsIs: e.Tail#1/2 } Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 8},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 9},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 10},
      {refalrts::icAllocFunc, 0, 1, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 12},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icLinkBrackets, 8, 9, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 12, 12, 0},
      {refalrts::icSpliceTile, 7, 7, 0},
      {refalrts::icSpliceTile, 10, 11, 0},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icSpliceTile, 8, 9, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseElement_SwDirective

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseElement_SwDirective(
  "ParseElement-SwDirective",
  scope_ParseElement_SwDirective::raa,
  scope_ParseElement_SwDirective::functions,
  scope_ParseElement_SwDirective::idents,
  scope_ParseElement_SwDirective::numbers,
  scope_ParseElement_SwDirective::strings
);
refalrts::RefalFunction& ParseElement_SwDirective = descr_ParseElement_SwDirective;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseElement_SwDirective(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  //FAST GEN: e.$
  //GLOBAL GEN: t.$ s.$ e.$
  // </0 & ParseElement-SwDirective/4 t.idx#0/5 s.idxV#0/7 e.idxVV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[7], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxVV#0 as range 2
  do {
    refalrts::start_sentence();
    // t.idx # Entry ( # TkName s.idx e.idx ) e.idx
    // </0 & ParseElement-SwDirective/4 t.ErrorList#1/5 # Entry/7 (/10 # TkName/12 s.LnNum#1/13 e.Name#1/8 )/11 e.Tail#1/2 >/1
    if( ! refalrts::ident_term(  & ident_Entry<int>::name, context[7] ) )
      continue;
    context[17] = context[2];
    context[18] = context[3];
    context[8] = 0;
    context[9] = 0;
    context[10] = refalrts::brackets_left( context[8], context[9], context[17], context[18] );
    if( ! context[10] )
      continue;
    refalrts::bracket_pointers(context[10], context[11]);
    context[12] = refalrts::ident_left(  & ident_TkName<int>::name, context[8], context[9] );
    if( ! context[12] )
      continue;
    // closed e.Tail#1 as range 17(2)
    if( ! refalrts::svar_left( context[13], context[8], context[9] ) )
      continue;
    // closed e.Name#1 as range 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} # TkName/12 s.LnNum#1/13 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseFunction/4 } Tile{ Reuse: # GN-Entry/7 AsIs: (/10 } Tile{ AsIs: e.Name#1/8 } Tile{ AsIs: )/11 } Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: e.Tail#1/17(2) } Tile{ AsIs: >/1 ]] }
    refalrts::update_name( context[4], & ParseFunction );
    refalrts::update_ident( context[7], & ident_GN_Entry<int>::name );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[10], context[11] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[11], context[11] );
    res = refalrts::splice_evar( res, context[8], context[9] );
    res = refalrts::splice_evar( res, context[7], context[10] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx # Entry t.idx e.idx
    // </0 & ParseElement-SwDirective/4 t.ErrorList#1/5 # Entry/7 t.Unexpected#1/8 e.Tail#1/2 >/1
    if( ! refalrts::ident_term(  & ident_Entry<int>::name, context[7] ) )
      continue;
    context[17] = context[2];
    context[18] = context[3];
    context[9] = refalrts::tvar_left( context[8], context[17], context[18] );
    if( ! context[9] )
      continue;
    // closed e.Tail#1 as range 17(2)

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/10 )/11 Tile{ AsIs: </0 Reuse: & EL-AddUnexpected/4 AsIs: t.ErrorList#1/5 } t.Unexpected#1/8/12 'f'/14 Tile{ HalfReuse: 'u'/1 }"nction name"/15 Tile{ HalfReuse: >/7 AsIs: t.Unexpected#1/8 } Tile{ AsIs: e.Tail#1/17(2) } Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[11] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[12], context[13], context[8], context[9]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[14], 'f' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[15], context[16], "nction name", 11 ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & EL_AddUnexpected );
    refalrts::reinit_char( context[1], 'u' );
    refalrts::reinit_close_call( context[7] );
    refalrts::push_stack( context[7] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[10], context[11] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[7], context[9] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    res = refalrts::splice_evar( res, context[12], context[14] );
    res = refalrts::splice_evar( res, context[0], context[6] );
    res = refalrts::splice_evar( res, context[10], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  // t.idx s.idx e.idx
  // </0 & ParseElement-SwDirective/4 t.ErrorList#1/5 s.Directive#1/7 e.Tail#1/2 >/1
  // closed e.Tail#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseNameList/4 } (/8 )/9 Tile{ AsIs: t.ErrorList#1/5 } </10 & ASTItemFromDirective/11 Tile{ AsIs: s.Directive#1/7 } >/12 Tile{ AsIs: e.Tail#1/2 } Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], & ASTItemFromDirective ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & ParseNameList );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::link_brackets( context[8], context[9] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[7], context[7] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[8], context[9] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_ParseElement_SwDirective(func_ParseElement_SwDirective, "ParseElement-SwDirective");
refalrts::RefalFunction& ParseElement_SwDirective = descr_ParseElement_SwDirective;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseNameList {
    static refalrts::RefalFunction *functions[] = {
      & EL_AddUnexpected,
      & Wrap,
      & ParseNameList_Tail
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TkName<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"function name", 13}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 21, 0, 0},
      //FAST GEN: ( e.$ ) t.$ s.$ s.$ t.$ e.$
      //GLOBAL GEN: ( e.$ ) t.$ s.$ s.$ t.$ e.$
      // </0 & ParseNameList/4 (/7 e.idxB#0/5 )/8 t.idxT#0/9 s.idxTV#0/11 s.idxTVV#0/12 t.idxTVVV#0/13 e.idxTVVVV#0/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icBracketLeftSave, 0, 5, 2},
      // closed e.idxB#0 as range 5
      {refalrts::ictVarLeftSave, 0, 9, 2},
      {refalrts::icsVarLeft, 0, 11, 2},
      {refalrts::icsVarLeft, 0, 12, 2},
      {refalrts::ictVarLeftSave, 0, 13, 2},
      // closed e.idxTVVVV#0 as range 2
      {refalrts::icOnFailGoTo, +23, 0, 0},
      // ( e.idx ) t.idx s.idx s.idx ( # TkName s.idx e.idx ) e.idx
      // </0 & ParseNameList/4 (/7 e.AST#1/5 )/8 t.ErrorList#1/9 s.ASTItem#1/11 s.ScopeClass#1/12 (/13 # TkName/17 s.LnNum#1/18 e.Name#1/15 )/14 e.Tail#1/2 >/1
      {refalrts::icBracketTerm, 0, 15, 13},
      {refalrts::icIdentLeftSave, 17, 0, 15},
      // closed e.AST#1 as range 5
      // closed e.Tail#1 as range 2
      {refalrts::icsVarLeft, 0, 18, 15},
      // closed e.Name#1 as range 15
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseNameList-Tail/4 AsIs: (/7 AsIs: e.AST#1/5 HalfReuse: </8 } Tile{ HalfReuse: & Wrap/13 HalfReuse: s.ASTItem1 #11/17 AsIs: s.LnNum#1/18 } Tile{ AsIs: s.ScopeClass#1/12 } Tile{ AsIs: e.Name#1/15 } >/19 )/20 Tile{ AsIs: t.ErrorList#1/9 AsIs: s.ASTItem#1/11 } Tile{ HalfReuse: s.ScopeClass1 #12/14 AsIs: e.Tail#1/2 AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 19},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 20},
      {refalrts::icUpdateFunc, 0, 2, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 8},
      {refalrts::icReinitFunc, 0, 1, 13},
      {refalrts::icReinitSVar, 0, 11, 17},
      {refalrts::icReinitSVar, 0, 12, 14},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 7, 20, 0},
      {refalrts::icPushStack, 0, 0, 19},
      {refalrts::icPushStack, 0, 0, 8},
      {refalrts::icSetRes, 0, 0, 14},
      {refalrts::icSpliceTile, 9, 11, 0},
      {refalrts::icSpliceTile, 19, 20, 0},
      {refalrts::icSpliceEVar, 0, 0, 15},
      {refalrts::icSpliceTile, 12, 12, 0},
      {refalrts::icSpliceTile, 13, 18, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // ( e.idx ) t.idx s.idx s.idx t.idx e.idx
      // </0 & ParseNameList/4 (/7 e.AST#1/5 )/8 t.ErrorList#1/9 s.ASTItem#1/11 s.ScopeClass#1/12 t.Unexpected#1/13 e.Tail#1/2 >/1
      // closed e.AST#1 as range 5
      // closed e.Tail#1 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.ASTItem#1/11 s.ScopeClass#1/12 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.AST#1/5 AsIs: )/8 } Tile{ AsIs: </0 Reuse: & EL-AddUnexpected/4 } Tile{ AsIs: t.ErrorList#1/9 } Tile{ AsIs: t.Unexpected#1/13 }"function name"/15 Tile{ AsIs: >/1 } t.Unexpected#1/13/17 Tile{ AsIs: e.Tail#1/2 } Tile{ ]] }
      {refalrts::icAllocString, 0, 0, 15},
      {refalrts::icCopyEVar, 17, 13, 0},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 7, 8, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 17, 18, 0},
      {refalrts::icSpliceTile, 1, 1, 0},
      {refalrts::icSpliceTile, 15, 16, 0},
      {refalrts::icSpliceTile, 13, 14, 0},
      {refalrts::icSpliceTile, 9, 10, 0},
      {refalrts::icSpliceTile, 0, 4, 0},
      {refalrts::icSpliceTile, 7, 8, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseNameList

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseNameList(
  "ParseNameList",
  scope_ParseNameList::raa,
  scope_ParseNameList::functions,
  scope_ParseNameList::idents,
  scope_ParseNameList::numbers,
  scope_ParseNameList::strings
);
refalrts::RefalFunction& ParseNameList = descr_ParseNameList;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseNameList(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  //FAST GEN: ( e.$ ) t.$ s.$ s.$ t.$ e.$
  //GLOBAL GEN: ( e.$ ) t.$ s.$ s.$ t.$ e.$
  // </0 & ParseNameList/4 (/7 e.idxB#0/5 )/8 t.idxT#0/9 s.idxTV#0/11 s.idxTVV#0/12 t.idxTVVV#0/13 e.idxTVVVV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  context[10] = refalrts::tvar_left( context[9], context[2], context[3] );
  if( ! context[10] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[14] = refalrts::tvar_left( context[13], context[2], context[3] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTVVVV#0 as range 2
  do {
    refalrts::start_sentence();
    // ( e.idx ) t.idx s.idx s.idx ( # TkName s.idx e.idx ) e.idx
    // </0 & ParseNameList/4 (/7 e.AST#1/5 )/8 t.ErrorList#1/9 s.ASTItem#1/11 s.ScopeClass#1/12 (/13 # TkName/17 s.LnNum#1/18 e.Name#1/15 )/14 e.Tail#1/2 >/1
    context[15] = 0;
    context[16] = 0;
    if( ! refalrts::brackets_term( context[15], context[16], context[13] ) )
      continue;
    context[17] = refalrts::ident_left(  & ident_TkName<int>::name, context[15], context[16] );
    if( ! context[17] )
      continue;
    // closed e.AST#1 as range 5
    // closed e.Tail#1 as range 2
    if( ! refalrts::svar_left( context[18], context[15], context[16] ) )
      continue;
    // closed e.Name#1 as range 15

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseNameList-Tail/4 AsIs: (/7 AsIs: e.AST#1/5 HalfReuse: </8 } Tile{ HalfReuse: & Wrap/13 HalfReuse: s.ASTItem1 #11/17 AsIs: s.LnNum#1/18 } Tile{ AsIs: s.ScopeClass#1/12 } Tile{ AsIs: e.Name#1/15 } >/19 )/20 Tile{ AsIs: t.ErrorList#1/9 AsIs: s.ASTItem#1/11 } Tile{ HalfReuse: s.ScopeClass1 #12/14 AsIs: e.Tail#1/2 AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[20] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ParseNameList_Tail );
    refalrts::reinit_open_call( context[8] );
    refalrts::reinit_name( context[13], & Wrap );
    refalrts::reinit_svar( context[17], context[11] );
    refalrts::reinit_svar( context[14], context[12] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[20] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[14];
    res = refalrts::splice_evar( res, context[9], context[11] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[13], context[18] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  // ( e.idx ) t.idx s.idx s.idx t.idx e.idx
  // </0 & ParseNameList/4 (/7 e.AST#1/5 )/8 t.ErrorList#1/9 s.ASTItem#1/11 s.ScopeClass#1/12 t.Unexpected#1/13 e.Tail#1/2 >/1
  // closed e.AST#1 as range 5
  // closed e.Tail#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.ASTItem#1/11 s.ScopeClass#1/12 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.AST#1/5 AsIs: )/8 } Tile{ AsIs: </0 Reuse: & EL-AddUnexpected/4 } Tile{ AsIs: t.ErrorList#1/9 } Tile{ AsIs: t.Unexpected#1/13 }"function name"/15 Tile{ AsIs: >/1 } t.Unexpected#1/13/17 Tile{ AsIs: e.Tail#1/2 } Tile{ ]] }
  if( ! refalrts::alloc_chars( context[15], context[16], "function name", 13 ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[17], context[18], context[13], context[14]))
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & EL_AddUnexpected );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[17], context[18] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[15], context[16] );
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_ParseNameList(func_ParseNameList, "ParseNameList");
refalrts::RefalFunction& ParseNameList = descr_ParseNameList;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_Wrap {
    using refalrts::functions;
    static const refalrts::RefalIdentifier idents[] = {
      & ident_Ident<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 8, 0, 0},
      //FAST GEN: s.$ s.$ s.$ e.$
      //GLOBAL GEN: s.$ s.$ s.$ e.$
      // </0 & Wrap/4 s.idx#0/5 s.idxV#0/6 s.idxVV#0/7 e.idxVVV#0/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icsVarLeft, 0, 6, 2},
      {refalrts::icsVarLeft, 0, 7, 2},
      // closed e.idxVVV#0 as range 2
      {refalrts::icOnFailGoTo, +10, 0, 0},
      // # Ident s.idx s.idx e.idx
      // </0 & Wrap/4 # Ident/5 s.LnNum#1/6 s.ScopeClass#1/7 e.Name#1/2 >/1
      {refalrts::icIdentTerm, 0, 0, 5},
      // closed e.Name#1 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 {REMOVED TILE} s.ScopeClass#1/7 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: (/4 AsIs: # Ident/5 AsIs: s.LnNum#1/6 } Tile{ AsIs: e.Name#1/2 } Tile{ HalfReuse: )/1 ]] }
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 1},
      {refalrts::icLinkBrackets, 4, 1, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 4, 6, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // s.idx s.idx s.idx e.idx
      // </0 & Wrap/4 s.ASTItem#1/5 s.LnNum#1/6 s.ScopeClass#1/7 e.Name#1/2 >/1
      // closed e.Name#1 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: (/4 AsIs: s.ASTItem#1/5 AsIs: s.LnNum#1/6 AsIs: s.ScopeClass#1/7 AsIs: e.Name#1/2 HalfReuse: )/1 ]] }
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 1},
      {refalrts::icLinkBrackets, 4, 1, 0},
      {refalrts::icSetRes, 0, 0, 4},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_Wrap

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_Wrap(
  "Wrap",
  scope_Wrap::raa,
  scope_Wrap::functions,
  scope_Wrap::idents,
  scope_Wrap::numbers,
  scope_Wrap::strings
);
refalrts::RefalFunction& Wrap = descr_Wrap;

} // unnamed namespace

#else
static refalrts::FnResult func_Wrap(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  //FAST GEN: s.$ s.$ s.$ e.$
  //GLOBAL GEN: s.$ s.$ s.$ e.$
  // </0 & Wrap/4 s.idx#0/5 s.idxV#0/6 s.idxVV#0/7 e.idxVVV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[7], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxVVV#0 as range 2
  do {
    refalrts::start_sentence();
    // # Ident s.idx s.idx e.idx
    // </0 & Wrap/4 # Ident/5 s.LnNum#1/6 s.ScopeClass#1/7 e.Name#1/2 >/1
    if( ! refalrts::ident_term(  & ident_Ident<int>::name, context[5] ) )
      continue;
    // closed e.Name#1 as range 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 {REMOVED TILE} s.ScopeClass#1/7 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: (/4 AsIs: # Ident/5 AsIs: s.LnNum#1/6 } Tile{ AsIs: e.Name#1/2 } Tile{ HalfReuse: )/1 ]] }
    refalrts::reinit_open_bracket( context[4] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[4], context[1] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[4], context[6] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  // s.idx s.idx s.idx e.idx
  // </0 & Wrap/4 s.ASTItem#1/5 s.LnNum#1/6 s.ScopeClass#1/7 e.Name#1/2 >/1
  // closed e.Name#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: (/4 AsIs: s.ASTItem#1/5 AsIs: s.LnNum#1/6 AsIs: s.ScopeClass#1/7 AsIs: e.Name#1/2 HalfReuse: )/1 ]] }
  refalrts::reinit_open_bracket( context[4] );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[4], context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[4];
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_Wrap(func_Wrap, "Wrap");
refalrts::RefalFunction& Wrap = descr_Wrap;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseNameList_Tail {
    static refalrts::RefalFunction *functions[] = {
      & EL_AddUnexpected,
      & ParseNameList
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TkSemicolon<int>::name,
      & ident_TkComma<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"comma or semicolon", 18}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 2, 0, 0},
      {refalrts::icIssueMemory, 19, 0, 0},
      //FAST GEN: ( e.$ ) t.$ s.$ s.$ t.$ e.$
      //GLOBAL GEN: ( e.$ ) t.$ s.$ s.$ t.$ e.$
      // </0 & ParseNameList-Tail/4 (/7 e.idxB#0/5 )/8 t.idxT#0/9 s.idxTV#0/11 s.idxTVV#0/12 t.idxTVVV#0/13 e.idxTVVVV#0/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icBracketLeftSave, 0, 5, 2},
      // closed e.idxB#0 as range 5
      {refalrts::ictVarLeftSave, 0, 9, 2},
      {refalrts::icsVarLeft, 0, 11, 2},
      {refalrts::icsVarLeft, 0, 12, 2},
      {refalrts::ictVarLeftSave, 0, 13, 2},
      // closed e.idxTVVVV#0 as range 2
      {refalrts::icOnFailGoTo, +13, 0, 0},
      // ( e.idx ) t.idx s.idx s.idx ( # TkComma s.idx ) e.idx
      // </0 & ParseNameList-Tail/4 (/7 e.AST#1/5 )/8 t.ErrorList#1/9 s.ASTItem#1/11 s.ScopeClass#1/12 (/13 # TkComma/17 s.LnNum#1/18 )/14 e.Tail#1/2 >/1
      {refalrts::icBracketTerm, 0, 15, 13},
      {refalrts::icIdentLeftSave, 17, 1, 15},
      // closed e.AST#1 as range 5
      // closed e.Tail#1 as range 2
      {refalrts::icsVarLeft, 0, 18, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} (/13 # TkComma/17 s.LnNum#1/18 )/14 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseNameList/4 AsIs: (/7 AsIs: e.AST#1/5 AsIs: )/8 AsIs: t.ErrorList#1/9 AsIs: s.ASTItem#1/11 AsIs: s.ScopeClass#1/12 } Tile{ AsIs: e.Tail#1/2 } Tile{ AsIs: >/1 ]] }
      {refalrts::icUpdateFunc, 0, 1, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 7, 8, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icTrash, 0, 0, 12},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +11, 0, 0},
      // ( e.idx ) t.idx s.idx s.idx ( # TkSemicolon s.idx ) e.idx
      // </0 & ParseNameList-Tail/4 (/7 e.AST#1/5 )/8 t.ErrorList#1/9 s.ASTItem#1/11 s.ScopeClass#1/12 (/13 # TkSemicolon/17 s.LnNum#1/18 )/14 e.Tail#1/2 >/1
      {refalrts::icBracketTerm, 0, 15, 13},
      {refalrts::icIdentLeftSave, 17, 0, 15},
      // closed e.AST#1 as range 5
      // closed e.Tail#1 as range 2
      {refalrts::icsVarLeft, 0, 18, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseNameList-Tail/4 {REMOVED TILE} s.ASTItem#1/11 s.ScopeClass#1/12 (/13 # TkSemicolon/17 s.LnNum#1/18 )/14 {REMOVED TILE} >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.AST#1/5 AsIs: )/8 AsIs: t.ErrorList#1/9 } Tile{ AsIs: e.Tail#1/2 } Tile{ ]] }
      {refalrts::icLinkBrackets, 7, 8, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 7, 10, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // ( e.idx ) t.idx s.idx s.idx t.idx e.idx
      // </0 & ParseNameList-Tail/4 (/7 e.AST#1/5 )/8 t.ErrorList#1/9 s.ASTItem#1/11 s.ScopeClass#1/12 t.Unexpected#1/13 e.Tail#1/2 >/1
      // closed e.AST#1 as range 5
      // closed e.Tail#1 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.ASTItem#1/11 s.ScopeClass#1/12 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.AST#1/5 AsIs: )/8 } Tile{ AsIs: </0 Reuse: & EL-AddUnexpected/4 } Tile{ AsIs: t.ErrorList#1/9 } Tile{ AsIs: t.Unexpected#1/13 }"comma or semicolon"/15 Tile{ AsIs: >/1 } t.Unexpected#1/13/17 Tile{ AsIs: e.Tail#1/2 } Tile{ ]] }
      {refalrts::icAllocString, 0, 0, 15},
      {refalrts::icCopyEVar, 17, 13, 0},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 7, 8, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 17, 18, 0},
      {refalrts::icSpliceTile, 1, 1, 0},
      {refalrts::icSpliceTile, 15, 16, 0},
      {refalrts::icSpliceTile, 13, 14, 0},
      {refalrts::icSpliceTile, 9, 10, 0},
      {refalrts::icSpliceTile, 0, 4, 0},
      {refalrts::icSpliceTile, 7, 8, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseNameList_Tail

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseNameList_Tail(
  "ParseNameList-Tail",
  scope_ParseNameList_Tail::raa,
  scope_ParseNameList_Tail::functions,
  scope_ParseNameList_Tail::idents,
  scope_ParseNameList_Tail::numbers,
  scope_ParseNameList_Tail::strings
);
refalrts::RefalFunction& ParseNameList_Tail = descr_ParseNameList_Tail;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseNameList_Tail(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  //FAST GEN: ( e.$ ) t.$ s.$ s.$ t.$ e.$
  //GLOBAL GEN: ( e.$ ) t.$ s.$ s.$ t.$ e.$
  // </0 & ParseNameList-Tail/4 (/7 e.idxB#0/5 )/8 t.idxT#0/9 s.idxTV#0/11 s.idxTVV#0/12 t.idxTVVV#0/13 e.idxTVVVV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  context[10] = refalrts::tvar_left( context[9], context[2], context[3] );
  if( ! context[10] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[14] = refalrts::tvar_left( context[13], context[2], context[3] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTVVVV#0 as range 2
  do {
    refalrts::start_sentence();
    // ( e.idx ) t.idx s.idx s.idx ( # TkComma s.idx ) e.idx
    // </0 & ParseNameList-Tail/4 (/7 e.AST#1/5 )/8 t.ErrorList#1/9 s.ASTItem#1/11 s.ScopeClass#1/12 (/13 # TkComma/17 s.LnNum#1/18 )/14 e.Tail#1/2 >/1
    context[15] = 0;
    context[16] = 0;
    if( ! refalrts::brackets_term( context[15], context[16], context[13] ) )
      continue;
    context[17] = refalrts::ident_left(  & ident_TkComma<int>::name, context[15], context[16] );
    if( ! context[17] )
      continue;
    // closed e.AST#1 as range 5
    // closed e.Tail#1 as range 2
    if( ! refalrts::svar_left( context[18], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} (/13 # TkComma/17 s.LnNum#1/18 )/14 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseNameList/4 AsIs: (/7 AsIs: e.AST#1/5 AsIs: )/8 AsIs: t.ErrorList#1/9 AsIs: s.ASTItem#1/11 AsIs: s.ScopeClass#1/12 } Tile{ AsIs: e.Tail#1/2 } Tile{ AsIs: >/1 ]] }
    refalrts::update_name( context[4], & ParseNameList );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[2], context[3] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[12], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // ( e.idx ) t.idx s.idx s.idx ( # TkSemicolon s.idx ) e.idx
    // </0 & ParseNameList-Tail/4 (/7 e.AST#1/5 )/8 t.ErrorList#1/9 s.ASTItem#1/11 s.ScopeClass#1/12 (/13 # TkSemicolon/17 s.LnNum#1/18 )/14 e.Tail#1/2 >/1
    context[15] = 0;
    context[16] = 0;
    if( ! refalrts::brackets_term( context[15], context[16], context[13] ) )
      continue;
    context[17] = refalrts::ident_left(  & ident_TkSemicolon<int>::name, context[15], context[16] );
    if( ! context[17] )
      continue;
    // closed e.AST#1 as range 5
    // closed e.Tail#1 as range 2
    if( ! refalrts::svar_left( context[18], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & ParseNameList-Tail/4 {REMOVED TILE} s.ASTItem#1/11 s.ScopeClass#1/12 (/13 # TkSemicolon/17 s.LnNum#1/18 )/14 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.AST#1/5 AsIs: )/8 AsIs: t.ErrorList#1/9 } Tile{ AsIs: e.Tail#1/2 } Tile{ ]] }
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[7], context[10] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  // ( e.idx ) t.idx s.idx s.idx t.idx e.idx
  // </0 & ParseNameList-Tail/4 (/7 e.AST#1/5 )/8 t.ErrorList#1/9 s.ASTItem#1/11 s.ScopeClass#1/12 t.Unexpected#1/13 e.Tail#1/2 >/1
  // closed e.AST#1 as range 5
  // closed e.Tail#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.ASTItem#1/11 s.ScopeClass#1/12 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.AST#1/5 AsIs: )/8 } Tile{ AsIs: </0 Reuse: & EL-AddUnexpected/4 } Tile{ AsIs: t.ErrorList#1/9 } Tile{ AsIs: t.Unexpected#1/13 }"comma or semicolon"/15 Tile{ AsIs: >/1 } t.Unexpected#1/13/17 Tile{ AsIs: e.Tail#1/2 } Tile{ ]] }
  if( ! refalrts::alloc_chars( context[15], context[16], "comma or semicolon", 18 ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[17], context[18], context[13], context[14]))
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & EL_AddUnexpected );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[17], context[18] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[15], context[16] );
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_ParseNameList_Tail(func_ParseNameList_Tail, "ParseNameList-Tail");
refalrts::RefalFunction& ParseNameList_Tail = descr_ParseNameList_Tail;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseFunction_S1L1 {
    using refalrts::functions;
    static const refalrts::RefalIdentifier idents[] = {
      & ident_Function<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icIssueMemory, 17, 0, 0},
      // </0 & ParseFunction$1\1/4 s.LnNum#1/5 s.ScopeClass#1/6 (/9 e.Name#1/7 )/10 (/13 e.Block#2/11 )/14 t.ErrorList#2/15 e.Tail#2/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icsVarLeft, 0, 6, 2},
      {refalrts::icBracketLeftSave, 0, 7, 2},
      {refalrts::icBracketLeftSave, 0, 11, 2},
      // closed e.Name#1 as range 7
      // closed e.Block#2 as range 11
      {refalrts::ictVarLeftSave, 0, 15, 2},
      // closed e.Tail#2 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: (/13 } Tile{ HalfReuse: (/0 HalfReuse: # Function/4 AsIs: s.LnNum#1/5 AsIs: s.ScopeClass#1/6 AsIs: (/9 AsIs: e.Name#1/7 AsIs: )/10 } Tile{ AsIs: e.Block#2/11 } Tile{ HalfReuse: )/1 } Tile{ AsIs: )/14 AsIs: t.ErrorList#2/15 } Tile{ AsIs: e.Tail#2/2 } Tile{ ]] }
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 0},
      {refalrts::icReinitIdent, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 1},
      {refalrts::icLinkBrackets, 13, 14, 0},
      {refalrts::icLinkBrackets, 0, 1, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 14, 16, 0},
      {refalrts::icSpliceTile, 1, 1, 0},
      {refalrts::icSpliceEVar, 0, 0, 11},
      {refalrts::icSpliceTile, 0, 10, 0},
      {refalrts::icSpliceTile, 13, 13, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseFunction_S1L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseFunction_S1L1(
  "ParseFunction$1\\1",
  scope_gen_ParseFunction_S1L1::raa,
  scope_gen_ParseFunction_S1L1::functions,
  scope_gen_ParseFunction_S1L1::idents,
  scope_gen_ParseFunction_S1L1::numbers,
  scope_gen_ParseFunction_S1L1::strings
);
refalrts::RefalFunction& gen_ParseFunction_S1L1 = descr_gen_ParseFunction_S1L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseFunction_S1L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 17 elems
  refalrts::Iter context[17];
  refalrts::zeros( context, 17 );
  // </0 & ParseFunction$1\1/4 s.LnNum#1/5 s.ScopeClass#1/6 (/9 e.Name#1/7 )/10 (/13 e.Block#2/11 )/14 t.ErrorList#2/15 e.Tail#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[7] = 0;
  context[8] = 0;
  context[9] = refalrts::brackets_left( context[7], context[8], context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[9], context[10]);
  context[11] = 0;
  context[12] = 0;
  context[13] = refalrts::brackets_left( context[11], context[12], context[2], context[3] );
  if( ! context[13] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[13], context[14]);
  // closed e.Name#1 as range 7
  // closed e.Block#2 as range 11
  context[16] = refalrts::tvar_left( context[15], context[2], context[3] );
  if( ! context[16] )
    return refalrts::cRecognitionImpossible;
  // closed e.Tail#2 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/13 } Tile{ HalfReuse: (/0 HalfReuse: # Function/4 AsIs: s.LnNum#1/5 AsIs: s.ScopeClass#1/6 AsIs: (/9 AsIs: e.Name#1/7 AsIs: )/10 } Tile{ AsIs: e.Block#2/11 } Tile{ HalfReuse: )/1 } Tile{ AsIs: )/14 AsIs: t.ErrorList#2/15 } Tile{ AsIs: e.Tail#2/2 } Tile{ ]] }
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_ident( context[4], & ident_Function<int>::name );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[13], context[14] );
  refalrts::link_brackets( context[0], context[1] );
  refalrts::link_brackets( context[9], context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[14], context[16] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[11], context[12] );
  res = refalrts::splice_evar( res, context[0], context[10] );
  res = refalrts::splice_evar( res, context[13], context[13] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_gen_ParseFunction_S1L1(func_gen_ParseFunction_S1L1, "ParseFunction$1\\1");
refalrts::RefalFunction& gen_ParseFunction_S1L1 = descr_gen_ParseFunction_S1L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseFunction {
    static refalrts::RefalFunction *functions[] = {
      & EL_AddUnexpected,
      & gen_ParseFunction_S1L1,
      & ParseBlock,
      & Fetch,
      & refalrts::create_closure
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TkOpenBlock<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"en brace", 8}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 23, 0, 0},
      //FAST GEN: s.$ ( e.$ ) t.$ t.$ e.$
      //GLOBAL GEN: s.$ ( e.$ ) t.$ t.$ e.$
      // </0 & ParseFunction/4 s.idx#0/5 (/8 e.idxVB#0/6 )/9 t.idxVT#0/10 t.idxVTV#0/12 e.idxVTVV#0/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icBracketLeftSave, 0, 6, 2},
      // closed e.idxVB#0 as range 6
      {refalrts::ictVarLeftSave, 0, 10, 2},
      {refalrts::ictVarLeftSave, 0, 12, 2},
      // closed e.idxVTVV#0 as range 2
      {refalrts::icOnFailGoTo, +33, 0, 0},
      // s.idx ( e.idx ) t.idx ( # TkOpenBlock s.idx ) e.idx
      // </0 & ParseFunction/4 s.ScopeClass#1/5 (/8 e.Name#1/6 )/9 t.ErrorList#1/10 (/12 # TkOpenBlock/16 s.LnNum#1/17 )/13 e.Tail#1/2 >/1
      {refalrts::icBracketTerm, 0, 14, 12},
      {refalrts::icIdentLeftSave, 16, 0, 14},
      // closed e.Name#1 as range 6
      // closed e.Tail#1 as range 2
      {refalrts::icsVarLeft, 0, 17, 14},
      {refalrts::icEmpty, 0, 0, 14},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNum#1/17 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: </12 HalfReuse: & Fetch/16 } </18 Tile{ HalfReuse: & ParseBlock/13 } Tile{ AsIs: t.ErrorList#1/10 } Tile{ AsIs: e.Tail#1/2 } >/19 </20 & @create_closure@/21 Tile{ HalfReuse: & ParseFunction$1\1/0 HalfReuse: s.LnNum1 #17/4 AsIs: s.ScopeClass#1/5 AsIs: (/8 AsIs: e.Name#1/6 AsIs: )/9 } >/22 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 18},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 19},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 20},
      {refalrts::icAllocFunc, 0, 4, 21},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 22},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 12},
      {refalrts::icReinitFunc, 0, 3, 16},
      {refalrts::icReinitFunc, 0, 2, 13},
      {refalrts::icReinitFunc, 0, 1, 0},
      {refalrts::icReinitSVar, 0, 17, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 12},
      {refalrts::icPushStack, 0, 0, 22},
      {refalrts::icPushStack, 0, 0, 20},
      {refalrts::icLinkBrackets, 8, 9, 0},
      {refalrts::icPushStack, 0, 0, 19},
      {refalrts::icPushStack, 0, 0, 18},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 22, 22, 0},
      {refalrts::icSpliceTile, 0, 9, 0},
      {refalrts::icSpliceTile, 19, 21, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 10, 11, 0},
      {refalrts::icSpliceTile, 13, 13, 0},
      {refalrts::icSpliceTile, 18, 18, 0},
      {refalrts::icSpliceTile, 12, 16, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // s.idx ( e.idx ) t.idx t.idx e.idx
      // </0 & ParseFunction/4 s.ScopeClass#1/5 (/8 e.Name#1/6 )/9 t.ErrorList#1/10 t.Unexpected#1/12 e.Tail#1/2 >/1
      // closed e.Name#1 as range 6
      // closed e.Tail#1 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.ScopeClass#1/5 {REMOVED TILE} e.Name#1/6 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: )/4 } </14 Tile{ HalfReuse: & EL-AddUnexpected/9 AsIs: t.ErrorList#1/10 AsIs: t.Unexpected#1/12 } 'o'/15 Tile{ HalfReuse: 'p'/8 }"en brace"/16 Tile{ AsIs: >/1 } t.Unexpected#1/12/18 Tile{ AsIs: e.Tail#1/2 } Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 14},
      {refalrts::icAllocChar, 0, 'o', 15},
      {refalrts::icAllocString, 0, 0, 16},
      {refalrts::icCopyEVar, 18, 12, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 4},
      {refalrts::icReinitFunc, 0, 0, 9},
      {refalrts::icReinitChar, 0, 'p', 8},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 14},
      {refalrts::icLinkBrackets, 0, 4, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 18, 19, 0},
      {refalrts::icSpliceTile, 1, 1, 0},
      {refalrts::icSpliceTile, 16, 17, 0},
      {refalrts::icSpliceTile, 8, 8, 0},
      {refalrts::icSpliceTile, 15, 15, 0},
      {refalrts::icSpliceTile, 9, 13, 0},
      {refalrts::icSpliceTile, 14, 14, 0},
      {refalrts::icTrash, 0, 0, 4},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseFunction

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseFunction(
  "ParseFunction",
  scope_ParseFunction::raa,
  scope_ParseFunction::functions,
  scope_ParseFunction::idents,
  scope_ParseFunction::numbers,
  scope_ParseFunction::strings
);
refalrts::RefalFunction& ParseFunction = descr_ParseFunction;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseFunction(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 23 elems
  refalrts::Iter context[23];
  refalrts::zeros( context, 23 );
  //FAST GEN: s.$ ( e.$ ) t.$ t.$ e.$
  //GLOBAL GEN: s.$ ( e.$ ) t.$ t.$ e.$
  // </0 & ParseFunction/4 s.idx#0/5 (/8 e.idxVB#0/6 )/9 t.idxVT#0/10 t.idxVTV#0/12 e.idxVTVV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  // closed e.idxVB#0 as range 6
  context[11] = refalrts::tvar_left( context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  context[13] = refalrts::tvar_left( context[12], context[2], context[3] );
  if( ! context[13] )
    return refalrts::cRecognitionImpossible;
  // closed e.idxVTVV#0 as range 2
  do {
    refalrts::start_sentence();
    // s.idx ( e.idx ) t.idx ( # TkOpenBlock s.idx ) e.idx
    // </0 & ParseFunction/4 s.ScopeClass#1/5 (/8 e.Name#1/6 )/9 t.ErrorList#1/10 (/12 # TkOpenBlock/16 s.LnNum#1/17 )/13 e.Tail#1/2 >/1
    context[14] = 0;
    context[15] = 0;
    if( ! refalrts::brackets_term( context[14], context[15], context[12] ) )
      continue;
    context[16] = refalrts::ident_left(  & ident_TkOpenBlock<int>::name, context[14], context[15] );
    if( ! context[16] )
      continue;
    // closed e.Name#1 as range 6
    // closed e.Tail#1 as range 2
    if( ! refalrts::svar_left( context[17], context[14], context[15] ) )
      continue;
    if( ! refalrts::empty_seq( context[14], context[15] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNum#1/17 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: </12 HalfReuse: & Fetch/16 } </18 Tile{ HalfReuse: & ParseBlock/13 } Tile{ AsIs: t.ErrorList#1/10 } Tile{ AsIs: e.Tail#1/2 } >/19 </20 & @create_closure@/21 Tile{ HalfReuse: & ParseFunction$1\1/0 HalfReuse: s.LnNum1 #17/4 AsIs: s.ScopeClass#1/5 AsIs: (/8 AsIs: e.Name#1/6 AsIs: )/9 } >/22 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[21], & refalrts::create_closure ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[12] );
    refalrts::reinit_name( context[16], & Fetch );
    refalrts::reinit_name( context[13], & ParseBlock );
    refalrts::reinit_name( context[0], & gen_ParseFunction_S1L1 );
    refalrts::reinit_svar( context[4], context[17] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[20] );
    refalrts::link_brackets( context[8], context[9] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[18] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[22], context[22] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[19], context[21] );
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[10], context[11] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[12], context[16] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  // s.idx ( e.idx ) t.idx t.idx e.idx
  // </0 & ParseFunction/4 s.ScopeClass#1/5 (/8 e.Name#1/6 )/9 t.ErrorList#1/10 t.Unexpected#1/12 e.Tail#1/2 >/1
  // closed e.Name#1 as range 6
  // closed e.Tail#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.ScopeClass#1/5 {REMOVED TILE} e.Name#1/6 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: )/4 } </14 Tile{ HalfReuse: & EL-AddUnexpected/9 AsIs: t.ErrorList#1/10 AsIs: t.Unexpected#1/12 } 'o'/15 Tile{ HalfReuse: 'p'/8 }"en brace"/16 Tile{ AsIs: >/1 } t.Unexpected#1/12/18 Tile{ AsIs: e.Tail#1/2 } Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[15], 'o' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[16], context[17], "en brace", 8 ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[18], context[19], context[12], context[13]))
    return refalrts::cNoMemory;
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::reinit_name( context[9], & EL_AddUnexpected );
  refalrts::reinit_char( context[8], 'p' );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[14] );
  refalrts::link_brackets( context[0], context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[18], context[19] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[16], context[17] );
  res = refalrts::splice_evar( res, context[8], context[8] );
  res = refalrts::splice_evar( res, context[15], context[15] );
  res = refalrts::splice_evar( res, context[9], context[13] );
  res = refalrts::splice_evar( res, context[14], context[14] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_ParseFunction(func_ParseFunction, "ParseFunction");
refalrts::RefalFunction& ParseFunction = descr_ParseFunction;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseBlock_S1L1 {
    static refalrts::RefalFunction *functions[] = {
      & EL_AddUnexpected
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_NativeBody<int>::name,
      & ident_TkCloseBlock<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 20, 0, 0},
      //FAST GEN: t.$ ( e.$ ) t.$ t.$ e.$
      //GLOBAL GEN: t.$ ( e.$ ) t.$ t.$ e.$
      // </0 & ParseBlock$1\1/4 t.idx#0/5 (/9 e.idxVB#0/7 )/10 t.idxVT#0/11 t.idxVTV#0/13 e.idxVTVV#0/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::ictVarLeftSave, 0, 5, 2},
      {refalrts::icBracketLeftSave, 0, 7, 2},
      // closed e.idxVB#0 as range 7
      {refalrts::ictVarLeftSave, 0, 11, 2},
      {refalrts::ictVarLeftSave, 0, 13, 2},
      // closed e.idxVTVV#0 as range 2
      {refalrts::icOnFailGoTo, +14, 0, 0},
      // t.idx ( e.idx ) t.idx ( # TkCloseBlock t.idx ) e.idx
      // </0 & ParseBlock$1\1/4 t.SrcPos#1/5 (/9 e.Block#1/7 )/10 t.ErrorList#1/11 (/13 # TkCloseBlock/17 t.CloseBlockSrcPos#2/18 )/14 e.Tokens#2/2 >/1
      {refalrts::icBracketTerm, 0, 15, 13},
      {refalrts::icIdentLeftSave, 17, 1, 15},
      // closed e.Block#1 as range 7
      // closed e.Tokens#2 as range 2
      {refalrts::ictVarLeftSave, 0, 18, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} (/9 {REMOVED TILE} {REMOVED TILE} (/13 # TkCloseBlock/17 t.CloseBlockSrcPos#2/18 )/14 {REMOVED TILE} >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: # NativeBody/4 AsIs: t.SrcPos#1/5 } Tile{ AsIs: e.Block#1/7 } Tile{ AsIs: )/10 AsIs: t.ErrorList#1/11 } Tile{ AsIs: e.Tokens#2/2 } Tile{ ]] }
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 0},
      {refalrts::icReinitIdent, 0, 0, 4},
      {refalrts::icLinkBrackets, 0, 10, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 10, 12, 0},
      {refalrts::icSpliceEVar, 0, 0, 7},
      {refalrts::icTrash, 0, 0, 6},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // t.idx ( e.idx ) t.idx t.idx e.idx
      // </0 & ParseBlock$1\1/4 t.SrcPos#1/5 (/9 e.Block#1/7 )/10 t.ErrorList#1/11 t.Unexpected#2/13 e.Tokens#2/2 >/1
      // closed e.Block#1 as range 7
      // closed e.Tokens#2 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: # NativeBody/4 AsIs: t.SrcPos#1/5 } Tile{ AsIs: e.Block#1/7 } Tile{ HalfReuse: )/9 } </15 Tile{ HalfReuse: & EL-AddUnexpected/10 AsIs: t.ErrorList#1/11 AsIs: t.Unexpected#2/13 } '}'/16 Tile{ AsIs: >/1 } t.Unexpected#2/13/17 Tile{ AsIs: e.Tokens#2/2 } Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 15},
      {refalrts::icAllocChar, 0, '}', 16},
      {refalrts::icCopyEVar, 17, 13, 0},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 0},
      {refalrts::icReinitIdent, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 9},
      {refalrts::icReinitFunc, 0, 0, 10},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 15},
      {refalrts::icLinkBrackets, 0, 9, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 17, 18, 0},
      {refalrts::icSpliceTile, 1, 1, 0},
      {refalrts::icSpliceTile, 16, 16, 0},
      {refalrts::icSpliceTile, 10, 14, 0},
      {refalrts::icSpliceTile, 15, 15, 0},
      {refalrts::icSpliceTile, 9, 9, 0},
      {refalrts::icSpliceEVar, 0, 0, 7},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseBlock_S1L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseBlock_S1L1(
  "ParseBlock$1\\1",
  scope_gen_ParseBlock_S1L1::raa,
  scope_gen_ParseBlock_S1L1::functions,
  scope_gen_ParseBlock_S1L1::idents,
  scope_gen_ParseBlock_S1L1::numbers,
  scope_gen_ParseBlock_S1L1::strings
);
refalrts::RefalFunction& gen_ParseBlock_S1L1 = descr_gen_ParseBlock_S1L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseBlock_S1L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 20 elems
  refalrts::Iter context[20];
  refalrts::zeros( context, 20 );
  //FAST GEN: t.$ ( e.$ ) t.$ t.$ e.$
  //GLOBAL GEN: t.$ ( e.$ ) t.$ t.$ e.$
  // </0 & ParseBlock$1\1/4 t.idx#0/5 (/9 e.idxVB#0/7 )/10 t.idxVT#0/11 t.idxVTV#0/13 e.idxVTVV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  context[7] = 0;
  context[8] = 0;
  context[9] = refalrts::brackets_left( context[7], context[8], context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[9], context[10]);
  // closed e.idxVB#0 as range 7
  context[12] = refalrts::tvar_left( context[11], context[2], context[3] );
  if( ! context[12] )
    return refalrts::cRecognitionImpossible;
  context[14] = refalrts::tvar_left( context[13], context[2], context[3] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  // closed e.idxVTVV#0 as range 2
  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) t.idx ( # TkCloseBlock t.idx ) e.idx
    // </0 & ParseBlock$1\1/4 t.SrcPos#1/5 (/9 e.Block#1/7 )/10 t.ErrorList#1/11 (/13 # TkCloseBlock/17 t.CloseBlockSrcPos#2/18 )/14 e.Tokens#2/2 >/1
    context[15] = 0;
    context[16] = 0;
    if( ! refalrts::brackets_term( context[15], context[16], context[13] ) )
      continue;
    context[17] = refalrts::ident_left(  & ident_TkCloseBlock<int>::name, context[15], context[16] );
    if( ! context[17] )
      continue;
    // closed e.Block#1 as range 7
    // closed e.Tokens#2 as range 2
    context[19] = refalrts::tvar_left( context[18], context[15], context[16] );
    if( ! context[19] )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} (/9 {REMOVED TILE} {REMOVED TILE} (/13 # TkCloseBlock/17 t.CloseBlockSrcPos#2/18 )/14 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: # NativeBody/4 AsIs: t.SrcPos#1/5 } Tile{ AsIs: e.Block#1/7 } Tile{ AsIs: )/10 AsIs: t.ErrorList#1/11 } Tile{ AsIs: e.Tokens#2/2 } Tile{ ]] }
    refalrts::reinit_open_bracket( context[0] );
    refalrts::reinit_ident( context[4], & ident_NativeBody<int>::name );
    refalrts::link_brackets( context[0], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[10], context[12] );
    res = refalrts::splice_evar( res, context[7], context[8] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[6], res );
    return refalrts::cSuccess;
  } while ( 0 );

  // t.idx ( e.idx ) t.idx t.idx e.idx
  // </0 & ParseBlock$1\1/4 t.SrcPos#1/5 (/9 e.Block#1/7 )/10 t.ErrorList#1/11 t.Unexpected#2/13 e.Tokens#2/2 >/1
  // closed e.Block#1 as range 7
  // closed e.Tokens#2 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: # NativeBody/4 AsIs: t.SrcPos#1/5 } Tile{ AsIs: e.Block#1/7 } Tile{ HalfReuse: )/9 } </15 Tile{ HalfReuse: & EL-AddUnexpected/10 AsIs: t.ErrorList#1/11 AsIs: t.Unexpected#2/13 } '}'/16 Tile{ AsIs: >/1 } t.Unexpected#2/13/17 Tile{ AsIs: e.Tokens#2/2 } Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[16], '}' ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[17], context[18], context[13], context[14]))
    return refalrts::cNoMemory;
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_ident( context[4], & ident_NativeBody<int>::name );
  refalrts::reinit_close_bracket( context[9] );
  refalrts::reinit_name( context[10], & EL_AddUnexpected );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[15] );
  refalrts::link_brackets( context[0], context[9] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[17], context[18] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[16], context[16] );
  res = refalrts::splice_evar( res, context[10], context[14] );
  res = refalrts::splice_evar( res, context[15], context[15] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_gen_ParseBlock_S1L1(func_gen_ParseBlock_S1L1, "ParseBlock$1\\1");
refalrts::RefalFunction& gen_ParseBlock_S1L1 = descr_gen_ParseBlock_S1L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseBlock {
    static refalrts::RefalFunction *functions[] = {
      & DoParseBlock,
      & gen_ParseBlock_S1L1,
      & refalrts::create_closure,
      & Fetch
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TkNativeBlock<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 19, 0, 0},
      //FAST GEN: t.$ e.$
      //GLOBAL GEN: t.$ e.$
      // </0 & ParseBlock/4 t.idx#0/5 e.idxV#0/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::ictVarLeftSave, 0, 5, 2},
      // closed e.idxV#0 as range 2
      {refalrts::icOnFailGoTo, +26, 0, 0},
      // t.idx ( # TkNativeBlock t.idx e.idx ) e.idx
      // </0 & ParseBlock/4 t.ErrorList#1/5 (/9 # TkNativeBlock/11 t.SrcPos#1/12 e.Block#1/7 )/10 e.Tokens#1/2 >/1
      {refalrts::icSave, 0, 17, 2},
      {refalrts::icBracketLeftSave, 0, 7, 17},
      {refalrts::icIdentLeftSave, 11, 0, 7},
      // closed e.Tokens#1 as range 17(2)
      {refalrts::ictVarLeftSave, 0, 12, 7},
      // closed e.Block#1 as range 7
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 } Tile{ AsIs: e.Tokens#1/17(2) } </14 Tile{ HalfReuse: & @create_closure@/9 HalfReuse: & ParseBlock$1\1/11 AsIs: t.SrcPos#1/12 } (/15 Tile{ AsIs: e.Block#1/7 } Tile{ AsIs: )/10 } Tile{ AsIs: t.ErrorList#1/5 } >/16 Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 14},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 15},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 16},
      {refalrts::icUpdateFunc, 0, 3, 4},
      {refalrts::icReinitFunc, 0, 2, 9},
      {refalrts::icReinitFunc, 0, 1, 11},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 16},
      {refalrts::icPushStack, 0, 0, 14},
      {refalrts::icLinkBrackets, 15, 10, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceTile, 16, 16, 0},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icSpliceTile, 10, 10, 0},
      {refalrts::icSpliceEVar, 0, 0, 7},
      {refalrts::icSpliceTile, 15, 15, 0},
      {refalrts::icSpliceTile, 9, 13, 0},
      {refalrts::icSpliceTile, 14, 14, 0},
      {refalrts::icSpliceEVar, 0, 0, 17},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // t.idx e.idx
      // </0 & ParseBlock/4 t.ErrorList#1/5 e.Tokens#1/2 >/1
      // closed e.Tokens#1 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & DoParseBlock/4 AsIs: t.ErrorList#1/5 } (/7 )/8 Tile{ AsIs: e.Tokens#1/2 } Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 7},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 8},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 7, 8, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 7, 8, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseBlock

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseBlock(
  "ParseBlock",
  scope_ParseBlock::raa,
  scope_ParseBlock::functions,
  scope_ParseBlock::idents,
  scope_ParseBlock::numbers,
  scope_ParseBlock::strings
);
refalrts::RefalFunction& ParseBlock = descr_ParseBlock;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseBlock(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  //FAST GEN: t.$ e.$
  //GLOBAL GEN: t.$ e.$
  // </0 & ParseBlock/4 t.idx#0/5 e.idxV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  // closed e.idxV#0 as range 2
  do {
    refalrts::start_sentence();
    // t.idx ( # TkNativeBlock t.idx e.idx ) e.idx
    // </0 & ParseBlock/4 t.ErrorList#1/5 (/9 # TkNativeBlock/11 t.SrcPos#1/12 e.Block#1/7 )/10 e.Tokens#1/2 >/1
    context[17] = context[2];
    context[18] = context[3];
    context[7] = 0;
    context[8] = 0;
    context[9] = refalrts::brackets_left( context[7], context[8], context[17], context[18] );
    if( ! context[9] )
      continue;
    refalrts::bracket_pointers(context[9], context[10]);
    context[11] = refalrts::ident_left(  & ident_TkNativeBlock<int>::name, context[7], context[8] );
    if( ! context[11] )
      continue;
    // closed e.Tokens#1 as range 17(2)
    context[13] = refalrts::tvar_left( context[12], context[7], context[8] );
    if( ! context[13] )
      continue;
    // closed e.Block#1 as range 7

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Fetch/4 } Tile{ AsIs: e.Tokens#1/17(2) } </14 Tile{ HalfReuse: & @create_closure@/9 HalfReuse: & ParseBlock$1\1/11 AsIs: t.SrcPos#1/12 } (/15 Tile{ AsIs: e.Block#1/7 } Tile{ AsIs: )/10 } Tile{ AsIs: t.ErrorList#1/5 } >/16 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & Fetch );
    refalrts::reinit_name( context[9], & refalrts::create_closure );
    refalrts::reinit_name( context[11], & gen_ParseBlock_S1L1 );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[14] );
    refalrts::link_brackets( context[15], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[7], context[8] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[9], context[13] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  // t.idx e.idx
  // </0 & ParseBlock/4 t.ErrorList#1/5 e.Tokens#1/2 >/1
  // closed e.Tokens#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & DoParseBlock/4 AsIs: t.ErrorList#1/5 } (/7 )/8 Tile{ AsIs: e.Tokens#1/2 } Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[8] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & DoParseBlock );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_ParseBlock(func_ParseBlock, "ParseBlock");
refalrts::RefalFunction& ParseBlock = descr_ParseBlock;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_DoParseBlock {
    static refalrts::RefalFunction *functions[] = {
      & ParseSentence,
      & DoParseBlock,
      & EL_AddErrorAt
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_Sentences<int>::name,
      & ident_TkEOF<int>::name,
      & ident_TkCloseBlock<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"expected EOF, expected \"}\"", 26}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 2, 0, 0},
      {refalrts::icIssueMemory, 25, 0, 0},
      //FAST GEN: e.$
      //GLOBAL GEN: t.$ ( e.$ ) e.$
      // </0 & DoParseBlock/4 t.idx#0/5 (/9 e.idxVB#0/7 )/10 e.idxVT#0/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::ictVarLeftSave, 0, 5, 2},
      {refalrts::icBracketLeftSave, 0, 7, 2},
      // closed e.idxVB#0 as range 7
      // closed e.idxVT#0 as range 2
      {refalrts::icOnFailGoTo, +15, 0, 0},
      // t.idx ( e.idx ) ( # TkCloseBlock s.idx ) e.idx
      // </0 & DoParseBlock/4 t.ErrorList#1/5 (/9 e.Sentences#1/7 )/10 (/13 # TkCloseBlock/15 s.LnNumber#1/16 )/14 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 23, 2},
      {refalrts::icBracketLeftSave, 0, 11, 23},
      {refalrts::icIdentLeftSave, 15, 2, 11},
      // closed e.Sentences#1 as range 7
      // closed e.Tail#1 as range 23(2)
      {refalrts::icsVarLeft, 0, 16, 11},
      {refalrts::icEmpty, 0, 0, 11},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} & DoParseBlock/4 {REMOVED TILE} {REMOVED TILE} (/13 # TkCloseBlock/15 s.LnNumber#1/16 )/14 {REMOVED TILE} >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: (/0 } Tile{ HalfReuse: # Sentences/9 AsIs: e.Sentences#1/7 AsIs: )/10 } Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: e.Tail#1/23(2) } Tile{ ]] }
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 0},
      {refalrts::icReinitIdent, 0, 0, 9},
      {refalrts::icLinkBrackets, 0, 10, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 23},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icSpliceTile, 9, 10, 0},
      {refalrts::icTrash, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +30, 0, 0},
      // t.idx ( e.idx ) ( # TkEOF s.idx ) e.idx
      // </0 & DoParseBlock/4 t.ErrorList#1/5 (/9 e.Sentences#1/7 )/10 (/13 # TkEOF/15 s.LnNum#1/16 )/14 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 23, 2},
      {refalrts::icBracketLeftSave, 0, 11, 23},
      {refalrts::icIdentLeftSave, 15, 1, 11},
      // closed e.Sentences#1 as range 7
      // closed e.Tail#1 as range 23(2)
      {refalrts::icsVarLeft, 0, 16, 11},
      {refalrts::icEmpty, 0, 0, 11},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } (/17 # Sentences/18 Tile{ AsIs: e.Sentences#1/7 } )/19 Tile{ AsIs: </0 Reuse: & EL-AddErrorAt/4 AsIs: t.ErrorList#1/5 HalfReuse: s.LnNum1 #16/9 } 'U'/20 Tile{ HalfReuse: 'n'/1 }"expected EOF, expected \"}\""/21 Tile{ HalfReuse: >/10 AsIs: (/13 AsIs: # TkEOF/15 AsIs: s.LnNum#1/16 AsIs: )/14 } Tile{ AsIs: e.Tail#1/23(2) } Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 17},
      {refalrts::icAllocIdent, 0, 0, 18},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 19},
      {refalrts::icAllocChar, 0, 'U', 20},
      {refalrts::icAllocString, 0, 0, 21},
      {refalrts::icUpdateFunc, 0, 2, 4},
      {refalrts::icReinitSVar, 0, 16, 9},
      {refalrts::icReinitChar, 0, 'n', 1},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 10},
      {refalrts::icLinkBrackets, 13, 14, 0},
      {refalrts::icPushStack, 0, 0, 10},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 17, 19, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 23},
      {refalrts::icSpliceTile, 10, 14, 0},
      {refalrts::icSpliceTile, 21, 22, 0},
      {refalrts::icSpliceTile, 1, 1, 0},
      {refalrts::icSpliceTile, 20, 20, 0},
      {refalrts::icSpliceTile, 0, 9, 0},
      {refalrts::icSpliceTile, 19, 19, 0},
      {refalrts::icSpliceEVar, 0, 0, 7},
      {refalrts::icSpliceTile, 17, 18, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // t.idx ( e.idx ) e.idx
      // </0 & DoParseBlock/4 t.ErrorList#1/5 (/9 e.Sentences#1/7 )/10 e.Tokens#1/2 >/1
      // closed e.Sentences#1 as range 7
      // closed e.Tokens#1 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </11 & DoParseBlock/12 Tile{ AsIs: </0 Reuse: & ParseSentence/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.Sentences#1/7 AsIs: )/10 AsIs: e.Tokens#1/2 AsIs: >/1 } >/13 Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 11},
      {refalrts::icAllocFunc, 0, 1, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 13},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icPushStack, 0, 0, 11},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 13, 13, 0},
      {refalrts::icSpliceTile, 0, 1, 0},
      {refalrts::icSpliceTile, 11, 12, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_DoParseBlock

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_DoParseBlock(
  "DoParseBlock",
  scope_DoParseBlock::raa,
  scope_DoParseBlock::functions,
  scope_DoParseBlock::idents,
  scope_DoParseBlock::numbers,
  scope_DoParseBlock::strings
);
refalrts::RefalFunction& DoParseBlock = descr_DoParseBlock;

} // unnamed namespace

#else
static refalrts::FnResult func_DoParseBlock(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 25 elems
  refalrts::Iter context[25];
  refalrts::zeros( context, 25 );
  //FAST GEN: e.$
  //GLOBAL GEN: t.$ ( e.$ ) e.$
  // </0 & DoParseBlock/4 t.idx#0/5 (/9 e.idxVB#0/7 )/10 e.idxVT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  context[7] = 0;
  context[8] = 0;
  context[9] = refalrts::brackets_left( context[7], context[8], context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[9], context[10]);
  // closed e.idxVB#0 as range 7
  // closed e.idxVT#0 as range 2
  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( # TkCloseBlock s.idx ) e.idx
    // </0 & DoParseBlock/4 t.ErrorList#1/5 (/9 e.Sentences#1/7 )/10 (/13 # TkCloseBlock/15 s.LnNumber#1/16 )/14 e.Tail#1/2 >/1
    context[23] = context[2];
    context[24] = context[3];
    context[11] = 0;
    context[12] = 0;
    context[13] = refalrts::brackets_left( context[11], context[12], context[23], context[24] );
    if( ! context[13] )
      continue;
    refalrts::bracket_pointers(context[13], context[14]);
    context[15] = refalrts::ident_left(  & ident_TkCloseBlock<int>::name, context[11], context[12] );
    if( ! context[15] )
      continue;
    // closed e.Sentences#1 as range 7
    // closed e.Tail#1 as range 23(2)
    if( ! refalrts::svar_left( context[16], context[11], context[12] ) )
      continue;
    if( ! refalrts::empty_seq( context[11], context[12] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} & DoParseBlock/4 {REMOVED TILE} {REMOVED TILE} (/13 # TkCloseBlock/15 s.LnNumber#1/16 )/14 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: (/0 } Tile{ HalfReuse: # Sentences/9 AsIs: e.Sentences#1/7 AsIs: )/10 } Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: e.Tail#1/23(2) } Tile{ ]] }
    refalrts::reinit_open_bracket( context[0] );
    refalrts::reinit_ident( context[9], & ident_Sentences<int>::name );
    refalrts::link_brackets( context[0], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[0], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( # TkEOF s.idx ) e.idx
    // </0 & DoParseBlock/4 t.ErrorList#1/5 (/9 e.Sentences#1/7 )/10 (/13 # TkEOF/15 s.LnNum#1/16 )/14 e.Tail#1/2 >/1
    context[23] = context[2];
    context[24] = context[3];
    context[11] = 0;
    context[12] = 0;
    context[13] = refalrts::brackets_left( context[11], context[12], context[23], context[24] );
    if( ! context[13] )
      continue;
    refalrts::bracket_pointers(context[13], context[14]);
    context[15] = refalrts::ident_left(  & ident_TkEOF<int>::name, context[11], context[12] );
    if( ! context[15] )
      continue;
    // closed e.Sentences#1 as range 7
    // closed e.Tail#1 as range 23(2)
    if( ! refalrts::svar_left( context[16], context[11], context[12] ) )
      continue;
    if( ! refalrts::empty_seq( context[11], context[12] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/17 # Sentences/18 Tile{ AsIs: e.Sentences#1/7 } )/19 Tile{ AsIs: </0 Reuse: & EL-AddErrorAt/4 AsIs: t.ErrorList#1/5 HalfReuse: s.LnNum1 #16/9 } 'U'/20 Tile{ HalfReuse: 'n'/1 }"expected EOF, expected \"}\""/21 Tile{ HalfReuse: >/10 AsIs: (/13 AsIs: # TkEOF/15 AsIs: s.LnNum#1/16 AsIs: )/14 } Tile{ AsIs: e.Tail#1/23(2) } Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[18], & ident_Sentences<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[20], 'U' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "expected EOF, expected \"}\"", 26 ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & EL_AddErrorAt );
    refalrts::reinit_svar( context[9], context[16] );
    refalrts::reinit_char( context[1], 'n' );
    refalrts::reinit_close_call( context[10] );
    refalrts::link_brackets( context[13], context[14] );
    refalrts::push_stack( context[10] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[17], context[19] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[10], context[14] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    res = refalrts::splice_evar( res, context[20], context[20] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[19], context[19] );
    res = refalrts::splice_evar( res, context[7], context[8] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  // t.idx ( e.idx ) e.idx
  // </0 & DoParseBlock/4 t.ErrorList#1/5 (/9 e.Sentences#1/7 )/10 e.Tokens#1/2 >/1
  // closed e.Sentences#1 as range 7
  // closed e.Tokens#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </11 & DoParseBlock/12 Tile{ AsIs: </0 Reuse: & ParseSentence/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.Sentences#1/7 AsIs: )/10 AsIs: e.Tokens#1/2 AsIs: >/1 } >/13 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[12], & DoParseBlock ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & ParseSentence );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[9], context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[13], context[13] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[11], context[12] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_DoParseBlock(func_DoParseBlock, "DoParseBlock");
refalrts::RefalFunction& DoParseBlock = descr_DoParseBlock;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseSentence_L1 {
    static refalrts::RefalFunction *functions[] = {
      & EL_AddUnexpected
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TkReplace<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 17, 0, 0},
      //FAST GEN: t.$ ( e.$ ) t.$ e.$
      //GLOBAL GEN: t.$ ( e.$ ) t.$ e.$
      // </0 & ParseSentence\1/4 t.idx#0/5 (/9 e.idxVB#0/7 )/10 t.idxVT#0/11 e.idxVTV#0/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::ictVarLeftSave, 0, 5, 2},
      {refalrts::icBracketLeftSave, 0, 7, 2},
      // closed e.idxVB#0 as range 7
      {refalrts::ictVarLeftSave, 0, 11, 2},
      // closed e.idxVTV#0 as range 2
      {refalrts::icOnFailGoTo, +11, 0, 0},
      // t.idx ( e.idx ) ( # TkReplace s.idx ) e.idx
      // </0 & ParseSentence\1/4 t.ErrorList#2/5 (/9 e.Pattern#2/7 )/10 (/11 # TkReplace/15 s.LnNum#2/16 )/12 e.Tokens#2/2 >/1
      {refalrts::icBracketTerm, 0, 13, 11},
      {refalrts::icIdentLeftSave, 15, 0, 13},
      // closed e.Pattern#2 as range 7
      // closed e.Tokens#2 as range 2
      {refalrts::icsVarLeft, 0, 16, 13},
      {refalrts::icEmpty, 0, 0, 13},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseSentence\1/4 {REMOVED TILE} (/11 # TkReplace/15 s.LnNum#2/16 )/12 {REMOVED TILE} >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: t.ErrorList#2/5 AsIs: (/9 AsIs: e.Pattern#2/7 AsIs: )/10 } Tile{ AsIs: e.Tokens#2/2 } Tile{ ]] }
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 5, 10, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // t.idx ( e.idx ) t.idx e.idx
      // </0 & ParseSentence\1/4 t.ErrorList#2/5 (/9 e.Pattern#2/7 )/10 t.NextResultToken#2/11 e.Tokens#2/2 >/1
      // closed e.Pattern#2 as range 7
      // closed e.Tokens#2 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & EL-AddUnexpected/4 AsIs: t.ErrorList#2/5 } t.NextResultToken#2/11/13 '='/15 Tile{ AsIs: >/1 } Tile{ AsIs: (/9 AsIs: e.Pattern#2/7 AsIs: )/10 AsIs: t.NextResultToken#2/11 } Tile{ AsIs: e.Tokens#2/2 } Tile{ ]] }
      {refalrts::icCopyEVar, 13, 11, 0},
      {refalrts::icAllocChar, 0, '=', 15},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 9, 12, 0},
      {refalrts::icSpliceTile, 1, 1, 0},
      {refalrts::icSpliceTile, 13, 15, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseSentence_L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseSentence_L1(
  "ParseSentence\\1",
  scope_gen_ParseSentence_L1::raa,
  scope_gen_ParseSentence_L1::functions,
  scope_gen_ParseSentence_L1::idents,
  scope_gen_ParseSentence_L1::numbers,
  scope_gen_ParseSentence_L1::strings
);
refalrts::RefalFunction& gen_ParseSentence_L1 = descr_gen_ParseSentence_L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseSentence_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 17 elems
  refalrts::Iter context[17];
  refalrts::zeros( context, 17 );
  //FAST GEN: t.$ ( e.$ ) t.$ e.$
  //GLOBAL GEN: t.$ ( e.$ ) t.$ e.$
  // </0 & ParseSentence\1/4 t.idx#0/5 (/9 e.idxVB#0/7 )/10 t.idxVT#0/11 e.idxVTV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  context[7] = 0;
  context[8] = 0;
  context[9] = refalrts::brackets_left( context[7], context[8], context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[9], context[10]);
  // closed e.idxVB#0 as range 7
  context[12] = refalrts::tvar_left( context[11], context[2], context[3] );
  if( ! context[12] )
    return refalrts::cRecognitionImpossible;
  // closed e.idxVTV#0 as range 2
  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( # TkReplace s.idx ) e.idx
    // </0 & ParseSentence\1/4 t.ErrorList#2/5 (/9 e.Pattern#2/7 )/10 (/11 # TkReplace/15 s.LnNum#2/16 )/12 e.Tokens#2/2 >/1
    context[13] = 0;
    context[14] = 0;
    if( ! refalrts::brackets_term( context[13], context[14], context[11] ) )
      continue;
    context[15] = refalrts::ident_left(  & ident_TkReplace<int>::name, context[13], context[14] );
    if( ! context[15] )
      continue;
    // closed e.Pattern#2 as range 7
    // closed e.Tokens#2 as range 2
    if( ! refalrts::svar_left( context[16], context[13], context[14] ) )
      continue;
    if( ! refalrts::empty_seq( context[13], context[14] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & ParseSentence\1/4 {REMOVED TILE} (/11 # TkReplace/15 s.LnNum#2/16 )/12 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: t.ErrorList#2/5 AsIs: (/9 AsIs: e.Pattern#2/7 AsIs: )/10 } Tile{ AsIs: e.Tokens#2/2 } Tile{ ]] }
    refalrts::link_brackets( context[9], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[5], context[10] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  // t.idx ( e.idx ) t.idx e.idx
  // </0 & ParseSentence\1/4 t.ErrorList#2/5 (/9 e.Pattern#2/7 )/10 t.NextResultToken#2/11 e.Tokens#2/2 >/1
  // closed e.Pattern#2 as range 7
  // closed e.Tokens#2 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & EL-AddUnexpected/4 AsIs: t.ErrorList#2/5 } t.NextResultToken#2/11/13 '='/15 Tile{ AsIs: >/1 } Tile{ AsIs: (/9 AsIs: e.Pattern#2/7 AsIs: )/10 AsIs: t.NextResultToken#2/11 } Tile{ AsIs: e.Tokens#2/2 } Tile{ ]] }
  if (! refalrts::copy_evar(context[13], context[14], context[11], context[12]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[15], '=' ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & EL_AddUnexpected );
  refalrts::link_brackets( context[9], context[10] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[9], context[12] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[13], context[15] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_gen_ParseSentence_L1(func_gen_ParseSentence_L1, "ParseSentence\\1");
refalrts::RefalFunction& gen_ParseSentence_L1 = descr_gen_ParseSentence_L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseSentence_L2 {
    static refalrts::RefalFunction *functions[] = {
      & ParseResult
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icIssueMemory, 15, 0, 0},
      // </0 & ParseSentence\2/4 t.ErrorList#2/5 (/9 e.Pattern#2/7 )/10 e.Tokens#2/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::ictVarLeftSave, 0, 5, 2},
      {refalrts::icBracketLeftSave, 0, 7, 2},
      // closed e.Pattern#2 as range 7
      // closed e.Tokens#2 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } (/11 Tile{ AsIs: e.Pattern#2/7 } )/12 Tile{ AsIs: </0 Reuse: & ParseResult/4 AsIs: t.ErrorList#2/5 AsIs: (/9 } )/13 (/14 Tile{ AsIs: )/10 AsIs: e.Tokens#2/2 AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 11},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 13},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 14},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 14, 10, 0},
      {refalrts::icLinkBrackets, 9, 13, 0},
      {refalrts::icLinkBrackets, 11, 12, 0},
      {refalrts::icSetRes, 0, 0, 10},
      {refalrts::icSpliceTile, 13, 14, 0},
      {refalrts::icSpliceTile, 0, 9, 0},
      {refalrts::icSpliceTile, 12, 12, 0},
      {refalrts::icSpliceEVar, 0, 0, 7},
      {refalrts::icSpliceTile, 11, 11, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseSentence_L2

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseSentence_L2(
  "ParseSentence\\2",
  scope_gen_ParseSentence_L2::raa,
  scope_gen_ParseSentence_L2::functions,
  scope_gen_ParseSentence_L2::idents,
  scope_gen_ParseSentence_L2::numbers,
  scope_gen_ParseSentence_L2::strings
);
refalrts::RefalFunction& gen_ParseSentence_L2 = descr_gen_ParseSentence_L2;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseSentence_L2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & ParseSentence\2/4 t.ErrorList#2/5 (/9 e.Pattern#2/7 )/10 e.Tokens#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  context[7] = 0;
  context[8] = 0;
  context[9] = refalrts::brackets_left( context[7], context[8], context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[9], context[10]);
  // closed e.Pattern#2 as range 7
  // closed e.Tokens#2 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } (/11 Tile{ AsIs: e.Pattern#2/7 } )/12 Tile{ AsIs: </0 Reuse: & ParseResult/4 AsIs: t.ErrorList#2/5 AsIs: (/9 } )/13 (/14 Tile{ AsIs: )/10 AsIs: e.Tokens#2/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & ParseResult );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[14], context[10] );
  refalrts::link_brackets( context[9], context[13] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[10];
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[0], context[9] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_gen_ParseSentence_L2(func_gen_ParseSentence_L2, "ParseSentence\\2");
refalrts::RefalFunction& gen_ParseSentence_L2 = descr_gen_ParseSentence_L2;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseSentence_L3 {
    static refalrts::RefalFunction *functions[] = {
      & EL_AddUnexpected,
      & EL_AddErrorAt
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TkEOF<int>::name,
      & ident_TkCloseBlock<int>::name,
      & ident_TkSemicolon<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"semicolo", 8},
      {"xpected EOF in functio", 22},
      {"Un", 2},
      {"sed semicolo", 12},
      {"Mi", 2}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 3, 0, 0},
      {refalrts::icIssueMemory, 36, 0, 0},
      //FAST GEN: e.$
      //GLOBAL GEN: ( e.$ ) ( e.$ ) t.$ ( e.$ ) t.$ e.$
      // </0 & ParseSentence\3/4 (/7 e.idxB#0/5 )/8 (/11 e.idxTB#0/9 )/12 t.idxTT#0/13 (/17 e.idxTTVB#0/15 )/18 t.idxTTVT#0/19 e.idxTTVTV#0/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icBracketLeftSave, 0, 5, 2},
      {refalrts::icBracketLeftSave, 0, 9, 2},
      // closed e.idxB#0 as range 5
      // closed e.idxTB#0 as range 9
      {refalrts::ictVarLeftSave, 0, 13, 2},
      {refalrts::icBracketLeftSave, 0, 15, 2},
      // closed e.idxTTVB#0 as range 15
      {refalrts::ictVarLeftSave, 0, 19, 2},
      // closed e.idxTTVTV#0 as range 2
      {refalrts::icOnFailGoTo, +19, 0, 0},
      // ( e.idx ) ( e.idx ) t.idx ( e.idx ) ( # TkSemicolon s.idx ) e.idx
      // </0 & ParseSentence\3/4 (/7 e.Sentences#1/5 )/8 (/11 e.Pattern#2/9 )/12 t.ErrorList#2/13 (/17 e.Result#2/15 )/18 (/19 # TkSemicolon/23 s.LnNum#2/24 )/20 e.Tokens#2/2 >/1
      {refalrts::icBracketTerm, 0, 21, 19},
      {refalrts::icIdentLeftSave, 23, 2, 21},
      // closed e.Sentences#1 as range 5
      // closed e.Pattern#2 as range 9
      // closed e.Result#2 as range 15
      // closed e.Tokens#2 as range 2
      {refalrts::icsVarLeft, 0, 24, 21},
      {refalrts::icEmpty, 0, 0, 21},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseSentence\3/4 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNum#2/24 )/20 {REMOVED TILE} >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: t.ErrorList#2/13 } Tile{ AsIs: (/7 AsIs: e.Sentences#1/5 HalfReuse: (/8 AsIs: (/11 AsIs: e.Pattern#2/9 AsIs: )/12 } Tile{ AsIs: (/17 AsIs: e.Result#2/15 AsIs: )/18 HalfReuse: )/19 HalfReuse: )/23 } Tile{ AsIs: e.Tokens#2/2 } Tile{ ]] }
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 8},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 19},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 23},
      {refalrts::icLinkBrackets, 7, 23, 0},
      {refalrts::icLinkBrackets, 8, 19, 0},
      {refalrts::icLinkBrackets, 17, 18, 0},
      {refalrts::icLinkBrackets, 11, 12, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 17, 23, 0},
      {refalrts::icSpliceTile, 7, 12, 0},
      {refalrts::icSpliceTile, 13, 14, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +37, 0, 0},
      // ( e.idx ) ( e.idx ) t.idx ( e.idx ) ( # TkCloseBlock s.idx ) e.idx
      // </0 & ParseSentence\3/4 (/7 e.Sentences#1/5 )/8 (/11 e.Pattern#2/9 )/12 t.ErrorList#2/13 (/17 e.Result#2/15 )/18 (/19 # TkCloseBlock/23 s.LnNum#2/24 )/20 e.Tokens#2/2 >/1
      {refalrts::icBracketTerm, 0, 21, 19},
      {refalrts::icIdentLeftSave, 23, 1, 21},
      // closed e.Sentences#1 as range 5
      // closed e.Pattern#2 as range 9
      // closed e.Result#2 as range 15
      // closed e.Tokens#2 as range 2
      {refalrts::icsVarLeft, 0, 24, 21},
      {refalrts::icEmpty, 0, 0, 21},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </25 & EL-AddErrorAt/26 Tile{ AsIs: t.ErrorList#2/13 HalfReuse: s.LnNum2 #24/17 }"Mi"/27 Tile{ HalfReuse: 's'/1 }"sed semicolo"/29 Tile{ HalfReuse: 'n'/0 HalfReuse: >/4 AsIs: (/7 AsIs: e.Sentences#1/5 HalfReuse: (/8 AsIs: (/11 AsIs: e.Pattern#2/9 AsIs: )/12 } (/31 Tile{ AsIs: e.Result#2/15 } )/32 )/33 Tile{ AsIs: )/18 AsIs: (/19 AsIs: # TkCloseBlock/23 AsIs: s.LnNum#2/24 AsIs: )/20 } Tile{ AsIs: e.Tokens#2/2 } Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 25},
      {refalrts::icAllocFunc, 0, 1, 26},
      {refalrts::icAllocString, 0, 4, 27},
      {refalrts::icAllocString, 0, 3, 29},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 31},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 32},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 33},
      {refalrts::icReinitSVar, 0, 24, 17},
      {refalrts::icReinitChar, 0, 's', 1},
      {refalrts::icReinitChar, 0, 'n', 0},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 8},
      {refalrts::icLinkBrackets, 19, 20, 0},
      {refalrts::icLinkBrackets, 7, 18, 0},
      {refalrts::icLinkBrackets, 8, 33, 0},
      {refalrts::icLinkBrackets, 31, 32, 0},
      {refalrts::icLinkBrackets, 11, 12, 0},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 25},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 18, 20, 0},
      {refalrts::icSpliceTile, 32, 33, 0},
      {refalrts::icSpliceEVar, 0, 0, 15},
      {refalrts::icSpliceTile, 31, 31, 0},
      {refalrts::icSpliceTile, 0, 12, 0},
      {refalrts::icSpliceTile, 29, 30, 0},
      {refalrts::icSpliceTile, 1, 1, 0},
      {refalrts::icSpliceTile, 27, 28, 0},
      {refalrts::icSpliceTile, 13, 17, 0},
      {refalrts::icSpliceTile, 25, 26, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +38, 0, 0},
      // ( e.idx ) ( e.idx ) t.idx ( e.idx ) ( # TkEOF s.idx )
      // </0 & ParseSentence\3/4 (/7 e.Sentences#1/5 )/8 (/11 e.Pattern#2/9 )/12 t.ErrorList#2/13 (/17 e.Result#2/15 )/18 (/19 # TkEOF/23 s.LnNum#2/24 )/20 >/1
      {refalrts::icBracketTerm, 0, 21, 19},
      {refalrts::icIdentLeftSave, 23, 0, 21},
      {refalrts::icSave, 0, 34, 2},
      {refalrts::icEmpty, 0, 0, 34},
      // closed e.Sentences#1 as range 5
      // closed e.Pattern#2 as range 9
      // closed e.Result#2 as range 15
      {refalrts::icsVarLeft, 0, 24, 21},
      {refalrts::icEmpty, 0, 0, 21},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </25 & EL-AddErrorAt/26 Tile{ AsIs: t.ErrorList#2/13 HalfReuse: s.LnNum2 #24/17 }"Un"/27 Tile{ HalfReuse: 'e'/1 }"xpected EOF in functio"/29 Tile{ HalfReuse: 'n'/0 HalfReuse: >/4 AsIs: (/7 AsIs: e.Sentences#1/5 HalfReuse: (/8 AsIs: (/11 AsIs: e.Pattern#2/9 AsIs: )/12 } (/31 Tile{ AsIs: e.Result#2/15 } )/32 )/33 Tile{ AsIs: )/18 AsIs: (/19 AsIs: # TkEOF/23 AsIs: s.LnNum#2/24 AsIs: )/20 } Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 25},
      {refalrts::icAllocFunc, 0, 1, 26},
      {refalrts::icAllocString, 0, 2, 27},
      {refalrts::icAllocString, 0, 1, 29},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 31},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 32},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 33},
      {refalrts::icReinitSVar, 0, 24, 17},
      {refalrts::icReinitChar, 0, 'e', 1},
      {refalrts::icReinitChar, 0, 'n', 0},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 8},
      {refalrts::icLinkBrackets, 19, 20, 0},
      {refalrts::icLinkBrackets, 7, 18, 0},
      {refalrts::icLinkBrackets, 8, 33, 0},
      {refalrts::icLinkBrackets, 31, 32, 0},
      {refalrts::icLinkBrackets, 11, 12, 0},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 25},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 18, 20, 0},
      {refalrts::icSpliceTile, 32, 33, 0},
      {refalrts::icSpliceEVar, 0, 0, 15},
      {refalrts::icSpliceTile, 31, 31, 0},
      {refalrts::icSpliceTile, 0, 12, 0},
      {refalrts::icSpliceTile, 29, 30, 0},
      {refalrts::icSpliceTile, 1, 1, 0},
      {refalrts::icSpliceTile, 27, 28, 0},
      {refalrts::icSpliceTile, 13, 17, 0},
      {refalrts::icSpliceTile, 25, 26, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // ( e.idx ) ( e.idx ) t.idx ( e.idx ) t.idx e.idx
      // </0 & ParseSentence\3/4 (/7 e.Sentences#1/5 )/8 (/11 e.Pattern#2/9 )/12 t.ErrorList#2/13 (/17 e.Result#2/15 )/18 t.Unexpected#2/19 e.Tokens#2/2 >/1
      // closed e.Sentences#1 as range 5
      // closed e.Pattern#2 as range 9
      // closed e.Result#2 as range 15
      // closed e.Tokens#2 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </21 Tile{ HalfReuse: & EL-AddUnexpected/1 } Tile{ AsIs: t.ErrorList#2/13 } Tile{ AsIs: t.Unexpected#2/19 }"semicolo"/22 Tile{ HalfReuse: 'n'/0 HalfReuse: >/4 AsIs: (/7 AsIs: e.Sentences#1/5 HalfReuse: (/8 AsIs: (/11 AsIs: e.Pattern#2/9 AsIs: )/12 } Tile{ AsIs: (/17 AsIs: e.Result#2/15 AsIs: )/18 } )/24 )/25 Tile{ AsIs: e.Tokens#2/2 } Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 21},
      {refalrts::icAllocString, 0, 0, 22},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 24},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 25},
      {refalrts::icReinitFunc, 0, 0, 1},
      {refalrts::icReinitChar, 0, 'n', 0},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 8},
      {refalrts::icLinkBrackets, 7, 25, 0},
      {refalrts::icLinkBrackets, 8, 24, 0},
      {refalrts::icLinkBrackets, 17, 18, 0},
      {refalrts::icLinkBrackets, 11, 12, 0},
      {refalrts::icPushStack, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 21},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 24, 25, 0},
      {refalrts::icSpliceTile, 17, 18, 0},
      {refalrts::icSpliceTile, 0, 12, 0},
      {refalrts::icSpliceTile, 22, 23, 0},
      {refalrts::icSpliceTile, 19, 20, 0},
      {refalrts::icSpliceTile, 13, 14, 0},
      {refalrts::icSpliceTile, 1, 1, 0},
      {refalrts::icSpliceTile, 21, 21, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseSentence_L3

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseSentence_L3(
  "ParseSentence\\3",
  scope_gen_ParseSentence_L3::raa,
  scope_gen_ParseSentence_L3::functions,
  scope_gen_ParseSentence_L3::idents,
  scope_gen_ParseSentence_L3::numbers,
  scope_gen_ParseSentence_L3::strings
);
refalrts::RefalFunction& gen_ParseSentence_L3 = descr_gen_ParseSentence_L3;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseSentence_L3(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 36 elems
  refalrts::Iter context[36];
  refalrts::zeros( context, 36 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) ( e.$ ) t.$ ( e.$ ) t.$ e.$
  // </0 & ParseSentence\3/4 (/7 e.idxB#0/5 )/8 (/11 e.idxTB#0/9 )/12 t.idxTT#0/13 (/17 e.idxTTVB#0/15 )/18 t.idxTTVT#0/19 e.idxTTVTV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.idxB#0 as range 5
  // closed e.idxTB#0 as range 9
  context[14] = refalrts::tvar_left( context[13], context[2], context[3] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  context[15] = 0;
  context[16] = 0;
  context[17] = refalrts::brackets_left( context[15], context[16], context[2], context[3] );
  if( ! context[17] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[17], context[18]);
  // closed e.idxTTVB#0 as range 15
  context[20] = refalrts::tvar_left( context[19], context[2], context[3] );
  if( ! context[20] )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTTVTV#0 as range 2
  do {
    refalrts::start_sentence();
    // ( e.idx ) ( e.idx ) t.idx ( e.idx ) ( # TkSemicolon s.idx ) e.idx
    // </0 & ParseSentence\3/4 (/7 e.Sentences#1/5 )/8 (/11 e.Pattern#2/9 )/12 t.ErrorList#2/13 (/17 e.Result#2/15 )/18 (/19 # TkSemicolon/23 s.LnNum#2/24 )/20 e.Tokens#2/2 >/1
    context[21] = 0;
    context[22] = 0;
    if( ! refalrts::brackets_term( context[21], context[22], context[19] ) )
      continue;
    context[23] = refalrts::ident_left(  & ident_TkSemicolon<int>::name, context[21], context[22] );
    if( ! context[23] )
      continue;
    // closed e.Sentences#1 as range 5
    // closed e.Pattern#2 as range 9
    // closed e.Result#2 as range 15
    // closed e.Tokens#2 as range 2
    if( ! refalrts::svar_left( context[24], context[21], context[22] ) )
      continue;
    if( ! refalrts::empty_seq( context[21], context[22] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & ParseSentence\3/4 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNum#2/24 )/20 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: t.ErrorList#2/13 } Tile{ AsIs: (/7 AsIs: e.Sentences#1/5 HalfReuse: (/8 AsIs: (/11 AsIs: e.Pattern#2/9 AsIs: )/12 } Tile{ AsIs: (/17 AsIs: e.Result#2/15 AsIs: )/18 HalfReuse: )/19 HalfReuse: )/23 } Tile{ AsIs: e.Tokens#2/2 } Tile{ ]] }
    refalrts::reinit_open_bracket( context[8] );
    refalrts::reinit_close_bracket( context[19] );
    refalrts::reinit_close_bracket( context[23] );
    refalrts::link_brackets( context[7], context[23] );
    refalrts::link_brackets( context[8], context[19] );
    refalrts::link_brackets( context[17], context[18] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[17], context[23] );
    res = refalrts::splice_evar( res, context[7], context[12] );
    res = refalrts::splice_evar( res, context[13], context[14] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // ( e.idx ) ( e.idx ) t.idx ( e.idx ) ( # TkCloseBlock s.idx ) e.idx
    // </0 & ParseSentence\3/4 (/7 e.Sentences#1/5 )/8 (/11 e.Pattern#2/9 )/12 t.ErrorList#2/13 (/17 e.Result#2/15 )/18 (/19 # TkCloseBlock/23 s.LnNum#2/24 )/20 e.Tokens#2/2 >/1
    context[21] = 0;
    context[22] = 0;
    if( ! refalrts::brackets_term( context[21], context[22], context[19] ) )
      continue;
    context[23] = refalrts::ident_left(  & ident_TkCloseBlock<int>::name, context[21], context[22] );
    if( ! context[23] )
      continue;
    // closed e.Sentences#1 as range 5
    // closed e.Pattern#2 as range 9
    // closed e.Result#2 as range 15
    // closed e.Tokens#2 as range 2
    if( ! refalrts::svar_left( context[24], context[21], context[22] ) )
      continue;
    if( ! refalrts::empty_seq( context[21], context[22] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </25 & EL-AddErrorAt/26 Tile{ AsIs: t.ErrorList#2/13 HalfReuse: s.LnNum2 #24/17 }"Mi"/27 Tile{ HalfReuse: 's'/1 }"sed semicolo"/29 Tile{ HalfReuse: 'n'/0 HalfReuse: >/4 AsIs: (/7 AsIs: e.Sentences#1/5 HalfReuse: (/8 AsIs: (/11 AsIs: e.Pattern#2/9 AsIs: )/12 } (/31 Tile{ AsIs: e.Result#2/15 } )/32 )/33 Tile{ AsIs: )/18 AsIs: (/19 AsIs: # TkCloseBlock/23 AsIs: s.LnNum#2/24 AsIs: )/20 } Tile{ AsIs: e.Tokens#2/2 } Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], & EL_AddErrorAt ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], "Mi", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[29], context[30], "sed semicolo", 12 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[33] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_svar( context[17], context[24] );
    refalrts::reinit_char( context[1], 's' );
    refalrts::reinit_char( context[0], 'n' );
    refalrts::reinit_close_call( context[4] );
    refalrts::reinit_open_bracket( context[8] );
    refalrts::link_brackets( context[19], context[20] );
    refalrts::link_brackets( context[7], context[18] );
    refalrts::link_brackets( context[8], context[33] );
    refalrts::link_brackets( context[31], context[32] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::push_stack( context[4] );
    refalrts::push_stack( context[25] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[18], context[20] );
    res = refalrts::splice_evar( res, context[32], context[33] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[31], context[31] );
    res = refalrts::splice_evar( res, context[0], context[12] );
    res = refalrts::splice_evar( res, context[29], context[30] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    res = refalrts::splice_evar( res, context[27], context[28] );
    res = refalrts::splice_evar( res, context[13], context[17] );
    res = refalrts::splice_evar( res, context[25], context[26] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // ( e.idx ) ( e.idx ) t.idx ( e.idx ) ( # TkEOF s.idx )
    // </0 & ParseSentence\3/4 (/7 e.Sentences#1/5 )/8 (/11 e.Pattern#2/9 )/12 t.ErrorList#2/13 (/17 e.Result#2/15 )/18 (/19 # TkEOF/23 s.LnNum#2/24 )/20 >/1
    context[21] = 0;
    context[22] = 0;
    if( ! refalrts::brackets_term( context[21], context[22], context[19] ) )
      continue;
    context[23] = refalrts::ident_left(  & ident_TkEOF<int>::name, context[21], context[22] );
    if( ! context[23] )
      continue;
    context[34] = context[2];
    context[35] = context[3];
    if( ! refalrts::empty_seq( context[34], context[35] ) )
      continue;
    // closed e.Sentences#1 as range 5
    // closed e.Pattern#2 as range 9
    // closed e.Result#2 as range 15
    if( ! refalrts::svar_left( context[24], context[21], context[22] ) )
      continue;
    if( ! refalrts::empty_seq( context[21], context[22] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </25 & EL-AddErrorAt/26 Tile{ AsIs: t.ErrorList#2/13 HalfReuse: s.LnNum2 #24/17 }"Un"/27 Tile{ HalfReuse: 'e'/1 }"xpected EOF in functio"/29 Tile{ HalfReuse: 'n'/0 HalfReuse: >/4 AsIs: (/7 AsIs: e.Sentences#1/5 HalfReuse: (/8 AsIs: (/11 AsIs: e.Pattern#2/9 AsIs: )/12 } (/31 Tile{ AsIs: e.Result#2/15 } )/32 )/33 Tile{ AsIs: )/18 AsIs: (/19 AsIs: # TkEOF/23 AsIs: s.LnNum#2/24 AsIs: )/20 } Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], & EL_AddErrorAt ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], "Un", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[29], context[30], "xpected EOF in functio", 22 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[33] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_svar( context[17], context[24] );
    refalrts::reinit_char( context[1], 'e' );
    refalrts::reinit_char( context[0], 'n' );
    refalrts::reinit_close_call( context[4] );
    refalrts::reinit_open_bracket( context[8] );
    refalrts::link_brackets( context[19], context[20] );
    refalrts::link_brackets( context[7], context[18] );
    refalrts::link_brackets( context[8], context[33] );
    refalrts::link_brackets( context[31], context[32] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::push_stack( context[4] );
    refalrts::push_stack( context[25] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[18], context[20] );
    res = refalrts::splice_evar( res, context[32], context[33] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[31], context[31] );
    res = refalrts::splice_evar( res, context[0], context[12] );
    res = refalrts::splice_evar( res, context[29], context[30] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    res = refalrts::splice_evar( res, context[27], context[28] );
    res = refalrts::splice_evar( res, context[13], context[17] );
    res = refalrts::splice_evar( res, context[25], context[26] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  // ( e.idx ) ( e.idx ) t.idx ( e.idx ) t.idx e.idx
  // </0 & ParseSentence\3/4 (/7 e.Sentences#1/5 )/8 (/11 e.Pattern#2/9 )/12 t.ErrorList#2/13 (/17 e.Result#2/15 )/18 t.Unexpected#2/19 e.Tokens#2/2 >/1
  // closed e.Sentences#1 as range 5
  // closed e.Pattern#2 as range 9
  // closed e.Result#2 as range 15
  // closed e.Tokens#2 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </21 Tile{ HalfReuse: & EL-AddUnexpected/1 } Tile{ AsIs: t.ErrorList#2/13 } Tile{ AsIs: t.Unexpected#2/19 }"semicolo"/22 Tile{ HalfReuse: 'n'/0 HalfReuse: >/4 AsIs: (/7 AsIs: e.Sentences#1/5 HalfReuse: (/8 AsIs: (/11 AsIs: e.Pattern#2/9 AsIs: )/12 } Tile{ AsIs: (/17 AsIs: e.Result#2/15 AsIs: )/18 } )/24 )/25 Tile{ AsIs: e.Tokens#2/2 } Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[22], context[23], "semicolo", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[24] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[25] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[1], & EL_AddUnexpected );
  refalrts::reinit_char( context[0], 'n' );
  refalrts::reinit_close_call( context[4] );
  refalrts::reinit_open_bracket( context[8] );
  refalrts::link_brackets( context[7], context[25] );
  refalrts::link_brackets( context[8], context[24] );
  refalrts::link_brackets( context[17], context[18] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::push_stack( context[4] );
  refalrts::push_stack( context[21] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[24], context[25] );
  res = refalrts::splice_evar( res, context[17], context[18] );
  res = refalrts::splice_evar( res, context[0], context[12] );
  res = refalrts::splice_evar( res, context[22], context[23] );
  res = refalrts::splice_evar( res, context[19], context[20] );
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[21], context[21] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_gen_ParseSentence_L3(func_gen_ParseSentence_L3, "ParseSentence\\3");
refalrts::RefalFunction& gen_ParseSentence_L3 = descr_gen_ParseSentence_L3;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseSentence {
    static refalrts::RefalFunction *functions[] = {
      & ParsePattern,
      & gen_ParseSentence_L3,
      & refalrts::create_closure,
      & gen_ParseSentence_L2,
      & gen_ParseSentence_L1,
      & Seq,
      & Fetch
    };
    using refalrts::idents;
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icIssueMemory, 27, 0, 0},
      // </0 & ParseSentence/4 t.ErrorList#1/5 (/9 e.Sentences#1/7 )/10 e.Tokens#1/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::ictVarLeftSave, 0, 5, 2},
      {refalrts::icBracketLeftSave, 0, 7, 2},
      // closed e.Sentences#1 as range 7
      // closed e.Tokens#1 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </11 & Fetch/12 Tile{ AsIs: </0 Reuse: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 } )/13 (/14 Tile{ AsIs: )/10 AsIs: e.Tokens#1/2 AsIs: >/1 } </15 & Seq/16 & ParseSentence\1/17 & ParseSentence\2/18 </19 & @create_closure@/20 & ParseSentence\3/21 (/22 Tile{ AsIs: e.Sentences#1/7 } )/23 >/24 >/25 >/26 Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 11},
      {refalrts::icAllocFunc, 0, 6, 12},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 13},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 14},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 15},
      {refalrts::icAllocFunc, 0, 5, 16},
      {refalrts::icAllocFunc, 0, 4, 17},
      {refalrts::icAllocFunc, 0, 3, 18},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 19},
      {refalrts::icAllocFunc, 0, 2, 20},
      {refalrts::icAllocFunc, 0, 1, 21},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 22},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 23},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 24},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 25},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 26},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icPushStack, 0, 0, 26},
      {refalrts::icPushStack, 0, 0, 11},
      {refalrts::icPushStack, 0, 0, 25},
      {refalrts::icPushStack, 0, 0, 15},
      {refalrts::icPushStack, 0, 0, 24},
      {refalrts::icPushStack, 0, 0, 19},
      {refalrts::icLinkBrackets, 22, 23, 0},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 14, 10, 0},
      {refalrts::icLinkBrackets, 9, 13, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 23, 26, 0},
      {refalrts::icSpliceEVar, 0, 0, 7},
      {refalrts::icSpliceTile, 15, 22, 0},
      {refalrts::icSpliceTile, 10, 1, 0},
      {refalrts::icSpliceTile, 13, 14, 0},
      {refalrts::icSpliceTile, 0, 9, 0},
      {refalrts::icSpliceTile, 11, 12, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseSentence

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseSentence(
  "ParseSentence",
  scope_ParseSentence::raa,
  scope_ParseSentence::functions,
  scope_ParseSentence::idents,
  scope_ParseSentence::numbers,
  scope_ParseSentence::strings
);
refalrts::RefalFunction& ParseSentence = descr_ParseSentence;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseSentence(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 27 elems
  refalrts::Iter context[27];
  refalrts::zeros( context, 27 );
  // </0 & ParseSentence/4 t.ErrorList#1/5 (/9 e.Sentences#1/7 )/10 e.Tokens#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  context[7] = 0;
  context[8] = 0;
  context[9] = refalrts::brackets_left( context[7], context[8], context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[9], context[10]);
  // closed e.Sentences#1 as range 7
  // closed e.Tokens#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </11 & Fetch/12 Tile{ AsIs: </0 Reuse: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 } )/13 (/14 Tile{ AsIs: )/10 AsIs: e.Tokens#1/2 AsIs: >/1 } </15 & Seq/16 & ParseSentence\1/17 & ParseSentence\2/18 </19 & @create_closure@/20 & ParseSentence\3/21 (/22 Tile{ AsIs: e.Sentences#1/7 } )/23 >/24 >/25 >/26 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[12], & Fetch ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[16], & Seq ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[17], & gen_ParseSentence_L1 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[18], & gen_ParseSentence_L2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[20], & refalrts::create_closure ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[21], & gen_ParseSentence_L3 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[23] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[24] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[25] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[26] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & ParsePattern );
  refalrts::push_stack( context[26] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[25] );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[19] );
  refalrts::link_brackets( context[22], context[23] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[14], context[10] );
  refalrts::link_brackets( context[9], context[13] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[23], context[26] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  res = refalrts::splice_evar( res, context[15], context[22] );
  res = refalrts::splice_evar( res, context[10], context[1] );
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[0], context[9] );
  res = refalrts::splice_evar( res, context[11], context[12] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_ParseSentence(func_ParseSentence, "ParseSentence");
refalrts::RefalFunction& ParseSentence = descr_ParseSentence;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParsePattern {
    static refalrts::RefalFunction *functions[] = {
      & EL_AddErrorAt,
      & StrFromBracket,
      & ParsePattern
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_Close<int>::name,
      & ident_TkCloseCall<int>::name,
      & ident_Brackets<int>::name,
      & ident_TkOpenCall<int>::name,
      & ident_Open<int>::name,
      & ident_UnnamedADT<int>::name,
      & ident_TkCloseADT<int>::name,
      & ident_ADT_Brackets<int>::name,
      & ident_TkOpenADT<int>::name,
      & ident_TkName<int>::name,
      & ident_TkCloseBracket<int>::name,
      & ident_TkOpenBracket<int>::name,
      & ident_TkRedefinition<int>::name,
      & ident_TkVariable<int>::name,
      & ident_TkNewVariable<int>::name,
      & ident_TkIdentMarker<int>::name,
      & ident_TkIdentifier<int>::name,
      & ident_TkNumber<int>::name,
      & ident_TkChar<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"Unbalanced bracket \"", 20},
      {"anced bracket \"", 15},
      {"Unb", 3},
      {"Unexpected call bracket in pattern expression", 45},
      {"Expected name after \"[\"", 23},
      {" redefinition sign", 18},
      {"ak", 2},
      {"d name after \'#\'", 16},
      {"is", 2}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 16, 0, 0},
      {refalrts::icIssueMemory, 44, 0, 0},
      //FAST GEN: e.$
      //GLOBAL GEN: t.$ ( e.$ ) ( e.$ ) e.$
      // </0 & ParsePattern/4 t.idx#0/5 (/9 e.idxVB#0/7 )/10 (/13 e.idxVTB#0/11 )/14 e.idxVTT#0/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::ictVarLeftSave, 0, 5, 2},
      {refalrts::icBracketLeftSave, 0, 7, 2},
      {refalrts::icBracketLeftSave, 0, 11, 2},
      // closed e.idxVB#0 as range 7
      // closed e.idxVTB#0 as range 11
      // closed e.idxVTT#0 as range 2
      {refalrts::icOnFailGoTo, +20, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # TkChar s.idx s.idx ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBrackets#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkChar/19 s.LnNum#1/20 s.Char#1/21 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 2},
      {refalrts::icBracketLeftSave, 0, 15, 40},
      {refalrts::icIdentLeftSave, 19, 18, 15},
      // closed e.MultiBrackets#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 40(2)
      {refalrts::icsVarLeft, 0, 20, 15},
      {refalrts::icsVarLeft, 0, 21, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.LnNum#1/20 s.Char#1/21 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBrackets#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkChar/17 HalfReuse: s.Char1 #21/19 } )/22 Tile{ AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 22},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 14},
      {refalrts::icReinitIdent, 0, 18, 17},
      {refalrts::icReinitSVar, 0, 21, 19},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 18, 0},
      {refalrts::icLinkBrackets, 14, 22, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icSetRes, 0, 0, 18},
      {refalrts::icSpliceTile, 22, 22, 0},
      {refalrts::icTrash, 0, 0, 19},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +20, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # TkNumber s.idx s.idx ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBrackets#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkNumber/19 s.LnNum#1/20 s.Number#1/21 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 2},
      {refalrts::icBracketLeftSave, 0, 15, 40},
      {refalrts::icIdentLeftSave, 19, 17, 15},
      // closed e.MultiBrackets#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 40(2)
      {refalrts::icsVarLeft, 0, 20, 15},
      {refalrts::icsVarLeft, 0, 21, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.LnNum#1/20 s.Number#1/21 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBrackets#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkNumber/17 HalfReuse: s.Number1 #21/19 } )/22 Tile{ AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 22},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 14},
      {refalrts::icReinitIdent, 0, 17, 17},
      {refalrts::icReinitSVar, 0, 21, 19},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 18, 0},
      {refalrts::icLinkBrackets, 14, 22, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icSetRes, 0, 0, 18},
      {refalrts::icSpliceTile, 22, 22, 0},
      {refalrts::icTrash, 0, 0, 19},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +19, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # TkName s.idx e.idx ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBrackets#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkName/19 s.LnNum#1/20 e.Name#1/15 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 2},
      {refalrts::icBracketLeftSave, 0, 15, 40},
      {refalrts::icIdentLeftSave, 19, 9, 15},
      // closed e.MultiBrackets#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 40(2)
      {refalrts::icsVarLeft, 0, 20, 15},
      // closed e.Name#1 as range 15
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.LnNum#1/20 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBrackets#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkName/17 HalfReuse: s.LnNum1 #20/19 } Tile{ AsIs: e.Name#1/15 } )/21 Tile{ AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 21},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 14},
      {refalrts::icReinitIdent, 0, 9, 17},
      {refalrts::icReinitSVar, 0, 20, 19},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 18, 0},
      {refalrts::icLinkBrackets, 14, 21, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icSetRes, 0, 0, 18},
      {refalrts::icSpliceTile, 21, 21, 0},
      {refalrts::icSpliceEVar, 0, 0, 15},
      {refalrts::icTrash, 0, 0, 19},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +21, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # TkIdentMarker s.idx ) ( # TkName s.idx e.idx ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBrackets#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkIdentMarker/19 s.LnNumMarker#1/25 )/18 (/22 # TkName/24 s.LnNumName#1/26 e.Name#1/20 )/23 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 2},
      {refalrts::icBracketLeftSave, 0, 15, 40},
      {refalrts::icIdentLeftSave, 19, 15, 15},
      {refalrts::icBracketLeftSave, 0, 20, 40},
      {refalrts::icIdentLeftSave, 24, 9, 20},
      // closed e.MultiBrackets#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 40(2)
      {refalrts::icsVarLeft, 0, 25, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icsVarLeft, 0, 26, 20},
      // closed e.Name#1 as range 20
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} # TkIdentMarker/19 s.LnNumMarker#1/25 {REMOVED TILE} (/22 # TkName/24 s.LnNumName#1/26 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBrackets#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkIdentifier/17 } Tile{ AsIs: e.Name#1/20 } Tile{ AsIs: )/18 } Tile{ AsIs: )/23 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 14},
      {refalrts::icReinitIdent, 0, 16, 17},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 23, 0},
      {refalrts::icLinkBrackets, 14, 18, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icSetRes, 0, 0, 23},
      {refalrts::icSpliceTile, 18, 18, 0},
      {refalrts::icSpliceEVar, 0, 0, 20},
      {refalrts::icTrash, 0, 0, 17},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +30, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # TkIdentMarker s.idx ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBrackets#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkIdentMarker/19 s.LnNum#1/20 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 2},
      {refalrts::icBracketLeftSave, 0, 15, 40},
      {refalrts::icIdentLeftSave, 19, 15, 15},
      // closed e.MultiBrackets#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 40(2)
      {refalrts::icsVarLeft, 0, 20, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 } </21 & EL-AddErrorAt/22 Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: s.LnNum#1/20 HalfReuse: 'M'/18 }"is"/23 Tile{ HalfReuse: 's'/17 HalfReuse: 'e'/19 }"d name after \'#\'"/25 >/27 Tile{ AsIs: (/9 AsIs: e.MultiBrackets#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 AsIs: )/14 } Tile{ AsIs: e.Tail#1/40(2) } Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 21},
      {refalrts::icAllocFunc, 0, 0, 22},
      {refalrts::icAllocString, 0, 8, 23},
      {refalrts::icAllocString, 0, 7, 25},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 27},
      {refalrts::icReinitChar, 0, 'M', 18},
      {refalrts::icReinitChar, 0, 's', 17},
      {refalrts::icReinitChar, 0, 'e', 19},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 14, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icPushStack, 0, 0, 27},
      {refalrts::icPushStack, 0, 0, 21},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 40},
      {refalrts::icSpliceTile, 9, 14, 0},
      {refalrts::icSpliceTile, 25, 27, 0},
      {refalrts::icSpliceTile, 17, 19, 0},
      {refalrts::icSpliceTile, 23, 24, 0},
      {refalrts::icSpliceTile, 20, 18, 0},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icSpliceTile, 21, 22, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +22, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # TkVariable s.idx s.idx e.idx ) ( # TkRedefinition s.idx ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkVariable/19 s.LnNumVar#1/25 s.Mode#1/26 e.Index#1/15 )/18 (/22 # TkRedefinition/24 s.LnNumRedef#1/27 )/23 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 2},
      {refalrts::icBracketLeftSave, 0, 15, 40},
      {refalrts::icIdentLeftSave, 19, 13, 15},
      {refalrts::icBracketLeftSave, 0, 20, 40},
      {refalrts::icIdentLeftSave, 24, 12, 20},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 40(2)
      {refalrts::icsVarLeft, 0, 25, 15},
      {refalrts::icsVarLeft, 0, 26, 15},
      // closed e.Index#1 as range 15
      {refalrts::icsVarLeft, 0, 27, 20},
      {refalrts::icEmpty, 0, 0, 20},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.LnNumVar#1/25 {REMOVED TILE} (/22 # TkRedefinition/24 s.LnNumRedef#1/27 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkNewVariable/17 HalfReuse: s.LnNumVar1 #25/19 } Tile{ AsIs: s.Mode#1/26 AsIs: e.Index#1/15 AsIs: )/18 } Tile{ AsIs: )/23 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 14},
      {refalrts::icReinitIdent, 0, 14, 17},
      {refalrts::icReinitSVar, 0, 25, 19},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 23, 0},
      {refalrts::icLinkBrackets, 14, 18, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icSetRes, 0, 0, 23},
      {refalrts::icSpliceTile, 26, 18, 0},
      {refalrts::icTrash, 0, 0, 19},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +21, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # TkVariable s.idx s.idx e.idx ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkVariable/19 s.LnNum#1/20 s.Mode#1/21 e.Index#1/15 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 2},
      {refalrts::icBracketLeftSave, 0, 15, 40},
      {refalrts::icIdentLeftSave, 19, 13, 15},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 40(2)
      {refalrts::icsVarLeft, 0, 20, 15},
      {refalrts::icsVarLeft, 0, 21, 15},
      // closed e.Index#1 as range 15
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.LnNum#1/20 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkVariable/17 HalfReuse: s.LnNum1 #20/19 } Tile{ AsIs: s.Mode#1/21 } Tile{ AsIs: e.Index#1/15 } )/22 Tile{ AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 22},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 14},
      {refalrts::icReinitIdent, 0, 13, 17},
      {refalrts::icReinitSVar, 0, 20, 19},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 18, 0},
      {refalrts::icLinkBrackets, 14, 22, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icSetRes, 0, 0, 18},
      {refalrts::icSpliceTile, 22, 22, 0},
      {refalrts::icSpliceEVar, 0, 0, 15},
      {refalrts::icSpliceTile, 21, 21, 0},
      {refalrts::icTrash, 0, 0, 19},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +30, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # TkRedefinition s.idx ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkRedefinition/19 s.LnNum#1/20 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 2},
      {refalrts::icBracketLeftSave, 0, 15, 40},
      {refalrts::icIdentLeftSave, 19, 12, 15},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 40(2)
      {refalrts::icsVarLeft, 0, 20, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 } </21 & EL-AddErrorAt/22 Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: s.LnNum#1/20 HalfReuse: 'N'/18 }"ak"/23 Tile{ HalfReuse: 'e'/17 HalfReuse: 'd'/19 }" redefinition sign"/25 >/27 Tile{ AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 AsIs: )/14 } Tile{ AsIs: e.Tail#1/40(2) } Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 21},
      {refalrts::icAllocFunc, 0, 0, 22},
      {refalrts::icAllocString, 0, 6, 23},
      {refalrts::icAllocString, 0, 5, 25},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 27},
      {refalrts::icReinitChar, 0, 'N', 18},
      {refalrts::icReinitChar, 0, 'e', 17},
      {refalrts::icReinitChar, 0, 'd', 19},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 14, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icPushStack, 0, 0, 27},
      {refalrts::icPushStack, 0, 0, 21},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 40},
      {refalrts::icSpliceTile, 9, 14, 0},
      {refalrts::icSpliceTile, 25, 27, 0},
      {refalrts::icSpliceTile, 17, 19, 0},
      {refalrts::icSpliceTile, 23, 24, 0},
      {refalrts::icSpliceTile, 20, 18, 0},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icSpliceTile, 21, 22, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +23, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # Open s.idx # TkOpenBracket ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Open/19 s.LnNum#1/21 # TkOpenBracket/20 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 2},
      {refalrts::icBracketLeftSave, 0, 15, 40},
      {refalrts::icIdentLeftSave, 19, 4, 15},
      {refalrts::icIdentRightSave, 20, 11, 15},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 40(2)
      {refalrts::icsVarLeft, 0, 21, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 HalfReuse: (/10 HalfReuse: # Brackets/13 } Tile{ AsIs: s.LnNum#1/21 } Tile{ Reuse: # TkCloseBracket/19 } Tile{ AsIs: e.Scanned#1/11 } Tile{ AsIs: )/14 HalfReuse: )/17 } Tile{ HalfReuse: (/20 AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 10},
      {refalrts::icReinitIdent, 0, 2, 13},
      {refalrts::icUpdateIdent, 0, 10, 19},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 17},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 20},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 20, 18, 0},
      {refalrts::icLinkBrackets, 9, 17, 0},
      {refalrts::icLinkBrackets, 10, 14, 0},
      {refalrts::icSetRes, 0, 0, 20},
      {refalrts::icSpliceTile, 14, 17, 0},
      {refalrts::icSpliceEVar, 0, 0, 11},
      {refalrts::icSpliceTile, 19, 19, 0},
      {refalrts::icSpliceTile, 21, 21, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +32, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # Open s.idx # TkOpenADT ) ( # TkName s.idx e.idx ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Open/19 s.LnNumBracket#1/26 # TkOpenADT/20 )/18 (/23 # TkName/25 s.LnNumName#1/27 e.Name#1/21 )/24 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 2},
      {refalrts::icBracketLeftSave, 0, 15, 40},
      {refalrts::icIdentLeftSave, 19, 4, 15},
      {refalrts::icIdentRightSave, 20, 8, 15},
      {refalrts::icBracketLeftSave, 0, 21, 40},
      {refalrts::icIdentLeftSave, 25, 9, 21},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 40(2)
      {refalrts::icsVarLeft, 0, 26, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icsVarLeft, 0, 27, 21},
      // closed e.Name#1 as range 21
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNumBracket#1/26 {REMOVED TILE} s.LnNumName#1/27 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 HalfReuse: (/10 HalfReuse: # ADT-Brackets/13 } Tile{ HalfReuse: s.LnNumBracket1 #26/17 Reuse: # TkCloseADT/19 } Tile{ AsIs: e.Scanned#1/11 } Tile{ HalfReuse: )/20 AsIs: )/18 AsIs: (/23 HalfReuse: s.LnNumName1 #27/25 } (/28 Tile{ AsIs: e.Name#1/21 } Tile{ AsIs: )/14 } Tile{ AsIs: )/24 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 28},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 10},
      {refalrts::icReinitIdent, 0, 7, 13},
      {refalrts::icReinitSVar, 0, 26, 17},
      {refalrts::icUpdateIdent, 0, 6, 19},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 20},
      {refalrts::icReinitSVar, 0, 27, 25},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 23, 24, 0},
      {refalrts::icLinkBrackets, 28, 14, 0},
      {refalrts::icLinkBrackets, 9, 18, 0},
      {refalrts::icLinkBrackets, 10, 20, 0},
      {refalrts::icSetRes, 0, 0, 24},
      {refalrts::icSpliceTile, 14, 14, 0},
      {refalrts::icSpliceEVar, 0, 0, 21},
      {refalrts::icSpliceTile, 28, 28, 0},
      {refalrts::icSpliceTile, 20, 25, 0},
      {refalrts::icSpliceEVar, 0, 0, 11},
      {refalrts::icSpliceTile, 17, 19, 0},
      {refalrts::icTrash, 0, 0, 13},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +42, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # Open s.idx # TkOpenADT ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Open/19 s.LnNum#1/21 # TkOpenADT/20 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 2},
      {refalrts::icBracketLeftSave, 0, 15, 40},
      {refalrts::icIdentLeftSave, 19, 4, 15},
      {refalrts::icIdentRightSave, 20, 8, 15},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 40(2)
      {refalrts::icsVarLeft, 0, 21, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </22 & ParsePattern/23 Tile{ AsIs: </0 Reuse: & EL-AddErrorAt/4 AsIs: t.ErrorList#1/5 HalfReuse: s.LnNum1 #21/9 }"Expected name after \"[\""/24 >/26 (/27 Tile{ AsIs: e.MultiBracket#1/7 } (/28 # ADT-Brackets/29 Tile{ HalfReuse: s.LnNum1 #21/10 HalfReuse: # TkCloseADT/13 AsIs: e.Scanned#1/11 AsIs: )/14 HalfReuse: )/17 HalfReuse: (/19 AsIs: s.LnNum#1/21 HalfReuse: (/20 HalfReuse: # UnnamedADT/18 } )/30 )/31 Tile{ AsIs: e.Tail#1/40(2) } Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 22},
      {refalrts::icAllocFunc, 0, 2, 23},
      {refalrts::icAllocString, 0, 4, 24},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 26},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 27},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 28},
      {refalrts::icAllocIdent, 0, 7, 29},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 30},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 31},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitSVar, 0, 21, 9},
      {refalrts::icReinitSVar, 0, 21, 10},
      {refalrts::icReinitIdent, 0, 6, 13},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 17},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 19},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 20},
      {refalrts::icReinitIdent, 0, 5, 18},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 22},
      {refalrts::icLinkBrackets, 19, 31, 0},
      {refalrts::icLinkBrackets, 20, 30, 0},
      {refalrts::icLinkBrackets, 27, 17, 0},
      {refalrts::icLinkBrackets, 28, 14, 0},
      {refalrts::icPushStack, 0, 0, 26},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 40},
      {refalrts::icSpliceTile, 30, 31, 0},
      {refalrts::icSpliceTile, 10, 18, 0},
      {refalrts::icSpliceTile, 28, 29, 0},
      {refalrts::icSpliceEVar, 0, 0, 7},
      {refalrts::icSpliceTile, 24, 27, 0},
      {refalrts::icSpliceTile, 0, 9, 0},
      {refalrts::icSpliceTile, 22, 23, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +37, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # Open s.idx # TkOpenCall ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Open/19 s.LnNum#1/21 # TkOpenCall/20 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 2},
      {refalrts::icBracketLeftSave, 0, 15, 40},
      {refalrts::icIdentLeftSave, 19, 4, 15},
      {refalrts::icIdentRightSave, 20, 3, 15},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 40(2)
      {refalrts::icsVarLeft, 0, 21, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNum#1/21 {REMOVED TILE}
      //RESULT: Tile{ [[ } </22 & ParsePattern/23 Tile{ AsIs: </0 Reuse: & EL-AddErrorAt/4 AsIs: t.ErrorList#1/5 HalfReuse: s.LnNum1 #21/9 }"Unexpected call bracket in pattern expression"/24 >/26 (/27 Tile{ AsIs: e.MultiBracket#1/7 } (/28 Tile{ Reuse: # Brackets/19 } Tile{ HalfReuse: s.LnNum1 #21/10 HalfReuse: # TkCloseCall/13 AsIs: e.Scanned#1/11 AsIs: )/14 HalfReuse: )/17 } Tile{ HalfReuse: (/20 AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 22},
      {refalrts::icAllocFunc, 0, 2, 23},
      {refalrts::icAllocString, 0, 3, 24},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 26},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 27},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 28},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitSVar, 0, 21, 9},
      {refalrts::icUpdateIdent, 0, 2, 19},
      {refalrts::icReinitSVar, 0, 21, 10},
      {refalrts::icReinitIdent, 0, 1, 13},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 17},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 20},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 22},
      {refalrts::icLinkBrackets, 20, 18, 0},
      {refalrts::icLinkBrackets, 27, 17, 0},
      {refalrts::icLinkBrackets, 28, 14, 0},
      {refalrts::icPushStack, 0, 0, 26},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetRes, 0, 0, 20},
      {refalrts::icSpliceTile, 10, 17, 0},
      {refalrts::icSpliceTile, 19, 19, 0},
      {refalrts::icSpliceTile, 28, 28, 0},
      {refalrts::icSpliceEVar, 0, 0, 7},
      {refalrts::icSpliceTile, 24, 27, 0},
      {refalrts::icSpliceTile, 0, 9, 0},
      {refalrts::icSpliceTile, 22, 23, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +26, 0, 0},
      // t.idx ( e.idx ( s.idx s.idx s.idx e.idx ) ) ( e.idx ) ( # Close s.idx s.idx ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 (/22 s.BracketsSign#1/24 s.InnerLnNum#1/25 s.CloseBracket#1/26 e.Scanned#1/20 )/23 )/10 (/13 e.InnerScanned#1/11 )/14 (/17 # Close/19 s.ClosedLnNum#1/28 s.CloseBracket#1/27 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 2},
      {refalrts::icBracketLeftSave, 0, 15, 40},
      {refalrts::icIdentLeftSave, 19, 0, 15},
      {refalrts::icSave, 0, 42, 7},
      {refalrts::icBracketRightSave, 0, 20, 42},
      // closed e.MultiBracket#1 as range 42(7)
      // closed e.InnerScanned#1 as range 11
      // closed e.Tail#1 as range 40(2)
      {refalrts::icsVarLeft, 0, 24, 20},
      {refalrts::icsVarLeft, 0, 25, 20},
      {refalrts::icsVarLeft, 0, 26, 20},
      {refalrts::icsRepeatRight, 27, 26, 15},
      // closed e.Scanned#1 as range 20
      {refalrts::icsVarLeft, 0, 28, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.BracketsSign#1/24 s.InnerLnNum#1/25 s.CloseBracket#1/26 {REMOVED TILE} )/23 {REMOVED TILE} {REMOVED TILE} # Close/19 s.ClosedLnNum#1/28 s.CloseBracket#1/27 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/42(7) HalfReuse: )/22 } Tile{ AsIs: (/17 } Tile{ AsIs: e.Scanned#1/20 } Tile{ HalfReuse: (/10 HalfReuse: s.BracketsSign1 #24/13 AsIs: e.InnerScanned#1/11 AsIs: )/14 } Tile{ AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 22},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 10},
      {refalrts::icReinitSVar, 0, 24, 13},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 17, 18, 0},
      {refalrts::icLinkBrackets, 10, 14, 0},
      {refalrts::icLinkBrackets, 9, 22, 0},
      {refalrts::icSetRes, 0, 0, 18},
      {refalrts::icSpliceTile, 10, 14, 0},
      {refalrts::icSpliceEVar, 0, 0, 20},
      {refalrts::icSpliceTile, 17, 17, 0},
      {refalrts::icTrash, 0, 0, 22},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +46, 0, 0},
      // t.idx ( e.idx ( s.idx s.idx s.idx e.idx ) ) ( e.idx ) ( # Close s.idx s.idx ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 (/22 s.BracketsSign#1/24 s.InnerLnNum#1/25 s.CloseBracket#1/26 e.Scanned#1/20 )/23 )/10 (/13 e.InnerScanned#1/11 )/14 (/17 # Close/19 s.LnNum#1/27 s.OtherCloseBracket#1/28 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 2},
      {refalrts::icBracketLeftSave, 0, 15, 40},
      {refalrts::icIdentLeftSave, 19, 0, 15},
      {refalrts::icSave, 0, 42, 7},
      {refalrts::icBracketRightSave, 0, 20, 42},
      // closed e.MultiBracket#1 as range 42(7)
      // closed e.InnerScanned#1 as range 11
      // closed e.Tail#1 as range 40(2)
      {refalrts::icsVarLeft, 0, 24, 20},
      {refalrts::icsVarLeft, 0, 25, 20},
      {refalrts::icsVarLeft, 0, 26, 20},
      // closed e.Scanned#1 as range 20
      {refalrts::icsVarLeft, 0, 27, 15},
      {refalrts::icsVarLeft, 0, 28, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.InnerLnNum#1/25 s.CloseBracket#1/26 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </29 & ParsePattern/30 Tile{ AsIs: </0 Reuse: & EL-AddErrorAt/4 AsIs: t.ErrorList#1/5 HalfReuse: s.InnerLnNum1 #25/9 }"Unbalanced bracket \""/31 </33 & StrFromBracket/34 s.BracketsSign#1/24/35 >/36 '\"'/37 >/38 (/39 Tile{ AsIs: e.MultiBracket#1/42(7) } Tile{ AsIs: )/10 AsIs: (/13 } Tile{ AsIs: e.Scanned#1/20 } Tile{ AsIs: (/22 AsIs: s.BracketsSign#1/24 } Tile{ AsIs: e.InnerScanned#1/11 } Tile{ AsIs: )/23 } Tile{ AsIs: )/14 AsIs: (/17 AsIs: # Close/19 AsIs: s.LnNum#1/27 AsIs: s.OtherCloseBracket#1/28 AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 29},
      {refalrts::icAllocFunc, 0, 2, 30},
      {refalrts::icAllocString, 0, 0, 31},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 33},
      {refalrts::icAllocFunc, 0, 1, 34},
      {refalrts::icCopySTVar, 35, 24, 0},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 36},
      {refalrts::icAllocChar, 0, '\"', 37},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 38},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 39},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitSVar, 0, 25, 9},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 29},
      {refalrts::icLinkBrackets, 17, 18, 0},
      {refalrts::icLinkBrackets, 13, 14, 0},
      {refalrts::icLinkBrackets, 22, 23, 0},
      {refalrts::icLinkBrackets, 39, 10, 0},
      {refalrts::icPushStack, 0, 0, 38},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 36},
      {refalrts::icPushStack, 0, 0, 33},
      {refalrts::icSetRes, 0, 0, 14},
      {refalrts::icSpliceTile, 23, 23, 0},
      {refalrts::icSpliceEVar, 0, 0, 11},
      {refalrts::icSpliceTile, 22, 24, 0},
      {refalrts::icSpliceEVar, 0, 0, 20},
      {refalrts::icSpliceTile, 10, 13, 0},
      {refalrts::icSpliceEVar, 0, 0, 42},
      {refalrts::icSpliceTile, 31, 39, 0},
      {refalrts::icSpliceTile, 0, 9, 0},
      {refalrts::icSpliceTile, 29, 30, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +40, 0, 0},
      // t.idx ( ) ( e.idx ) ( # Close s.idx s.idx ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Close/19 s.LnNum#1/20 s.CloseBracket#1/21 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 2},
      {refalrts::icBracketLeftSave, 0, 15, 40},
      {refalrts::icIdentLeftSave, 19, 0, 15},
      {refalrts::icSave, 0, 42, 7},
      {refalrts::icEmpty, 0, 0, 42},
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 40(2)
      {refalrts::icsVarLeft, 0, 20, 15},
      {refalrts::icsVarLeft, 0, 21, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 } </22 & EL-AddErrorAt/23 Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: s.LnNum#1/20 }"Unb"/24 Tile{ HalfReuse: 'a'/17 HalfReuse: 'l'/19 }"anced bracket \""/26 </28 & StrFromBracket/29 Tile{ AsIs: s.CloseBracket#1/21 HalfReuse: >/18 } '\"'/30 >/31 Tile{ AsIs: (/9 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 AsIs: )/14 } Tile{ AsIs: e.Tail#1/40(2) } Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 22},
      {refalrts::icAllocFunc, 0, 0, 23},
      {refalrts::icAllocString, 0, 2, 24},
      {refalrts::icAllocString, 0, 1, 26},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 28},
      {refalrts::icAllocFunc, 0, 1, 29},
      {refalrts::icAllocChar, 0, '\"', 30},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 31},
      {refalrts::icReinitChar, 0, 'a', 17},
      {refalrts::icReinitChar, 0, 'l', 19},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 18},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 14, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icPushStack, 0, 0, 31},
      {refalrts::icPushStack, 0, 0, 22},
      {refalrts::icPushStack, 0, 0, 18},
      {refalrts::icPushStack, 0, 0, 28},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 40},
      {refalrts::icSpliceTile, 9, 14, 0},
      {refalrts::icSpliceTile, 30, 31, 0},
      {refalrts::icSpliceTile, 21, 18, 0},
      {refalrts::icSpliceTile, 26, 29, 0},
      {refalrts::icSpliceTile, 17, 19, 0},
      {refalrts::icSpliceTile, 24, 25, 0},
      {refalrts::icSpliceTile, 20, 20, 0},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icSpliceTile, 22, 23, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +39, 0, 0},
      // t.idx ( e.idx ( s.idx s.idx s.idx e.idx ) ) ( e.idx ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 (/17 s.BracketsSign#1/19 s.InnerLnNum#1/20 s.CloseBracket#1/21 e.Scanned#1/15 )/18 )/10 (/13 e.InnerScanned#1/11 )/14 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 40, 7},
      {refalrts::icBracketRightSave, 0, 15, 40},
      // closed e.MultiBracket#1 as range 40(7)
      // closed e.InnerScanned#1 as range 11
      // closed e.Tail#1 as range 2
      {refalrts::icsVarLeft, 0, 19, 15},
      {refalrts::icsVarLeft, 0, 20, 15},
      {refalrts::icsVarLeft, 0, 21, 15},
      // closed e.Scanned#1 as range 15
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.InnerLnNum#1/20 s.CloseBracket#1/21 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </22 & ParsePattern/23 Tile{ AsIs: </0 Reuse: & EL-AddErrorAt/4 AsIs: t.ErrorList#1/5 HalfReuse: s.InnerLnNum1 #20/9 }"Unbalanced bracket \""/24 </26 & StrFromBracket/27 s.BracketsSign#1/19/28 >/29 '\"'/30 >/31 (/32 Tile{ AsIs: e.MultiBracket#1/40(7) } Tile{ AsIs: )/10 AsIs: (/13 } Tile{ AsIs: e.Scanned#1/15 } Tile{ AsIs: (/17 AsIs: s.BracketsSign#1/19 } Tile{ AsIs: e.InnerScanned#1/11 } Tile{ AsIs: )/18 } Tile{ AsIs: )/14 AsIs: e.Tail#1/2 AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 22},
      {refalrts::icAllocFunc, 0, 2, 23},
      {refalrts::icAllocString, 0, 0, 24},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 26},
      {refalrts::icAllocFunc, 0, 1, 27},
      {refalrts::icCopySTVar, 28, 19, 0},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 29},
      {refalrts::icAllocChar, 0, '\"', 30},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 31},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 32},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitSVar, 0, 20, 9},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 22},
      {refalrts::icLinkBrackets, 13, 14, 0},
      {refalrts::icLinkBrackets, 17, 18, 0},
      {refalrts::icLinkBrackets, 32, 10, 0},
      {refalrts::icPushStack, 0, 0, 31},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 29},
      {refalrts::icPushStack, 0, 0, 26},
      {refalrts::icSetRes, 0, 0, 14},
      {refalrts::icSpliceTile, 18, 18, 0},
      {refalrts::icSpliceEVar, 0, 0, 11},
      {refalrts::icSpliceTile, 17, 19, 0},
      {refalrts::icSpliceEVar, 0, 0, 15},
      {refalrts::icSpliceTile, 10, 13, 0},
      {refalrts::icSpliceEVar, 0, 0, 40},
      {refalrts::icSpliceTile, 24, 32, 0},
      {refalrts::icSpliceTile, 0, 9, 0},
      {refalrts::icSpliceTile, 22, 23, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // t.idx ( ) ( e.idx ) e.idx
      // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 )/10 (/13 e.Pattern#1/11 )/14 e.Tail#1/2 >/1
      {refalrts::icEmpty, 0, 0, 7},
      // closed e.Pattern#1 as range 11
      // closed e.Tail#1 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParsePattern/4 {REMOVED TILE} (/9 )/10 {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: (/13 AsIs: e.Pattern#1/11 AsIs: )/14 } Tile{ AsIs: e.Tail#1/2 } Tile{ ]] }
      {refalrts::icLinkBrackets, 13, 14, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 13, 14, 0},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParsePattern

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParsePattern(
  "ParsePattern",
  scope_ParsePattern::raa,
  scope_ParsePattern::functions,
  scope_ParsePattern::idents,
  scope_ParsePattern::numbers,
  scope_ParsePattern::strings
);
refalrts::RefalFunction& ParsePattern = descr_ParsePattern;

} // unnamed namespace

#else
static refalrts::FnResult func_ParsePattern(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 44 elems
  refalrts::Iter context[44];
  refalrts::zeros( context, 44 );
  //FAST GEN: e.$
  //GLOBAL GEN: t.$ ( e.$ ) ( e.$ ) e.$
  // </0 & ParsePattern/4 t.idx#0/5 (/9 e.idxVB#0/7 )/10 (/13 e.idxVTB#0/11 )/14 e.idxVTT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  context[7] = 0;
  context[8] = 0;
  context[9] = refalrts::brackets_left( context[7], context[8], context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[9], context[10]);
  context[11] = 0;
  context[12] = 0;
  context[13] = refalrts::brackets_left( context[11], context[12], context[2], context[3] );
  if( ! context[13] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[13], context[14]);
  // closed e.idxVB#0 as range 7
  // closed e.idxVTB#0 as range 11
  // closed e.idxVTT#0 as range 2
  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # TkChar s.idx s.idx ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBrackets#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkChar/19 s.LnNum#1/20 s.Char#1/21 )/18 e.Tail#1/2 >/1
    context[40] = context[2];
    context[41] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_TkChar<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    // closed e.MultiBrackets#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 40(2)
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.LnNum#1/20 s.Char#1/21 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBrackets#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkChar/17 HalfReuse: s.Char1 #21/19 } )/22 Tile{ AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_bracket( context[22] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[14] );
    refalrts::reinit_ident( context[17], & ident_TkChar<int>::name );
    refalrts::reinit_svar( context[19], context[21] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[18] );
    refalrts::link_brackets( context[14], context[22] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[18];
    res = refalrts::splice_evar( res, context[22], context[22] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[19], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # TkNumber s.idx s.idx ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBrackets#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkNumber/19 s.LnNum#1/20 s.Number#1/21 )/18 e.Tail#1/2 >/1
    context[40] = context[2];
    context[41] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_TkNumber<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    // closed e.MultiBrackets#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 40(2)
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.LnNum#1/20 s.Number#1/21 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBrackets#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkNumber/17 HalfReuse: s.Number1 #21/19 } )/22 Tile{ AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_bracket( context[22] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[14] );
    refalrts::reinit_ident( context[17], & ident_TkNumber<int>::name );
    refalrts::reinit_svar( context[19], context[21] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[18] );
    refalrts::link_brackets( context[14], context[22] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[18];
    res = refalrts::splice_evar( res, context[22], context[22] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[19], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # TkName s.idx e.idx ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBrackets#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkName/19 s.LnNum#1/20 e.Name#1/15 )/18 e.Tail#1/2 >/1
    context[40] = context[2];
    context[41] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_TkName<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    // closed e.MultiBrackets#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 40(2)
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    // closed e.Name#1 as range 15

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.LnNum#1/20 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBrackets#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkName/17 HalfReuse: s.LnNum1 #20/19 } Tile{ AsIs: e.Name#1/15 } )/21 Tile{ AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_bracket( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[14] );
    refalrts::reinit_ident( context[17], & ident_TkName<int>::name );
    refalrts::reinit_svar( context[19], context[20] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[18] );
    refalrts::link_brackets( context[14], context[21] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[18];
    res = refalrts::splice_evar( res, context[21], context[21] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[19], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # TkIdentMarker s.idx ) ( # TkName s.idx e.idx ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBrackets#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkIdentMarker/19 s.LnNumMarker#1/25 )/18 (/22 # TkName/24 s.LnNumName#1/26 e.Name#1/20 )/23 e.Tail#1/2 >/1
    context[40] = context[2];
    context[41] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_TkIdentMarker<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    context[20] = 0;
    context[21] = 0;
    context[22] = refalrts::brackets_left( context[20], context[21], context[40], context[41] );
    if( ! context[22] )
      continue;
    refalrts::bracket_pointers(context[22], context[23]);
    context[24] = refalrts::ident_left(  & ident_TkName<int>::name, context[20], context[21] );
    if( ! context[24] )
      continue;
    // closed e.MultiBrackets#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 40(2)
    if( ! refalrts::svar_left( context[25], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[26], context[20], context[21] ) )
      continue;
    // closed e.Name#1 as range 20

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} # TkIdentMarker/19 s.LnNumMarker#1/25 {REMOVED TILE} (/22 # TkName/24 s.LnNumName#1/26 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBrackets#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkIdentifier/17 } Tile{ AsIs: e.Name#1/20 } Tile{ AsIs: )/18 } Tile{ AsIs: )/23 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
    refalrts::reinit_open_bracket( context[14] );
    refalrts::reinit_ident( context[17], & ident_TkIdentifier<int>::name );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[23] );
    refalrts::link_brackets( context[14], context[18] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[23];
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[17], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # TkIdentMarker s.idx ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBrackets#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkIdentMarker/19 s.LnNum#1/20 )/18 e.Tail#1/2 >/1
    context[40] = context[2];
    context[41] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_TkIdentMarker<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    // closed e.MultiBrackets#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 40(2)
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 } </21 & EL-AddErrorAt/22 Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: s.LnNum#1/20 HalfReuse: 'M'/18 }"is"/23 Tile{ HalfReuse: 's'/17 HalfReuse: 'e'/19 }"d name after \'#\'"/25 >/27 Tile{ AsIs: (/9 AsIs: e.MultiBrackets#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 AsIs: )/14 } Tile{ AsIs: e.Tail#1/40(2) } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], & EL_AddErrorAt ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], "is", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "d name after \'#\'", 16 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[27] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[18], 'M' );
    refalrts::reinit_char( context[17], 's' );
    refalrts::reinit_char( context[19], 'e' );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[14] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[21] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[40], context[41] );
    res = refalrts::splice_evar( res, context[9], context[14] );
    res = refalrts::splice_evar( res, context[25], context[27] );
    res = refalrts::splice_evar( res, context[17], context[19] );
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[20], context[18] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # TkVariable s.idx s.idx e.idx ) ( # TkRedefinition s.idx ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkVariable/19 s.LnNumVar#1/25 s.Mode#1/26 e.Index#1/15 )/18 (/22 # TkRedefinition/24 s.LnNumRedef#1/27 )/23 e.Tail#1/2 >/1
    context[40] = context[2];
    context[41] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_TkVariable<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    context[20] = 0;
    context[21] = 0;
    context[22] = refalrts::brackets_left( context[20], context[21], context[40], context[41] );
    if( ! context[22] )
      continue;
    refalrts::bracket_pointers(context[22], context[23]);
    context[24] = refalrts::ident_left(  & ident_TkRedefinition<int>::name, context[20], context[21] );
    if( ! context[24] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 40(2)
    if( ! refalrts::svar_left( context[25], context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[26], context[15], context[16] ) )
      continue;
    // closed e.Index#1 as range 15
    if( ! refalrts::svar_left( context[27], context[20], context[21] ) )
      continue;
    if( ! refalrts::empty_seq( context[20], context[21] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.LnNumVar#1/25 {REMOVED TILE} (/22 # TkRedefinition/24 s.LnNumRedef#1/27 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkNewVariable/17 HalfReuse: s.LnNumVar1 #25/19 } Tile{ AsIs: s.Mode#1/26 AsIs: e.Index#1/15 AsIs: )/18 } Tile{ AsIs: )/23 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
    refalrts::reinit_open_bracket( context[14] );
    refalrts::reinit_ident( context[17], & ident_TkNewVariable<int>::name );
    refalrts::reinit_svar( context[19], context[25] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[23] );
    refalrts::link_brackets( context[14], context[18] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[23];
    res = refalrts::splice_evar( res, context[26], context[18] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[19], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # TkVariable s.idx s.idx e.idx ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkVariable/19 s.LnNum#1/20 s.Mode#1/21 e.Index#1/15 )/18 e.Tail#1/2 >/1
    context[40] = context[2];
    context[41] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_TkVariable<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 40(2)
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[15], context[16] ) )
      continue;
    // closed e.Index#1 as range 15

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.LnNum#1/20 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkVariable/17 HalfReuse: s.LnNum1 #20/19 } Tile{ AsIs: s.Mode#1/21 } Tile{ AsIs: e.Index#1/15 } )/22 Tile{ AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_bracket( context[22] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[14] );
    refalrts::reinit_ident( context[17], & ident_TkVariable<int>::name );
    refalrts::reinit_svar( context[19], context[20] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[18] );
    refalrts::link_brackets( context[14], context[22] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[18];
    res = refalrts::splice_evar( res, context[22], context[22] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[21], context[21] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[19], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # TkRedefinition s.idx ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkRedefinition/19 s.LnNum#1/20 )/18 e.Tail#1/2 >/1
    context[40] = context[2];
    context[41] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_TkRedefinition<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 40(2)
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 } </21 & EL-AddErrorAt/22 Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: s.LnNum#1/20 HalfReuse: 'N'/18 }"ak"/23 Tile{ HalfReuse: 'e'/17 HalfReuse: 'd'/19 }" redefinition sign"/25 >/27 Tile{ AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 AsIs: )/14 } Tile{ AsIs: e.Tail#1/40(2) } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], & EL_AddErrorAt ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], "ak", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], " redefinition sign", 18 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[27] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[18], 'N' );
    refalrts::reinit_char( context[17], 'e' );
    refalrts::reinit_char( context[19], 'd' );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[14] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[21] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[40], context[41] );
    res = refalrts::splice_evar( res, context[9], context[14] );
    res = refalrts::splice_evar( res, context[25], context[27] );
    res = refalrts::splice_evar( res, context[17], context[19] );
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[20], context[18] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # Open s.idx # TkOpenBracket ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Open/19 s.LnNum#1/21 # TkOpenBracket/20 )/18 e.Tail#1/2 >/1
    context[40] = context[2];
    context[41] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_Open<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    context[20] = refalrts::ident_right(  & ident_TkOpenBracket<int>::name, context[15], context[16] );
    if( ! context[20] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 40(2)
    if( ! refalrts::svar_left( context[21], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 HalfReuse: (/10 HalfReuse: # Brackets/13 } Tile{ AsIs: s.LnNum#1/21 } Tile{ Reuse: # TkCloseBracket/19 } Tile{ AsIs: e.Scanned#1/11 } Tile{ AsIs: )/14 HalfReuse: )/17 } Tile{ HalfReuse: (/20 AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
    refalrts::reinit_open_bracket( context[10] );
    refalrts::reinit_ident( context[13], & ident_Brackets<int>::name );
    refalrts::update_ident( context[19], & ident_TkCloseBracket<int>::name );
    refalrts::reinit_close_bracket( context[17] );
    refalrts::reinit_open_bracket( context[20] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[20], context[18] );
    refalrts::link_brackets( context[9], context[17] );
    refalrts::link_brackets( context[10], context[14] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[20];
    res = refalrts::splice_evar( res, context[14], context[17] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[19], context[19] );
    res = refalrts::splice_evar( res, context[21], context[21] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # Open s.idx # TkOpenADT ) ( # TkName s.idx e.idx ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Open/19 s.LnNumBracket#1/26 # TkOpenADT/20 )/18 (/23 # TkName/25 s.LnNumName#1/27 e.Name#1/21 )/24 e.Tail#1/2 >/1
    context[40] = context[2];
    context[41] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_Open<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    context[20] = refalrts::ident_right(  & ident_TkOpenADT<int>::name, context[15], context[16] );
    if( ! context[20] )
      continue;
    context[21] = 0;
    context[22] = 0;
    context[23] = refalrts::brackets_left( context[21], context[22], context[40], context[41] );
    if( ! context[23] )
      continue;
    refalrts::bracket_pointers(context[23], context[24]);
    context[25] = refalrts::ident_left(  & ident_TkName<int>::name, context[21], context[22] );
    if( ! context[25] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 40(2)
    if( ! refalrts::svar_left( context[26], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[27], context[21], context[22] ) )
      continue;
    // closed e.Name#1 as range 21

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNumBracket#1/26 {REMOVED TILE} s.LnNumName#1/27 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 HalfReuse: (/10 HalfReuse: # ADT-Brackets/13 } Tile{ HalfReuse: s.LnNumBracket1 #26/17 Reuse: # TkCloseADT/19 } Tile{ AsIs: e.Scanned#1/11 } Tile{ HalfReuse: )/20 AsIs: )/18 AsIs: (/23 HalfReuse: s.LnNumName1 #27/25 } (/28 Tile{ AsIs: e.Name#1/21 } Tile{ AsIs: )/14 } Tile{ AsIs: )/24 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[28] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[10] );
    refalrts::reinit_ident( context[13], & ident_ADT_Brackets<int>::name );
    refalrts::reinit_svar( context[17], context[26] );
    refalrts::update_ident( context[19], & ident_TkCloseADT<int>::name );
    refalrts::reinit_close_bracket( context[20] );
    refalrts::reinit_svar( context[25], context[27] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[23], context[24] );
    refalrts::link_brackets( context[28], context[14] );
    refalrts::link_brackets( context[9], context[18] );
    refalrts::link_brackets( context[10], context[20] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[24];
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[28], context[28] );
    res = refalrts::splice_evar( res, context[20], context[25] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[17], context[19] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[13], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # Open s.idx # TkOpenADT ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Open/19 s.LnNum#1/21 # TkOpenADT/20 )/18 e.Tail#1/2 >/1
    context[40] = context[2];
    context[41] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_Open<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    context[20] = refalrts::ident_right(  & ident_TkOpenADT<int>::name, context[15], context[16] );
    if( ! context[20] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 40(2)
    if( ! refalrts::svar_left( context[21], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </22 & ParsePattern/23 Tile{ AsIs: </0 Reuse: & EL-AddErrorAt/4 AsIs: t.ErrorList#1/5 HalfReuse: s.LnNum1 #21/9 }"Expected name after \"[\""/24 >/26 (/27 Tile{ AsIs: e.MultiBracket#1/7 } (/28 # ADT-Brackets/29 Tile{ HalfReuse: s.LnNum1 #21/10 HalfReuse: # TkCloseADT/13 AsIs: e.Scanned#1/11 AsIs: )/14 HalfReuse: )/17 HalfReuse: (/19 AsIs: s.LnNum#1/21 HalfReuse: (/20 HalfReuse: # UnnamedADT/18 } )/30 )/31 Tile{ AsIs: e.Tail#1/40(2) } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[23], & ParsePattern ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "Expected name after \"[\"", 23 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[29], & ident_ADT_Brackets<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[31] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & EL_AddErrorAt );
    refalrts::reinit_svar( context[9], context[21] );
    refalrts::reinit_svar( context[10], context[21] );
    refalrts::reinit_ident( context[13], & ident_TkCloseADT<int>::name );
    refalrts::reinit_close_bracket( context[17] );
    refalrts::reinit_open_bracket( context[19] );
    refalrts::reinit_open_bracket( context[20] );
    refalrts::reinit_ident( context[18], & ident_UnnamedADT<int>::name );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[22] );
    refalrts::link_brackets( context[19], context[31] );
    refalrts::link_brackets( context[20], context[30] );
    refalrts::link_brackets( context[27], context[17] );
    refalrts::link_brackets( context[28], context[14] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[40], context[41] );
    res = refalrts::splice_evar( res, context[30], context[31] );
    res = refalrts::splice_evar( res, context[10], context[18] );
    res = refalrts::splice_evar( res, context[28], context[29] );
    res = refalrts::splice_evar( res, context[7], context[8] );
    res = refalrts::splice_evar( res, context[24], context[27] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # Open s.idx # TkOpenCall ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Open/19 s.LnNum#1/21 # TkOpenCall/20 )/18 e.Tail#1/2 >/1
    context[40] = context[2];
    context[41] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_Open<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    context[20] = refalrts::ident_right(  & ident_TkOpenCall<int>::name, context[15], context[16] );
    if( ! context[20] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 40(2)
    if( ! refalrts::svar_left( context[21], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNum#1/21 {REMOVED TILE}
    //RESULT: Tile{ [[ } </22 & ParsePattern/23 Tile{ AsIs: </0 Reuse: & EL-AddErrorAt/4 AsIs: t.ErrorList#1/5 HalfReuse: s.LnNum1 #21/9 }"Unexpected call bracket in pattern expression"/24 >/26 (/27 Tile{ AsIs: e.MultiBracket#1/7 } (/28 Tile{ Reuse: # Brackets/19 } Tile{ HalfReuse: s.LnNum1 #21/10 HalfReuse: # TkCloseCall/13 AsIs: e.Scanned#1/11 AsIs: )/14 HalfReuse: )/17 } Tile{ HalfReuse: (/20 AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[23], & ParsePattern ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "Unexpected call bracket in pattern expression", 45 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[28] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & EL_AddErrorAt );
    refalrts::reinit_svar( context[9], context[21] );
    refalrts::update_ident( context[19], & ident_Brackets<int>::name );
    refalrts::reinit_svar( context[10], context[21] );
    refalrts::reinit_ident( context[13], & ident_TkCloseCall<int>::name );
    refalrts::reinit_close_bracket( context[17] );
    refalrts::reinit_open_bracket( context[20] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[22] );
    refalrts::link_brackets( context[20], context[18] );
    refalrts::link_brackets( context[27], context[17] );
    refalrts::link_brackets( context[28], context[14] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[20];
    res = refalrts::splice_evar( res, context[10], context[17] );
    res = refalrts::splice_evar( res, context[19], context[19] );
    res = refalrts::splice_evar( res, context[28], context[28] );
    res = refalrts::splice_evar( res, context[7], context[8] );
    res = refalrts::splice_evar( res, context[24], context[27] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ( s.idx s.idx s.idx e.idx ) ) ( e.idx ) ( # Close s.idx s.idx ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 (/22 s.BracketsSign#1/24 s.InnerLnNum#1/25 s.CloseBracket#1/26 e.Scanned#1/20 )/23 )/10 (/13 e.InnerScanned#1/11 )/14 (/17 # Close/19 s.ClosedLnNum#1/28 s.CloseBracket#1/27 )/18 e.Tail#1/2 >/1
    context[40] = context[2];
    context[41] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_Close<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    context[42] = context[7];
    context[43] = context[8];
    context[20] = 0;
    context[21] = 0;
    context[22] = refalrts::brackets_right( context[20], context[21], context[42], context[43] );
    if( ! context[22] )
      continue;
    refalrts::bracket_pointers(context[22], context[23]);
    // closed e.MultiBracket#1 as range 42(7)
    // closed e.InnerScanned#1 as range 11
    // closed e.Tail#1 as range 40(2)
    if( ! refalrts::svar_left( context[24], context[20], context[21] ) )
      continue;
    if( ! refalrts::svar_left( context[25], context[20], context[21] ) )
      continue;
    if( ! refalrts::svar_left( context[26], context[20], context[21] ) )
      continue;
    if( ! refalrts::repeated_stvar_right( context[27], context[26], context[15], context[16] ) )
      continue;
    // closed e.Scanned#1 as range 20
    if( ! refalrts::svar_left( context[28], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.BracketsSign#1/24 s.InnerLnNum#1/25 s.CloseBracket#1/26 {REMOVED TILE} )/23 {REMOVED TILE} {REMOVED TILE} # Close/19 s.ClosedLnNum#1/28 s.CloseBracket#1/27 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/42(7) HalfReuse: )/22 } Tile{ AsIs: (/17 } Tile{ AsIs: e.Scanned#1/20 } Tile{ HalfReuse: (/10 HalfReuse: s.BracketsSign1 #24/13 AsIs: e.InnerScanned#1/11 AsIs: )/14 } Tile{ AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
    refalrts::reinit_close_bracket( context[22] );
    refalrts::reinit_open_bracket( context[10] );
    refalrts::reinit_svar( context[13], context[24] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[17], context[18] );
    refalrts::link_brackets( context[10], context[14] );
    refalrts::link_brackets( context[9], context[22] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[18];
    res = refalrts::splice_evar( res, context[10], context[14] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[17], context[17] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[22], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ( s.idx s.idx s.idx e.idx ) ) ( e.idx ) ( # Close s.idx s.idx ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 (/22 s.BracketsSign#1/24 s.InnerLnNum#1/25 s.CloseBracket#1/26 e.Scanned#1/20 )/23 )/10 (/13 e.InnerScanned#1/11 )/14 (/17 # Close/19 s.LnNum#1/27 s.OtherCloseBracket#1/28 )/18 e.Tail#1/2 >/1
    context[40] = context[2];
    context[41] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_Close<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    context[42] = context[7];
    context[43] = context[8];
    context[20] = 0;
    context[21] = 0;
    context[22] = refalrts::brackets_right( context[20], context[21], context[42], context[43] );
    if( ! context[22] )
      continue;
    refalrts::bracket_pointers(context[22], context[23]);
    // closed e.MultiBracket#1 as range 42(7)
    // closed e.InnerScanned#1 as range 11
    // closed e.Tail#1 as range 40(2)
    if( ! refalrts::svar_left( context[24], context[20], context[21] ) )
      continue;
    if( ! refalrts::svar_left( context[25], context[20], context[21] ) )
      continue;
    if( ! refalrts::svar_left( context[26], context[20], context[21] ) )
      continue;
    // closed e.Scanned#1 as range 20
    if( ! refalrts::svar_left( context[27], context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[28], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.InnerLnNum#1/25 s.CloseBracket#1/26 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </29 & ParsePattern/30 Tile{ AsIs: </0 Reuse: & EL-AddErrorAt/4 AsIs: t.ErrorList#1/5 HalfReuse: s.InnerLnNum1 #25/9 }"Unbalanced bracket \""/31 </33 & StrFromBracket/34 s.BracketsSign#1/24/35 >/36 '\"'/37 >/38 (/39 Tile{ AsIs: e.MultiBracket#1/42(7) } Tile{ AsIs: )/10 AsIs: (/13 } Tile{ AsIs: e.Scanned#1/20 } Tile{ AsIs: (/22 AsIs: s.BracketsSign#1/24 } Tile{ AsIs: e.InnerScanned#1/11 } Tile{ AsIs: )/23 } Tile{ AsIs: )/14 AsIs: (/17 AsIs: # Close/19 AsIs: s.LnNum#1/27 AsIs: s.OtherCloseBracket#1/28 AsIs: )/18 AsIs: e.Tail#1/40(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], & ParsePattern ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[31], context[32], "Unbalanced bracket \"", 20 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[33] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[34], & StrFromBracket ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[35], context[24]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[36] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[37], '\"' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[38] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[39] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & EL_AddErrorAt );
    refalrts::reinit_svar( context[9], context[25] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[29] );
    refalrts::link_brackets( context[17], context[18] );
    refalrts::link_brackets( context[13], context[14] );
    refalrts::link_brackets( context[22], context[23] );
    refalrts::link_brackets( context[39], context[10] );
    refalrts::push_stack( context[38] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[36] );
    refalrts::push_stack( context[33] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[14];
    res = refalrts::splice_evar( res, context[23], context[23] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[22], context[24] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[10], context[13] );
    res = refalrts::splice_evar( res, context[42], context[43] );
    res = refalrts::splice_evar( res, context[31], context[39] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[29], context[30] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( ) ( e.idx ) ( # Close s.idx s.idx ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Close/19 s.LnNum#1/20 s.CloseBracket#1/21 )/18 e.Tail#1/2 >/1
    context[40] = context[2];
    context[41] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_Close<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    context[42] = context[7];
    context[43] = context[8];
    if( ! refalrts::empty_seq( context[42], context[43] ) )
      continue;
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 40(2)
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParsePattern/4 } </22 & EL-AddErrorAt/23 Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: s.LnNum#1/20 }"Unb"/24 Tile{ HalfReuse: 'a'/17 HalfReuse: 'l'/19 }"anced bracket \""/26 </28 & StrFromBracket/29 Tile{ AsIs: s.CloseBracket#1/21 HalfReuse: >/18 } '\"'/30 >/31 Tile{ AsIs: (/9 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 AsIs: )/14 } Tile{ AsIs: e.Tail#1/40(2) } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[23], & EL_AddErrorAt ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "Unb", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[26], context[27], "anced bracket \"", 15 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[29], & StrFromBracket ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[30], '\"' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[17], 'a' );
    refalrts::reinit_char( context[19], 'l' );
    refalrts::reinit_close_call( context[18] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[14] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[28] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[40], context[41] );
    res = refalrts::splice_evar( res, context[9], context[14] );
    res = refalrts::splice_evar( res, context[30], context[31] );
    res = refalrts::splice_evar( res, context[21], context[18] );
    res = refalrts::splice_evar( res, context[26], context[29] );
    res = refalrts::splice_evar( res, context[17], context[19] );
    res = refalrts::splice_evar( res, context[24], context[25] );
    res = refalrts::splice_evar( res, context[20], context[20] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ( s.idx s.idx s.idx e.idx ) ) ( e.idx ) e.idx
    // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 (/17 s.BracketsSign#1/19 s.InnerLnNum#1/20 s.CloseBracket#1/21 e.Scanned#1/15 )/18 )/10 (/13 e.InnerScanned#1/11 )/14 e.Tail#1/2 >/1
    context[40] = context[7];
    context[41] = context[8];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_right( context[15], context[16], context[40], context[41] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    // closed e.MultiBracket#1 as range 40(7)
    // closed e.InnerScanned#1 as range 11
    // closed e.Tail#1 as range 2
    if( ! refalrts::svar_left( context[19], context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[15], context[16] ) )
      continue;
    // closed e.Scanned#1 as range 15

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.InnerLnNum#1/20 s.CloseBracket#1/21 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </22 & ParsePattern/23 Tile{ AsIs: </0 Reuse: & EL-AddErrorAt/4 AsIs: t.ErrorList#1/5 HalfReuse: s.InnerLnNum1 #20/9 }"Unbalanced bracket \""/24 </26 & StrFromBracket/27 s.BracketsSign#1/19/28 >/29 '\"'/30 >/31 (/32 Tile{ AsIs: e.MultiBracket#1/40(7) } Tile{ AsIs: )/10 AsIs: (/13 } Tile{ AsIs: e.Scanned#1/15 } Tile{ AsIs: (/17 AsIs: s.BracketsSign#1/19 } Tile{ AsIs: e.InnerScanned#1/11 } Tile{ AsIs: )/18 } Tile{ AsIs: )/14 AsIs: e.Tail#1/2 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[23], & ParsePattern ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "Unbalanced bracket \"", 20 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & StrFromBracket ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[28], context[19]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[30], '\"' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[32] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & EL_AddErrorAt );
    refalrts::reinit_svar( context[9], context[20] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[22] );
    refalrts::link_brackets( context[13], context[14] );
    refalrts::link_brackets( context[17], context[18] );
    refalrts::link_brackets( context[32], context[10] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[26] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[14];
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[17], context[19] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[10], context[13] );
    res = refalrts::splice_evar( res, context[40], context[41] );
    res = refalrts::splice_evar( res, context[24], context[32] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  // t.idx ( ) ( e.idx ) e.idx
  // </0 & ParsePattern/4 t.ErrorList#1/5 (/9 )/10 (/13 e.Pattern#1/11 )/14 e.Tail#1/2 >/1
  if( ! refalrts::empty_seq( context[7], context[8] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Pattern#1 as range 11
  // closed e.Tail#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ParsePattern/4 {REMOVED TILE} (/9 )/10 {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: (/13 AsIs: e.Pattern#1/11 AsIs: )/14 } Tile{ AsIs: e.Tail#1/2 } Tile{ ]] }
  refalrts::link_brackets( context[13], context[14] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_ParsePattern(func_ParsePattern, "ParsePattern");
refalrts::RefalFunction& ParsePattern = descr_ParsePattern;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_StrFromBracket {
    using refalrts::functions;
    static const refalrts::RefalIdentifier idents[] = {
      & ident_CallBrackets<int>::name,
      & ident_ADT_Brackets<int>::name,
      & ident_Brackets<int>::name,
      & ident_TkCloseADT<int>::name,
      & ident_TkOpenADT<int>::name,
      & ident_TkCloseCall<int>::name,
      & ident_TkOpenCall<int>::name,
      & ident_TkCloseBracket<int>::name,
      & ident_TkOpenBracket<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 8, 0, 0},
      {refalrts::icIssueMemory, 6, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & StrFromBracket/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +6, 0, 0},
      // # TkOpenBracket
      // </0 & StrFromBracket/4 # TkOpenBracket/5 >/1
      {refalrts::icIdentTerm, 0, 8, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # TkOpenBracket/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: '('/1 ]] }
      {refalrts::icReinitChar, 0, '(', 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +6, 0, 0},
      // # TkCloseBracket
      // </0 & StrFromBracket/4 # TkCloseBracket/5 >/1
      {refalrts::icIdentTerm, 0, 7, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # TkCloseBracket/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: ')'/1 ]] }
      {refalrts::icReinitChar, 0, ')', 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +6, 0, 0},
      // # TkOpenCall
      // </0 & StrFromBracket/4 # TkOpenCall/5 >/1
      {refalrts::icIdentTerm, 0, 6, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # TkOpenCall/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: '<'/1 ]] }
      {refalrts::icReinitChar, 0, '<', 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +6, 0, 0},
      // # TkCloseCall
      // </0 & StrFromBracket/4 # TkCloseCall/5 >/1
      {refalrts::icIdentTerm, 0, 5, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # TkCloseCall/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: '>'/1 ]] }
      {refalrts::icReinitChar, 0, '>', 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +6, 0, 0},
      // # TkOpenADT
      // </0 & StrFromBracket/4 # TkOpenADT/5 >/1
      {refalrts::icIdentTerm, 0, 4, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # TkOpenADT/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: '['/1 ]] }
      {refalrts::icReinitChar, 0, '[', 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +6, 0, 0},
      // # TkCloseADT
      // </0 & StrFromBracket/4 # TkCloseADT/5 >/1
      {refalrts::icIdentTerm, 0, 3, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # TkCloseADT/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: ']'/1 ]] }
      {refalrts::icReinitChar, 0, ']', 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +6, 0, 0},
      // # Brackets
      // </0 & StrFromBracket/4 # Brackets/5 >/1
      {refalrts::icIdentTerm, 0, 2, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # Brackets/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: '('/1 ]] }
      {refalrts::icReinitChar, 0, '(', 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +6, 0, 0},
      // # ADT-Brackets
      // </0 & StrFromBracket/4 # ADT-Brackets/5 >/1
      {refalrts::icIdentTerm, 0, 1, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # ADT-Brackets/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: '['/1 ]] }
      {refalrts::icReinitChar, 0, '[', 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // # CallBrackets
      // </0 & StrFromBracket/4 # CallBrackets/5 >/1
      {refalrts::icIdentTerm, 0, 0, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # CallBrackets/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: '<'/1 ]] }
      {refalrts::icReinitChar, 0, '<', 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_StrFromBracket

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_StrFromBracket(
  "StrFromBracket",
  scope_StrFromBracket::raa,
  scope_StrFromBracket::functions,
  scope_StrFromBracket::idents,
  scope_StrFromBracket::numbers,
  scope_StrFromBracket::strings
);
refalrts::RefalFunction& StrFromBracket = descr_StrFromBracket;

} // unnamed namespace

#else
static refalrts::FnResult func_StrFromBracket(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & StrFromBracket/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    refalrts::start_sentence();
    // # TkOpenBracket
    // </0 & StrFromBracket/4 # TkOpenBracket/5 >/1
    if( ! refalrts::ident_term(  & ident_TkOpenBracket<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # TkOpenBracket/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '('/1 ]] }
    refalrts::reinit_char( context[1], '(' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // # TkCloseBracket
    // </0 & StrFromBracket/4 # TkCloseBracket/5 >/1
    if( ! refalrts::ident_term(  & ident_TkCloseBracket<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # TkCloseBracket/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: ')'/1 ]] }
    refalrts::reinit_char( context[1], ')' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // # TkOpenCall
    // </0 & StrFromBracket/4 # TkOpenCall/5 >/1
    if( ! refalrts::ident_term(  & ident_TkOpenCall<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # TkOpenCall/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '<'/1 ]] }
    refalrts::reinit_char( context[1], '<' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // # TkCloseCall
    // </0 & StrFromBracket/4 # TkCloseCall/5 >/1
    if( ! refalrts::ident_term(  & ident_TkCloseCall<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # TkCloseCall/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '>'/1 ]] }
    refalrts::reinit_char( context[1], '>' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // # TkOpenADT
    // </0 & StrFromBracket/4 # TkOpenADT/5 >/1
    if( ! refalrts::ident_term(  & ident_TkOpenADT<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # TkOpenADT/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '['/1 ]] }
    refalrts::reinit_char( context[1], '[' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // # TkCloseADT
    // </0 & StrFromBracket/4 # TkCloseADT/5 >/1
    if( ! refalrts::ident_term(  & ident_TkCloseADT<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # TkCloseADT/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: ']'/1 ]] }
    refalrts::reinit_char( context[1], ']' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // # Brackets
    // </0 & StrFromBracket/4 # Brackets/5 >/1
    if( ! refalrts::ident_term(  & ident_Brackets<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # Brackets/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '('/1 ]] }
    refalrts::reinit_char( context[1], '(' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // # ADT-Brackets
    // </0 & StrFromBracket/4 # ADT-Brackets/5 >/1
    if( ! refalrts::ident_term(  & ident_ADT_Brackets<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # ADT-Brackets/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '['/1 ]] }
    refalrts::reinit_char( context[1], '[' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  // # CallBrackets
  // </0 & StrFromBracket/4 # CallBrackets/5 >/1
  if( ! refalrts::ident_term(  & ident_CallBrackets<int>::name, context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & StrFromBracket/4 # CallBrackets/5 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: '<'/1 ]] }
  refalrts::reinit_char( context[1], '<' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_StrFromBracket(func_StrFromBracket, "StrFromBracket");
refalrts::RefalFunction& StrFromBracket = descr_StrFromBracket;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseResult_S9L1 {
    using refalrts::functions;
    static const refalrts::RefalIdentifier idents[] = {
      & ident_CallBrackets<int>::name,
      & ident_TkOpenCall<int>::name,
      & ident_Brackets<int>::name,
      & ident_TkOpenBracket<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 6, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseResult$9\1/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +6, 0, 0},
      // # TkOpenBracket
      // </0 & ParseResult$9\1/4 # TkOpenBracket/5 >/1
      {refalrts::icIdentTerm, 0, 3, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseResult$9\1/4 # TkOpenBracket/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: # Brackets/1 ]] }
      {refalrts::icReinitIdent, 0, 2, 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // # TkOpenCall
      // </0 & ParseResult$9\1/4 # TkOpenCall/5 >/1
      {refalrts::icIdentTerm, 0, 1, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseResult$9\1/4 # TkOpenCall/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: # CallBrackets/1 ]] }
      {refalrts::icReinitIdent, 0, 0, 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseResult_S9L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseResult_S9L1(
  "ParseResult$9\\1",
  scope_gen_ParseResult_S9L1::raa,
  scope_gen_ParseResult_S9L1::functions,
  scope_gen_ParseResult_S9L1::idents,
  scope_gen_ParseResult_S9L1::numbers,
  scope_gen_ParseResult_S9L1::strings
);
refalrts::RefalFunction& gen_ParseResult_S9L1 = descr_gen_ParseResult_S9L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseResult_S9L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseResult$9\1/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    refalrts::start_sentence();
    // # TkOpenBracket
    // </0 & ParseResult$9\1/4 # TkOpenBracket/5 >/1
    if( ! refalrts::ident_term(  & ident_TkOpenBracket<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & ParseResult$9\1/4 # TkOpenBracket/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: # Brackets/1 ]] }
    refalrts::reinit_ident( context[1], & ident_Brackets<int>::name );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  // # TkOpenCall
  // </0 & ParseResult$9\1/4 # TkOpenCall/5 >/1
  if( ! refalrts::ident_term(  & ident_TkOpenCall<int>::name, context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ParseResult$9\1/4 # TkOpenCall/5 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: # CallBrackets/1 ]] }
  refalrts::reinit_ident( context[1], & ident_CallBrackets<int>::name );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_gen_ParseResult_S9L1(func_gen_ParseResult_S9L1, "ParseResult$9\\1");
refalrts::RefalFunction& gen_ParseResult_S9L1 = descr_gen_ParseResult_S9L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseResult_S9L2 {
    using refalrts::functions;
    static const refalrts::RefalIdentifier idents[] = {
      & ident_TkCloseCall<int>::name,
      & ident_TkOpenCall<int>::name,
      & ident_TkCloseBracket<int>::name,
      & ident_TkOpenBracket<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 1, 0, 0},
      {refalrts::icIssueMemory, 6, 0, 0},
      //FAST GEN: s.$
      //GLOBAL GEN: s.$
      // </0 & ParseResult$9\2/4 s.idx#0/5 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icsVarLeft, 0, 5, 2},
      {refalrts::icEmpty, 0, 0, 2},
      {refalrts::icOnFailGoTo, +6, 0, 0},
      // # TkOpenBracket
      // </0 & ParseResult$9\2/4 # TkOpenBracket/5 >/1
      {refalrts::icIdentTerm, 0, 3, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseResult$9\2/4 # TkOpenBracket/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: # TkCloseBracket/1 ]] }
      {refalrts::icReinitIdent, 0, 2, 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // # TkOpenCall
      // </0 & ParseResult$9\2/4 # TkOpenCall/5 >/1
      {refalrts::icIdentTerm, 0, 1, 5},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseResult$9\2/4 # TkOpenCall/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: # TkCloseCall/1 ]] }
      {refalrts::icReinitIdent, 0, 0, 1},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseResult_S9L2

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseResult_S9L2(
  "ParseResult$9\\2",
  scope_gen_ParseResult_S9L2::raa,
  scope_gen_ParseResult_S9L2::functions,
  scope_gen_ParseResult_S9L2::idents,
  scope_gen_ParseResult_S9L2::numbers,
  scope_gen_ParseResult_S9L2::strings
);
refalrts::RefalFunction& gen_ParseResult_S9L2 = descr_gen_ParseResult_S9L2;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseResult_S9L2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & ParseResult$9\2/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    refalrts::start_sentence();
    // # TkOpenBracket
    // </0 & ParseResult$9\2/4 # TkOpenBracket/5 >/1
    if( ! refalrts::ident_term(  & ident_TkOpenBracket<int>::name, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & ParseResult$9\2/4 # TkOpenBracket/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: # TkCloseBracket/1 ]] }
    refalrts::reinit_ident( context[1], & ident_TkCloseBracket<int>::name );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  // # TkOpenCall
  // </0 & ParseResult$9\2/4 # TkOpenCall/5 >/1
  if( ! refalrts::ident_term(  & ident_TkOpenCall<int>::name, context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ParseResult$9\2/4 # TkOpenCall/5 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: # TkCloseCall/1 ]] }
  refalrts::reinit_ident( context[1], & ident_TkCloseCall<int>::name );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_gen_ParseResult_S9L2(func_gen_ParseResult_S9L2, "ParseResult$9\\2");
refalrts::RefalFunction& gen_ParseResult_S9L2 = descr_gen_ParseResult_S9L2;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_gen_ParseResult_S11L1 {
    static refalrts::RefalFunction *functions[] = {
      & ParseResult
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_Closure<int>::name
    };
    using refalrts::numbers;
    using refalrts::strings;
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icIssueMemory, 20, 0, 0},
      // </0 & ParseResult$11\1/4 (/7 e.MultiBracket#1/5 )/8 (/11 e.Scanned#1/9 )/12 (/15 e.Block#2/13 )/16 t.ErrorList#2/17 e.Tail#2/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::icBracketLeftSave, 0, 5, 2},
      {refalrts::icBracketLeftSave, 0, 9, 2},
      {refalrts::icBracketLeftSave, 0, 13, 2},
      // closed e.MultiBracket#1 as range 5
      // closed e.Scanned#1 as range 9
      // closed e.Block#2 as range 13
      {refalrts::ictVarLeftSave, 0, 17, 2},
      // closed e.Tail#2 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseResult/4 } Tile{ AsIs: t.ErrorList#2/17 } Tile{ AsIs: (/7 AsIs: e.MultiBracket#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.Scanned#1/9 HalfReuse: (/12 HalfReuse: # Closure/15 AsIs: e.Block#2/13 AsIs: )/16 } )/19 Tile{ AsIs: e.Tail#2/2 } Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 19},
      {refalrts::icUpdateFunc, 0, 0, 4},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 12},
      {refalrts::icReinitIdent, 0, 0, 15},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 11, 19, 0},
      {refalrts::icLinkBrackets, 12, 16, 0},
      {refalrts::icLinkBrackets, 7, 8, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 19, 19, 0},
      {refalrts::icSpliceTile, 7, 16, 0},
      {refalrts::icSpliceTile, 17, 18, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_gen_ParseResult_S11L1

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_gen_ParseResult_S11L1(
  "ParseResult$11\\1",
  scope_gen_ParseResult_S11L1::raa,
  scope_gen_ParseResult_S11L1::functions,
  scope_gen_ParseResult_S11L1::idents,
  scope_gen_ParseResult_S11L1::numbers,
  scope_gen_ParseResult_S11L1::strings
);
refalrts::RefalFunction& gen_ParseResult_S11L1 = descr_gen_ParseResult_S11L1;

} // unnamed namespace

#else
static refalrts::FnResult func_gen_ParseResult_S11L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 20 elems
  refalrts::Iter context[20];
  refalrts::zeros( context, 20 );
  // </0 & ParseResult$11\1/4 (/7 e.MultiBracket#1/5 )/8 (/11 e.Scanned#1/9 )/12 (/15 e.Block#2/13 )/16 t.ErrorList#2/17 e.Tail#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  context[13] = 0;
  context[14] = 0;
  context[15] = refalrts::brackets_left( context[13], context[14], context[2], context[3] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[15], context[16]);
  // closed e.MultiBracket#1 as range 5
  // closed e.Scanned#1 as range 9
  // closed e.Block#2 as range 13
  context[18] = refalrts::tvar_left( context[17], context[2], context[3] );
  if( ! context[18] )
    return refalrts::cRecognitionImpossible;
  // closed e.Tail#2 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & ParseResult/4 } Tile{ AsIs: t.ErrorList#2/17 } Tile{ AsIs: (/7 AsIs: e.MultiBracket#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.Scanned#1/9 HalfReuse: (/12 HalfReuse: # Closure/15 AsIs: e.Block#2/13 AsIs: )/16 } )/19 Tile{ AsIs: e.Tail#2/2 } Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_close_bracket( context[19] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], & ParseResult );
  refalrts::reinit_open_bracket( context[12] );
  refalrts::reinit_ident( context[15], & ident_Closure<int>::name );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[11], context[19] );
  refalrts::link_brackets( context[12], context[16] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[19], context[19] );
  res = refalrts::splice_evar( res, context[7], context[16] );
  res = refalrts::splice_evar( res, context[17], context[18] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_gen_ParseResult_S11L1(func_gen_ParseResult_S11L1, "ParseResult$11\\1");
refalrts::RefalFunction& gen_ParseResult_S11L1 = descr_gen_ParseResult_S11L1;

} // unnamed namespace

#endif
#ifdef INTERPRET
namespace /* unnamed */ {
  namespace scope_ParseResult {
    static refalrts::RefalFunction *functions[] = {
      & StrFromBracket,
      & EL_AddErrorAt,
      & ParseResult,
      & refalrts::create_closure,
      & ParseBlock,
      & gen_ParseResult_S11L1,
      & Fetch,
      & gen_ParseResult_S9L1,
      & gen_ParseResult_S9L2
    };
    static const refalrts::RefalIdentifier idents[] = {
      & ident_Close<int>::name,
      & ident_TkOpenBlock<int>::name,
      & ident_Open<int>::name,
      & ident_UnnamedADT<int>::name,
      & ident_TkCloseADT<int>::name,
      & ident_ADT_Brackets<int>::name,
      & ident_TkOpenADT<int>::name,
      & ident_TkName<int>::name,
      & ident_TkVariable<int>::name,
      & ident_TkIdentMarker<int>::name,
      & ident_TkIdentifier<int>::name,
      & ident_TkNumber<int>::name,
      & ident_TkChar<int>::name
    };
    using refalrts::numbers;
    static const refalrts::StringItem strings[] = {
      {"anced bracket \"", 15},
      {"Unb", 3},
      {"Unbalanced bracket \"", 20},
      {"Expected name after \"[\"", 23},
      {"d name after \"#\"", 16},
      {"is", 2}
    };
    static const refalrts::RASLCommand raa[] = {
      {refalrts::icReserveBacktrackStack, 13, 0, 0},
      {refalrts::icIssueMemory, 37, 0, 0},
      //FAST GEN: e.$
      //GLOBAL GEN: t.$ ( e.$ ) ( e.$ ) e.$
      // </0 & ParseResult/4 t.idx#0/5 (/9 e.idxVB#0/7 )/10 (/13 e.idxVTB#0/11 )/14 e.idxVTT#0/2 >/1
      {refalrts::icInitB0_Lite, 0, 0, 0},
      {refalrts::icCallSaveLeft, 0, 2, 0},
      {refalrts::ictVarLeftSave, 0, 5, 2},
      {refalrts::icBracketLeftSave, 0, 7, 2},
      {refalrts::icBracketLeftSave, 0, 11, 2},
      // closed e.idxVB#0 as range 7
      // closed e.idxVTB#0 as range 11
      // closed e.idxVTT#0 as range 2
      {refalrts::icOnFailGoTo, +20, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # TkChar s.idx s.idx ) e.idx
      // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkChar/19 s.LnNum#1/20 s.Char#1/21 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 33, 2},
      {refalrts::icBracketLeftSave, 0, 15, 33},
      {refalrts::icIdentLeftSave, 19, 12, 15},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 33(2)
      {refalrts::icsVarLeft, 0, 20, 15},
      {refalrts::icsVarLeft, 0, 21, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.LnNum#1/20 s.Char#1/21 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkChar/17 HalfReuse: s.Char1 #21/19 } )/22 Tile{ AsIs: )/18 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 22},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 14},
      {refalrts::icReinitIdent, 0, 12, 17},
      {refalrts::icReinitSVar, 0, 21, 19},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 18, 0},
      {refalrts::icLinkBrackets, 14, 22, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icSetRes, 0, 0, 18},
      {refalrts::icSpliceTile, 22, 22, 0},
      {refalrts::icTrash, 0, 0, 19},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +20, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # TkNumber s.idx s.idx ) e.idx
      // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkNumber/19 s.LnNum#1/20 s.Number#1/21 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 33, 2},
      {refalrts::icBracketLeftSave, 0, 15, 33},
      {refalrts::icIdentLeftSave, 19, 11, 15},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 33(2)
      {refalrts::icsVarLeft, 0, 20, 15},
      {refalrts::icsVarLeft, 0, 21, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.LnNum#1/20 s.Number#1/21 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkNumber/17 HalfReuse: s.Number1 #21/19 } )/22 Tile{ AsIs: )/18 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 22},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 14},
      {refalrts::icReinitIdent, 0, 11, 17},
      {refalrts::icReinitSVar, 0, 21, 19},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 18, 0},
      {refalrts::icLinkBrackets, 14, 22, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icSetRes, 0, 0, 18},
      {refalrts::icSpliceTile, 22, 22, 0},
      {refalrts::icTrash, 0, 0, 19},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +19, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # TkName s.idx e.idx ) e.idx
      // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkName/19 s.LnNum#1/20 e.Name#1/15 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 33, 2},
      {refalrts::icBracketLeftSave, 0, 15, 33},
      {refalrts::icIdentLeftSave, 19, 7, 15},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 33(2)
      {refalrts::icsVarLeft, 0, 20, 15},
      // closed e.Name#1 as range 15
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.LnNum#1/20 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkName/17 HalfReuse: s.LnNum1 #20/19 } Tile{ AsIs: e.Name#1/15 } )/21 Tile{ AsIs: )/18 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 21},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 14},
      {refalrts::icReinitIdent, 0, 7, 17},
      {refalrts::icReinitSVar, 0, 20, 19},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 18, 0},
      {refalrts::icLinkBrackets, 14, 21, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icSetRes, 0, 0, 18},
      {refalrts::icSpliceTile, 21, 21, 0},
      {refalrts::icSpliceEVar, 0, 0, 15},
      {refalrts::icTrash, 0, 0, 19},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +21, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # TkIdentMarker s.idx ) ( # TkName s.idx e.idx ) e.idx
      // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkIdentMarker/19 s.MarkerLnNum#1/25 )/18 (/22 # TkName/24 s.NameLnNum#1/26 e.Name#1/20 )/23 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 33, 2},
      {refalrts::icBracketLeftSave, 0, 15, 33},
      {refalrts::icIdentLeftSave, 19, 9, 15},
      {refalrts::icBracketLeftSave, 0, 20, 33},
      {refalrts::icIdentLeftSave, 24, 7, 20},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 33(2)
      {refalrts::icsVarLeft, 0, 25, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icsVarLeft, 0, 26, 20},
      // closed e.Name#1 as range 20
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} # TkIdentMarker/19 s.MarkerLnNum#1/25 {REMOVED TILE} (/22 # TkName/24 s.NameLnNum#1/26 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkIdentifier/17 } Tile{ AsIs: e.Name#1/20 } Tile{ AsIs: )/18 } Tile{ AsIs: )/23 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 14},
      {refalrts::icReinitIdent, 0, 10, 17},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 23, 0},
      {refalrts::icLinkBrackets, 14, 18, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icSetRes, 0, 0, 23},
      {refalrts::icSpliceTile, 18, 18, 0},
      {refalrts::icSpliceEVar, 0, 0, 20},
      {refalrts::icTrash, 0, 0, 17},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +30, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # TkIdentMarker s.idx ) e.idx
      // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkIdentMarker/19 s.LnNum#1/20 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 33, 2},
      {refalrts::icBracketLeftSave, 0, 15, 33},
      {refalrts::icIdentLeftSave, 19, 9, 15},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 33(2)
      {refalrts::icsVarLeft, 0, 20, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 } </21 & EL-AddErrorAt/22 Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: s.LnNum#1/20 HalfReuse: 'M'/18 }"is"/23 Tile{ HalfReuse: 's'/17 HalfReuse: 'e'/19 }"d name after \"#\""/25 >/27 Tile{ AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 AsIs: )/14 } Tile{ AsIs: e.Tail#1/33(2) } Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 21},
      {refalrts::icAllocFunc, 0, 1, 22},
      {refalrts::icAllocString, 0, 5, 23},
      {refalrts::icAllocString, 0, 4, 25},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 27},
      {refalrts::icReinitChar, 0, 'M', 18},
      {refalrts::icReinitChar, 0, 's', 17},
      {refalrts::icReinitChar, 0, 'e', 19},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 14, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icPushStack, 0, 0, 27},
      {refalrts::icPushStack, 0, 0, 21},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 33},
      {refalrts::icSpliceTile, 9, 14, 0},
      {refalrts::icSpliceTile, 25, 27, 0},
      {refalrts::icSpliceTile, 17, 19, 0},
      {refalrts::icSpliceTile, 23, 24, 0},
      {refalrts::icSpliceTile, 20, 18, 0},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icSpliceTile, 21, 22, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +21, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # TkVariable s.idx s.idx e.idx ) e.idx
      // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkVariable/19 s.LnNum#1/20 s.Mode#1/21 e.Index#1/15 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 33, 2},
      {refalrts::icBracketLeftSave, 0, 15, 33},
      {refalrts::icIdentLeftSave, 19, 8, 15},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 33(2)
      {refalrts::icsVarLeft, 0, 20, 15},
      {refalrts::icsVarLeft, 0, 21, 15},
      // closed e.Index#1 as range 15
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.LnNum#1/20 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkVariable/17 HalfReuse: s.LnNum1 #20/19 } Tile{ AsIs: s.Mode#1/21 } Tile{ AsIs: e.Index#1/15 } )/22 Tile{ AsIs: )/18 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 22},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 14},
      {refalrts::icReinitIdent, 0, 8, 17},
      {refalrts::icReinitSVar, 0, 20, 19},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 18, 0},
      {refalrts::icLinkBrackets, 14, 22, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icSetRes, 0, 0, 18},
      {refalrts::icSpliceTile, 22, 22, 0},
      {refalrts::icSpliceEVar, 0, 0, 15},
      {refalrts::icSpliceTile, 21, 21, 0},
      {refalrts::icTrash, 0, 0, 19},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +32, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # Open s.idx # TkOpenADT ) ( # TkName s.idx e.idx ) e.idx
      // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Open/19 s.LnNumADT#1/26 # TkOpenADT/20 )/18 (/23 # TkName/25 s.LnNumName#1/27 e.Name#1/21 )/24 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 33, 2},
      {refalrts::icBracketLeftSave, 0, 15, 33},
      {refalrts::icIdentLeftSave, 19, 2, 15},
      {refalrts::icIdentRightSave, 20, 6, 15},
      {refalrts::icBracketLeftSave, 0, 21, 33},
      {refalrts::icIdentLeftSave, 25, 7, 21},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 33(2)
      {refalrts::icsVarLeft, 0, 26, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icsVarLeft, 0, 27, 21},
      // closed e.Name#1 as range 21
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNumADT#1/26 {REMOVED TILE} s.LnNumName#1/27 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 HalfReuse: (/10 HalfReuse: # ADT-Brackets/13 } Tile{ HalfReuse: s.LnNumADT1 #26/17 Reuse: # TkCloseADT/19 } Tile{ AsIs: e.Scanned#1/11 } Tile{ HalfReuse: )/20 AsIs: )/18 AsIs: (/23 HalfReuse: s.LnNumName1 #27/25 } (/28 Tile{ AsIs: e.Name#1/21 } Tile{ AsIs: )/14 } Tile{ AsIs: )/24 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 28},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 10},
      {refalrts::icReinitIdent, 0, 5, 13},
      {refalrts::icReinitSVar, 0, 26, 17},
      {refalrts::icUpdateIdent, 0, 4, 19},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 20},
      {refalrts::icReinitSVar, 0, 27, 25},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 23, 24, 0},
      {refalrts::icLinkBrackets, 28, 14, 0},
      {refalrts::icLinkBrackets, 9, 18, 0},
      {refalrts::icLinkBrackets, 10, 20, 0},
      {refalrts::icSetRes, 0, 0, 24},
      {refalrts::icSpliceTile, 14, 14, 0},
      {refalrts::icSpliceEVar, 0, 0, 21},
      {refalrts::icSpliceTile, 28, 28, 0},
      {refalrts::icSpliceTile, 20, 25, 0},
      {refalrts::icSpliceEVar, 0, 0, 11},
      {refalrts::icSpliceTile, 17, 19, 0},
      {refalrts::icTrash, 0, 0, 13},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +42, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # Open s.idx # TkOpenADT ) e.idx
      // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Open/19 s.LnNum#1/21 # TkOpenADT/20 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 33, 2},
      {refalrts::icBracketLeftSave, 0, 15, 33},
      {refalrts::icIdentLeftSave, 19, 2, 15},
      {refalrts::icIdentRightSave, 20, 6, 15},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 33(2)
      {refalrts::icsVarLeft, 0, 21, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </22 & ParseResult/23 Tile{ AsIs: </0 Reuse: & EL-AddErrorAt/4 AsIs: t.ErrorList#1/5 HalfReuse: s.LnNum1 #21/9 }"Expected name after \"[\""/24 >/26 (/27 Tile{ AsIs: e.MultiBracket#1/7 } (/28 # ADT-Brackets/29 Tile{ HalfReuse: s.LnNum1 #21/10 HalfReuse: # TkCloseADT/13 AsIs: e.Scanned#1/11 AsIs: )/14 HalfReuse: )/17 HalfReuse: (/19 AsIs: s.LnNum#1/21 HalfReuse: (/20 HalfReuse: # UnnamedADT/18 } )/30 )/31 Tile{ AsIs: e.Tail#1/33(2) } Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 22},
      {refalrts::icAllocFunc, 0, 2, 23},
      {refalrts::icAllocString, 0, 3, 24},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 26},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 27},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 28},
      {refalrts::icAllocIdent, 0, 5, 29},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 30},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 31},
      {refalrts::icUpdateFunc, 0, 1, 4},
      {refalrts::icReinitSVar, 0, 21, 9},
      {refalrts::icReinitSVar, 0, 21, 10},
      {refalrts::icReinitIdent, 0, 4, 13},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 17},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 19},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 20},
      {refalrts::icReinitIdent, 0, 3, 18},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 22},
      {refalrts::icLinkBrackets, 19, 31, 0},
      {refalrts::icLinkBrackets, 20, 30, 0},
      {refalrts::icLinkBrackets, 27, 17, 0},
      {refalrts::icLinkBrackets, 28, 14, 0},
      {refalrts::icPushStack, 0, 0, 26},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 33},
      {refalrts::icSpliceTile, 30, 31, 0},
      {refalrts::icSpliceTile, 10, 18, 0},
      {refalrts::icSpliceTile, 28, 29, 0},
      {refalrts::icSpliceEVar, 0, 0, 7},
      {refalrts::icSpliceTile, 24, 27, 0},
      {refalrts::icSpliceTile, 0, 9, 0},
      {refalrts::icSpliceTile, 22, 23, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +38, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # Open s.idx s.idx ) e.idx
      // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Open/19 s.LnNum#1/20 s.OpenBracket#1/21 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 33, 2},
      {refalrts::icBracketLeftSave, 0, 15, 33},
      {refalrts::icIdentLeftSave, 19, 2, 15},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 33(2)
      {refalrts::icsVarLeft, 0, 20, 15},
      {refalrts::icsVarLeft, 0, 21, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 HalfReuse: (/10 HalfReuse: </13 } & Fetch/22 Tile{ HalfReuse: s.OpenBracket1 #21/14 HalfReuse: & ParseResult$9\1/17 HalfReuse: >/19 AsIs: s.LnNum#1/20 } </23 & Fetch/24 Tile{ AsIs: s.OpenBracket#1/21 } & ParseResult$9\2/25 >/26 Tile{ AsIs: e.Scanned#1/11 } )/27 )/28 (/29 Tile{ AsIs: )/18 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
      {refalrts::icAllocFunc, 0, 6, 22},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 23},
      {refalrts::icAllocFunc, 0, 6, 24},
      {refalrts::icAllocFunc, 0, 8, 25},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 26},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 27},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseBracket, 28},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 29},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 10},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenCall, 13},
      {refalrts::icReinitSVar, 0, 21, 14},
      {refalrts::icReinitFunc, 0, 7, 17},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 19},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 29, 18, 0},
      {refalrts::icLinkBrackets, 9, 28, 0},
      {refalrts::icLinkBrackets, 10, 27, 0},
      {refalrts::icPushStack, 0, 0, 26},
      {refalrts::icPushStack, 0, 0, 23},
      {refalrts::icPushStack, 0, 0, 19},
      {refalrts::icPushStack, 0, 0, 13},
      {refalrts::icSetRes, 0, 0, 18},
      {refalrts::icSpliceTile, 27, 29, 0},
      {refalrts::icSpliceEVar, 0, 0, 11},
      {refalrts::icSpliceTile, 25, 26, 0},
      {refalrts::icSpliceTile, 21, 21, 0},
      {refalrts::icSpliceTile, 23, 24, 0},
      {refalrts::icSpliceTile, 14, 20, 0},
      {refalrts::icSpliceTile, 22, 22, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +26, 0, 0},
      // t.idx ( e.idx ( s.idx s.idx s.idx e.idx ) ) ( e.idx ) ( # Close s.idx s.idx ) e.idx
      // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 (/22 s.BracketsSign#1/24 s.OpenLnNum#1/25 s.CloseBracket#1/26 e.Scanned#1/20 )/23 )/10 (/13 e.InnerScanned#1/11 )/14 (/17 # Close/19 s.LnNum#1/28 s.CloseBracket#1/27 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 33, 2},
      {refalrts::icBracketLeftSave, 0, 15, 33},
      {refalrts::icIdentLeftSave, 19, 0, 15},
      {refalrts::icSave, 0, 35, 7},
      {refalrts::icBracketRightSave, 0, 20, 35},
      // closed e.MultiBracket#1 as range 35(7)
      // closed e.InnerScanned#1 as range 11
      // closed e.Tail#1 as range 33(2)
      {refalrts::icsVarLeft, 0, 24, 20},
      {refalrts::icsVarLeft, 0, 25, 20},
      {refalrts::icsVarLeft, 0, 26, 20},
      {refalrts::icsRepeatRight, 27, 26, 15},
      // closed e.Scanned#1 as range 20
      {refalrts::icsVarLeft, 0, 28, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} s.BracketsSign#1/24 s.OpenLnNum#1/25 s.CloseBracket#1/26 {REMOVED TILE} )/23 {REMOVED TILE} {REMOVED TILE} # Close/19 s.LnNum#1/28 s.CloseBracket#1/27 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/35(7) HalfReuse: )/22 } Tile{ AsIs: (/17 } Tile{ AsIs: e.Scanned#1/20 } Tile{ HalfReuse: (/10 HalfReuse: s.BracketsSign1 #24/13 AsIs: e.InnerScanned#1/11 AsIs: )/14 } Tile{ AsIs: )/18 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
      {refalrts::icReinitBracket, 0, refalrts::ibCloseBracket, 22},
      {refalrts::icReinitBracket, 0, refalrts::ibOpenBracket, 10},
      {refalrts::icReinitSVar, 0, 24, 13},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 17, 18, 0},
      {refalrts::icLinkBrackets, 10, 14, 0},
      {refalrts::icLinkBrackets, 9, 22, 0},
      {refalrts::icSetRes, 0, 0, 18},
      {refalrts::icSpliceTile, 10, 14, 0},
      {refalrts::icSpliceEVar, 0, 0, 20},
      {refalrts::icSpliceTile, 17, 17, 0},
      {refalrts::icTrash, 0, 0, 22},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +33, 0, 0},
      // t.idx ( e.idx ) ( e.idx ) ( # TkOpenBlock s.idx ) e.idx
      // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkOpenBlock/19 s.LnNum#1/20 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 33, 2},
      {refalrts::icBracketLeftSave, 0, 15, 33},
      {refalrts::icIdentLeftSave, 19, 1, 15},
      // closed e.MultiBracket#1 as range 7
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 33(2)
      {refalrts::icsVarLeft, 0, 20, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNum#1/20 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </21 & Fetch/22 Tile{ AsIs: </0 Reuse: & ParseBlock/4 AsIs: t.ErrorList#1/5 } Tile{ AsIs: e.Tail#1/33(2) } Tile{ AsIs: >/1 } </23 Tile{ HalfReuse: & @create_closure@/18 } & ParseResult$11\1/24 Tile{ AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 AsIs: )/14 HalfReuse: >/17 HalfReuse: >/19 } Tile{ ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 21},
      {refalrts::icAllocFunc, 0, 6, 22},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 23},
      {refalrts::icAllocFunc, 0, 5, 24},
      {refalrts::icUpdateFunc, 0, 4, 4},
      {refalrts::icReinitFunc, 0, 3, 18},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 17},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 19},
      {refalrts::icPushStack, 0, 0, 19},
      {refalrts::icPushStack, 0, 0, 21},
      {refalrts::icPushStack, 0, 0, 17},
      {refalrts::icPushStack, 0, 0, 23},
      {refalrts::icLinkBrackets, 13, 14, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceTile, 9, 19, 0},
      {refalrts::icSpliceTile, 24, 24, 0},
      {refalrts::icSpliceTile, 18, 18, 0},
      {refalrts::icSpliceTile, 23, 23, 0},
      {refalrts::icSpliceTile, 1, 1, 0},
      {refalrts::icSpliceEVar, 0, 0, 33},
      {refalrts::icSpliceTile, 0, 6, 0},
      {refalrts::icSpliceTile, 21, 22, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +39, 0, 0},
      // t.idx ( e.idx ( s.idx s.idx s.idx e.idx ) ) ( e.idx ) e.idx
      // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 (/17 s.BracketsSign#1/19 s.OpenLnNum#1/20 s.CloseBracket#1/21 e.Scanned#1/15 )/18 )/10 (/13 e.InnerScanned#1/11 )/14 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 33, 7},
      {refalrts::icBracketRightSave, 0, 15, 33},
      // closed e.MultiBracket#1 as range 33(7)
      // closed e.InnerScanned#1 as range 11
      // closed e.Tail#1 as range 2
      {refalrts::icsVarLeft, 0, 19, 15},
      {refalrts::icsVarLeft, 0, 20, 15},
      {refalrts::icsVarLeft, 0, 21, 15},
      // closed e.Scanned#1 as range 15
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.OpenLnNum#1/20 s.CloseBracket#1/21 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </22 & ParseResult/23 Tile{ AsIs: </0 Reuse: & EL-AddErrorAt/4 AsIs: t.ErrorList#1/5 HalfReuse: s.OpenLnNum1 #20/9 }"Unbalanced bracket \""/24 </26 & StrFromBracket/27 s.BracketsSign#1/19/28 >/29 '\"'/30 >/31 (/32 Tile{ AsIs: e.MultiBracket#1/33(7) } Tile{ AsIs: )/10 AsIs: (/13 } Tile{ AsIs: e.Scanned#1/15 } Tile{ AsIs: (/17 AsIs: s.BracketsSign#1/19 } Tile{ AsIs: e.InnerScanned#1/11 } Tile{ AsIs: )/18 } Tile{ AsIs: )/14 AsIs: e.Tail#1/2 AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 22},
      {refalrts::icAllocFunc, 0, 2, 23},
      {refalrts::icAllocString, 0, 2, 24},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 26},
      {refalrts::icAllocFunc, 0, 0, 27},
      {refalrts::icCopySTVar, 28, 19, 0},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 29},
      {refalrts::icAllocChar, 0, '\"', 30},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 31},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenBracket, 32},
      {refalrts::icUpdateFunc, 0, 1, 4},
      {refalrts::icReinitSVar, 0, 20, 9},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 22},
      {refalrts::icLinkBrackets, 13, 14, 0},
      {refalrts::icLinkBrackets, 17, 18, 0},
      {refalrts::icLinkBrackets, 32, 10, 0},
      {refalrts::icPushStack, 0, 0, 31},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icPushStack, 0, 0, 29},
      {refalrts::icPushStack, 0, 0, 26},
      {refalrts::icSetRes, 0, 0, 14},
      {refalrts::icSpliceTile, 18, 18, 0},
      {refalrts::icSpliceEVar, 0, 0, 11},
      {refalrts::icSpliceTile, 17, 19, 0},
      {refalrts::icSpliceEVar, 0, 0, 15},
      {refalrts::icSpliceTile, 10, 13, 0},
      {refalrts::icSpliceEVar, 0, 0, 33},
      {refalrts::icSpliceTile, 24, 32, 0},
      {refalrts::icSpliceTile, 0, 9, 0},
      {refalrts::icSpliceTile, 22, 23, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icOnFailGoTo, +40, 0, 0},
      // t.idx ( ) ( e.idx ) ( # Close s.idx s.idx ) e.idx
      // </0 & ParseResult/4 t.ErrorList#1/5 (/9 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Close/19 s.LnNum#1/20 s.CloseBracket#1/21 )/18 e.Tail#1/2 >/1
      {refalrts::icSave, 0, 33, 2},
      {refalrts::icBracketLeftSave, 0, 15, 33},
      {refalrts::icIdentLeftSave, 19, 0, 15},
      {refalrts::icSave, 0, 35, 7},
      {refalrts::icEmpty, 0, 0, 35},
      // closed e.Scanned#1 as range 11
      // closed e.Tail#1 as range 33(2)
      {refalrts::icsVarLeft, 0, 20, 15},
      {refalrts::icsVarLeft, 0, 21, 15},
      {refalrts::icEmpty, 0, 0, 15},
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 } </22 & EL-AddErrorAt/23 Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: s.LnNum#1/20 }"Unb"/24 Tile{ HalfReuse: 'a'/17 HalfReuse: 'l'/19 }"anced bracket \""/26 </28 & StrFromBracket/29 Tile{ AsIs: s.CloseBracket#1/21 HalfReuse: >/18 } '\"'/30 >/31 Tile{ AsIs: (/9 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 AsIs: )/14 } Tile{ AsIs: e.Tail#1/33(2) } Tile{ AsIs: >/1 ]] }
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 22},
      {refalrts::icAllocFunc, 0, 1, 23},
      {refalrts::icAllocString, 0, 1, 24},
      {refalrts::icAllocString, 0, 0, 26},
      {refalrts::icAllocBracket, 0, refalrts::ibOpenCall, 28},
      {refalrts::icAllocFunc, 0, 0, 29},
      {refalrts::icAllocChar, 0, '\"', 30},
      {refalrts::icAllocBracket, 0, refalrts::ibCloseCall, 31},
      {refalrts::icReinitChar, 0, 'a', 17},
      {refalrts::icReinitChar, 0, 'l', 19},
      {refalrts::icReinitBracket, 0, refalrts::ibCloseCall, 18},
      {refalrts::icPushStack, 0, 0, 1},
      {refalrts::icPushStack, 0, 0, 0},
      {refalrts::icLinkBrackets, 13, 14, 0},
      {refalrts::icLinkBrackets, 9, 10, 0},
      {refalrts::icPushStack, 0, 0, 31},
      {refalrts::icPushStack, 0, 0, 22},
      {refalrts::icPushStack, 0, 0, 18},
      {refalrts::icPushStack, 0, 0, 28},
      {refalrts::icSetRes, 0, 0, 1},
      {refalrts::icSpliceEVar, 0, 0, 33},
      {refalrts::icSpliceTile, 9, 14, 0},
      {refalrts::icSpliceTile, 30, 31, 0},
      {refalrts::icSpliceTile, 21, 18, 0},
      {refalrts::icSpliceTile, 26, 29, 0},
      {refalrts::icSpliceTile, 17, 19, 0},
      {refalrts::icSpliceTile, 24, 25, 0},
      {refalrts::icSpliceTile, 20, 20, 0},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icSpliceTile, 22, 23, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      // t.idx ( ) ( e.idx ) e.idx
      // </0 & ParseResult/4 t.ErrorList#1/5 (/9 )/10 (/13 e.Result#1/11 )/14 e.Tail#1/2 >/1
      {refalrts::icEmpty, 0, 0, 7},
      // closed e.Result#1 as range 11
      // closed e.Tail#1 as range 2
      {refalrts::icEmptyResult, 0, 0, 0},
      //TRASH: {REMOVED TILE} </0 & ParseResult/4 {REMOVED TILE} (/9 )/10 {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: (/13 AsIs: e.Result#1/11 AsIs: )/14 } Tile{ AsIs: e.Tail#1/2 } Tile{ ]] }
      {refalrts::icLinkBrackets, 13, 14, 0},
      {refalrts::icSetResRightEdge, 0, 0, 0},
      {refalrts::icSpliceEVar, 0, 0, 2},
      {refalrts::icSpliceTile, 13, 14, 0},
      {refalrts::icSpliceTile, 5, 6, 0},
      {refalrts::icTrashLeftEdge, 0, 0, 0},
      {refalrts::icReturnResult_NoTrash, 0, 0, 0},
      {refalrts::icEnd, 0, 0, 0}
    };
  } // namespace scope_ParseResult

} // unnamed namespace

namespace /* unnamed */ {
refalrts::RASLFunction descr_ParseResult(
  "ParseResult",
  scope_ParseResult::raa,
  scope_ParseResult::functions,
  scope_ParseResult::idents,
  scope_ParseResult::numbers,
  scope_ParseResult::strings
);
refalrts::RefalFunction& ParseResult = descr_ParseResult;

} // unnamed namespace

#else
static refalrts::FnResult func_ParseResult(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 37 elems
  refalrts::Iter context[37];
  refalrts::zeros( context, 37 );
  //FAST GEN: e.$
  //GLOBAL GEN: t.$ ( e.$ ) ( e.$ ) e.$
  // </0 & ParseResult/4 t.idx#0/5 (/9 e.idxVB#0/7 )/10 (/13 e.idxVTB#0/11 )/14 e.idxVTT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  context[7] = 0;
  context[8] = 0;
  context[9] = refalrts::brackets_left( context[7], context[8], context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[9], context[10]);
  context[11] = 0;
  context[12] = 0;
  context[13] = refalrts::brackets_left( context[11], context[12], context[2], context[3] );
  if( ! context[13] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[13], context[14]);
  // closed e.idxVB#0 as range 7
  // closed e.idxVTB#0 as range 11
  // closed e.idxVTT#0 as range 2
  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # TkChar s.idx s.idx ) e.idx
    // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkChar/19 s.LnNum#1/20 s.Char#1/21 )/18 e.Tail#1/2 >/1
    context[33] = context[2];
    context[34] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[33], context[34] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_TkChar<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 33(2)
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.LnNum#1/20 s.Char#1/21 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkChar/17 HalfReuse: s.Char1 #21/19 } )/22 Tile{ AsIs: )/18 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_bracket( context[22] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[14] );
    refalrts::reinit_ident( context[17], & ident_TkChar<int>::name );
    refalrts::reinit_svar( context[19], context[21] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[18] );
    refalrts::link_brackets( context[14], context[22] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[18];
    res = refalrts::splice_evar( res, context[22], context[22] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[19], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # TkNumber s.idx s.idx ) e.idx
    // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkNumber/19 s.LnNum#1/20 s.Number#1/21 )/18 e.Tail#1/2 >/1
    context[33] = context[2];
    context[34] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[33], context[34] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_TkNumber<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 33(2)
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.LnNum#1/20 s.Number#1/21 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkNumber/17 HalfReuse: s.Number1 #21/19 } )/22 Tile{ AsIs: )/18 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_bracket( context[22] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[14] );
    refalrts::reinit_ident( context[17], & ident_TkNumber<int>::name );
    refalrts::reinit_svar( context[19], context[21] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[18] );
    refalrts::link_brackets( context[14], context[22] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[18];
    res = refalrts::splice_evar( res, context[22], context[22] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[19], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # TkName s.idx e.idx ) e.idx
    // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkName/19 s.LnNum#1/20 e.Name#1/15 )/18 e.Tail#1/2 >/1
    context[33] = context[2];
    context[34] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[33], context[34] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_TkName<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 33(2)
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    // closed e.Name#1 as range 15

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.LnNum#1/20 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkName/17 HalfReuse: s.LnNum1 #20/19 } Tile{ AsIs: e.Name#1/15 } )/21 Tile{ AsIs: )/18 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_bracket( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[14] );
    refalrts::reinit_ident( context[17], & ident_TkName<int>::name );
    refalrts::reinit_svar( context[19], context[20] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[18] );
    refalrts::link_brackets( context[14], context[21] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[18];
    res = refalrts::splice_evar( res, context[21], context[21] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[19], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # TkIdentMarker s.idx ) ( # TkName s.idx e.idx ) e.idx
    // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkIdentMarker/19 s.MarkerLnNum#1/25 )/18 (/22 # TkName/24 s.NameLnNum#1/26 e.Name#1/20 )/23 e.Tail#1/2 >/1
    context[33] = context[2];
    context[34] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[33], context[34] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_TkIdentMarker<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    context[20] = 0;
    context[21] = 0;
    context[22] = refalrts::brackets_left( context[20], context[21], context[33], context[34] );
    if( ! context[22] )
      continue;
    refalrts::bracket_pointers(context[22], context[23]);
    context[24] = refalrts::ident_left(  & ident_TkName<int>::name, context[20], context[21] );
    if( ! context[24] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 33(2)
    if( ! refalrts::svar_left( context[25], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[26], context[20], context[21] ) )
      continue;
    // closed e.Name#1 as range 20

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} # TkIdentMarker/19 s.MarkerLnNum#1/25 {REMOVED TILE} (/22 # TkName/24 s.NameLnNum#1/26 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkIdentifier/17 } Tile{ AsIs: e.Name#1/20 } Tile{ AsIs: )/18 } Tile{ AsIs: )/23 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
    refalrts::reinit_open_bracket( context[14] );
    refalrts::reinit_ident( context[17], & ident_TkIdentifier<int>::name );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[23] );
    refalrts::link_brackets( context[14], context[18] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[23];
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[17], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # TkIdentMarker s.idx ) e.idx
    // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkIdentMarker/19 s.LnNum#1/20 )/18 e.Tail#1/2 >/1
    context[33] = context[2];
    context[34] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[33], context[34] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_TkIdentMarker<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 33(2)
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 } </21 & EL-AddErrorAt/22 Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: s.LnNum#1/20 HalfReuse: 'M'/18 }"is"/23 Tile{ HalfReuse: 's'/17 HalfReuse: 'e'/19 }"d name after \"#\""/25 >/27 Tile{ AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 AsIs: )/14 } Tile{ AsIs: e.Tail#1/33(2) } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], & EL_AddErrorAt ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], "is", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "d name after \"#\"", 16 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[27] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[18], 'M' );
    refalrts::reinit_char( context[17], 's' );
    refalrts::reinit_char( context[19], 'e' );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[14] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[21] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[33], context[34] );
    res = refalrts::splice_evar( res, context[9], context[14] );
    res = refalrts::splice_evar( res, context[25], context[27] );
    res = refalrts::splice_evar( res, context[17], context[19] );
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[20], context[18] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # TkVariable s.idx s.idx e.idx ) e.idx
    // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkVariable/19 s.LnNum#1/20 s.Mode#1/21 e.Index#1/15 )/18 e.Tail#1/2 >/1
    context[33] = context[2];
    context[34] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[33], context[34] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_TkVariable<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 33(2)
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[15], context[16] ) )
      continue;
    // closed e.Index#1 as range 15

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.LnNum#1/20 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 HalfReuse: (/14 HalfReuse: # TkVariable/17 HalfReuse: s.LnNum1 #20/19 } Tile{ AsIs: s.Mode#1/21 } Tile{ AsIs: e.Index#1/15 } )/22 Tile{ AsIs: )/18 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_bracket( context[22] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[14] );
    refalrts::reinit_ident( context[17], & ident_TkVariable<int>::name );
    refalrts::reinit_svar( context[19], context[20] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[18] );
    refalrts::link_brackets( context[14], context[22] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[18];
    res = refalrts::splice_evar( res, context[22], context[22] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[21], context[21] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[19], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # Open s.idx # TkOpenADT ) ( # TkName s.idx e.idx ) e.idx
    // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Open/19 s.LnNumADT#1/26 # TkOpenADT/20 )/18 (/23 # TkName/25 s.LnNumName#1/27 e.Name#1/21 )/24 e.Tail#1/2 >/1
    context[33] = context[2];
    context[34] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[33], context[34] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_Open<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    context[20] = refalrts::ident_right(  & ident_TkOpenADT<int>::name, context[15], context[16] );
    if( ! context[20] )
      continue;
    context[21] = 0;
    context[22] = 0;
    context[23] = refalrts::brackets_left( context[21], context[22], context[33], context[34] );
    if( ! context[23] )
      continue;
    refalrts::bracket_pointers(context[23], context[24]);
    context[25] = refalrts::ident_left(  & ident_TkName<int>::name, context[21], context[22] );
    if( ! context[25] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 33(2)
    if( ! refalrts::svar_left( context[26], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[27], context[21], context[22] ) )
      continue;
    // closed e.Name#1 as range 21

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNumADT#1/26 {REMOVED TILE} s.LnNumName#1/27 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 HalfReuse: (/10 HalfReuse: # ADT-Brackets/13 } Tile{ HalfReuse: s.LnNumADT1 #26/17 Reuse: # TkCloseADT/19 } Tile{ AsIs: e.Scanned#1/11 } Tile{ HalfReuse: )/20 AsIs: )/18 AsIs: (/23 HalfReuse: s.LnNumName1 #27/25 } (/28 Tile{ AsIs: e.Name#1/21 } Tile{ AsIs: )/14 } Tile{ AsIs: )/24 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[28] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[10] );
    refalrts::reinit_ident( context[13], & ident_ADT_Brackets<int>::name );
    refalrts::reinit_svar( context[17], context[26] );
    refalrts::update_ident( context[19], & ident_TkCloseADT<int>::name );
    refalrts::reinit_close_bracket( context[20] );
    refalrts::reinit_svar( context[25], context[27] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[23], context[24] );
    refalrts::link_brackets( context[28], context[14] );
    refalrts::link_brackets( context[9], context[18] );
    refalrts::link_brackets( context[10], context[20] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[24];
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[28], context[28] );
    res = refalrts::splice_evar( res, context[20], context[25] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[17], context[19] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[13], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # Open s.idx # TkOpenADT ) e.idx
    // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Open/19 s.LnNum#1/21 # TkOpenADT/20 )/18 e.Tail#1/2 >/1
    context[33] = context[2];
    context[34] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[33], context[34] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_Open<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    context[20] = refalrts::ident_right(  & ident_TkOpenADT<int>::name, context[15], context[16] );
    if( ! context[20] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 33(2)
    if( ! refalrts::svar_left( context[21], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </22 & ParseResult/23 Tile{ AsIs: </0 Reuse: & EL-AddErrorAt/4 AsIs: t.ErrorList#1/5 HalfReuse: s.LnNum1 #21/9 }"Expected name after \"[\""/24 >/26 (/27 Tile{ AsIs: e.MultiBracket#1/7 } (/28 # ADT-Brackets/29 Tile{ HalfReuse: s.LnNum1 #21/10 HalfReuse: # TkCloseADT/13 AsIs: e.Scanned#1/11 AsIs: )/14 HalfReuse: )/17 HalfReuse: (/19 AsIs: s.LnNum#1/21 HalfReuse: (/20 HalfReuse: # UnnamedADT/18 } )/30 )/31 Tile{ AsIs: e.Tail#1/33(2) } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[23], & ParseResult ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "Expected name after \"[\"", 23 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[29], & ident_ADT_Brackets<int>::name ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[31] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & EL_AddErrorAt );
    refalrts::reinit_svar( context[9], context[21] );
    refalrts::reinit_svar( context[10], context[21] );
    refalrts::reinit_ident( context[13], & ident_TkCloseADT<int>::name );
    refalrts::reinit_close_bracket( context[17] );
    refalrts::reinit_open_bracket( context[19] );
    refalrts::reinit_open_bracket( context[20] );
    refalrts::reinit_ident( context[18], & ident_UnnamedADT<int>::name );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[22] );
    refalrts::link_brackets( context[19], context[31] );
    refalrts::link_brackets( context[20], context[30] );
    refalrts::link_brackets( context[27], context[17] );
    refalrts::link_brackets( context[28], context[14] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[33], context[34] );
    res = refalrts::splice_evar( res, context[30], context[31] );
    res = refalrts::splice_evar( res, context[10], context[18] );
    res = refalrts::splice_evar( res, context[28], context[29] );
    res = refalrts::splice_evar( res, context[7], context[8] );
    res = refalrts::splice_evar( res, context[24], context[27] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # Open s.idx s.idx ) e.idx
    // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Open/19 s.LnNum#1/20 s.OpenBracket#1/21 )/18 e.Tail#1/2 >/1
    context[33] = context[2];
    context[34] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[33], context[34] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_Open<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 33(2)
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/7 HalfReuse: (/10 HalfReuse: </13 } & Fetch/22 Tile{ HalfReuse: s.OpenBracket1 #21/14 HalfReuse: & ParseResult$9\1/17 HalfReuse: >/19 AsIs: s.LnNum#1/20 } </23 & Fetch/24 Tile{ AsIs: s.OpenBracket#1/21 } & ParseResult$9\2/25 >/26 Tile{ AsIs: e.Scanned#1/11 } )/27 )/28 (/29 Tile{ AsIs: )/18 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
    if( ! refalrts::alloc_name( context[22], & Fetch ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[24], & Fetch ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[25], & gen_ParseResult_S9L2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[29] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[10] );
    refalrts::reinit_open_call( context[13] );
    refalrts::reinit_svar( context[14], context[21] );
    refalrts::reinit_name( context[17], & gen_ParseResult_S9L1 );
    refalrts::reinit_close_call( context[19] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[29], context[18] );
    refalrts::link_brackets( context[9], context[28] );
    refalrts::link_brackets( context[10], context[27] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[13] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[18];
    res = refalrts::splice_evar( res, context[27], context[29] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[25], context[26] );
    res = refalrts::splice_evar( res, context[21], context[21] );
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[14], context[20] );
    res = refalrts::splice_evar( res, context[22], context[22] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ( s.idx s.idx s.idx e.idx ) ) ( e.idx ) ( # Close s.idx s.idx ) e.idx
    // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 (/22 s.BracketsSign#1/24 s.OpenLnNum#1/25 s.CloseBracket#1/26 e.Scanned#1/20 )/23 )/10 (/13 e.InnerScanned#1/11 )/14 (/17 # Close/19 s.LnNum#1/28 s.CloseBracket#1/27 )/18 e.Tail#1/2 >/1
    context[33] = context[2];
    context[34] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[33], context[34] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_Close<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    context[35] = context[7];
    context[36] = context[8];
    context[20] = 0;
    context[21] = 0;
    context[22] = refalrts::brackets_right( context[20], context[21], context[35], context[36] );
    if( ! context[22] )
      continue;
    refalrts::bracket_pointers(context[22], context[23]);
    // closed e.MultiBracket#1 as range 35(7)
    // closed e.InnerScanned#1 as range 11
    // closed e.Tail#1 as range 33(2)
    if( ! refalrts::svar_left( context[24], context[20], context[21] ) )
      continue;
    if( ! refalrts::svar_left( context[25], context[20], context[21] ) )
      continue;
    if( ! refalrts::svar_left( context[26], context[20], context[21] ) )
      continue;
    if( ! refalrts::repeated_stvar_right( context[27], context[26], context[15], context[16] ) )
      continue;
    // closed e.Scanned#1 as range 20
    if( ! refalrts::svar_left( context[28], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.BracketsSign#1/24 s.OpenLnNum#1/25 s.CloseBracket#1/26 {REMOVED TILE} )/23 {REMOVED TILE} {REMOVED TILE} # Close/19 s.LnNum#1/28 s.CloseBracket#1/27 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 AsIs: t.ErrorList#1/5 AsIs: (/9 AsIs: e.MultiBracket#1/35(7) HalfReuse: )/22 } Tile{ AsIs: (/17 } Tile{ AsIs: e.Scanned#1/20 } Tile{ HalfReuse: (/10 HalfReuse: s.BracketsSign1 #24/13 AsIs: e.InnerScanned#1/11 AsIs: )/14 } Tile{ AsIs: )/18 AsIs: e.Tail#1/33(2) AsIs: >/1 ]] }
    refalrts::reinit_close_bracket( context[22] );
    refalrts::reinit_open_bracket( context[10] );
    refalrts::reinit_svar( context[13], context[24] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[17], context[18] );
    refalrts::link_brackets( context[10], context[14] );
    refalrts::link_brackets( context[9], context[22] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[18];
    res = refalrts::splice_evar( res, context[10], context[14] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[17], context[17] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( context[22], res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ) ( e.idx ) ( # TkOpenBlock s.idx ) e.idx
    // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 )/10 (/13 e.Scanned#1/11 )/14 (/17 # TkOpenBlock/19 s.LnNum#1/20 )/18 e.Tail#1/2 >/1
    context[33] = context[2];
    context[34] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[33], context[34] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_TkOpenBlock<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    // closed e.MultiBracket#1 as range 7
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 33(2)
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LnNum#1/20 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </21 & Fetch/22 Tile{ AsIs: </0 Reuse: & ParseBlock/4 AsIs: t.ErrorList#1/5 } Tile{ AsIs: e.Tail#1/33(2) } Tile{ AsIs: >/1 } </23 Tile{ HalfReuse: & @create_closure@/18 } & ParseResult$11\1/24 Tile{ AsIs: (/9 AsIs: e.MultiBracket#1/7 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 AsIs: )/14 HalfReuse: >/17 HalfReuse: >/19 } Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], & Fetch ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[24], & gen_ParseResult_S11L1 ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & ParseBlock );
    refalrts::reinit_name( context[18], & refalrts::create_closure );
    refalrts::reinit_close_call( context[17] );
    refalrts::reinit_close_call( context[19] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[17] );
    refalrts::push_stack( context[23] );
    refalrts::link_brackets( context[13], context[14] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[9], context[19] );
    res = refalrts::splice_evar( res, context[24], context[24] );
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[23], context[23] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    res = refalrts::splice_evar( res, context[33], context[34] );
    res = refalrts::splice_evar( res, context[0], context[6] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( e.idx ( s.idx s.idx s.idx e.idx ) ) ( e.idx ) e.idx
    // </0 & ParseResult/4 t.ErrorList#1/5 (/9 e.MultiBracket#1/7 (/17 s.BracketsSign#1/19 s.OpenLnNum#1/20 s.CloseBracket#1/21 e.Scanned#1/15 )/18 )/10 (/13 e.InnerScanned#1/11 )/14 e.Tail#1/2 >/1
    context[33] = context[7];
    context[34] = context[8];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_right( context[15], context[16], context[33], context[34] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    // closed e.MultiBracket#1 as range 33(7)
    // closed e.InnerScanned#1 as range 11
    // closed e.Tail#1 as range 2
    if( ! refalrts::svar_left( context[19], context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[15], context[16] ) )
      continue;
    // closed e.Scanned#1 as range 15

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.OpenLnNum#1/20 s.CloseBracket#1/21 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </22 & ParseResult/23 Tile{ AsIs: </0 Reuse: & EL-AddErrorAt/4 AsIs: t.ErrorList#1/5 HalfReuse: s.OpenLnNum1 #20/9 }"Unbalanced bracket \""/24 </26 & StrFromBracket/27 s.BracketsSign#1/19/28 >/29 '\"'/30 >/31 (/32 Tile{ AsIs: e.MultiBracket#1/33(7) } Tile{ AsIs: )/10 AsIs: (/13 } Tile{ AsIs: e.Scanned#1/15 } Tile{ AsIs: (/17 AsIs: s.BracketsSign#1/19 } Tile{ AsIs: e.InnerScanned#1/11 } Tile{ AsIs: )/18 } Tile{ AsIs: )/14 AsIs: e.Tail#1/2 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[23], & ParseResult ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "Unbalanced bracket \"", 20 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], & StrFromBracket ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[28], context[19]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[30], '\"' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[32] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], & EL_AddErrorAt );
    refalrts::reinit_svar( context[9], context[20] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[22] );
    refalrts::link_brackets( context[13], context[14] );
    refalrts::link_brackets( context[17], context[18] );
    refalrts::link_brackets( context[32], context[10] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[26] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[14];
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[17], context[19] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    res = refalrts::splice_evar( res, context[10], context[13] );
    res = refalrts::splice_evar( res, context[33], context[34] );
    res = refalrts::splice_evar( res, context[24], context[32] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    refalrts::use( res );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );

  do {
    refalrts::start_sentence();
    // t.idx ( ) ( e.idx ) ( # Close s.idx s.idx ) e.idx
    // </0 & ParseResult/4 t.ErrorList#1/5 (/9 )/10 (/13 e.Scanned#1/11 )/14 (/17 # Close/19 s.LnNum#1/20 s.CloseBracket#1/21 )/18 e.Tail#1/2 >/1
    context[33] = context[2];
    context[34] = context[3];
    context[15] = 0;
    context[16] = 0;
    context[17] = refalrts::brackets_left( context[15], context[16], context[33], context[34] );
    if( ! context[17] )
      continue;
    refalrts::bracket_pointers(context[17], context[18]);
    context[19] = refalrts::ident_left(  & ident_Close<int>::name, context[15], context[16] );
    if( ! context[19] )
      continue;
    context[35] = context[7];
    context[36] = context[8];
    if( ! refalrts::empty_seq( context[35], context[36] ) )
      continue;
    // closed e.Scanned#1 as range 11
    // closed e.Tail#1 as range 33(2)
    if( ! refalrts::svar_left( context[20], context[15], context[16] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[15], context[16] ) )
      continue;
    if( ! refalrts::empty_seq( context[15], context[16] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & ParseResult/4 } </22 & EL-AddErrorAt/23 Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: s.LnNum#1/20 }"Unb"/24 Tile{ HalfReuse: 'a'/17 HalfReuse: 'l'/19 }"anced bracket \""/26 </28 & StrFromBracket/29 Tile{ AsIs: s.CloseBracket#1/21 HalfReuse: >/18 } '\"'/30 >/31 Tile{ AsIs: (/9 AsIs: )/10 AsIs: (/13 AsIs: e.Scanned#1/11 AsIs: )/14 } Tile{ AsIs: e.Tail#1/33(2) } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[23], & EL_AddErrorAt ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "Unb", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[26], context[27], "anced bracket \"", 15 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[29], & StrFromBracket ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[30], '\"' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[17], 'a' );
    refalrts::reinit_char( context[19], 'l' );
    refalrts::reinit_close_call( context[18] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[13], context[14] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[28] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[33], context[34] );
    res = refalrts::splice_evar( res, context[9], context[14] );
    res = refalrts::splice_evar( res, context[30], context[31] );
    res = refalrts::splice_evar( res, context[21], context[18] );
    res = refalrts::splice_evar( res, context[26], context[29] );
    res = refalrts::splice_evar( res, context[17], context[19] );
    res = refalrts::splice_evar( res, context[24], context[25] );
    res = refalrts::splice_evar( res, context[20], context[20] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );

  // t.idx ( ) ( e.idx ) e.idx
  // </0 & ParseResult/4 t.ErrorList#1/5 (/9 )/10 (/13 e.Result#1/11 )/14 e.Tail#1/2 >/1
  if( ! refalrts::empty_seq( context[7], context[8] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Result#1 as range 11
  // closed e.Tail#1 as range 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ParseResult/4 {REMOVED TILE} (/9 )/10 {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: t.ErrorList#1/5 } Tile{ AsIs: (/13 AsIs: e.Result#1/11 AsIs: )/14 } Tile{ AsIs: e.Tail#1/2 } Tile{ ]] }
  refalrts::link_brackets( context[13], context[14] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

namespace /* unnamed */ {
refalrts::RefalFunction descr_ParseResult(func_ParseResult, "ParseResult");
refalrts::RefalFunction& ParseResult = descr_ParseResult;

} // unnamed namespace

#endif

//End of file
