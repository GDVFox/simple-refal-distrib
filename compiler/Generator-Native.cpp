// This file automatically generated from 'Generator-Native.sref'
// Don't edit! Edit 'Generator-Native.sref' and recompile it

#include "refalrts.h"

#define cookie_ns cookie_ns_2638096229_2630503357
static const refalrts::RefalIdentifier ident_ARGm_BEGIN = refalrts::ident_from_static("ARG-BEGIN");
static const refalrts::RefalIdentifier ident_AlgLeft = refalrts::ident_from_static("AlgLeft");
static const refalrts::RefalIdentifier ident_AlgRight = refalrts::ident_from_static("AlgRight");
static const refalrts::RefalIdentifier ident_AlgTerm = refalrts::ident_from_static("AlgTerm");
static const refalrts::RefalIdentifier ident_Allocate = refalrts::ident_from_static("Allocate");
static const refalrts::RefalIdentifier ident_CmdADT = refalrts::ident_from_static("CmdADT");
static const refalrts::RefalIdentifier ident_CmdADTSave = refalrts::ident_from_static("CmdADTSave");
static const refalrts::RefalIdentifier ident_CmdBrackets = refalrts::ident_from_static("CmdBrackets");
static const refalrts::RefalIdentifier ident_CmdBracketsSave = refalrts::ident_from_static("CmdBracketsSave");
static const refalrts::RefalIdentifier ident_CmdCallCondition = refalrts::ident_from_static("CmdCallCondition");
static const refalrts::RefalIdentifier ident_CmdCallSave = refalrts::ident_from_static("CmdCallSave");
static const refalrts::RefalIdentifier ident_CmdChar = refalrts::ident_from_static("CmdChar");
static const refalrts::RefalIdentifier ident_CmdCharSave = refalrts::ident_from_static("CmdCharSave");
static const refalrts::RefalIdentifier ident_CmdComment = refalrts::ident_from_static("CmdComment");
static const refalrts::RefalIdentifier ident_CmdCookieNS = refalrts::ident_from_static("CmdCookieNS");
static const refalrts::RefalIdentifier ident_CmdCopyVar = refalrts::ident_from_static("CmdCopyVar");
static const refalrts::RefalIdentifier ident_CmdCreateElem = refalrts::ident_from_static("CmdCreateElem");
static const refalrts::RefalIdentifier ident_CmdDefineIdent = refalrts::ident_from_static("CmdDefineIdent");
static const refalrts::RefalIdentifier ident_CmdEmitNativeCode = refalrts::ident_from_static("CmdEmitNativeCode");
static const refalrts::RefalIdentifier ident_CmdEmpty = refalrts::ident_from_static("CmdEmpty");
static const refalrts::RefalIdentifier ident_CmdEndSentence = refalrts::ident_from_static("CmdEndSentence");
static const refalrts::RefalIdentifier ident_CmdExtern = refalrts::ident_from_static("CmdExtern");
static const refalrts::RefalIdentifier ident_CmdFail = refalrts::ident_from_static("CmdFail");
static const refalrts::RefalIdentifier ident_CmdFnEnd = refalrts::ident_from_static("CmdFnEnd");
static const refalrts::RefalIdentifier ident_CmdFnStart = refalrts::ident_from_static("CmdFnStart");
static const refalrts::RefalIdentifier ident_CmdIdent = refalrts::ident_from_static("CmdIdent");
static const refalrts::RefalIdentifier ident_CmdIdentSave = refalrts::ident_from_static("CmdIdentSave");
static const refalrts::RefalIdentifier ident_CmdInitB0 = refalrts::ident_from_static("CmdInitB0");
static const refalrts::RefalIdentifier ident_CmdInitB0m_Lite = refalrts::ident_from_static("CmdInitB0-Lite");
static const refalrts::RefalIdentifier ident_CmdInsertElem = refalrts::ident_from_static("CmdInsertElem");
static const refalrts::RefalIdentifier ident_CmdInsertRange = refalrts::ident_from_static("CmdInsertRange");
static const refalrts::RefalIdentifier ident_CmdInsertTile = refalrts::ident_from_static("CmdInsertTile");
static const refalrts::RefalIdentifier ident_CmdInsertVar = refalrts::ident_from_static("CmdInsertVar");
static const refalrts::RefalIdentifier ident_CmdIssueMemory = refalrts::ident_from_static("CmdIssueMemory");
static const refalrts::RefalIdentifier ident_CmdLinkBrackets = refalrts::ident_from_static("CmdLinkBrackets");
static const refalrts::RefalIdentifier ident_CmdName = refalrts::ident_from_static("CmdName");
static const refalrts::RefalIdentifier ident_CmdNameSave = refalrts::ident_from_static("CmdNameSave");
static const refalrts::RefalIdentifier ident_CmdNativeFuncDescr = refalrts::ident_from_static("CmdNativeFuncDescr");
static const refalrts::RefalIdentifier ident_CmdNextStep = refalrts::ident_from_static("CmdNextStep");
static const refalrts::RefalIdentifier ident_CmdNumber = refalrts::ident_from_static("CmdNumber");
static const refalrts::RefalIdentifier ident_CmdNumberSave = refalrts::ident_from_static("CmdNumberSave");
static const refalrts::RefalIdentifier ident_CmdOpenedEm_End = refalrts::ident_from_static("CmdOpenedE-End");
static const refalrts::RefalIdentifier ident_CmdOpenedEm_Start = refalrts::ident_from_static("CmdOpenedE-Start");
static const refalrts::RefalIdentifier ident_CmdProfileFunction = refalrts::ident_from_static("CmdProfileFunction");
static const refalrts::RefalIdentifier ident_CmdPushStack = refalrts::ident_from_static("CmdPushStack");
static const refalrts::RefalIdentifier ident_CmdReinitSVar = refalrts::ident_from_static("CmdReinitSVar");
static const refalrts::RefalIdentifier ident_CmdRepeated = refalrts::ident_from_static("CmdRepeated");
static const refalrts::RefalIdentifier ident_CmdRepeatedTVarSave = refalrts::ident_from_static("CmdRepeatedTVarSave");
static const refalrts::RefalIdentifier ident_CmdResetAllocator = refalrts::ident_from_static("CmdResetAllocator");
static const refalrts::RefalIdentifier ident_CmdSave = refalrts::ident_from_static("CmdSave");
static const refalrts::RefalIdentifier ident_CmdSetRes = refalrts::ident_from_static("CmdSetRes");
static const refalrts::RefalIdentifier ident_CmdSpliceToFreeList = refalrts::ident_from_static("CmdSpliceToFreeList");
static const refalrts::RefalIdentifier ident_CmdSpliceToFreeListm_Range = refalrts::ident_from_static("CmdSpliceToFreeList-Range");
static const refalrts::RefalIdentifier ident_CmdStartSentence = refalrts::ident_from_static("CmdStartSentence");
static const refalrts::RefalIdentifier ident_CmdTrash = refalrts::ident_from_static("CmdTrash");
static const refalrts::RefalIdentifier ident_CmdUseRes = refalrts::ident_from_static("CmdUseRes");
static const refalrts::RefalIdentifier ident_CmdVar = refalrts::ident_from_static("CmdVar");
static const refalrts::RefalIdentifier ident_CmdVarSave = refalrts::ident_from_static("CmdVarSave");
static const refalrts::RefalIdentifier ident_CmdWrapClosure = refalrts::ident_from_static("CmdWrapClosure");
static const refalrts::RefalIdentifier ident_ElChar = refalrts::ident_from_static("ElChar");
static const refalrts::RefalIdentifier ident_ElCloseADT = refalrts::ident_from_static("ElCloseADT");
static const refalrts::RefalIdentifier ident_ElCloseBracket = refalrts::ident_from_static("ElCloseBracket");
static const refalrts::RefalIdentifier ident_ElCloseCall = refalrts::ident_from_static("ElCloseCall");
static const refalrts::RefalIdentifier ident_ElClosureHead = refalrts::ident_from_static("ElClosureHead");
static const refalrts::RefalIdentifier ident_ElIdent = refalrts::ident_from_static("ElIdent");
static const refalrts::RefalIdentifier ident_ElName = refalrts::ident_from_static("ElName");
static const refalrts::RefalIdentifier ident_ElNumber = refalrts::ident_from_static("ElNumber");
static const refalrts::RefalIdentifier ident_ElOpenADT = refalrts::ident_from_static("ElOpenADT");
static const refalrts::RefalIdentifier ident_ElOpenBracket = refalrts::ident_from_static("ElOpenBracket");
static const refalrts::RefalIdentifier ident_ElOpenCall = refalrts::ident_from_static("ElOpenCall");
static const refalrts::RefalIdentifier ident_ElString = refalrts::ident_from_static("ElString");
static const refalrts::RefalIdentifier ident_ElUnwrappedClosure = refalrts::ident_from_static("ElUnwrappedClosure");
static const refalrts::RefalIdentifier ident_FileLine = refalrts::ident_from_static("FileLine");
static const refalrts::RefalIdentifier ident_FileRowCol = refalrts::ident_from_static("FileRowCol");
static const refalrts::RefalIdentifier ident_Hash = refalrts::ident_from_static("Hash");
static const refalrts::RefalIdentifier ident_LEFTm_EDGE = refalrts::ident_from_static("LEFT-EDGE");
static const refalrts::RefalIdentifier ident_NativeInsertBegin = refalrts::ident_from_static("NativeInsertBegin");
static const refalrts::RefalIdentifier ident_NativeInsertEnd = refalrts::ident_from_static("NativeInsertEnd");
static const refalrts::RefalIdentifier ident_Offset = refalrts::ident_from_static("Offset");
static const refalrts::RefalIdentifier ident_RIGHTm_EDGE = refalrts::ident_from_static("RIGHT-EDGE");
static const refalrts::RefalIdentifier ident_Reinit = refalrts::ident_from_static("Reinit");
static const refalrts::RefalIdentifier ident_Update = refalrts::ident_from_static("Update");
static refalrts::ExternalReference ref_Add("Add", 0U, 0U);
static refalrts::ExternalReference ref_AllocatorFuncArgument("AllocatorFuncArgument", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_AllocatorFuncName("AllocatorFuncName", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_AllocatorMode("AllocatorMode", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_BaseCName("BaseCName", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_BreakerFromIndent("BreakerFromIndent", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_CName("CName", 0U, 0U);
static refalrts::ExternalReference ref_CNameAlias("CNameAlias", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_ContextItem("ContextItem", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_ContextRange("ContextRange", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_ContextRangem_B("ContextRange-B", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_ContextRangem_E("ContextRange-E", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_DisplayCName("DisplayCName", 0U, 0U);
static refalrts::ExternalReference ref_DoPrintLength("DoPrintLength", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_EscapeChar("EscapeChar", 0U, 0U);
static refalrts::ExternalReference ref_EscapeString("EscapeString", 0U, 0U);
static refalrts::ExternalReference ref_Fetch("Fetch", 0U, 0U);
static refalrts::ExternalReference ref_FormatOffsets("FormatOffsets", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_FuncArguments("FuncArguments", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_GenCommandm_Native("GenCommand-Native", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_gen_GenCommandm_Native_S39L1("GenCommand-Native$39\\1", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_gen_GenCommandm_Native_S57L1("GenCommand-Native$57\\1", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_GenProgramm_Native("GenProgram-Native", 0U, 0U);
static refalrts::ExternalReference ref_gen_GenProgramm_Native_B1("GenProgram-Native:1", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_gen_GenProgramm_Native_A1("GenProgram-Native=1", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_Inc("Inc", 0U, 0U);
static refalrts::ExternalReference ref_MakeRefalName("MakeRefalName", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_MapReduce("MapReduce", 0U, 0U);
static refalrts::ExternalReference ref_NameAndCookies("NameAndCookies", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintBracketsVarInit("PrintBracketsVarInit", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintCreateElem("PrintCreateElem", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintLength("PrintLength", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatch("PrintMatch", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchADT("PrintMatchADT", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchADTSave("PrintMatchADTSave", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchBrackets("PrintMatchBrackets", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchBracketsSave("PrintMatchBracketsSave", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchChar("PrintMatchChar", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchCharSave("PrintMatchCharSave", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchEmpty("PrintMatchEmpty", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchIdent("PrintMatchIdent", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchIdentSave("PrintMatchIdentSave", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchName("PrintMatchName", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchNameSave("PrintMatchNameSave", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchNumber("PrintMatchNumber", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchNumberSave("PrintMatchNumberSave", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchRepeated("PrintMatchRepeated", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchRepeatedTVarSave("PrintMatchRepeatedTVarSave", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchSTVar("PrintMatchSTVar", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchSTVarSave("PrintMatchSTVarSave", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintMatchSave("PrintMatchSave", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_PrintString("PrintString", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_SetLineNumbers("SetLineNumbers", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_StrFromDirection("StrFromDirection", 2638096229U, 2630503357U);
static refalrts::ExternalReference ref_StrFromInt("StrFromInt", 0U, 0U);
static refalrts::ExternalReference ref_VarMatchFunction("VarMatchFunction", 2638096229U, 2630503357U);

static refalrts::FnResult func_FuncArguments(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 7 elems
  refalrts::Iter context[7];
  refalrts::zeros( context, 7 );
  // </0 & FuncArguments/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: '('/0 HalfReuse: 'r'/4 HalfReuse: 'e'/1 }"falrts::Iter arg_begin, refalrts::Iter arg_end)"/5 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[5], context[6], "falrts::Iter arg_begin, refalrts::Iter arg_end)", 47 ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[0], '(' );
  refalrts::reinit_char( context[4], 'r' );
  refalrts::reinit_char( context[1], 'e' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_FuncArguments("FuncArguments", 2638096229U, 2630503357U, func_FuncArguments);


static refalrts::FnResult func_gen_GenProgramm_Native_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 31 elems
  refalrts::Iter context[31];
  refalrts::zeros( context, 31 );
  //FAST GEN: ( e.$ ) ( e.$ ) e.$
  //GLOBAL GEN: ( e.$ ) ( e.$ ) e.$
  // </0 & GenProgram-Native:1/4 (/7 e.idxB#0/5 )/8 (/11 e.idxTB#0/9 )/12 e.idxTT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.idxB#0 as range 5
  // closed e.idxTB#0 as range 9
  // closed e.idxTT#0 as range 2
  do {
    // ( e.idx ) ( e.idx ) e.idx
    // </0 & GenProgram-Native:1/4 (/7 e.SourceFileName#1/13 )/8 (/11 e.TargetFileName#1/15 )/12 e.Lines-B#3/19 (/25 # NativeInsertBegin/27 t.SrcPos#3/28 )/26 e.Lines-E#3/21 >/1
    context[13] = context[5];
    context[14] = context[6];
    context[15] = context[9];
    context[16] = context[10];
    context[17] = context[2];
    context[18] = context[3];
    // closed e.SourceFileName#1 as range 13
    // closed e.TargetFileName#1 as range 15
    context[19] = 0;
    context[20] = 0;
    refalrts::start_e_loop();
    do {
      context[21] = context[17];
      context[22] = context[18];
      context[23] = 0;
      context[24] = 0;
      context[25] = refalrts::brackets_left( context[23], context[24], context[21], context[22] );
      if( ! context[25] )
        continue;
      refalrts::bracket_pointers(context[25], context[26]);
      context[27] = refalrts::ident_left(  ident_NativeInsertBegin, context[23], context[24] );
      if( ! context[27] )
        continue;
      // closed e.Lines-E#3 as range 21
      context[29] = refalrts::tvar_left( context[28], context[23], context[24] );
      if( ! context[29] )
        continue;
      if( ! refalrts::empty_seq( context[23], context[24] ) )
        continue;
      //DEBUG: e.SourceFileName#1: 13
      //DEBUG: e.TargetFileName#1: 15
      //DEBUG: e.Lines-B#3: 19
      //DEBUG: e.Lines-E#3: 21
      //DEBUG: t.SrcPos#3: 28

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & SetLineNumbers/4 AsIs: (/7 AsIs: e.SourceFileName#1/13 AsIs: )/8 AsIs: (/11 AsIs: e.TargetFileName#1/15 AsIs: )/12 } 1/30 Tile{ AsIs: e.Lines-B#3/19 } Tile{ AsIs: (/25 AsIs: # NativeInsertBegin/27 AsIs: t.SrcPos#3/28 AsIs: )/26 AsIs: e.Lines-E#3/21 AsIs: >/1 ]] }
      if( ! refalrts::alloc_number( context[30], 1UL ) )
        return refalrts::cNoMemory;
      refalrts::update_name( context[4], ref_SetLineNumbers.ref.function );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[25], context[26] );
      refalrts::link_brackets( context[11], context[12] );
      refalrts::link_brackets( context[7], context[8] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[25];
      res = refalrts::splice_evar( res, context[19], context[20] );
      res = refalrts::splice_evar( res, context[30], context[30] );
      refalrts::use( res );
      return refalrts::cSuccess;
    } while ( refalrts::open_evar_advance( context[19], context[20], context[17], context[18] ) );
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) ( e.idx ) e.idx
  // </0 & GenProgram-Native:1/4 (/7 e.SourceFileName#1/13 )/8 (/11 e.TargetFileName#1/15 )/12 e.Lines#3/17 >/1
  context[13] = context[5];
  context[14] = context[6];
  context[15] = context[9];
  context[16] = context[10];
  context[17] = context[2];
  context[18] = context[3];
  // closed e.SourceFileName#1 as range 13
  // closed e.TargetFileName#1 as range 15
  // closed e.Lines#3 as range 17
  //DEBUG: e.SourceFileName#1: 13
  //DEBUG: e.TargetFileName#1: 15
  //DEBUG: e.Lines#3: 17

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & GenProgram-Native:1/4 (/7 e.SourceFileName#1/13 )/8 (/11 e.TargetFileName#1/15 )/12 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.Lines#3/17 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[17], context[18] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_GenProgramm_Native_B1("GenProgram-Native:1", 2638096229U, 2630503357U, func_gen_GenProgramm_Native_B1);


static refalrts::FnResult func_gen_GenProgramm_Native_A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 46 elems
  refalrts::Iter context[46];
  refalrts::zeros( context, 46 );
  // </0 & GenProgram-Native=1/4 (/7 e.SourceFileName#1/5 )/8 (/11 e.TargetFileName#1/9 )/12 (/15 )/16 e.Generated#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  context[13] = 0;
  context[14] = 0;
  context[15] = refalrts::brackets_left( context[13], context[14], context[2], context[3] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[15], context[16]);
  if( ! refalrts::empty_seq( context[13], context[14] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.SourceFileName#1 as range 5
  // closed e.TargetFileName#1 as range 9
  // closed e.Generated#2 as range 2
  //DEBUG: e.SourceFileName#1: 5
  //DEBUG: e.TargetFileName#1: 9
  //DEBUG: e.Generated#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </17 Tile{ HalfReuse: [*]/0 Reuse: & GenProgram-Native:1/4 AsIs: (/7 AsIs: e.SourceFileName#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.TargetFileName#1/9 AsIs: )/12 HalfReuse: {*}/15 HalfReuse: (/16 }"// This file automatically generated from \'"/18 e.SourceFileName#1/5/20 '\''/22 )/23 (/24"// Don\'t edit! Edit \'"/25 e.SourceFileName#1/5/27"\' and recompile it"/29 )/31 (/32 )/33 (/34"#include \"refalrts.h\""/35 )/37 (/38 )/39 Tile{ AsIs: e.Generated#2/2 } (/40 )/41 (/42"//End of file"/43 )/45 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[18], context[19], "// This file automatically generated from \'", 43 ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[20], context[21], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[22], '\'' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[23] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[24] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[25], context[26], "// Don\'t edit! Edit \'", 21 ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[27], context[28], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[29], context[30], "\' and recompile it", 18 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[31] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[32] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[33] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[34] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[35], context[36], "#include \"refalrts.h\"", 21 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[37] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[38] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[39] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[40] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[41] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[42] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[43], context[44], "//End of file", 13 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[45] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[0] );
  refalrts::update_name( context[4], ref_gen_GenProgramm_Native_B1.ref.function );
  refalrts::reinit_unwrapped_closure( context[15], context[0] );
  refalrts::reinit_open_bracket( context[16] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[17] );
  refalrts::link_brackets( context[42], context[45] );
  refalrts::link_brackets( context[40], context[41] );
  refalrts::link_brackets( context[38], context[39] );
  refalrts::link_brackets( context[34], context[37] );
  refalrts::link_brackets( context[32], context[33] );
  refalrts::link_brackets( context[24], context[31] );
  refalrts::link_brackets( context[16], context[23] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[40], context[45] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[18], context[39] );
  res = refalrts::splice_evar( res, context[0], context[16] );
  res = refalrts::splice_evar( res, context[17], context[17] );
  refalrts::use( res );
  refalrts::wrap_closure( context[15] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_GenProgramm_Native_A1("GenProgram-Native=1", 2638096229U, 2630503357U, func_gen_GenProgramm_Native_A1);


static refalrts::FnResult func_GenProgramm_Native(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 23 elems
  refalrts::Iter context[23];
  refalrts::zeros( context, 23 );
  // </0 & GenProgram-Native/4 (/7 e.SourceFileName#1/5 )/8 (/11 e.TargetFileName#1/9 )/12 (/15 e.NativeRASL#1/13 )/16 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  context[13] = 0;
  context[14] = 0;
  context[15] = refalrts::brackets_left( context[13], context[14], context[2], context[3] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[15], context[16]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.SourceFileName#1 as range 5
  // closed e.TargetFileName#1 as range 9
  // closed e.NativeRASL#1 as range 13
  //DEBUG: e.SourceFileName#1: 5
  //DEBUG: e.TargetFileName#1: 9
  //DEBUG: e.NativeRASL#1: 13

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </17 Tile{ HalfReuse: [*]/0 Reuse: & GenProgram-Native=1/4 AsIs: (/7 AsIs: e.SourceFileName#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.TargetFileName#1/9 AsIs: )/12 HalfReuse: {*}/15 } </18 & MapReduce/19 & GenCommand-Native/20 (/21 )/22 Tile{ AsIs: e.NativeRASL#1/13 } Tile{ HalfReuse: >/16 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], ref_MapReduce.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[20], ref_GenCommandm_Native.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[22] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[0] );
  refalrts::update_name( context[4], ref_gen_GenProgramm_Native_A1.ref.function );
  refalrts::reinit_unwrapped_closure( context[15], context[0] );
  refalrts::reinit_close_call( context[16] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[18] );
  refalrts::link_brackets( context[21], context[22] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[16];
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[18], context[22] );
  res = refalrts::splice_evar( res, context[0], context[15] );
  res = refalrts::splice_evar( res, context[17], context[17] );
  refalrts::use( res );
  refalrts::wrap_closure( context[15] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_GenProgramm_Native("GenProgram-Native", 0U, 0U, func_GenProgramm_Native);


static refalrts::FnResult func_SetLineNumbers(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 48 elems
  refalrts::Iter context[48];
  refalrts::zeros( context, 48 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) ( e.$ ) s.$ e.$
  // </0 & SetLineNumbers/4 (/7 e.idxB#0/5 )/8 (/11 e.idxTB#0/9 )/12 s.idxTT#0/13 e.idxTTV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.idxB#0 as range 5
  // closed e.idxTB#0 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTTV#0 as range 2
  do {
    // ( e.idx ) ( e.idx ) s.idx ( # NativeInsertBegin s.idx ) e.idx
    // </0 & SetLineNumbers/4 (/7 e.Source#1/14 )/8 (/11 e.Target#1/16 )/12 s.LineNum#1/13 (/22 # NativeInsertBegin/24 s.SrcLineNum#1/25 )/23 e.Lines#1/18 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    context[18] = context[2];
    context[19] = context[3];
    context[20] = 0;
    context[21] = 0;
    context[22] = refalrts::brackets_left( context[20], context[21], context[18], context[19] );
    if( ! context[22] )
      continue;
    refalrts::bracket_pointers(context[22], context[23]);
    context[24] = refalrts::ident_left(  ident_NativeInsertBegin, context[20], context[21] );
    if( ! context[24] )
      continue;
    // closed e.Source#1 as range 14
    // closed e.Target#1 as range 16
    // closed e.Lines#1 as range 18
    if( ! refalrts::svar_left( context[25], context[20], context[21] ) )
      continue;
    if( ! refalrts::empty_seq( context[20], context[21] ) )
      continue;
    //DEBUG: s.LineNum#1: 13
    //DEBUG: e.Source#1: 14
    //DEBUG: e.Target#1: 16
    //DEBUG: e.Lines#1: 18
    //DEBUG: s.SrcLineNum#1: 25

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/26"#line "/27 Tile{ HalfReuse: </22 HalfReuse: & StrFromInt/24 AsIs: s.SrcLineNum#1/25 } >/29" \""/30 </32 & EscapeString/33 e.Source#1/14/34 >/36 '\"'/37 )/38 Tile{ AsIs: </0 AsIs: & SetLineNumbers/4 AsIs: (/7 AsIs: e.Source#1/14 AsIs: )/8 AsIs: (/11 AsIs: e.Target#1/16 AsIs: )/12 } </39 & Inc/40 Tile{ AsIs: s.LineNum#1/13 } Tile{ HalfReuse: >/23 AsIs: e.Lines#1/18 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], "#line ", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[30], context[31], " \"", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[33], ref_EscapeString.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[34], context[35], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[36] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[37], '\"' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[38] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[39] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[40], ref_Inc.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[22] );
    refalrts::reinit_name( context[24], ref_StrFromInt.ref.function );
    refalrts::reinit_close_call( context[23] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[39] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[26], context[38] );
    refalrts::push_stack( context[36] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[22] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[23];
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[39], context[40] );
    res = refalrts::splice_evar( res, context[0], context[12] );
    res = refalrts::splice_evar( res, context[29], context[38] );
    res = refalrts::splice_evar( res, context[22], context[25] );
    res = refalrts::splice_evar( res, context[26], context[28] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( e.idx ) s.idx ( # NativeInsertBegin ( # FileLine s.idx e.idx ) ) e.idx
    // </0 & SetLineNumbers/4 (/7 e.Source#1/14 )/8 (/11 e.Target#1/16 )/12 s.LineNum#1/13 (/22 # NativeInsertBegin/24 (/27 # FileLine/29 s.Line#1/30 e.File#1/25 )/28 )/23 e.Lines#1/18 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    context[18] = context[2];
    context[19] = context[3];
    context[20] = 0;
    context[21] = 0;
    context[22] = refalrts::brackets_left( context[20], context[21], context[18], context[19] );
    if( ! context[22] )
      continue;
    refalrts::bracket_pointers(context[22], context[23]);
    context[24] = refalrts::ident_left(  ident_NativeInsertBegin, context[20], context[21] );
    if( ! context[24] )
      continue;
    context[25] = 0;
    context[26] = 0;
    context[27] = refalrts::brackets_left( context[25], context[26], context[20], context[21] );
    if( ! context[27] )
      continue;
    refalrts::bracket_pointers(context[27], context[28]);
    context[29] = refalrts::ident_left(  ident_FileLine, context[25], context[26] );
    if( ! context[29] )
      continue;
    if( ! refalrts::empty_seq( context[20], context[21] ) )
      continue;
    // closed e.Source#1 as range 14
    // closed e.Target#1 as range 16
    // closed e.Lines#1 as range 18
    if( ! refalrts::svar_left( context[30], context[25], context[26] ) )
      continue;
    // closed e.File#1 as range 25
    //DEBUG: s.LineNum#1: 13
    //DEBUG: e.Source#1: 14
    //DEBUG: e.Target#1: 16
    //DEBUG: e.Lines#1: 18
    //DEBUG: s.Line#1: 30
    //DEBUG: e.File#1: 25

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.LineNum#1/13 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/31"#lin"/32 Tile{ HalfReuse: 'e'/22 HalfReuse: ' '/24 HalfReuse: </27 HalfReuse: & StrFromInt/29 AsIs: s.Line#1/30 } >/34" \""/35 </37 & EscapeString/38 Tile{ AsIs: e.File#1/25 } >/39 '\"'/40 )/41 Tile{ AsIs: </0 AsIs: & SetLineNumbers/4 AsIs: (/7 AsIs: e.Source#1/14 AsIs: )/8 AsIs: (/11 AsIs: e.Target#1/16 AsIs: )/12 } </42 & Inc/43 Tile{ HalfReuse: s.LineNum1 #13/28 HalfReuse: >/23 AsIs: e.Lines#1/18 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[32], context[33], "#lin", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[34] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[35], context[36], " \"", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[37] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[38], ref_EscapeString.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[39] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[40], '\"' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[41] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[42] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[43], ref_Inc.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[22], 'e' );
    refalrts::reinit_char( context[24], ' ' );
    refalrts::reinit_open_call( context[27] );
    refalrts::reinit_name( context[29], ref_StrFromInt.ref.function );
    refalrts::reinit_svar( context[28], context[13] );
    refalrts::reinit_close_call( context[23] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[42] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[31], context[41] );
    refalrts::push_stack( context[39] );
    refalrts::push_stack( context[37] );
    refalrts::push_stack( context[34] );
    refalrts::push_stack( context[27] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[28];
    res = refalrts::splice_evar( res, context[42], context[43] );
    res = refalrts::splice_evar( res, context[0], context[12] );
    res = refalrts::splice_evar( res, context[39], context[41] );
    res = refalrts::splice_evar( res, context[25], context[26] );
    res = refalrts::splice_evar( res, context[34], context[38] );
    res = refalrts::splice_evar( res, context[22], context[30] );
    res = refalrts::splice_evar( res, context[31], context[33] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( e.idx ) s.idx ( # NativeInsertBegin ( # FileRowCol ( s.idx s.idx ) e.idx ) ) e.idx
    // </0 & SetLineNumbers/4 (/7 e.Source#1/14 )/8 (/11 e.Target#1/16 )/12 s.LineNum#1/13 (/22 # NativeInsertBegin/24 (/27 # FileRowCol/29 (/32 s.Line#1/34 s.Col#1/35 )/33 e.File#1/25 )/28 )/23 e.Lines#1/18 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    context[18] = context[2];
    context[19] = context[3];
    context[20] = 0;
    context[21] = 0;
    context[22] = refalrts::brackets_left( context[20], context[21], context[18], context[19] );
    if( ! context[22] )
      continue;
    refalrts::bracket_pointers(context[22], context[23]);
    context[24] = refalrts::ident_left(  ident_NativeInsertBegin, context[20], context[21] );
    if( ! context[24] )
      continue;
    context[25] = 0;
    context[26] = 0;
    context[27] = refalrts::brackets_left( context[25], context[26], context[20], context[21] );
    if( ! context[27] )
      continue;
    refalrts::bracket_pointers(context[27], context[28]);
    context[29] = refalrts::ident_left(  ident_FileRowCol, context[25], context[26] );
    if( ! context[29] )
      continue;
    context[30] = 0;
    context[31] = 0;
    context[32] = refalrts::brackets_left( context[30], context[31], context[25], context[26] );
    if( ! context[32] )
      continue;
    refalrts::bracket_pointers(context[32], context[33]);
    if( ! refalrts::empty_seq( context[20], context[21] ) )
      continue;
    // closed e.Source#1 as range 14
    // closed e.Target#1 as range 16
    // closed e.File#1 as range 25
    // closed e.Lines#1 as range 18
    if( ! refalrts::svar_left( context[34], context[30], context[31] ) )
      continue;
    if( ! refalrts::svar_left( context[35], context[30], context[31] ) )
      continue;
    if( ! refalrts::empty_seq( context[30], context[31] ) )
      continue;
    //DEBUG: s.LineNum#1: 13
    //DEBUG: e.Source#1: 14
    //DEBUG: e.Target#1: 16
    //DEBUG: e.File#1: 25
    //DEBUG: e.Lines#1: 18
    //DEBUG: s.Line#1: 34
    //DEBUG: s.Col#1: 35

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.LineNum#1/13 {REMOVED TILE} s.Col#1/35 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/36"#li"/37 Tile{ HalfReuse: 'n'/22 HalfReuse: 'e'/24 HalfReuse: ' '/27 HalfReuse: </29 HalfReuse: & StrFromInt/32 AsIs: s.Line#1/34 } >/39" \""/40 </42 & EscapeString/43 Tile{ AsIs: e.File#1/25 } >/44 '\"'/45 Tile{ AsIs: )/33 } Tile{ AsIs: </0 AsIs: & SetLineNumbers/4 AsIs: (/7 AsIs: e.Source#1/14 AsIs: )/8 AsIs: (/11 AsIs: e.Target#1/16 AsIs: )/12 } </46 & Inc/47 Tile{ HalfReuse: s.LineNum1 #13/28 HalfReuse: >/23 AsIs: e.Lines#1/18 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[36] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[37], context[38], "#li", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[39] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[40], context[41], " \"", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[42] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[43], ref_EscapeString.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[44] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[45], '\"' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[46] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[47], ref_Inc.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[22], 'n' );
    refalrts::reinit_char( context[24], 'e' );
    refalrts::reinit_char( context[27], ' ' );
    refalrts::reinit_open_call( context[29] );
    refalrts::reinit_name( context[32], ref_StrFromInt.ref.function );
    refalrts::reinit_svar( context[28], context[13] );
    refalrts::reinit_close_call( context[23] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[46] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[36], context[33] );
    refalrts::push_stack( context[44] );
    refalrts::push_stack( context[42] );
    refalrts::push_stack( context[39] );
    refalrts::push_stack( context[29] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[28];
    res = refalrts::splice_evar( res, context[46], context[47] );
    res = refalrts::splice_evar( res, context[0], context[12] );
    res = refalrts::splice_evar( res, context[33], context[33] );
    res = refalrts::splice_evar( res, context[44], context[45] );
    res = refalrts::splice_evar( res, context[25], context[26] );
    res = refalrts::splice_evar( res, context[39], context[43] );
    res = refalrts::splice_evar( res, context[22], context[34] );
    res = refalrts::splice_evar( res, context[36], context[38] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( e.idx ) s.idx ( # NativeInsertEnd ) e.idx
    // </0 & SetLineNumbers/4 (/7 e.Source#1/14 )/8 (/11 e.Target#1/16 )/12 s.LineNum#1/13 (/22 # NativeInsertEnd/24 )/23 e.Lines#1/18 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    context[18] = context[2];
    context[19] = context[3];
    context[20] = 0;
    context[21] = 0;
    context[22] = refalrts::brackets_left( context[20], context[21], context[18], context[19] );
    if( ! context[22] )
      continue;
    refalrts::bracket_pointers(context[22], context[23]);
    context[24] = refalrts::ident_left(  ident_NativeInsertEnd, context[20], context[21] );
    if( ! context[24] )
      continue;
    if( ! refalrts::empty_seq( context[20], context[21] ) )
      continue;
    // closed e.Source#1 as range 14
    // closed e.Target#1 as range 16
    // closed e.Lines#1 as range 18
    //DEBUG: s.LineNum#1: 13
    //DEBUG: e.Source#1: 14
    //DEBUG: e.Target#1: 16
    //DEBUG: e.Lines#1: 18

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/25"#line "/26 </28 & StrFromInt/29 </30 & Inc/31 Tile{ AsIs: s.LineNum#1/13 } >/32 >/33" \""/34 </36 & EscapeString/37 e.Target#1/16/38 >/40 '\"'/41 )/42 Tile{ AsIs: </0 AsIs: & SetLineNumbers/4 AsIs: (/7 AsIs: e.Source#1/14 AsIs: )/8 AsIs: (/11 AsIs: e.Target#1/16 AsIs: )/12 } </43 Tile{ HalfReuse: & Inc/22 HalfReuse: s.LineNum1 #13/24 HalfReuse: >/23 AsIs: e.Lines#1/18 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[26], context[27], "#line ", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[29], ref_StrFromInt.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[31], ref_Inc.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[33] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[34], context[35], " \"", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[36] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[37], ref_EscapeString.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[38], context[39], context[16], context[17]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[40] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[41], '\"' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[42] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[43] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_name( context[22], ref_Inc.ref.function );
    refalrts::reinit_svar( context[24], context[13] );
    refalrts::reinit_close_call( context[23] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[43] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[25], context[42] );
    refalrts::push_stack( context[40] );
    refalrts::push_stack( context[36] );
    refalrts::push_stack( context[33] );
    refalrts::push_stack( context[28] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[30] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[22];
    res = refalrts::splice_evar( res, context[43], context[43] );
    res = refalrts::splice_evar( res, context[0], context[12] );
    res = refalrts::splice_evar( res, context[32], context[42] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[25], context[31] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( e.idx ) s.idx ( e.idx ) e.idx
    // </0 & SetLineNumbers/4 (/7 e.Source#1/14 )/8 (/11 e.Target#1/16 )/12 s.LineNum#1/13 (/22 e.OtherLine#1/20 )/23 e.Lines#1/18 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    context[18] = context[2];
    context[19] = context[3];
    context[20] = 0;
    context[21] = 0;
    context[22] = refalrts::brackets_left( context[20], context[21], context[18], context[19] );
    if( ! context[22] )
      continue;
    refalrts::bracket_pointers(context[22], context[23]);
    // closed e.Source#1 as range 14
    // closed e.Target#1 as range 16
    // closed e.OtherLine#1 as range 20
    // closed e.Lines#1 as range 18
    //DEBUG: s.LineNum#1: 13
    //DEBUG: e.Source#1: 14
    //DEBUG: e.Target#1: 16
    //DEBUG: e.OtherLine#1: 20
    //DEBUG: e.Lines#1: 18

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/22 } Tile{ AsIs: e.OtherLine#1/20 } )/24 Tile{ AsIs: </0 AsIs: & SetLineNumbers/4 AsIs: (/7 AsIs: e.Source#1/14 AsIs: )/8 AsIs: (/11 AsIs: e.Target#1/16 AsIs: )/12 } </25 & Inc/26 Tile{ AsIs: s.LineNum#1/13 } Tile{ HalfReuse: >/23 AsIs: e.Lines#1/18 AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_bracket( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], ref_Inc.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::reinit_close_call( context[23] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[25] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[22], context[24] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[23];
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[25], context[26] );
    res = refalrts::splice_evar( res, context[0], context[12] );
    res = refalrts::splice_evar( res, context[24], context[24] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[22], context[22] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) ( e.idx ) s.idx
  // </0 & SetLineNumbers/4 (/7 e.Source#1/14 )/8 (/11 e.Target#1/16 )/12 s.LineNum#1/13 >/1
  context[14] = context[5];
  context[15] = context[6];
  context[16] = context[9];
  context[17] = context[10];
  context[18] = context[2];
  context[19] = context[3];
  if( ! refalrts::empty_seq( context[18], context[19] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Source#1 as range 14
  // closed e.Target#1 as range 16
  //DEBUG: s.LineNum#1: 13
  //DEBUG: e.Source#1: 14
  //DEBUG: e.Target#1: 16

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & SetLineNumbers/4 (/7 e.Source#1/14 )/8 (/11 e.Target#1/16 )/12 s.LineNum#1/13 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_SetLineNumbers("SetLineNumbers", 2638096229U, 2630503357U, func_SetLineNumbers);


static refalrts::FnResult func_ContextRangem_B(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ContextRange-B/4 s.RangeOffset#1/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.RangeOffset#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ }"context["/6 Tile{ AsIs: </0 Reuse: & StrFromInt/4 AsIs: s.RangeOffset#1/5 AsIs: >/1 } ']'/8 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "context[", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[8], ']' ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_StrFromInt.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[8], context[8] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_ContextRangem_B("ContextRange-B", 2638096229U, 2630503357U, func_ContextRangem_B);


static refalrts::FnResult func_ContextRangem_E(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & ContextRange-E/4 s.RangeOffset#1/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.RangeOffset#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ }"context["/6 </8 & StrFromInt/9 Tile{ AsIs: </0 Reuse: & Inc/4 AsIs: s.RangeOffset#1/5 AsIs: >/1 } >/10 ']'/11 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "context[", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], ref_StrFromInt.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[11], ']' ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Inc.ref.function );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[10], context[11] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[6], context[9] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_ContextRangem_E("ContextRange-E", 2638096229U, 2630503357U, func_ContextRangem_E);


static refalrts::FnResult func_ContextRange(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & ContextRange/4 s.RangeOffset#1/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.RangeOffset#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & ContextRange-B/4 AsIs: s.RangeOffset#1/5 AsIs: >/1 }", "/6 </8 & ContextRange-E/9 s.RangeOffset#1/5/10 >/11 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], ref_ContextRangem_E.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[10], context[5]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_ContextRangem_B.ref.function );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_ContextRange("ContextRange", 2638096229U, 2630503357U, func_ContextRange);


static refalrts::FnResult func_ContextItem(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & ContextItem/4 s.ItemNumber#1/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.ItemNumber#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ }"context["/6 Tile{ AsIs: </0 Reuse: & StrFromInt/4 AsIs: s.ItemNumber#1/5 AsIs: >/1 } ']'/8 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "context[", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[8], ']' ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_StrFromInt.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[8], context[8] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_ContextItem("ContextItem", 2638096229U, 2630503357U, func_ContextItem);


static refalrts::FnResult func_PrintBracketsVarInit(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 20 elems
  refalrts::Iter context[20];
  refalrts::zeros( context, 20 );
  // </0 & PrintBracketsVarInit/4 e.Indent#1/2 s.InnerBrackets#1/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_right( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Indent#1 as range 2
  //DEBUG: s.InnerBrackets#1: 5
  //DEBUG: e.Indent#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } (/6 Tile{ AsIs: e.Indent#1/2 } Tile{ AsIs: </0 Reuse: & ContextRange-B/4 } Tile{ AsIs: s.InnerBrackets#1/5 AsIs: >/1 }" = 0;"/7 )/9 (/10 e.Indent#1/2/11 </13 & ContextRange-E/14 s.InnerBrackets#1/5/15 >/16" = 0;"/17 )/19 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[7], context[8], " = 0;", 5 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[11], context[12], context[2], context[3]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], ref_ContextRangem_E.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[15], context[5]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[17], context[18], " = 0;", 5 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[19] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_ContextRangem_B.ref.function );
  refalrts::link_brackets( context[10], context[19] );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[13] );
  refalrts::link_brackets( context[6], context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[7], context[19] );
  res = refalrts::splice_evar( res, context[5], context[1] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[6], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintBracketsVarInit("PrintBracketsVarInit", 2638096229U, 2630503357U, func_PrintBracketsVarInit);


static refalrts::FnResult func_CNameAlias(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & CNameAlias/4 e.RegularName#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.RegularName#1 as range 2
  //DEBUG: e.RegularName#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ }"ref_"/5 Tile{ AsIs: </0 Reuse: & CName/4 AsIs: e.RegularName#1/2 AsIs: >/1 }".ref.function"/7 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[5], context[6], "ref_", 4 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[7], context[8], ".ref.function", 13 ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_CName.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[7], context[8] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_CNameAlias("CNameAlias", 2638096229U, 2630503357U, func_CNameAlias);


static refalrts::FnResult func_BaseCName(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & BaseCName/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // e.idx # Hash s.idx s.idx
    // </0 & BaseCName/4 e.Name#1/5 # Hash/9 s.Cookie1#1/8 s.Cookie2#1/7 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_right( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::svar_right( context[8], context[5], context[6] ) )
      continue;
    context[9] = refalrts::ident_right(  ident_Hash, context[5], context[6] );
    if( ! context[9] )
      continue;
    // closed e.Name#1 as range 5
    //DEBUG: s.Cookie2#1: 7
    //DEBUG: s.Cookie1#1: 8
    //DEBUG: e.Name#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.Cookie1#1/8 s.Cookie2#1/7 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & CName/4 AsIs: e.Name#1/5 HalfReuse: >/9 } Tile{ ]] }
    refalrts::update_name( context[4], ref_CName.ref.function );
    refalrts::reinit_close_call( context[9] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    refalrts::splice_to_freelist_open( context[9], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & BaseCName/4 e.Name#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.Name#1 as range 5
  //DEBUG: e.Name#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & CName/4 AsIs: e.Name#1/5 AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_CName.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_BaseCName("BaseCName", 2638096229U, 2630503357U, func_BaseCName);


static refalrts::FnResult func_NameAndCookies(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  // </0 & NameAndCookies/4 e.Name#1/2 # Hash/7 s.Cookie1#1/6 s.Cookie2#1/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_right( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_right( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[7] = refalrts::ident_right(  ident_Hash, context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  // closed e.Name#1 as range 2
  //DEBUG: s.Cookie2#1: 5
  //DEBUG: s.Cookie1#1: 6
  //DEBUG: e.Name#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } '\"'/8 Tile{ AsIs: </0 Reuse: & DisplayCName/4 AsIs: e.Name#1/2 HalfReuse: >/7 }"\", "/9 </11 & StrFromInt/12 Tile{ AsIs: s.Cookie1#1/6 } >/13"U, "/14 </16 & StrFromInt/17 Tile{ AsIs: s.Cookie2#1/5 AsIs: >/1 } 'U'/18 Tile{ ]] }
  if( ! refalrts::alloc_char( context[8], '\"' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[9], context[10], "\", ", 3 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[12], ref_StrFromInt.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[14], context[15], "U, ", 3 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[17], ref_StrFromInt.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[18], 'U' ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_DisplayCName.ref.function );
  refalrts::reinit_close_call( context[7] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[18], context[18] );
  res = refalrts::splice_evar( res, context[5], context[1] );
  res = refalrts::splice_evar( res, context[13], context[17] );
  res = refalrts::splice_evar( res, context[6], context[6] );
  res = refalrts::splice_evar( res, context[9], context[12] );
  res = refalrts::splice_evar( res, context[0], context[7] );
  res = refalrts::splice_evar( res, context[8], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_NameAndCookies("NameAndCookies", 2638096229U, 2630503357U, func_NameAndCookies);


static refalrts::FnResult func_MakeRefalName(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  // </0 & MakeRefalName/4 e.Name#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Name#1 as range 2
  //DEBUG: e.Name#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ }"refalrts::RefalFuncName("/5 Tile{ AsIs: </0 Reuse: & NameAndCookies/4 AsIs: e.Name#1/2 AsIs: >/1 } ')'/7 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[5], context[6], "refalrts::RefalFuncName(", 24 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[7], ')' ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NameAndCookies.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[7], context[7] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_MakeRefalName("MakeRefalName", 2638096229U, 2630503357U, func_MakeRefalName);


static refalrts::FnResult func_FormatOffsets(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & FormatOffsets/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // e.idx
    // </0 & FormatOffsets/4 e.Chars#1/7 # Offset/11 s.Offset#1/12 e.Text#1/9 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = 0;
    context[8] = 0;
    refalrts::start_e_loop();
    do {
      context[9] = context[5];
      context[10] = context[6];
      context[11] = refalrts::ident_left(  ident_Offset, context[9], context[10] );
      if( ! context[11] )
        continue;
      if( ! refalrts::svar_left( context[12], context[9], context[10] ) )
        continue;
      // closed e.Text#1 as range 9
      //DEBUG: e.Chars#1: 7
      //DEBUG: s.Offset#1: 12
      //DEBUG: e.Text#1: 9

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: e.Chars#1/7 } </13 Tile{ HalfReuse: & StrFromInt/11 AsIs: s.Offset#1/12 } >/14 Tile{ AsIs: </0 AsIs: & FormatOffsets/4 } Tile{ AsIs: e.Text#1/9 } Tile{ AsIs: >/1 ]] }
      if( ! refalrts::alloc_open_call( context[13] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[14] ) )
        return refalrts::cNoMemory;
      refalrts::reinit_name( context[11], ref_StrFromInt.ref.function );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::push_stack( context[14] );
      refalrts::push_stack( context[13] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[9], context[10] );
      res = refalrts::splice_evar( res, context[0], context[4] );
      res = refalrts::splice_evar( res, context[14], context[14] );
      res = refalrts::splice_evar( res, context[11], context[12] );
      res = refalrts::splice_evar( res, context[13], context[13] );
      res = refalrts::splice_evar( res, context[7], context[8] );
      refalrts::use( res );
      return refalrts::cSuccess;
    } while ( refalrts::open_evar_advance( context[7], context[8], context[5], context[6] ) );
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & FormatOffsets/4 e.Chars#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.Chars#1 as range 5
  //DEBUG: e.Chars#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & FormatOffsets/4 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.Chars#1/5 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_FormatOffsets("FormatOffsets", 2638096229U, 2630503357U, func_FormatOffsets);


static refalrts::FnResult func_gen_GenCommandm_Native_S39L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  //FAST GEN: ( e.$ ) s.$
  //GLOBAL GEN: ( e.$ ) s.$
  // </0 & GenCommand-Native$39\1/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // ( e.idx ) # RIGHT-EDGE
    // </0 & GenCommand-Native$39\1/4 (/7 e.Indent#1/10 )/8 # RIGHT-EDGE/9 >/1
    context[10] = context[5];
    context[11] = context[6];
    if( ! refalrts::ident_term(  ident_RIGHTm_EDGE, context[9] ) )
      continue;
    // closed e.Indent#1 as range 10
    //DEBUG: e.Indent#1: 10

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/10 HalfReuse: 'r'/8 HalfReuse: 'e'/9 HalfReuse: 'f'/1 } 'a'/12 Tile{ HalfReuse: 'l'/0 HalfReuse: 'r'/4 }"ts::Iter res = arg_end->next;"/13 )/15 Tile{ ]] }
    if( ! refalrts::alloc_char( context[12], 'a' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[13], context[14], "ts::Iter res = arg_end->next;", 29 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[15] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[8], 'r' );
    refalrts::reinit_char( context[9], 'e' );
    refalrts::reinit_char( context[1], 'f' );
    refalrts::reinit_char( context[0], 'l' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::link_brackets( context[7], context[15] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[13], context[15] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[7], context[1] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx
  // </0 & GenCommand-Native$39\1/4 (/7 e.Indent#1/10 )/8 s.Offset#2/9 >/1
  context[10] = context[5];
  context[11] = context[6];
  // closed e.Indent#1 as range 10
  //DEBUG: s.Offset#2: 9
  //DEBUG: e.Indent#1: 10

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/10 HalfReuse: 'r'/8 }"efalrts::Iter res = "/12 Tile{ AsIs: </0 Reuse: & ContextItem/4 } Tile{ AsIs: s.Offset#2/9 AsIs: >/1 } ';'/14 )/15 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[12], context[13], "efalrts::Iter res = ", 20 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[14], ';' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[8], 'r' );
  refalrts::update_name( context[4], ref_ContextItem.ref.function );
  refalrts::link_brackets( context[7], context[15] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[9], context[1] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[12], context[13] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_GenCommandm_Native_S39L1("GenCommand-Native$39\\1", 2638096229U, 2630503357U, func_gen_GenCommandm_Native_S39L1);


static refalrts::FnResult func_gen_GenCommandm_Native_S57L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 17 elems
  refalrts::Iter context[17];
  refalrts::zeros( context, 17 );
  //FAST GEN: ( e.$ ) s.$
  //GLOBAL GEN: ( e.$ ) s.$
  // </0 & GenCommand-Native$57\1/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // ( e.idx ) # LEFT-EDGE
    // </0 & GenCommand-Native$57\1/4 (/7 e.Indent#1/10 )/8 # LEFT-EDGE/9 >/1
    context[10] = context[5];
    context[11] = context[6];
    if( ! refalrts::ident_term(  ident_LEFTm_EDGE, context[9] ) )
      continue;
    // closed e.Indent#1 as range 10
    //DEBUG: e.Indent#1: 10

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/10 HalfReuse: 'r'/8 HalfReuse: 'e'/9 HalfReuse: 'f'/1 } 'a'/12 Tile{ HalfReuse: 'l'/0 HalfReuse: 'r'/4 }"ts::splice_to_freelist_open( trash_prev, res );"/13 )/15 Tile{ ]] }
    if( ! refalrts::alloc_char( context[12], 'a' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[13], context[14], "ts::splice_to_freelist_open( trash_prev, res );", 47 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[15] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[8], 'r' );
    refalrts::reinit_char( context[9], 'e' );
    refalrts::reinit_char( context[1], 'f' );
    refalrts::reinit_char( context[0], 'l' );
    refalrts::reinit_char( context[4], 'r' );
    refalrts::link_brackets( context[7], context[15] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[13], context[15] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[7], context[1] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx
  // </0 & GenCommand-Native$57\1/4 (/7 e.Indent#1/10 )/8 s.Offset#2/9 >/1
  context[10] = context[5];
  context[11] = context[6];
  // closed e.Indent#1 as range 10
  //DEBUG: s.Offset#2: 9
  //DEBUG: e.Indent#1: 10

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/10 HalfReuse: 'r'/8 }"efalrts::splice_to_freelist_open( "/12 Tile{ AsIs: </0 Reuse: & ContextItem/4 } Tile{ AsIs: s.Offset#2/9 AsIs: >/1 }", res );"/14 )/16 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[12], context[13], "efalrts::splice_to_freelist_open( ", 34 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[14], context[15], ", res );", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[16] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[8], 'r' );
  refalrts::update_name( context[4], ref_ContextItem.ref.function );
  refalrts::link_brackets( context[7], context[16] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[14], context[16] );
  res = refalrts::splice_evar( res, context[9], context[1] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[12], context[13] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_GenCommandm_Native_S57L1("GenCommand-Native$57\\1", 2638096229U, 2630503357U, func_gen_GenCommandm_Native_S57L1);


static refalrts::FnResult func_GenCommandm_Native(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 70 elems
  refalrts::Iter context[70];
  refalrts::zeros( context, 70 );
  //FAST GEN: ( e.$ ) ( e.$ )
  //GLOBAL GEN: ( e.$ ) ( s.$ e.$ )
  // </0 & GenCommand-Native/4 (/7 e.idxB#0/5 )/8 (/11 s.idxTB#0/13 e.idxTBV#0/9 )/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[13], context[9], context[10] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTBV#0 as range 9
  do {
    // ( e.idx ) ( # CmdComment e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdComment/13 e.Text#1/16 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdComment, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    // closed e.Text#1 as range 16
    //DEBUG: e.Indent#1: 14
    //DEBUG: e.Text#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/18 Tile{ HalfReuse: '/'/4 } '/'/20 Tile{ AsIs: </0 } Tile{ HalfReuse: & FormatOffsets/13 AsIs: e.Text#1/16 HalfReuse: >/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[20], '/' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[4], '/' );
    refalrts::reinit_name( context[13], ref_FormatOffsets.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[20], context[20] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdDefineIdent e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdDefineIdent/13 e.Name#1/16 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdDefineIdent, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    // closed e.Name#1 as range 16
    //DEBUG: e.Indent#1: 14
    //DEBUG: e.Name#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 HalfReuse: 's'/13 }"tatic const refalrts::RefalIdentifier ident_"/18 Tile{ AsIs: </0 Reuse: & CName/4 } Tile{ AsIs: e.Name#1/16 } >/20" = refalrts::ident_from_static(\""/21 </23 & DisplayCName/24 e.Name#1/16/25 >/27"\")"/28 Tile{ HalfReuse: ';'/12 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_chars( context[18], context[19], "tatic const refalrts::RefalIdentifier ident_", 44 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], " = refalrts::ident_from_static(\"", 32 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[24], ref_DisplayCName.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[25], context[26], context[16], context[17]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[28], context[29], "\")", 2 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 's' );
    refalrts::update_name( context[4], ref_CName.ref.function );
    refalrts::reinit_char( context[12], ';' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[20], context[29] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdExtern e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdExtern/13 e.Name#1/16 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdExtern, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    // closed e.Name#1 as range 16
    //DEBUG: e.Indent#1: 14
    //DEBUG: e.Name#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 HalfReuse: 's'/13 }"tatic refalrts::ExternalReference ref_"/18 Tile{ AsIs: </0 Reuse: & BaseCName/4 } Tile{ AsIs: e.Name#1/16 } >/20 '('/21 </22 & NameAndCookies/23 e.Name#1/16/24 >/26 ')'/27 Tile{ HalfReuse: ';'/12 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_chars( context[18], context[19], "tatic refalrts::ExternalReference ref_", 38 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[21], '(' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[23], ref_NameAndCookies.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[24], context[25], context[16], context[17]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[27], ')' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 's' );
    refalrts::update_name( context[4], ref_BaseCName.ref.function );
    refalrts::reinit_char( context[12], ';' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[20], context[27] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCookieNS s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdCookieNS/13 s.Cookie1#1/18 s.Cookie2#1/19 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdCookieNS, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Cookie1#1: 18
    //DEBUG: s.Cookie2#1: 19

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 HalfReuse: '#'/13 }"define cookie_ns cookie_ns_"/20 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } Tile{ AsIs: s.Cookie1#1/18 } >/22 '_'/23 </24 & StrFromInt/25 Tile{ AsIs: s.Cookie2#1/19 HalfReuse: >/12 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_chars( context[20], context[21], "define cookie_ns cookie_ns_", 27 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[23], '_' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[25], ref_StrFromInt.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], '#' );
    refalrts::update_name( context[4], ref_StrFromInt.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[19];
    res = refalrts::splice_evar( res, context[22], context[25] );
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNativeFuncDescr e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdNativeFuncDescr/13 e.Name#1/16 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdNativeFuncDescr, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    // closed e.Name#1 as range 16
    //DEBUG: e.Indent#1: 14
    //DEBUG: e.Name#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 HalfReuse: )/13 } (/18"static refalrts::NativeReference nat_ref_"/19 Tile{ AsIs: </0 Reuse: & BaseCName/4 } Tile{ AsIs: e.Name#1/16 } >/21 '('/22 </23 & NameAndCookies/24 e.Name#1/16/25 >/27", func_"/28 </30 & BaseCName/31 e.Name#1/16/32 >/34");"/35 )/37 Tile{ HalfReuse: (/12 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "static refalrts::NativeReference nat_ref_", 41 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[22], '(' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[24], ref_NameAndCookies.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[25], context[26], context[16], context[17]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[28], context[29], ", func_", 7 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[31], ref_BaseCName.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[32], context[33], context[16], context[17]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[34] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[35], context[36], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[37] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_close_bracket( context[13] );
    refalrts::update_name( context[4], ref_BaseCName.ref.function );
    refalrts::reinit_open_bracket( context[12] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[12], context[1] );
    refalrts::link_brackets( context[18], context[37] );
    refalrts::push_stack( context[34] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[11], context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[21], context[37] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[18], context[20] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdFnStart e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdFnStart/13 e.Name#1/16 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdFnStart, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    // closed e.Name#1 as range 16
    //DEBUG: e.Indent#1: 14
    //DEBUG: e.Name#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 HalfReuse: ' '/8 HalfReuse: ' '/11 HalfReuse: )/13 } (/18 )/19 (/20"static refalrts::FnResult func_"/21 Tile{ AsIs: </0 Reuse: & BaseCName/4 } Tile{ AsIs: e.Name#1/16 } >/23 </24 & FuncArguments/25 >/26 ' '/27 Tile{ HalfReuse: '{'/12 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "static refalrts::FnResult func_", 31 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[25], ref_FuncArguments.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[27], ' ' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[8], ' ' );
    refalrts::reinit_char( context[11], ' ' );
    refalrts::reinit_close_bracket( context[13] );
    refalrts::update_name( context[4], ref_BaseCName.ref.function );
    refalrts::reinit_char( context[12], '{' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[20], context[1] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[18], context[19] );
    refalrts::link_brackets( context[7], context[13] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[23], context[27] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[18], context[22] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx '  ' ) ( # CmdFnEnd )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 ' '/19 ' '/18 )/8 (/11 # CmdFnEnd/13 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdFnEnd, context[13] ) )
      continue;
    context[18] = refalrts::char_right( ' ', context[14], context[15] );
    if( ! context[18] )
      continue;
    context[19] = refalrts::char_right( ' ', context[14], context[15] );
    if( ! context[19] )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    // closed e.Indent#1 as range 14
    //DEBUG: e.Indent#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} & GenCommand-Native/4 (/7 {REMOVED TILE} ' '/19 ' '/18 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: (/0 } Tile{ AsIs: e.Indent#1/14 } Tile{ AsIs: )/8 AsIs: (/11 HalfReuse: '}'/13 AsIs: )/12 } Tile{ ]] }
    refalrts::reinit_open_bracket( context[0] );
    refalrts::reinit_char( context[13], '}' );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::link_brackets( context[0], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[8], context[12] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    refalrts::splice_to_freelist_open( context[0], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdEmitNativeCode t.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdEmitNativeCode/13 t.SrcPos#1/18 e.Code#1/16 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdEmitNativeCode, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    context[19] = refalrts::tvar_left( context[18], context[16], context[17] );
    if( ! context[19] )
      continue;
    // closed e.Code#1 as range 16
    //DEBUG: e.Indent#1: 14
    //DEBUG: t.SrcPos#1: 18
    //DEBUG: e.Code#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 Reuse: # NativeInsertBegin/13 AsIs: t.SrcPos#1/18 } Tile{ HalfReuse: )/4 } Tile{ AsIs: e.Code#1/16 } Tile{ HalfReuse: (/0 } Tile{ HalfReuse: # NativeInsertEnd/12 HalfReuse: )/1 ]] }
    refalrts::update_ident( context[13], ident_NativeInsertBegin );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_open_bracket( context[0] );
    refalrts::reinit_ident( context[12], ident_NativeInsertEnd );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[0], context[1] );
    refalrts::link_brackets( context[11], context[4] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[7], context[19] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCallCondition )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdCallCondition/13 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdCallCondition, context[13] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    // closed e.Indent#1 as range 14
    //DEBUG: e.Indent#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/18 e.Indent#1/14/19 )/21 (/22 e.Indent#1/14/23"refalrts::FnResult rec_res = refalrts::recursive_call_main_loop()"/25 Tile{ HalfReuse: ';'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/14 HalfReuse: 'i'/8 HalfReuse: 'f'/11 HalfReuse: ' '/13 HalfReuse: '('/12 HalfReuse: 'r'/1 }"ec_res != refalrts::cSuccess)"/27 )/29 (/30 e.Indent#1/14/31"  return rec_res;"/33 )/35 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[19], context[20], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[22] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[23], context[24], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "refalrts::FnResult rec_res = refalrts::recursive_call_main_loop()", 65 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], "ec_res != refalrts::cSuccess)", 29 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[30] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[31], context[32], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[33], context[34], "  return rec_res;", 17 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[35] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ';' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], 'i' );
    refalrts::reinit_char( context[11], 'f' );
    refalrts::reinit_char( context[13], ' ' );
    refalrts::reinit_char( context[12], '(' );
    refalrts::reinit_char( context[1], 'r' );
    refalrts::link_brackets( context[30], context[35] );
    refalrts::link_brackets( context[7], context[29] );
    refalrts::link_brackets( context[22], context[4] );
    refalrts::link_brackets( context[18], context[21] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[27], context[35] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[18], context[26] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdProfileFunction )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdProfileFunction/13 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdProfileFunction, context[13] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    // closed e.Indent#1 as range 14
    //DEBUG: e.Indent#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/18 Tile{ HalfReuse: 'r'/0 HalfReuse: 'e'/4 }"falrts::this_is_generated_function("/20 Tile{ HalfReuse: ')'/13 HalfReuse: ';'/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "falrts::this_is_generated_function(", 35 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[13], ')' );
    refalrts::reinit_char( context[12], ';' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdIssueMemory s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdIssueMemory/13 s.Number#1/18 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdIssueMemory, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Number#1: 18

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/19"// issue here memory for vars with "/21 </23 Tile{ HalfReuse: & StrFromInt/13 AsIs: s.Number#1/18 HalfReuse: >/12 HalfReuse: ' '/1 }"elems"/24 )/26 (/27 e.Indent#1/14/28"refalrts::Iter context["/30 Tile{ AsIs: </0 Reuse: & StrFromInt/4 } s.Number#1/18/32 >/33"];"/34 )/36 (/37 e.Indent#1/14/38"refalrts::zeros( context, "/40 </42 & StrFromInt/43 s.Number#1/18/44 >/45" );"/46 )/48 Tile{ ]] }
    if (! refalrts::copy_evar(context[19], context[20], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "// issue here memory for vars with ", 35 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "elems", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[27] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[28], context[29], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[30], context[31], "refalrts::Iter context[", 23 ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[32], context[18]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[33] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[34], context[35], "];", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[36] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[37] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[38], context[39], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[40], context[41], "refalrts::zeros( context, ", 26 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[42] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[43], ref_StrFromInt.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[44], context[18]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[45] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[46], context[47], " );", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[48] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_name( context[13], ref_StrFromInt.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::update_name( context[4], ref_StrFromInt.ref.function );
    refalrts::link_brackets( context[37], context[48] );
    refalrts::push_stack( context[45] );
    refalrts::push_stack( context[42] );
    refalrts::link_brackets( context[27], context[36] );
    refalrts::push_stack( context[33] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[11], context[26] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[23] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[32], context[48] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[24], context[31] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[21], context[23] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdStartSentence )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdStartSentence/13 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdStartSentence, context[13] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    // closed e.Indent#1 as range 14
    //DEBUG: e.Indent#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/18 e.Indent#1/14/19 ' '/21 Tile{ HalfReuse: ' '/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/14 HalfReuse: 'd'/8 HalfReuse: 'o'/11 HalfReuse: ' '/13 HalfReuse: '{'/12 HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[19], context[20], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[21], ' ' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ' ' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], 'd' );
    refalrts::reinit_char( context[11], 'o' );
    refalrts::reinit_char( context[13], ' ' );
    refalrts::reinit_char( context[12], '{' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[7], context[1] );
    refalrts::link_brackets( context[18], context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[18], context[21] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx '  ' ) ( # CmdEndSentence )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 ' '/19 ' '/18 )/8 (/11 # CmdEndSentence/13 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdEndSentence, context[13] ) )
      continue;
    context[18] = refalrts::char_right( ' ', context[14], context[15] );
    if( ! context[18] )
      continue;
    context[19] = refalrts::char_right( ' ', context[14], context[15] );
    if( ! context[19] )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    // closed e.Indent#1 as range 14
    //DEBUG: e.Indent#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: (/0 } e.Indent#1/14/20 Tile{ HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/14 Reuse: '}'/19 AsIs: ' '/18 HalfReuse: 'w'/8 HalfReuse: 'h'/11 HalfReuse: 'i'/13 HalfReuse: 'l'/12 HalfReuse: 'e'/1 }" ( 0 );"/22 )/24 (/25 e.Indent#1/14/26"refalrts::stop_sentence();"/28 )/30 (/31 )/32 Tile{ ]] }
    if (! refalrts::copy_evar(context[20], context[21], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], " ( 0 );", 7 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[25] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[26], context[27], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[28], context[29], "refalrts::stop_sentence();", 26 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[32] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[0] );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::update_char( context[19], '}' );
    refalrts::reinit_char( context[8], 'w' );
    refalrts::reinit_char( context[11], 'h' );
    refalrts::reinit_char( context[13], 'i' );
    refalrts::reinit_char( context[12], 'l' );
    refalrts::reinit_char( context[1], 'e' );
    refalrts::link_brackets( context[31], context[32] );
    refalrts::link_brackets( context[25], context[30] );
    refalrts::link_brackets( context[7], context[24] );
    refalrts::link_brackets( context[0], context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[22], context[32] );
    res = refalrts::splice_evar( res, context[4], context[1] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInitB0 )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdInitB0/13 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdInitB0, context[13] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    // closed e.Indent#1 as range 14
    //DEBUG: e.Indent#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/18 e.Indent#1/14/19 )/21 (/22 e.Indent#1/14/23 </25 & ContextRange-B/26 0/27 >/28" = arg_begin"/29 Tile{ HalfReuse: ';'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/14 HalfReuse: </8 HalfReuse: & ContextRange-E/11 HalfReuse: 0/13 HalfReuse: >/12 HalfReuse: ' '/1 }"= arg_end;"/31 )/33 (/34 e.Indent#1/14/35"refalrts::move_left( "/37 </39 & ContextRange/40 0/41 >/42" );"/43 )/45 (/46 e.Indent#1/14/47"refalrts::move_left( "/49 </51 & ContextRange/52 0/53 >/54" );"/55 )/57 (/58 e.Indent#1/14/59"refalrts::move_right( "/61 </63 & ContextRange/64 0/65 >/66" );"/67 )/69 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[19], context[20], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[22] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[23], context[24], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], ref_ContextRangem_B.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[27], 0UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[29], context[30], " = arg_begin", 12 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[31], context[32], "= arg_end;", 10 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[33] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[34] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[35], context[36], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[37], context[38], "refalrts::move_left( ", 21 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[39] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[40], ref_ContextRange.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[41], 0UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[42] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[43], context[44], " );", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[45] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[46] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[47], context[48], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[49], context[50], "refalrts::move_left( ", 21 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[51] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[52], ref_ContextRange.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[53], 0UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[54] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[55], context[56], " );", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[57] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[58] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[59], context[60], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[61], context[62], "refalrts::move_right( ", 22 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[63] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[64], ref_ContextRange.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[65], 0UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[66] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[67], context[68], " );", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[69] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ';' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_open_call( context[8] );
    refalrts::reinit_name( context[11], ref_ContextRangem_E.ref.function );
    refalrts::reinit_number( context[13], 0UL );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[58], context[69] );
    refalrts::push_stack( context[66] );
    refalrts::push_stack( context[63] );
    refalrts::link_brackets( context[46], context[57] );
    refalrts::push_stack( context[54] );
    refalrts::push_stack( context[51] );
    refalrts::link_brackets( context[34], context[45] );
    refalrts::push_stack( context[42] );
    refalrts::push_stack( context[39] );
    refalrts::link_brackets( context[7], context[33] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[8] );
    refalrts::link_brackets( context[22], context[4] );
    refalrts::push_stack( context[28] );
    refalrts::push_stack( context[25] );
    refalrts::link_brackets( context[18], context[21] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[31], context[69] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[18], context[30] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInitB0-Lite )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdInitB0-Lite/13 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdInitB0m_Lite, context[13] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    // closed e.Indent#1 as range 14
    //DEBUG: e.Indent#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/18 e.Indent#1/14/19 )/21 (/22 e.Indent#1/14/23 </25 & ContextRange-B/26 0/27 >/28" = arg_begin"/29 Tile{ HalfReuse: ';'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/14 HalfReuse: </8 HalfReuse: & ContextRange-E/11 HalfReuse: 0/13 HalfReuse: >/12 HalfReuse: ' '/1 }"= arg_end;"/31 )/33 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[19], context[20], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[22] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[23], context[24], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], ref_ContextRangem_B.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[27], 0UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[29], context[30], " = arg_begin", 12 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[31], context[32], "= arg_end;", 10 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[33] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ';' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_open_call( context[8] );
    refalrts::reinit_name( context[11], ref_ContextRangem_E.ref.function );
    refalrts::reinit_number( context[13], 0UL );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[7], context[33] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[8] );
    refalrts::link_brackets( context[22], context[4] );
    refalrts::push_stack( context[28] );
    refalrts::push_stack( context[25] );
    refalrts::link_brackets( context[18], context[21] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[31], context[33] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[18], context[30] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdChar s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdChar/13 s.Direction#1/18 s.BracketNumber#1/19 s.Char#1/20 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdChar, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.Char#1: 20

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 s.BracketNumber#1/19 s.Char#1/20 {REMOVED TILE}
    //RESULT: Tile{ [[ } (/21 e.Indent#1/14/22 )/24 Tile{ AsIs: </0 Reuse: & PrintMatchChar/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.Direction1 #18/11 HalfReuse: s.BracketNumber1 #19/13 } Tile{ HalfReuse: s.Char1 #20/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[24] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatchChar.ref.function );
    refalrts::reinit_svar( context[11], context[18] );
    refalrts::reinit_svar( context[13], context[19] );
    refalrts::reinit_svar( context[12], context[20] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[21], context[24] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[21], context[24] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCharSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdCharSave/13 s.Direction#1/18 s.BracketNumber#1/19 s.Offset#1/20 s.Char#1/21 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdCharSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.Offset#1: 20
    //DEBUG: s.Char#1: 21

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 {REMOVED TILE} s.Offset#1/20 s.Char#1/21 {REMOVED TILE}
    //RESULT: Tile{ [[ } (/22 e.Indent#1/14/23 )/25 Tile{ AsIs: </0 Reuse: & PrintMatchCharSave/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.Offset1 #20/11 HalfReuse: s.Direction1 #18/13 } Tile{ AsIs: s.BracketNumber#1/19 } Tile{ HalfReuse: s.Char1 #21/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[22] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[23], context[24], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[25] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatchCharSave.ref.function );
    refalrts::reinit_svar( context[11], context[20] );
    refalrts::reinit_svar( context[13], context[18] );
    refalrts::reinit_svar( context[12], context[21] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[22], context[25] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[19], context[19] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[22], context[25] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNumber s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdNumber/13 s.Direction#1/18 s.BracketNumber#1/19 s.Number#1/20 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdNumber, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.Number#1: 20

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 s.BracketNumber#1/19 s.Number#1/20 {REMOVED TILE}
    //RESULT: Tile{ [[ } (/21 e.Indent#1/14/22 )/24 Tile{ AsIs: </0 Reuse: & PrintMatchNumber/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.Direction1 #18/11 HalfReuse: s.BracketNumber1 #19/13 } Tile{ HalfReuse: s.Number1 #20/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[24] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatchNumber.ref.function );
    refalrts::reinit_svar( context[11], context[18] );
    refalrts::reinit_svar( context[13], context[19] );
    refalrts::reinit_svar( context[12], context[20] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[21], context[24] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[21], context[24] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNumberSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdNumberSave/13 s.Direction#1/18 s.BracketNumber#1/19 s.Offset#1/20 s.Number#1/21 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdNumberSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.Offset#1: 20
    //DEBUG: s.Number#1: 21

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 {REMOVED TILE} s.Offset#1/20 s.Number#1/21 {REMOVED TILE}
    //RESULT: Tile{ [[ } (/22 e.Indent#1/14/23 )/25 Tile{ AsIs: </0 Reuse: & PrintMatchNumberSave/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.Offset1 #20/11 HalfReuse: s.Direction1 #18/13 } Tile{ AsIs: s.BracketNumber#1/19 } Tile{ HalfReuse: s.Number1 #21/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[22] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[23], context[24], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[25] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatchNumberSave.ref.function );
    refalrts::reinit_svar( context[11], context[20] );
    refalrts::reinit_svar( context[13], context[18] );
    refalrts::reinit_svar( context[12], context[21] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[22], context[25] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[19], context[19] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[22], context[25] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdName s.idx s.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdName/13 s.Direction#1/18 s.BracketNumber#1/19 e.Name#1/16 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdName, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    // closed e.Name#1 as range 16
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: e.Name#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 s.BracketNumber#1/19 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/20 e.Indent#1/14/21 Tile{ AsIs: )/12 } Tile{ AsIs: </0 Reuse: & PrintMatchName/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.Direction1 #18/11 HalfReuse: s.BracketNumber1 #19/13 } Tile{ AsIs: e.Name#1/16 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[21], context[22], context[14], context[15]))
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatchName.ref.function );
    refalrts::reinit_svar( context[11], context[18] );
    refalrts::reinit_svar( context[13], context[19] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[20], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[20], context[20] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNameSave s.idx s.idx s.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdNameSave/13 s.Direction#1/18 s.BracketNumber#1/19 s.Offset#1/20 e.Name#1/16 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdNameSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    // closed e.Name#1 as range 16
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.Offset#1: 20
    //DEBUG: e.Name#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 {REMOVED TILE} s.Offset#1/20 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/21 e.Indent#1/14/22 Tile{ AsIs: )/12 } Tile{ AsIs: </0 Reuse: & PrintMatchNameSave/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.Offset1 #20/11 HalfReuse: s.Direction1 #18/13 } Tile{ AsIs: s.BracketNumber#1/19 } Tile{ AsIs: e.Name#1/16 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[14], context[15]))
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatchNameSave.ref.function );
    refalrts::reinit_svar( context[11], context[20] );
    refalrts::reinit_svar( context[13], context[18] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[21], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[19], context[19] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[21], context[21] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdIdent s.idx s.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdIdent/13 s.Direction#1/18 s.BracketNumber#1/19 e.Name#1/16 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdIdent, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    // closed e.Name#1 as range 16
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: e.Name#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 s.BracketNumber#1/19 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/20 e.Indent#1/14/21 Tile{ AsIs: )/12 } Tile{ AsIs: </0 Reuse: & PrintMatchIdent/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.Direction1 #18/11 HalfReuse: s.BracketNumber1 #19/13 } Tile{ AsIs: e.Name#1/16 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[21], context[22], context[14], context[15]))
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatchIdent.ref.function );
    refalrts::reinit_svar( context[11], context[18] );
    refalrts::reinit_svar( context[13], context[19] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[20], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[20], context[20] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdIdentSave s.idx s.idx s.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdIdentSave/13 s.Direction#1/18 s.BracketNumber#1/19 s.Offset#1/20 e.Name#1/16 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdIdentSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    // closed e.Name#1 as range 16
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.Offset#1: 20
    //DEBUG: e.Name#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 {REMOVED TILE} s.Offset#1/20 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/21 e.Indent#1/14/22 Tile{ AsIs: )/12 } Tile{ AsIs: </0 Reuse: & PrintMatchIdentSave/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.Offset1 #20/11 HalfReuse: s.Direction1 #18/13 } Tile{ AsIs: s.BracketNumber#1/19 } Tile{ AsIs: e.Name#1/16 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[14], context[15]))
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatchIdentSave.ref.function );
    refalrts::reinit_svar( context[11], context[20] );
    refalrts::reinit_svar( context[13], context[18] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[21], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[19], context[19] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[21], context[21] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdBrackets s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdBrackets/13 s.Direction#1/18 s.BracketNumber#1/19 s.InnerBrackets#1/20 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdBrackets, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.InnerBrackets#1: 20

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 s.BracketNumber#1/19 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/21 e.Indent#1/14/22 )/24 </25 & PrintBracketsVarInit/26 e.Indent#1/14/27 Tile{ AsIs: s.InnerBrackets#1/20 } >/29 Tile{ AsIs: </0 Reuse: & PrintMatchBrackets/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.Direction1 #18/11 HalfReuse: s.BracketNumber1 #19/13 } Tile{ HalfReuse: s.InnerBrackets1 #20/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], ref_PrintBracketsVarInit.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[27], context[28], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[29] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatchBrackets.ref.function );
    refalrts::reinit_svar( context[11], context[18] );
    refalrts::reinit_svar( context[13], context[19] );
    refalrts::reinit_svar( context[12], context[20] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[25] );
    refalrts::link_brackets( context[21], context[24] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[29], context[29] );
    res = refalrts::splice_evar( res, context[20], context[20] );
    res = refalrts::splice_evar( res, context[27], context[28] );
    res = refalrts::splice_evar( res, context[21], context[26] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdBracketsSave s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdBracketsSave/13 s.Direction#1/18 s.BracketNumber#1/19 s.InnerBrackets#1/20 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdBracketsSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.InnerBrackets#1: 20

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 s.BracketNumber#1/19 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/21 e.Indent#1/14/22 )/24 </25 & PrintBracketsVarInit/26 e.Indent#1/14/27 Tile{ AsIs: s.InnerBrackets#1/20 } >/29 Tile{ AsIs: </0 Reuse: & PrintMatchBracketsSave/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.Direction1 #18/11 HalfReuse: s.BracketNumber1 #19/13 } Tile{ HalfReuse: s.InnerBrackets1 #20/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], ref_PrintBracketsVarInit.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[27], context[28], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[29] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatchBracketsSave.ref.function );
    refalrts::reinit_svar( context[11], context[18] );
    refalrts::reinit_svar( context[13], context[19] );
    refalrts::reinit_svar( context[12], context[20] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[25] );
    refalrts::link_brackets( context[21], context[24] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[29], context[29] );
    res = refalrts::splice_evar( res, context[20], context[20] );
    res = refalrts::splice_evar( res, context[27], context[28] );
    res = refalrts::splice_evar( res, context[21], context[26] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdADT s.idx s.idx s.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdADT/13 s.Direction#1/18 s.BracketNumber#1/19 s.InnerBrackets#1/20 e.Name#1/16 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdADT, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    // closed e.Name#1 as range 16
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.InnerBrackets#1: 20
    //DEBUG: e.Name#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 s.BracketNumber#1/19 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/21 e.Indent#1/14/22 )/24 </25 & PrintBracketsVarInit/26 e.Indent#1/14/27 s.InnerBrackets#1/20/29 Tile{ AsIs: >/1 } Tile{ AsIs: </0 Reuse: & PrintMatchADT/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.Direction1 #18/11 HalfReuse: s.BracketNumber1 #19/13 } Tile{ AsIs: s.InnerBrackets#1/20 AsIs: e.Name#1/16 HalfReuse: >/12 } Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], ref_PrintBracketsVarInit.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[27], context[28], context[14], context[15]))
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[29], context[20]))
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatchADT.ref.function );
    refalrts::reinit_svar( context[11], context[18] );
    refalrts::reinit_svar( context[13], context[19] );
    refalrts::reinit_close_call( context[12] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[25] );
    refalrts::link_brackets( context[21], context[24] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[20], context[12] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    res = refalrts::splice_evar( res, context[21], context[29] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdADTSave s.idx s.idx s.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdADTSave/13 s.Direction#1/18 s.BracketNumber#1/19 s.InnerBrackets#1/20 e.Name#1/16 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdADTSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    // closed e.Name#1 as range 16
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.InnerBrackets#1: 20
    //DEBUG: e.Name#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 s.BracketNumber#1/19 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/21 e.Indent#1/14/22 )/24 </25 & PrintBracketsVarInit/26 e.Indent#1/14/27 s.InnerBrackets#1/20/29 Tile{ AsIs: >/1 } Tile{ AsIs: </0 Reuse: & PrintMatchADTSave/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.Direction1 #18/11 HalfReuse: s.BracketNumber1 #19/13 } Tile{ AsIs: s.InnerBrackets#1/20 AsIs: e.Name#1/16 HalfReuse: >/12 } Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], ref_PrintBracketsVarInit.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[27], context[28], context[14], context[15]))
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[29], context[20]))
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatchADTSave.ref.function );
    refalrts::reinit_svar( context[11], context[18] );
    refalrts::reinit_svar( context[13], context[19] );
    refalrts::reinit_close_call( context[12] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[25] );
    refalrts::link_brackets( context[21], context[24] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[20], context[12] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    res = refalrts::splice_evar( res, context[21], context[29] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCallSave s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdCallSave/13 s.Direction#1/18 s.BracketNumber#1/19 s.InnerBrackets#1/20 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdCallSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.InnerBrackets#1: 20

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: </11 HalfReuse: & PrintBracketsVarInit/13 } e.Indent#1/14/21 s.InnerBrackets#1/20/23 >/24 (/25 e.Indent#1/14/26 Tile{ AsIs: </0 Reuse: & ContextItem/4 } </28 & Add/29 2/30 Tile{ AsIs: s.InnerBrackets#1/20 HalfReuse: >/12 AsIs: >/1 }" = refalrts::call_"/31 </33 & StrFromDirection/34 Tile{ AsIs: s.Direction#1/18 } >/35"( "/36 </38 & ContextRange/39 s.InnerBrackets#1/20/40 >/41", "/42 </44 & ContextRange/45 Tile{ AsIs: s.BracketNumber#1/19 } >/46" );"/47 )/49 Tile{ ]] }
    if (! refalrts::copy_evar(context[21], context[22], context[14], context[15]))
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[23], context[20]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[25] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[26], context[27], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[29], ref_Add.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[30], 2UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[31], context[32], " = refalrts::call_", 18 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[33] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[34], ref_StrFromDirection.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[36], context[37], "( ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[38] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[39], ref_ContextRange.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[40], context[20]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[41] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[42], context[43], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[44] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[45], ref_ContextRange.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[46] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[47], context[48], " );", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[49] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[11] );
    refalrts::reinit_name( context[13], ref_PrintBracketsVarInit.ref.function );
    refalrts::update_name( context[4], ref_ContextItem.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::link_brackets( context[25], context[49] );
    refalrts::push_stack( context[46] );
    refalrts::push_stack( context[44] );
    refalrts::push_stack( context[41] );
    refalrts::push_stack( context[38] );
    refalrts::push_stack( context[35] );
    refalrts::push_stack( context[33] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[28] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[11] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[46], context[49] );
    res = refalrts::splice_evar( res, context[19], context[19] );
    res = refalrts::splice_evar( res, context[35], context[45] );
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[31], context[34] );
    res = refalrts::splice_evar( res, context[20], context[1] );
    res = refalrts::splice_evar( res, context[28], context[30] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[26], context[27] );
    res = refalrts::splice_evar( res, context[23], context[25] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[7], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdEmpty s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdEmpty/13 s.Direction#1/18 s.BracketNumber#1/19 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdEmpty, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 s.BracketNumber#1/19 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: (/1 } e.Indent#1/14/20 Tile{ AsIs: )/12 } Tile{ AsIs: </0 Reuse: & PrintMatchEmpty/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.BracketNumber1 #19/11 HalfReuse: >/13 } Tile{ ]] }
    if (! refalrts::copy_evar(context[20], context[21], context[14], context[15]))
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[1] );
    refalrts::update_name( context[4], ref_PrintMatchEmpty.ref.function );
    refalrts::reinit_svar( context[11], context[19] );
    refalrts::reinit_close_call( context[13] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[1], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdVar s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdVar/13 s.Direction#1/18 s.BracketNumber#1/19 s.Mode#1/20 s.VarNumber#1/21 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdVar, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.Mode#1: 20
    //DEBUG: s.VarNumber#1: 21

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 s.BracketNumber#1/19 {REMOVED TILE} s.VarNumber#1/21 {REMOVED TILE}
    //RESULT: Tile{ [[ } (/22 e.Indent#1/14/23 )/25 Tile{ AsIs: </0 Reuse: & PrintMatchSTVar/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.Direction1 #18/11 HalfReuse: s.BracketNumber1 #19/13 } Tile{ AsIs: s.Mode#1/20 } Tile{ HalfReuse: s.VarNumber1 #21/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[22] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[23], context[24], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[25] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatchSTVar.ref.function );
    refalrts::reinit_svar( context[11], context[18] );
    refalrts::reinit_svar( context[13], context[19] );
    refalrts::reinit_svar( context[12], context[21] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[22], context[25] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[20], context[20] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[22], context[25] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdVarSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdVarSave/13 s.Direction#1/18 s.BracketNumber#1/19 s.Mode#1/20 s.VarNumber#1/21 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdVarSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.Mode#1: 20
    //DEBUG: s.VarNumber#1: 21

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 s.BracketNumber#1/19 {REMOVED TILE} s.VarNumber#1/21 {REMOVED TILE}
    //RESULT: Tile{ [[ } (/22 e.Indent#1/14/23 )/25 Tile{ AsIs: </0 Reuse: & PrintMatchSTVarSave/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.Direction1 #18/11 HalfReuse: s.BracketNumber1 #19/13 } Tile{ AsIs: s.Mode#1/20 } Tile{ HalfReuse: s.VarNumber1 #21/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[22] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[23], context[24], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[25] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatchSTVarSave.ref.function );
    refalrts::reinit_svar( context[11], context[18] );
    refalrts::reinit_svar( context[13], context[19] );
    refalrts::reinit_svar( context[12], context[21] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[22], context[25] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[20], context[20] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[22], context[25] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdRepeated s.idx s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdRepeated/13 s.Direction#1/18 s.BracketNumber#1/19 s.Mode#1/20 s.Var#1/21 s.Sample#1/22 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdRepeated, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[22], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.Mode#1: 20
    //DEBUG: s.Var#1: 21
    //DEBUG: s.Sample#1: 22

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: </11 } Tile{ Reuse: & PrintMatchRepeated/4 } Tile{ HalfReuse: (/1 } e.Indent#1/14/23 Tile{ HalfReuse: )/13 AsIs: s.Direction#1/18 AsIs: s.BracketNumber#1/19 AsIs: s.Mode#1/20 AsIs: s.Var#1/21 AsIs: s.Sample#1/22 HalfReuse: >/12 } Tile{ ]] }
    if (! refalrts::copy_evar(context[23], context[24], context[14], context[15]))
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[11] );
    refalrts::update_name( context[4], ref_PrintMatchRepeated.ref.function );
    refalrts::reinit_open_bracket( context[1] );
    refalrts::reinit_close_bracket( context[13] );
    refalrts::reinit_close_call( context[12] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[11] );
    refalrts::link_brackets( context[1], context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[13], context[12] );
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdRepeatedTVarSave s.idx s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdRepeatedTVarSave/13 s.Direction#1/18 s.BracketNumber#1/19 s.Var#1/20 s.Sample#1/21 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdRepeatedTVarSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[21], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Direction#1: 18
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.Var#1: 20
    //DEBUG: s.Sample#1: 21

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Direction#1/18 s.BracketNumber#1/19 {REMOVED TILE} s.Sample#1/21 {REMOVED TILE}
    //RESULT: Tile{ [[ } (/22 e.Indent#1/14/23 )/25 Tile{ AsIs: </0 Reuse: & PrintMatchRepeatedTVarSave/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.Direction1 #18/11 HalfReuse: s.BracketNumber1 #19/13 } Tile{ AsIs: s.Var#1/20 } Tile{ HalfReuse: s.Sample1 #21/12 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[22] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[23], context[24], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[25] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatchRepeatedTVarSave.ref.function );
    refalrts::reinit_svar( context[11], context[18] );
    refalrts::reinit_svar( context[13], context[19] );
    refalrts::reinit_svar( context[12], context[21] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[22], context[25] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[20], context[20] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[22], context[25] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdOpenedE-Start # AlgLeft s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdOpenedE-Start/13 # AlgLeft/18 s.BracketNumber#1/19 s.VarNumber#1/20 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdOpenedEm_Start, context[13] ) )
      continue;
    context[18] = refalrts::ident_left(  ident_AlgLeft, context[16], context[17] );
    if( ! context[18] )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.BracketNumber#1: 19
    //DEBUG: s.VarNumber#1: 20

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.BracketNumber#1/19 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/21 e.Indent#1/14/22 ' '/24 Tile{ HalfReuse: ' '/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/14 HalfReuse: </8 HalfReuse: & ContextRange-B/11 HalfReuse: s.VarNumber1 #20/13 HalfReuse: >/18 }" = 0;"/25 )/27 (/28 e.Indent#1/14/29 </31 & ContextRange-E/32 Tile{ AsIs: s.VarNumber#1/20 HalfReuse: >/12 HalfReuse: ' '/1 }"= 0;"/33 )/35 (/36 e.Indent#1/14/37"refalrts::start_e_loop();"/39 )/41 (/42 e.Indent#1/14/43"do {"/45 )/47 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[24], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], " = 0;", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[28] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[29], context[30], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[32], ref_ContextRangem_E.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[33], context[34], "= 0;", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[36] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[37], context[38], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[39], context[40], "refalrts::start_e_loop();", 25 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[41] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[42] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[43], context[44], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[45], context[46], "do {", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[47] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ' ' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_open_call( context[8] );
    refalrts::reinit_name( context[11], ref_ContextRangem_B.ref.function );
    refalrts::reinit_svar( context[13], context[20] );
    refalrts::reinit_close_call( context[18] );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[42], context[47] );
    refalrts::link_brackets( context[36], context[41] );
    refalrts::link_brackets( context[28], context[35] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[31] );
    refalrts::link_brackets( context[7], context[27] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[8] );
    refalrts::link_brackets( context[21], context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[33], context[47] );
    res = refalrts::splice_evar( res, context[20], context[1] );
    res = refalrts::splice_evar( res, context[25], context[32] );
    res = refalrts::splice_evar( res, context[0], context[18] );
    res = refalrts::splice_evar( res, context[21], context[24] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx '  ' ) ( # CmdOpenedE-End # AlgLeft s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 ' '/20 ' '/19 )/8 (/11 # CmdOpenedE-End/13 # AlgLeft/18 s.BracketNumber#1/21 s.VarNumber#1/22 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdOpenedEm_End, context[13] ) )
      continue;
    context[18] = refalrts::ident_left(  ident_AlgLeft, context[16], context[17] );
    if( ! context[18] )
      continue;
    context[19] = refalrts::char_right( ' ', context[14], context[15] );
    if( ! context[19] )
      continue;
    context[20] = refalrts::char_right( ' ', context[14], context[15] );
    if( ! context[20] )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[21], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[22], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.BracketNumber#1: 21
    //DEBUG: s.VarNumber#1: 22

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: (/0 } e.Indent#1/14/23 Tile{ HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/14 Reuse: '}'/20 AsIs: ' '/19 HalfReuse: 'w'/8 HalfReuse: 'h'/11 HalfReuse: 'i'/13 HalfReuse: 'l'/18 }"e ( refalrts::open_evar_advance( "/25 </27 & ContextRange/28 Tile{ AsIs: s.VarNumber#1/22 HalfReuse: >/12 HalfReuse: ','/1 } ' '/29 </30 & ContextRange/31 Tile{ AsIs: s.BracketNumber#1/21 } >/32" ) );"/33 )/35 Tile{ ]] }
    if (! refalrts::copy_evar(context[23], context[24], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "e ( refalrts::open_evar_advance( ", 33 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[28], ref_ContextRange.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[29], ' ' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[31], ref_ContextRange.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[33], context[34], " ) );", 5 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[35] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[0] );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::update_char( context[20], '}' );
    refalrts::reinit_char( context[8], 'w' );
    refalrts::reinit_char( context[11], 'h' );
    refalrts::reinit_char( context[13], 'i' );
    refalrts::reinit_char( context[18], 'l' );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ',' );
    refalrts::link_brackets( context[7], context[35] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[27] );
    refalrts::link_brackets( context[0], context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[32], context[35] );
    res = refalrts::splice_evar( res, context[21], context[21] );
    res = refalrts::splice_evar( res, context[29], context[31] );
    res = refalrts::splice_evar( res, context[22], context[1] );
    res = refalrts::splice_evar( res, context[25], context[28] );
    res = refalrts::splice_evar( res, context[4], context[18] );
    res = refalrts::splice_evar( res, context[23], context[24] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdSave s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdSave/13 s.OldBracketNumber#1/18 s.NewBracketNumber#1/19 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdSave, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.OldBracketNumber#1: 18
    //DEBUG: s.NewBracketNumber#1: 19

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/20 Tile{ AsIs: </0 Reuse: & ContextRange-B/4 } Tile{ AsIs: s.NewBracketNumber#1/19 HalfReuse: >/12 HalfReuse: ' '/1 }"= "/22 </24 Tile{ HalfReuse: & ContextRange-B/13 AsIs: s.OldBracketNumber#1/18 } >/25 ';'/26 )/27 (/28 e.Indent#1/14/29 </31 & ContextRange-E/32 s.NewBracketNumber#1/19/33 >/34" = "/35 </37 & ContextRange-E/38 s.OldBracketNumber#1/18/39 >/40 ';'/41 )/42 Tile{ ]] }
    if (! refalrts::copy_evar(context[20], context[21], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "= ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[26], ';' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[28] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[29], context[30], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[32], ref_ContextRangem_E.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[33], context[19]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[34] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[35], context[36], " = ", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[37] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[38], ref_ContextRangem_E.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[39], context[18]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[40] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[41], ';' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[42] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_ContextRangem_B.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::reinit_name( context[13], ref_ContextRangem_B.ref.function );
    refalrts::link_brackets( context[28], context[42] );
    refalrts::push_stack( context[40] );
    refalrts::push_stack( context[37] );
    refalrts::push_stack( context[34] );
    refalrts::push_stack( context[31] );
    refalrts::link_brackets( context[11], context[27] );
    refalrts::push_stack( context[25] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[25], context[42] );
    res = refalrts::splice_evar( res, context[13], context[18] );
    res = refalrts::splice_evar( res, context[22], context[24] );
    res = refalrts::splice_evar( res, context[19], context[1] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdResetAllocator )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdResetAllocator/13 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdResetAllocator, context[13] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    // closed e.Indent#1 as range 14
    //DEBUG: e.Indent#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 HalfReuse: )/13 HalfReuse: (/12 } e.Indent#1/14/18 'r'/20 Tile{ HalfReuse: 'e'/0 HalfReuse: 'f'/4 }"alrts::reset_allocator();"/21 Tile{ HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[20], 'r' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "alrts::reset_allocator();", 25 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_close_bracket( context[13] );
    refalrts::reinit_open_bracket( context[12] );
    refalrts::reinit_char( context[0], 'e' );
    refalrts::reinit_char( context[4], 'f' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[12], context[1] );
    refalrts::link_brackets( context[11], context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[20], context[20] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[12] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdSetRes # ARG-BEGIN )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdSetRes/13 # ARG-BEGIN/18 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdSetRes, context[13] ) )
      continue;
    context[18] = refalrts::ident_left(  ident_ARGm_BEGIN, context[16], context[17] );
    if( ! context[18] )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    // closed e.Indent#1 as range 14
    //DEBUG: e.Indent#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: (/0 } e.Indent#1/14/19 Tile{ HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/14 HalfReuse: 'r'/8 HalfReuse: 'e'/11 HalfReuse: 'f'/13 HalfReuse: 'a'/18 HalfReuse: 'l'/12 HalfReuse: 'r'/1 }"ts::Iter res = arg_begin;"/21 )/23 Tile{ ]] }
    if (! refalrts::copy_evar(context[19], context[20], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "ts::Iter res = arg_begin;", 25 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[23] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[0] );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], 'r' );
    refalrts::reinit_char( context[11], 'e' );
    refalrts::reinit_char( context[13], 'f' );
    refalrts::reinit_char( context[18], 'a' );
    refalrts::reinit_char( context[12], 'l' );
    refalrts::reinit_char( context[1], 'r' );
    refalrts::link_brackets( context[7], context[23] );
    refalrts::link_brackets( context[0], context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[21], context[23] );
    res = refalrts::splice_evar( res, context[4], context[1] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdSetRes s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdSetRes/13 s.Offset#1/18 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdSetRes, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Offset#1: 18

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/19 e.Indent#1/14/20 Tile{ AsIs: )/12 HalfReuse: (/1 } e.Indent#1/14/22"refalrts::Iter trash_prev = arg_begin->prev;"/24 )/26 (/27 e.Indent#1/14/28"refalrts::use(trash_prev);"/30 )/32 </33 & Fetch/34 Tile{ AsIs: s.Offset#1/18 } Tile{ HalfReuse: [*]/0 Reuse: & GenCommand-Native$39\1/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: {*}/11 HalfReuse: >/13 } Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[19] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[20], context[21], context[14], context[15]))
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "refalrts::Iter trash_prev = arg_begin->prev;", 44 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[27] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[28], context[29], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[30], context[31], "refalrts::use(trash_prev);", 26 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[33] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[34], ref_Fetch.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_bracket( context[1] );
    refalrts::reinit_closure_head( context[0] );
    refalrts::update_name( context[4], ref_gen_GenCommandm_Native_S39L1.ref.function );
    refalrts::reinit_unwrapped_closure( context[11], context[0] );
    refalrts::reinit_close_call( context[13] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[33] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[27], context[32] );
    refalrts::link_brackets( context[1], context[26] );
    refalrts::link_brackets( context[19], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[24], context[34] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[12], context[1] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[19], context[19] );
    refalrts::use( res );
    refalrts::wrap_closure( context[11] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCopyVar 'e' s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdCopyVar/13 'e'/18 s.Target#1/19 s.Sample#1/20 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdCopyVar, context[13] ) )
      continue;
    context[18] = refalrts::char_left( 'e', context[16], context[17] );
    if( ! context[18] )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Target#1: 19
    //DEBUG: s.Sample#1: 20

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/21 e.Indent#1/14/22 )/24 (/25 e.Indent#1/14/26"if (! refalrts::copy_evar("/28 </30 & ContextRange/31 Tile{ AsIs: s.Target#1/19 } >/32", "/33 </35 & ContextRange/36 Tile{ AsIs: s.Sample#1/20 HalfReuse: >/12 HalfReuse: ')'/1 } Tile{ HalfReuse: ')'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/14 HalfReuse: ' '/8 HalfReuse: ' '/11 HalfReuse: 'r'/13 AsIs: 'e'/18 }"turn refalrts::cNoMemory;"/37 )/39 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[25] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[26], context[27], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[28], context[29], "if (! refalrts::copy_evar(", 26 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[31], ref_ContextRange.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[33], context[34], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[36], ref_ContextRange.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[37], context[38], "turn refalrts::cNoMemory;", 25 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[39] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ')' );
    refalrts::reinit_char( context[0], ')' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], ' ' );
    refalrts::reinit_char( context[11], ' ' );
    refalrts::reinit_char( context[13], 'r' );
    refalrts::link_brackets( context[7], context[39] );
    refalrts::link_brackets( context[25], context[4] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[35] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[30] );
    refalrts::link_brackets( context[21], context[24] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[37], context[39] );
    res = refalrts::splice_evar( res, context[0], context[18] );
    res = refalrts::splice_evar( res, context[20], context[1] );
    res = refalrts::splice_evar( res, context[32], context[36] );
    res = refalrts::splice_evar( res, context[19], context[19] );
    res = refalrts::splice_evar( res, context[21], context[31] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCopyVar s.idx s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdCopyVar/13 s.Mode#1/18 s.Target#1/19 s.Sample#1/20 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdCopyVar, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[20], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Mode#1: 18
    //DEBUG: s.Target#1: 19
    //DEBUG: s.Sample#1: 20

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.Mode#1/18 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/21"if ("/23 Tile{ HalfReuse: '!'/13 }" refalrts::copy_stvar("/25 Tile{ AsIs: </0 Reuse: & ContextItem/4 } Tile{ AsIs: s.Target#1/19 } >/27", "/28 </30 & ContextItem/31 Tile{ AsIs: s.Sample#1/20 HalfReuse: >/12 HalfReuse: ')'/1 } ')'/32 )/33 (/34 e.Indent#1/14/35"  return refalrts::cNoMemory;"/37 )/39 Tile{ ]] }
    if (! refalrts::copy_evar(context[21], context[22], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], "if (", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], " refalrts::copy_stvar(", 22 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[28], context[29], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[31], ref_ContextItem.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[32], ')' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[33] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[34] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[35], context[36], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[37], context[38], "  return refalrts::cNoMemory;", 29 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[39] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], '!' );
    refalrts::update_name( context[4], ref_ContextItem.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ')' );
    refalrts::link_brackets( context[34], context[39] );
    refalrts::link_brackets( context[11], context[33] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[32], context[39] );
    res = refalrts::splice_evar( res, context[20], context[1] );
    res = refalrts::splice_evar( res, context[27], context[31] );
    res = refalrts::splice_evar( res, context[19], context[19] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[25], context[26] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdReinitSVar s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdReinitSVar/13 s.Offset#1/18 s.Sample#1/19 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdReinitSVar, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Offset#1: 18
    //DEBUG: s.Sample#1: 19

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/20"ref"/22 Tile{ HalfReuse: 'a'/13 }"lrts::reinit_svar( "/24 Tile{ AsIs: </0 Reuse: & ContextItem/4 } Tile{ AsIs: s.Offset#1/18 } >/26", "/27 </29 & ContextItem/30 Tile{ AsIs: s.Sample#1/19 HalfReuse: >/12 HalfReuse: ' '/1 }");"/31 )/33 Tile{ ]] }
    if (! refalrts::copy_evar(context[20], context[21], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "ref", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "lrts::reinit_svar( ", 19 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], ref_ContextItem.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[31], context[32], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[33] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'a' );
    refalrts::update_name( context[4], ref_ContextItem.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[11], context[33] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[31], context[33] );
    res = refalrts::splice_evar( res, context[19], context[1] );
    res = refalrts::splice_evar( res, context[26], context[30] );
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[24], context[25] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCreateElem # Allocate s.idx # ElString e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdCreateElem/13 # Allocate/18 s.ElemNumber#1/19 # ElString/20 e.String#1/16 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdCreateElem, context[13] ) )
      continue;
    context[18] = refalrts::ident_left(  ident_Allocate, context[16], context[17] );
    if( ! context[18] )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    context[20] = refalrts::ident_left(  ident_ElString, context[16], context[17] );
    if( ! context[20] )
      continue;
    // closed e.String#1 as range 16
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.ElemNumber#1: 19
    //DEBUG: e.String#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/21"if( ! refalrts::alloc_chars( "/23 Tile{ HalfReuse: </13 HalfReuse: & ContextItem/18 AsIs: s.ElemNumber#1/19 HalfReuse: >/20 }", "/25 Tile{ AsIs: </0 Reuse: & ContextItem/4 } </27 & Inc/28 s.ElemNumber#1/19/29 >/30 >/31", "/32 </34 & PrintString/35 Tile{ AsIs: e.String#1/16 } >/36" ) )"/37 )/39 (/40 e.Indent#1/14/41"  return refalrts::cNoMemory"/43 Tile{ HalfReuse: ';'/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[21], context[22], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], "if( ! refalrts::alloc_chars( ", 29 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[28], ref_Inc.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[29], context[19]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[32], context[33], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[34] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[35], ref_PrintString.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[36] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[37], context[38], " ) )", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[39] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[40] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[41], context[42], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[43], context[44], "  return refalrts::cNoMemory", 28 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[13] );
    refalrts::reinit_name( context[18], ref_ContextItem.ref.function );
    refalrts::reinit_close_call( context[20] );
    refalrts::update_name( context[4], ref_ContextItem.ref.function );
    refalrts::reinit_char( context[12], ';' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[40], context[1] );
    refalrts::link_brackets( context[11], context[39] );
    refalrts::push_stack( context[36] );
    refalrts::push_stack( context[34] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[12];
    res = refalrts::splice_evar( res, context[36], context[44] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[27], context[35] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[25], context[26] );
    res = refalrts::splice_evar( res, context[13], context[20] );
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdCreateElem s.idx s.idx e.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdCreateElem/13 s.CreateMode#1/18 s.ElemNumber#1/19 e.ElemInfo#1/16 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdCreateElem, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    // closed e.ElemInfo#1 as range 16
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.CreateMode#1: 18
    //DEBUG: s.ElemNumber#1: 19
    //DEBUG: e.ElemInfo#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.CreateMode#1/18 s.ElemNumber#1/19 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/20 e.Indent#1/14/21 Tile{ AsIs: )/12 } Tile{ AsIs: </0 Reuse: & PrintCreateElem/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: s.CreateMode1 #18/11 HalfReuse: s.ElemNumber1 #19/13 } Tile{ AsIs: e.ElemInfo#1/16 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[21], context[22], context[14], context[15]))
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintCreateElem.ref.function );
    refalrts::reinit_svar( context[11], context[18] );
    refalrts::reinit_svar( context[13], context[19] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[20], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[0], context[13] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[20], context[20] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdLinkBrackets s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdLinkBrackets/13 s.Left#1/18 s.Right#1/19 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdLinkBrackets, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Left#1: 18
    //DEBUG: s.Right#1: 19

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/20"ref"/22 Tile{ HalfReuse: 'a'/13 }"lrts::link_brackets( "/24 Tile{ AsIs: </0 Reuse: & ContextItem/4 } Tile{ AsIs: s.Left#1/18 } >/26", "/27 </29 & ContextItem/30 Tile{ AsIs: s.Right#1/19 HalfReuse: >/12 HalfReuse: ' '/1 }");"/31 )/33 Tile{ ]] }
    if (! refalrts::copy_evar(context[20], context[21], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "ref", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "lrts::link_brackets( ", 21 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], ref_ContextItem.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[31], context[32], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[33] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'a' );
    refalrts::update_name( context[4], ref_ContextItem.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[11], context[33] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[31], context[33] );
    res = refalrts::splice_evar( res, context[19], context[1] );
    res = refalrts::splice_evar( res, context[26], context[30] );
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[24], context[25] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdPushStack s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdPushStack/13 s.ElemNumber#1/18 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdPushStack, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.ElemNumber#1: 18

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/19 Tile{ HalfReuse: 'r'/4 }"efalrts::push_stack( "/21 Tile{ AsIs: </0 } Tile{ HalfReuse: & ContextItem/13 AsIs: s.ElemNumber#1/18 HalfReuse: >/12 HalfReuse: ' '/1 }");"/23 )/25 Tile{ ]] }
    if (! refalrts::copy_evar(context[19], context[20], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "efalrts::push_stack( ", 21 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[25] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_name( context[13], ref_ContextItem.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[11], context[25] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[23], context[25] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdWrapClosure s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdWrapClosure/13 s.Offset#1/18 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdWrapClosure, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Offset#1: 18

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/19 Tile{ HalfReuse: 'r'/4 }"efalrts::wrap_closure( "/21 Tile{ AsIs: </0 } Tile{ HalfReuse: & ContextItem/13 AsIs: s.Offset#1/18 HalfReuse: >/12 HalfReuse: ' '/1 }");"/23 )/25 Tile{ ]] }
    if (! refalrts::copy_evar(context[19], context[20], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "efalrts::wrap_closure( ", 23 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[25] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_name( context[13], ref_ContextItem.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[11], context[25] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[23], context[25] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInsertElem s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdInsertElem/13 s.ElemNumber#1/18 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdInsertElem, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.ElemNumber#1: 18

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/19 Tile{ HalfReuse: 'r'/4 }"es = refalrts::splice_elem( res, "/21 Tile{ AsIs: </0 } Tile{ HalfReuse: & ContextItem/13 AsIs: s.ElemNumber#1/18 HalfReuse: >/12 HalfReuse: ' '/1 }");"/23 )/25 Tile{ ]] }
    if (! refalrts::copy_evar(context[19], context[20], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "es = refalrts::splice_elem( res, ", 33 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[25] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[4], 'r' );
    refalrts::reinit_name( context[13], ref_ContextItem.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[11], context[25] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[23], context[25] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[0], context[0] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[4], context[4] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInsertVar 'e' s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdInsertVar/13 'e'/18 s.Number#1/19 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdInsertVar, context[13] ) )
      continue;
    context[18] = refalrts::char_left( 'e', context[16], context[17] );
    if( ! context[18] )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Number#1: 19

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/20 'r'/22 Tile{ HalfReuse: 'e'/0 HalfReuse: 's'/4 }" = refalrts::splice_evar( res, "/23 Tile{ HalfReuse: </13 HalfReuse: & ContextRange/18 AsIs: s.Number#1/19 HalfReuse: >/12 HalfReuse: ' '/1 }");"/25 )/27 Tile{ ]] }
    if (! refalrts::copy_evar(context[20], context[21], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[22], 'r' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[23], context[24], " = refalrts::splice_evar( res, ", 31 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[27] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'e' );
    refalrts::reinit_char( context[4], 's' );
    refalrts::reinit_open_call( context[13] );
    refalrts::reinit_name( context[18], ref_ContextRange.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[11], context[27] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[25], context[27] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[22], context[22] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInsertVar s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdInsertVar/13 s.Mode#1/18 s.Number#1/19 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdInsertVar, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Mode#1: 18
    //DEBUG: s.Number#1: 19

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.Mode#1/18 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/20"res"/22 Tile{ HalfReuse: ' '/13 }"= refalrts::splice_stvar( res, "/24 Tile{ AsIs: </0 Reuse: & ContextItem/4 } Tile{ AsIs: s.Number#1/19 HalfReuse: >/12 HalfReuse: ' '/1 }");"/26 )/28 Tile{ ]] }
    if (! refalrts::copy_evar(context[20], context[21], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "res", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "= refalrts::splice_stvar( res, ", 31 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[26], context[27], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[28] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], ' ' );
    refalrts::update_name( context[4], ref_ContextItem.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[11], context[28] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[26], context[28] );
    res = refalrts::splice_evar( res, context[19], context[1] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[24], context[25] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInsertRange s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdInsertRange/13 s.Number#1/18 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdInsertRange, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Number#1: 18

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/19"res = refalrts::splice_evar( res, "/21 Tile{ AsIs: </0 Reuse: & ContextItem/4 } s.Number#1/18/23 >/24", "/25 </27 & ContextItem/28 </29 Tile{ HalfReuse: & Inc/13 AsIs: s.Number#1/18 HalfReuse: >/12 AsIs: >/1 }" );"/30 )/32 Tile{ ]] }
    if (! refalrts::copy_evar(context[19], context[20], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[21], context[22], "res = refalrts::splice_evar( res, ", 34 ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[23], context[18]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[28], ref_ContextItem.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[30], context[31], " );", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[32] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_ContextItem.ref.function );
    refalrts::reinit_name( context[13], ref_Inc.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::link_brackets( context[11], context[32] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[30], context[32] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[23], context[29] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdInsertTile s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdInsertTile/13 s.BeginOffset#1/18 s.EndOffset#1/19 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdInsertTile, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.BeginOffset#1: 18
    //DEBUG: s.EndOffset#1: 19

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/20"res"/22 Tile{ HalfReuse: ' '/13 }"= refalrts::splice_evar( res, "/24 Tile{ AsIs: </0 Reuse: & ContextItem/4 } Tile{ AsIs: s.BeginOffset#1/18 } >/26", "/27 </29 & ContextItem/30 Tile{ AsIs: s.EndOffset#1/19 HalfReuse: >/12 HalfReuse: ' '/1 }");"/31 )/33 Tile{ ]] }
    if (! refalrts::copy_evar(context[20], context[21], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "res", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "= refalrts::splice_evar( res, ", 30 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], ref_ContextItem.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[31], context[32], ");", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[33] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], ' ' );
    refalrts::update_name( context[4], ref_ContextItem.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ' ' );
    refalrts::link_brackets( context[11], context[33] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[31], context[33] );
    res = refalrts::splice_evar( res, context[19], context[1] );
    res = refalrts::splice_evar( res, context[26], context[30] );
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[24], context[25] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdUseRes )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdUseRes/13 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdUseRes, context[13] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    // closed e.Indent#1 as range 14
    //DEBUG: e.Indent#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/18 Tile{ HalfReuse: 'r'/0 HalfReuse: 'e'/4 }"falrts::use( res "/20 Tile{ HalfReuse: ')'/13 HalfReuse: ';'/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "falrts::use( res ", 17 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[13], ')' );
    refalrts::reinit_char( context[12], ';' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdSpliceToFreeList )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdSpliceToFreeList/13 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdSpliceToFreeList, context[13] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    // closed e.Indent#1 as range 14
    //DEBUG: e.Indent#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/18 Tile{ HalfReuse: 'r'/0 HalfReuse: 'e'/4 }"falrts::splice_to_freelist( arg_begin, arg_end "/20 Tile{ HalfReuse: ')'/13 HalfReuse: ';'/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "falrts::splice_to_freelist( arg_begin, arg_end ", 47 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[13], ')' );
    refalrts::reinit_char( context[12], ';' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdSpliceToFreeList-Range s.idx s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdSpliceToFreeList-Range/13 s.Left#1/18 s.Right#1/19 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdSpliceToFreeListm_Range, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::svar_left( context[19], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Left#1: 18
    //DEBUG: s.Right#1: 19

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/20"ref"/22 Tile{ HalfReuse: 'a'/13 }"lrts::splice_to_freelist("/24 Tile{ AsIs: </0 Reuse: & ContextItem/4 } Tile{ AsIs: s.Left#1/18 } >/26", "/27 </29 & ContextItem/30 Tile{ AsIs: s.Right#1/19 HalfReuse: >/12 HalfReuse: ')'/1 } ';'/31 )/32 Tile{ ]] }
    if (! refalrts::copy_evar(context[20], context[21], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], "ref", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "lrts::splice_to_freelist(", 25 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], ref_ContextItem.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[31], ';' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[32] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], 'a' );
    refalrts::update_name( context[4], ref_ContextItem.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_char( context[1], ')' );
    refalrts::link_brackets( context[11], context[32] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[31], context[32] );
    res = refalrts::splice_evar( res, context[19], context[1] );
    res = refalrts::splice_evar( res, context[26], context[30] );
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[24], context[25] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[22], context[23] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdNextStep )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdNextStep/13 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdNextStep, context[13] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    // closed e.Indent#1 as range 14
    //DEBUG: e.Indent#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/18 Tile{ HalfReuse: 'r'/0 HalfReuse: 'e'/4 }"turn refalrts::cSucces"/20 Tile{ HalfReuse: 's'/13 HalfReuse: ';'/12 HalfReuse: )/1 ]] }
    if (! refalrts::copy_evar(context[18], context[19], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "turn refalrts::cSucces", 22 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[13], 's' );
    refalrts::reinit_char( context[12], ';' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[11], context[1] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[13];
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[7], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( # CmdTrash s.idx )
    // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdTrash/13 s.Offset#1/18 )/12 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::ident_term(  ident_CmdTrash, context[13] ) )
      continue;
    // closed e.Indent#1 as range 14
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: e.Indent#1: 14
    //DEBUG: s.Offset#1: 18

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 HalfReuse: </11 HalfReuse: & Fetch/13 AsIs: s.Offset#1/18 HalfReuse: [*]/12 HalfReuse: & GenCommand-Native$57\1/1 } (/19 e.Indent#1/14/20 Tile{ HalfReuse: )/0 HalfReuse: {*}/4 } >/22 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[19] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[20], context[21], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[11] );
    refalrts::reinit_name( context[13], ref_Fetch.ref.function );
    refalrts::reinit_closure_head( context[12] );
    refalrts::reinit_name( context[1], ref_gen_GenCommandm_Native_S57L1.ref.function );
    refalrts::reinit_close_bracket( context[0] );
    refalrts::reinit_unwrapped_closure( context[4], context[12] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[11] );
    refalrts::link_brackets( context[19], context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[22], context[22] );
    res = refalrts::splice_evar( res, context[0], context[4] );
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[19], context[19] );
    res = refalrts::splice_evar( res, context[7], context[1] );
    refalrts::use( res );
    refalrts::wrap_closure( context[4] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) ( # CmdFail )
  // </0 & GenCommand-Native/4 (/7 e.Indent#1/14 )/8 (/11 # CmdFail/13 )/12 >/1
  context[14] = context[5];
  context[15] = context[6];
  context[16] = context[9];
  context[17] = context[10];
  if( ! refalrts::ident_term(  ident_CmdFail, context[13] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[16], context[17] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Indent#1 as range 14
  //DEBUG: e.Indent#1: 14

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} # CmdFail/13 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: (/11 } e.Indent#1/14/18 Tile{ AsIs: </0 Reuse: & BreakerFromIndent/4 } e.Indent#1/14/20 Tile{ HalfReuse: >/12 HalfReuse: )/1 ]] }
  if (! refalrts::copy_evar(context[18], context[19], context[14], context[15]))
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[20], context[21], context[14], context[15]))
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_BreakerFromIndent.ref.function );
  refalrts::reinit_close_call( context[12] );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[11], context[1] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[12];
  res = refalrts::splice_evar( res, context[20], context[21] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[18], context[19] );
  res = refalrts::splice_evar( res, context[7], context[11] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_GenCommandm_Native("GenCommand-Native", 2638096229U, 2630503357U, func_GenCommandm_Native);


static refalrts::FnResult func_PrintString(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  // </0 & PrintString/4 e.String#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.String#1 as range 2
  //DEBUG: e.String#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } '\"'/5 </6 & EscapeString/7 e.String#1/2/8 >/10"\", "/11 Tile{ AsIs: </0 Reuse: & PrintLength/4 AsIs: e.String#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_char( context[5], '\"' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], ref_EscapeString.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[8], context[9], context[2], context[3]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[11], context[12], "\", ", 3 ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintLength.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[6] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[0];
  res = refalrts::splice_evar( res, context[5], context[12] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintString("PrintString", 2638096229U, 2630503357U, func_PrintString);


static refalrts::FnResult func_PrintLength(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  // </0 & PrintLength/4 e.String#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.String#1 as range 2
  //DEBUG: e.String#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 Tile{ HalfReuse: & DoPrintLength/0 HalfReuse: 0/4 AsIs: e.String#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[0], ref_DoPrintLength.ref.function );
  refalrts::reinit_number( context[4], 0UL );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[5] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[0];
  res = refalrts::splice_evar( res, context[5], context[5] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintLength("PrintLength", 2638096229U, 2630503357U, func_PrintLength);


static refalrts::FnResult func_DoPrintLength(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  //FAST GEN: e.$
  //GLOBAL GEN: s.$ e.$
  // </0 & DoPrintLength/4 s.idx#0/5 e.idxV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxV#0 as range 2
  do {
    // s.idx s.idx e.idx
    // </0 & DoPrintLength/4 s.Length#1/5 s.Char#1/8 e.Tail#1/6 >/1
    context[6] = context[2];
    context[7] = context[3];
    if( ! refalrts::svar_left( context[8], context[6], context[7] ) )
      continue;
    // closed e.Tail#1 as range 6
    //DEBUG: s.Length#1: 5
    //DEBUG: s.Char#1: 8
    //DEBUG: e.Tail#1: 6

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.Char#1/8 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoPrintLength/4 } </9 & Inc/10 Tile{ AsIs: s.Length#1/5 } >/11 Tile{ AsIs: e.Tail#1/6 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], ref_Inc.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[11] ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[6], context[7] );
    res = refalrts::splice_evar( res, context[11], context[11] );
    res = refalrts::splice_evar( res, context[5], context[5] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & DoPrintLength/4 s.Length#1/5 >/1
  context[6] = context[2];
  context[7] = context[3];
  if( ! refalrts::empty_seq( context[6], context[7] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.Length#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & StrFromInt/4 AsIs: s.Length#1/5 AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_StrFromInt.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DoPrintLength("DoPrintLength", 2638096229U, 2630503357U, func_DoPrintLength);


static refalrts::FnResult func_PrintMatchChar(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & PrintMatchChar/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.Char#1/11 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.Direction#1: 9
  //DEBUG: s.BracketNumber#1: 10
  //DEBUG: s.Char#1: 11

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/12"char"/13 )/15 '\''/16 </17 & EscapeChar/18 Tile{ AsIs: s.Char#1/11 AsIs: >/1 } '\''/19 >/20 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[13], context[14], "char", 4 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[16], '\'' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[18], ref_EscapeChar.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[19], '\'' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatch.ref.function );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[17] );
  refalrts::link_brackets( context[12], context[15] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[19], context[20] );
  res = refalrts::splice_evar( res, context[11], context[1] );
  res = refalrts::splice_evar( res, context[12], context[18] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchChar("PrintMatchChar", 2638096229U, 2630503357U, func_PrintMatchChar);


static refalrts::FnResult func_PrintMatchCharSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 22 elems
  refalrts::Iter context[22];
  refalrts::zeros( context, 22 );
  // </0 & PrintMatchCharSave/4 (/7 e.Indent#1/5 )/8 s.Offset#1/9 s.Direction#1/10 s.BracketNumber#1/11 s.Char#1/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.Offset#1: 9
  //DEBUG: s.Direction#1: 10
  //DEBUG: s.BracketNumber#1: 11
  //DEBUG: s.Char#1: 12

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Offset#1/9 AsIs: s.Direction#1/10 AsIs: s.BracketNumber#1/11 } (/13"char"/14 )/16 '\''/17 </18 & EscapeChar/19 Tile{ AsIs: s.Char#1/12 AsIs: >/1 } '\''/20 >/21 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[14], context[15], "char", 4 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[17], '\'' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], ref_EscapeChar.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[20], '\'' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[21] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatchSave.ref.function );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[18] );
  refalrts::link_brackets( context[13], context[16] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[20], context[21] );
  res = refalrts::splice_evar( res, context[12], context[1] );
  res = refalrts::splice_evar( res, context[13], context[19] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchCharSave("PrintMatchCharSave", 2638096229U, 2630503357U, func_PrintMatchCharSave);


static refalrts::FnResult func_PrintMatchNumber(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & PrintMatchNumber/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.Number#1/11 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.Direction#1: 9
  //DEBUG: s.BracketNumber#1: 10
  //DEBUG: s.Number#1: 11

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/12"number"/13 )/15 </16 & StrFromInt/17 Tile{ AsIs: s.Number#1/11 AsIs: >/1 }"UL"/18 >/20 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[13], context[14], "number", 6 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[17], ref_StrFromInt.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[18], context[19], "UL", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatch.ref.function );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[16] );
  refalrts::link_brackets( context[12], context[15] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[18], context[20] );
  res = refalrts::splice_evar( res, context[11], context[1] );
  res = refalrts::splice_evar( res, context[12], context[17] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchNumber("PrintMatchNumber", 2638096229U, 2630503357U, func_PrintMatchNumber);


static refalrts::FnResult func_PrintMatchNumberSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 22 elems
  refalrts::Iter context[22];
  refalrts::zeros( context, 22 );
  // </0 & PrintMatchNumberSave/4 (/7 e.Indent#1/5 )/8 s.Offset#1/9 s.Direction#1/10 s.BracketNumber#1/11 s.Number#1/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.Offset#1: 9
  //DEBUG: s.Direction#1: 10
  //DEBUG: s.BracketNumber#1: 11
  //DEBUG: s.Number#1: 12

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Offset#1/9 AsIs: s.Direction#1/10 AsIs: s.BracketNumber#1/11 } (/13"number"/14 )/16 </17 & StrFromInt/18 Tile{ AsIs: s.Number#1/12 AsIs: >/1 }"UL"/19 >/21 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[14], context[15], "number", 6 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[18], ref_StrFromInt.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[19], context[20], "UL", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[21] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatchSave.ref.function );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[17] );
  refalrts::link_brackets( context[13], context[16] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[19], context[21] );
  res = refalrts::splice_evar( res, context[12], context[1] );
  res = refalrts::splice_evar( res, context[13], context[18] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchNumberSave("PrintMatchNumberSave", 2638096229U, 2630503357U, func_PrintMatchNumberSave);


static refalrts::FnResult func_PrintMatchName(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 18 elems
  refalrts::Iter context[18];
  refalrts::zeros( context, 18 );
  // </0 & PrintMatchName/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 e.Name#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Name#1 as range 2
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.Direction#1: 9
  //DEBUG: s.BracketNumber#1: 10
  //DEBUG: e.Name#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/11"function"/12 )/14 </15 & CNameAlias/16 Tile{ AsIs: e.Name#1/2 } >/17 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[12], context[13], "function", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[16], ref_CNameAlias.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[17] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatch.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[15] );
  refalrts::link_brackets( context[11], context[14] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[17], context[17] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[11], context[16] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchName("PrintMatchName", 2638096229U, 2630503357U, func_PrintMatchName);


static refalrts::FnResult func_PrintMatchNameSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  // </0 & PrintMatchNameSave/4 (/7 e.Indent#1/5 )/8 s.Offset#1/9 s.Direction#1/10 s.BracketNumber#1/11 e.Name#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Name#1 as range 2
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.Offset#1: 9
  //DEBUG: s.Direction#1: 10
  //DEBUG: s.BracketNumber#1: 11
  //DEBUG: e.Name#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Offset#1/9 AsIs: s.Direction#1/10 AsIs: s.BracketNumber#1/11 } (/12"function"/13 )/15 </16 & CNameAlias/17 Tile{ AsIs: e.Name#1/2 } >/18 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[13], context[14], "function", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[17], ref_CNameAlias.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatchSave.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[16] );
  refalrts::link_brackets( context[12], context[15] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[18], context[18] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[12], context[17] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchNameSave("PrintMatchNameSave", 2638096229U, 2630503357U, func_PrintMatchNameSave);


static refalrts::FnResult func_PrintMatchIdent(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 20 elems
  refalrts::Iter context[20];
  refalrts::zeros( context, 20 );
  // </0 & PrintMatchIdent/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 e.Name#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Name#1 as range 2
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.Direction#1: 9
  //DEBUG: s.BracketNumber#1: 10
  //DEBUG: e.Name#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/11"ident"/12 )/14" ident_"/15 </17 & CName/18 Tile{ AsIs: e.Name#1/2 } >/19 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[12], context[13], "ident", 5 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[15], context[16], " ident_", 7 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[18], ref_CName.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[19] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatch.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[19] );
  refalrts::push_stack( context[17] );
  refalrts::link_brackets( context[11], context[14] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[19], context[19] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[11], context[18] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchIdent("PrintMatchIdent", 2638096229U, 2630503357U, func_PrintMatchIdent);


static refalrts::FnResult func_PrintMatchIdentSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & PrintMatchIdentSave/4 (/7 e.Indent#1/5 )/8 s.Offset#1/9 s.Direction#1/10 s.BracketNumber#1/11 e.Name#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Name#1 as range 2
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.Offset#1: 9
  //DEBUG: s.Direction#1: 10
  //DEBUG: s.BracketNumber#1: 11
  //DEBUG: e.Name#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Offset#1/9 AsIs: s.Direction#1/10 AsIs: s.BracketNumber#1/11 } (/12"ident"/13 )/15" ident_"/16 </18 & CName/19 Tile{ AsIs: e.Name#1/2 } >/20 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[13], context[14], "ident", 5 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[16], context[17], " ident_", 7 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], ref_CName.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatchSave.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[18] );
  refalrts::link_brackets( context[12], context[15] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[20], context[20] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[12], context[19] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchIdentSave("PrintMatchIdentSave", 2638096229U, 2630503357U, func_PrintMatchIdentSave);


static refalrts::FnResult func_PrintMatchBrackets(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  // </0 & PrintMatchBrackets/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.InnerNum#1/11 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.Direction#1: 9
  //DEBUG: s.BracketNumber#1: 10
  //DEBUG: s.InnerNum#1: 11

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/12"brackets"/13 )/15 </16 & ContextRange/17 Tile{ AsIs: s.InnerNum#1/11 AsIs: >/1 } >/18 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[13], context[14], "brackets", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[17], ref_ContextRange.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatch.ref.function );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[16] );
  refalrts::link_brackets( context[12], context[15] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[18], context[18] );
  res = refalrts::splice_evar( res, context[11], context[1] );
  res = refalrts::splice_evar( res, context[12], context[17] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchBrackets("PrintMatchBrackets", 2638096229U, 2630503357U, func_PrintMatchBrackets);


static refalrts::FnResult func_PrintMatchBracketsSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 50 elems
  refalrts::Iter context[50];
  refalrts::zeros( context, 50 );
  // </0 & PrintMatchBracketsSave/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.InnerNum#1/11 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.Direction#1: 9
  //DEBUG: s.BracketNumber#1: 10
  //DEBUG: s.InnerNum#1: 11

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 } </12 & Add/13 2/14 Tile{ AsIs: s.InnerNum#1/11 AsIs: >/1 } Tile{ AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/15"brackets"/16 )/18 </19 & ContextRange/20 s.InnerNum#1/11/21 >/22 >/23 (/24 e.Indent#1/5/25"refalrts::bracket_pointers("/27 </29 & ContextItem/30 </31 & Add/32 s.InnerNum#1/11/33 2/34 >/35 >/36", "/37 </39 & ContextItem/40 </41 & Add/42 s.InnerNum#1/11/43 3/44 >/45 >/46");"/47 )/49 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[13], ref_Add.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[14], 2UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[16], context[17], "brackets", 8 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[20], ref_ContextRange.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[21], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[23] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[24] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[25], context[26], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[27], context[28], "refalrts::bracket_pointers(", 27 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[29] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[30], ref_ContextItem.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[31] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[32], ref_Add.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[33], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[34], 2UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[35] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[36] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[37], context[38], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[39] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[40], ref_ContextItem.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[41] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[42], ref_Add.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[43], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[44], 3UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[45] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[46] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[47], context[48], ");", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[49] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatchSave.ref.function );
  refalrts::link_brackets( context[24], context[49] );
  refalrts::push_stack( context[46] );
  refalrts::push_stack( context[39] );
  refalrts::push_stack( context[45] );
  refalrts::push_stack( context[41] );
  refalrts::push_stack( context[36] );
  refalrts::push_stack( context[29] );
  refalrts::push_stack( context[35] );
  refalrts::push_stack( context[31] );
  refalrts::push_stack( context[23] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[22] );
  refalrts::push_stack( context[19] );
  refalrts::link_brackets( context[15], context[18] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[15], context[49] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[11], context[1] );
  res = refalrts::splice_evar( res, context[12], context[14] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchBracketsSave("PrintMatchBracketsSave", 2638096229U, 2630503357U, func_PrintMatchBracketsSave);


static refalrts::FnResult func_PrintMatchADT(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 24 elems
  refalrts::Iter context[24];
  refalrts::zeros( context, 24 );
  // </0 & PrintMatchADT/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.InnerNum#1/11 e.Name#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Name#1 as range 2
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.Direction#1: 9
  //DEBUG: s.BracketNumber#1: 10
  //DEBUG: s.InnerNum#1: 11
  //DEBUG: e.Name#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/12"adt"/13 )/15 </16 & ContextRange/17 Tile{ AsIs: s.InnerNum#1/11 } >/18", "/19 </21 & CNameAlias/22 Tile{ AsIs: e.Name#1/2 } >/23 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[13], context[14], "adt", 3 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[17], ref_ContextRange.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[19], context[20], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[22], ref_CNameAlias.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[23] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatch.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[23] );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[16] );
  refalrts::link_brackets( context[12], context[15] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[23], context[23] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[18], context[22] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[12], context[17] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchADT("PrintMatchADT", 2638096229U, 2630503357U, func_PrintMatchADT);


static refalrts::FnResult func_PrintMatchADTSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 69 elems
  refalrts::Iter context[69];
  refalrts::zeros( context, 69 );
  //FAST GEN: ( e.$ ) s.$ s.$ s.$ e.$
  //GLOBAL GEN: ( e.$ ) s.$ s.$ s.$ e.$
  // </0 & PrintMatchADTSave/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 s.idxTV#0/10 s.idxTVV#0/11 e.idxTVVV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTVVV#0 as range 2
  do {
    // ( e.idx ) # AlgTerm s.idx s.idx e.idx
    // </0 & PrintMatchADTSave/4 (/7 e.Indent#1/12 )/8 # AlgTerm/9 s.Offset#1/10 s.InnerNum#1/11 e.Name#1/14 >/1
    context[12] = context[5];
    context[13] = context[6];
    context[14] = context[2];
    context[15] = context[3];
    if( ! refalrts::ident_term(  ident_AlgTerm, context[9] ) )
      continue;
    // closed e.Indent#1 as range 12
    // closed e.Name#1 as range 14
    //DEBUG: s.Offset#1: 10
    //DEBUG: s.InnerNum#1: 11
    //DEBUG: e.Indent#1: 12
    //DEBUG: e.Name#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/16 e.Indent#1/12/17 </19 & ContextItem/20 </21 & Add/22 s.InnerNum#1/11/23 2/24 >/25 >/26" = refalrts::adt_term("/27 </29 & ContextRange/30 Tile{ AsIs: s.InnerNum#1/11 } >/31", "/32 </34 & CNameAlias/35 Tile{ AsIs: e.Name#1/14 } >/36", "/37 </39 & ContextItem/40 Tile{ AsIs: s.Offset#1/10 } >/41 ')'/42 Tile{ HalfReuse: ';'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/12 HalfReuse: 'i'/8 HalfReuse: 'f'/9 }"( ! "/43 </45 & ContextItem/46 </47 & Add/48 s.InnerNum#1/11/49 2/50 >/51 >/52" )"/53 )/55 (/56 e.Indent#1/12/57"  "/59 </61 & BreakerFromIndent/62 e.Indent#1/12/63 >/65 Tile{ HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[17], context[18], context[12], context[13]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[20], ref_ContextItem.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], ref_Add.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[23], context[11]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[24], 2UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[27], context[28], " = refalrts::adt_term(", 22 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[30], ref_ContextRange.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[32], context[33], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[34] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[35], ref_CNameAlias.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[36] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[37], context[38], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[39] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[40], ref_ContextItem.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[41] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[42], ')' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[43], context[44], "( ! ", 4 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[45] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[46], ref_ContextItem.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[47] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[48], ref_Add.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[49], context[11]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[50], 2UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[51] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[52] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[53], context[54], " )", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[55] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[56] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[57], context[58], context[12], context[13]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[59], context[60], "  ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[61] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[62], ref_BreakerFromIndent.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[63], context[64], context[12], context[13]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[65] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ';' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], 'i' );
    refalrts::reinit_char( context[9], 'f' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[56], context[1] );
    refalrts::push_stack( context[65] );
    refalrts::push_stack( context[61] );
    refalrts::link_brackets( context[7], context[55] );
    refalrts::push_stack( context[52] );
    refalrts::push_stack( context[45] );
    refalrts::push_stack( context[51] );
    refalrts::push_stack( context[47] );
    refalrts::link_brackets( context[16], context[4] );
    refalrts::push_stack( context[41] );
    refalrts::push_stack( context[39] );
    refalrts::push_stack( context[36] );
    refalrts::push_stack( context[34] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[25] );
    refalrts::push_stack( context[21] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[43], context[65] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[41], context[42] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[36], context[40] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[31], context[35] );
    res = refalrts::splice_evar( res, context[11], context[11] );
    res = refalrts::splice_evar( res, context[16], context[30] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx s.idx s.idx e.idx
  // </0 & PrintMatchADTSave/4 (/7 e.Indent#1/12 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.InnerNum#1/11 e.Name#1/14 >/1
  context[12] = context[5];
  context[13] = context[6];
  context[14] = context[2];
  context[15] = context[3];
  // closed e.Indent#1 as range 12
  // closed e.Name#1 as range 14
  //DEBUG: s.Direction#1: 9
  //DEBUG: s.BracketNumber#1: 10
  //DEBUG: s.InnerNum#1: 11
  //DEBUG: e.Indent#1: 12
  //DEBUG: e.Name#1: 14

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/12 AsIs: )/8 } </16 & Add/17 2/18 s.InnerNum#1/11/19 >/20 Tile{ AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/21"adt"/22 )/24 </25 & ContextRange/26 Tile{ AsIs: s.InnerNum#1/11 } >/27", "/28 </30 & CNameAlias/31 Tile{ AsIs: e.Name#1/14 } >/32 >/33 (/34 e.Indent#1/12/35"refalrts::adt_pointers("/37 </39 & ContextItem/40 </41 & Add/42 s.InnerNum#1/11/43 2/44 >/45 >/46", "/47 </49 & ContextItem/50 </51 & Add/52 s.InnerNum#1/11/53 3/54 >/55 >/56", "/57 </59 & ContextItem/60 </61 & Add/62 s.InnerNum#1/11/63 4/64 >/65 >/66");"/67 Tile{ HalfReuse: )/1 ]] }
  if( ! refalrts::alloc_open_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[17], ref_Add.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[18], 2UL ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[19], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[22], context[23], "adt", 3 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[24] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[25] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[26], ref_ContextRange.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[27] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[28], context[29], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[30] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[31], ref_CNameAlias.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[32] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[33] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[34] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[35], context[36], context[12], context[13]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[37], context[38], "refalrts::adt_pointers(", 23 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[39] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[40], ref_ContextItem.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[41] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[42], ref_Add.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[43], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[44], 2UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[45] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[46] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[47], context[48], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[49] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[50], ref_ContextItem.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[51] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[52], ref_Add.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[53], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[54], 3UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[55] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[56] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[57], context[58], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[59] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[60], ref_ContextItem.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[61] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[62], ref_Add.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[63], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[64], 4UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[65] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[66] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[67], context[68], ");", 2 ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatchSave.ref.function );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[34], context[1] );
  refalrts::push_stack( context[66] );
  refalrts::push_stack( context[59] );
  refalrts::push_stack( context[65] );
  refalrts::push_stack( context[61] );
  refalrts::push_stack( context[56] );
  refalrts::push_stack( context[49] );
  refalrts::push_stack( context[55] );
  refalrts::push_stack( context[51] );
  refalrts::push_stack( context[46] );
  refalrts::push_stack( context[39] );
  refalrts::push_stack( context[45] );
  refalrts::push_stack( context[41] );
  refalrts::push_stack( context[33] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[32] );
  refalrts::push_stack( context[30] );
  refalrts::push_stack( context[27] );
  refalrts::push_stack( context[25] );
  refalrts::link_brackets( context[21], context[24] );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[16] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[32], context[68] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[27], context[31] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[21], context[26] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[16], context[20] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchADTSave("PrintMatchADTSave", 2638096229U, 2630503357U, func_PrintMatchADTSave);


static refalrts::FnResult func_BreakerFromIndent(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & BreakerFromIndent/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // '  '
    // </0 & BreakerFromIndent/4 ' '/7 ' '/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::char_left( ' ', context[5], context[6] );
    if( ! context[7] )
      continue;
    context[8] = refalrts::char_left( ' ', context[5], context[6] );
    if( ! context[8] )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'r'/0 HalfReuse: 'e'/4 Reuse: 't'/7 Reuse: 'u'/8 HalfReuse: 'r'/1 }"n refalrts::cRecognitionImpossible;"/9 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[9], context[10], "n refalrts::cRecognitionImpossible;", 35 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::update_char( context[7], 't' );
    refalrts::update_char( context[8], 'u' );
    refalrts::reinit_char( context[1], 'r' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[9], context[10] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & BreakerFromIndent/4 e.OtherIndent#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.OtherIndent#1 as range 5
  //DEBUG: e.OtherIndent#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} e.OtherIndent#1/5 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 'c'/0 HalfReuse: 'o'/4 }"ntinue"/7 Tile{ HalfReuse: ';'/1 ]] }
  if( ! refalrts::alloc_chars( context[7], context[8], "ntinue", 6 ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[0], 'c' );
  refalrts::reinit_char( context[4], 'o' );
  refalrts::reinit_char( context[1], ';' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_BreakerFromIndent("BreakerFromIndent", 2638096229U, 2630503357U, func_BreakerFromIndent);


static refalrts::FnResult func_PrintMatchEmpty(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 26 elems
  refalrts::Iter context[26];
  refalrts::zeros( context, 26 );
  // </0 & PrintMatchEmpty/4 (/7 e.Indent#1/5 )/8 s.BracketNumber#1/9 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.BracketNumber#1: 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } (/10 e.Indent#1/5/11"if( ! refalrts::empty_seq( "/13 </15 & ContextRange/16 Tile{ AsIs: s.BracketNumber#1/9 AsIs: >/1 }" ) "/17 Tile{ HalfReuse: ')'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: ' '/8 } ' '/19 </20 & BreakerFromIndent/21 e.Indent#1/5/22 >/24 )/25 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[11], context[12], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[13], context[14], "if( ! refalrts::empty_seq( ", 27 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[16], ref_ContextRange.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[17], context[18], " ) ", 3 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[19], ' ' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[21], ref_BreakerFromIndent.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[22], context[23], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[24] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[25] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[0], ')' );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::reinit_char( context[8], ' ' );
  refalrts::link_brackets( context[7], context[25] );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[20] );
  refalrts::link_brackets( context[10], context[4] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[15] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[19], context[25] );
  res = refalrts::splice_evar( res, context[0], context[8] );
  res = refalrts::splice_evar( res, context[17], context[18] );
  res = refalrts::splice_evar( res, context[9], context[1] );
  res = refalrts::splice_evar( res, context[10], context[16] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchEmpty("PrintMatchEmpty", 2638096229U, 2630503357U, func_PrintMatchEmpty);


static refalrts::FnResult func_StrFromDirection(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 7 elems
  refalrts::Iter context[7];
  refalrts::zeros( context, 7 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & StrFromDirection/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # AlgLeft
    // </0 & StrFromDirection/4 # AlgLeft/5 >/1
    if( ! refalrts::ident_term(  ident_AlgLeft, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'l'/0 HalfReuse: 'e'/4 HalfReuse: 'f'/5 HalfReuse: 't'/1 ]] }
    refalrts::reinit_char( context[0], 'l' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[5], 'f' );
    refalrts::reinit_char( context[1], 't' );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // # AlgRight
  // </0 & StrFromDirection/4 # AlgRight/5 >/1
  if( ! refalrts::ident_term(  ident_AlgRight, context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 'r'/0 HalfReuse: 'i'/4 HalfReuse: 'g'/5 HalfReuse: 'h'/1 } 't'/6 Tile{ ]] }
  if( ! refalrts::alloc_char( context[6], 't' ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[0], 'r' );
  refalrts::reinit_char( context[4], 'i' );
  refalrts::reinit_char( context[5], 'g' );
  refalrts::reinit_char( context[1], 'h' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_StrFromDirection("StrFromDirection", 2638096229U, 2630503357U, func_StrFromDirection);


static refalrts::FnResult func_VarMatchFunction(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & VarMatchFunction/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // 's'
    // </0 & VarMatchFunction/4 's'/5 >/1
    if( ! refalrts::char_term( 's', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 's'/0 HalfReuse: 'v'/4 Reuse: 'a'/5 HalfReuse: 'r'/1 ]] }
    refalrts::reinit_char( context[0], 's' );
    refalrts::reinit_char( context[4], 'v' );
    refalrts::update_char( context[5], 'a' );
    refalrts::reinit_char( context[1], 'r' );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // 't'
  // </0 & VarMatchFunction/4 't'/5 >/1
  if( ! refalrts::char_term( 't', context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 't'/0 HalfReuse: 'v'/4 Reuse: 'a'/5 HalfReuse: 'r'/1 ]] }
  refalrts::reinit_char( context[0], 't' );
  refalrts::reinit_char( context[4], 'v' );
  refalrts::update_char( context[5], 'a' );
  refalrts::reinit_char( context[1], 'r' );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_VarMatchFunction("VarMatchFunction", 2638096229U, 2630503357U, func_VarMatchFunction);


static refalrts::FnResult func_PrintMatchSTVar(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & PrintMatchSTVar/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.Mode#1/11 s.VarNumber#1/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.Direction#1: 9
  //DEBUG: s.BracketNumber#1: 10
  //DEBUG: s.Mode#1: 11
  //DEBUG: s.VarNumber#1: 12

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/13 </14 & VarMatchFunction/15 Tile{ AsIs: s.Mode#1/11 } >/16 )/17 </18 & ContextItem/19 Tile{ AsIs: s.VarNumber#1/12 AsIs: >/1 } >/20 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[15], ref_VarMatchFunction.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], ref_ContextItem.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatch.ref.function );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[18] );
  refalrts::link_brackets( context[13], context[17] );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[14] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[20], context[20] );
  res = refalrts::splice_evar( res, context[12], context[1] );
  res = refalrts::splice_evar( res, context[16], context[19] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[13], context[15] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchSTVar("PrintMatchSTVar", 2638096229U, 2630503357U, func_PrintMatchSTVar);


static refalrts::FnResult func_PrintMatchSTVarSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 25 elems
  refalrts::Iter context[25];
  refalrts::zeros( context, 25 );
  // </0 & PrintMatchSTVarSave/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 't'/11 s.VarNumber#1/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[11] = refalrts::char_left( 't', context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.Direction#1: 9
  //DEBUG: s.BracketNumber#1: 10
  //DEBUG: s.VarNumber#1: 12

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 } </13 Tile{ HalfReuse: & Inc/11 AsIs: s.VarNumber#1/12 AsIs: >/1 } Tile{ AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/14 </15 & VarMatchFunction/16 't'/17 >/18 )/19 </20 & ContextItem/21 s.VarNumber#1/12/22 >/23 >/24 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[16], ref_VarMatchFunction.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[17], 't' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[21], ref_ContextItem.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[22], context[12]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[23] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[24] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatchSave.ref.function );
  refalrts::reinit_name( context[11], ref_Inc.ref.function );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[23] );
  refalrts::push_stack( context[20] );
  refalrts::link_brackets( context[14], context[19] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[13] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[14], context[24] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[11], context[1] );
  res = refalrts::splice_evar( res, context[13], context[13] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchSTVarSave("PrintMatchSTVarSave", 2638096229U, 2630503357U, func_PrintMatchSTVarSave);


static refalrts::FnResult func_PrintMatchRepeated(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 36 elems
  refalrts::Iter context[36];
  refalrts::zeros( context, 36 );
  //FAST GEN: ( e.$ ) s.$ s.$ s.$ s.$ s.$
  //GLOBAL GEN: ( e.$ ) s.$ s.$ s.$ s.$ s.$
  // </0 & PrintMatchRepeated/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 s.idxTV#0/10 s.idxTVV#0/11 s.idxTVVV#0/12 s.idxTVVVV#0/13 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // ( e.idx ) s.idx s.idx 'e' s.idx s.idx
    // </0 & PrintMatchRepeated/4 (/7 e.Indent#1/14 )/8 s.Direction#1/9 s.BracketNumber#1/10 'e'/11 s.VarNumber#1/12 s.SampleNumber#1/13 >/1
    context[14] = context[5];
    context[15] = context[6];
    if( ! refalrts::char_term( 'e', context[11] ) )
      continue;
    // closed e.Indent#1 as range 14
    //DEBUG: s.Direction#1: 9
    //DEBUG: s.BracketNumber#1: 10
    //DEBUG: s.VarNumber#1: 12
    //DEBUG: s.SampleNumber#1: 13
    //DEBUG: e.Indent#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 HalfReuse: (/11 }"repeated_evar"/16 )/18 </19 & ContextRange/20 Tile{ AsIs: s.VarNumber#1/12 } >/21", "/22 </24 & ContextRange/25 Tile{ AsIs: s.SampleNumber#1/13 AsIs: >/1 } >/26 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[16], context[17], "repeated_evar", 13 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[20], ref_ContextRange.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[22], context[23], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[25], ref_ContextRange.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[26] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_PrintMatch.ref.function );
    refalrts::reinit_open_bracket( context[11] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[19] );
    refalrts::link_brackets( context[11], context[18] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[26], context[26] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[21], context[25] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[16], context[20] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) # AlgTerm s.idx s.idx s.idx s.idx
    // </0 & PrintMatchRepeated/4 (/7 e.Indent#1/14 )/8 # AlgTerm/9 s.BracketNumber#1/10 s.Mode#1/11 s.VarNumber#1/12 s.SampleNumber#1/13 >/1
    context[14] = context[5];
    context[15] = context[6];
    if( ! refalrts::ident_term(  ident_AlgTerm, context[9] ) )
      continue;
    // closed e.Indent#1 as range 14
    //DEBUG: s.BracketNumber#1: 10
    //DEBUG: s.Mode#1: 11
    //DEBUG: s.VarNumber#1: 12
    //DEBUG: s.SampleNumber#1: 13
    //DEBUG: e.Indent#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.BracketNumber#1/10 s.Mode#1/11 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/16 e.Indent#1/14/17"if( ! refalrts::repeated_stvar_term( "/19 </21 & ContextItem/22 Tile{ AsIs: s.VarNumber#1/12 } >/23", "/24 </26 & ContextItem/27 Tile{ AsIs: s.SampleNumber#1/13 AsIs: >/1 }" ) "/28 Tile{ HalfReuse: ')'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/14 HalfReuse: ' '/8 HalfReuse: ' '/9 } </30 & BreakerFromIndent/31 e.Indent#1/14/32 >/34 )/35 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[17], context[18], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "if( ! refalrts::repeated_stvar_term( ", 37 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], ref_ContextItem.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[26] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[27], ref_ContextItem.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[28], context[29], " ) ", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[31], ref_BreakerFromIndent.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[32], context[33], context[14], context[15]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[34] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[35] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ')' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], ' ' );
    refalrts::reinit_char( context[9], ' ' );
    refalrts::link_brackets( context[7], context[35] );
    refalrts::push_stack( context[34] );
    refalrts::push_stack( context[30] );
    refalrts::link_brackets( context[16], context[4] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[26] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[21] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[30], context[35] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[28], context[29] );
    res = refalrts::splice_evar( res, context[13], context[1] );
    res = refalrts::splice_evar( res, context[23], context[27] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[16], context[22] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx s.idx s.idx s.idx s.idx
  // </0 & PrintMatchRepeated/4 (/7 e.Indent#1/14 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.Mode#1/11 s.VarNumber#1/12 s.SampleNumber#1/13 >/1
  context[14] = context[5];
  context[15] = context[6];
  // closed e.Indent#1 as range 14
  //DEBUG: s.Direction#1: 9
  //DEBUG: s.BracketNumber#1: 10
  //DEBUG: s.Mode#1: 11
  //DEBUG: s.VarNumber#1: 12
  //DEBUG: s.SampleNumber#1: 13
  //DEBUG: e.Indent#1: 14

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Mode#1/11 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatch/4 AsIs: (/7 AsIs: e.Indent#1/14 AsIs: )/8 AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/16"repeated_stvar"/17 )/19 </20 & ContextItem/21 Tile{ AsIs: s.VarNumber#1/12 } >/22", "/23 </25 & ContextItem/26 Tile{ AsIs: s.SampleNumber#1/13 AsIs: >/1 } >/27 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[17], context[18], "repeated_stvar", 14 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[21], ref_ContextItem.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[23], context[24], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[25] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[26], ref_ContextItem.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[27] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatch.ref.function );
  refalrts::push_stack( context[27] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[25] );
  refalrts::push_stack( context[22] );
  refalrts::push_stack( context[20] );
  refalrts::link_brackets( context[16], context[19] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[27], context[27] );
  res = refalrts::splice_evar( res, context[13], context[1] );
  res = refalrts::splice_evar( res, context[22], context[26] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[16], context[21] );
  refalrts::splice_to_freelist_open( context[10], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchRepeated("PrintMatchRepeated", 2638096229U, 2630503357U, func_PrintMatchRepeated);


static refalrts::FnResult func_PrintMatchRepeatedTVarSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 29 elems
  refalrts::Iter context[29];
  refalrts::zeros( context, 29 );
  // </0 & PrintMatchRepeatedTVarSave/4 (/7 e.Indent#1/5 )/8 s.Direction#1/9 s.BracketNumber#1/10 s.VarNumber#1/11 s.SampleNumber#1/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.Direction#1: 9
  //DEBUG: s.BracketNumber#1: 10
  //DEBUG: s.VarNumber#1: 11
  //DEBUG: s.SampleNumber#1: 12

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & PrintMatchSave/4 AsIs: (/7 AsIs: e.Indent#1/5 AsIs: )/8 } </13 & Inc/14 s.VarNumber#1/11/15 >/16 Tile{ AsIs: s.Direction#1/9 AsIs: s.BracketNumber#1/10 } (/17"repeated_stvar"/18 )/20 </21 & ContextItem/22 Tile{ AsIs: s.VarNumber#1/11 } >/23", "/24 </26 & ContextItem/27 Tile{ AsIs: s.SampleNumber#1/12 AsIs: >/1 } >/28 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], ref_Inc.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[15], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[18], context[19], "repeated_stvar", 14 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[22], ref_ContextItem.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[23] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[24], context[25], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[26] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[27], ref_ContextItem.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[28] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PrintMatchSave.ref.function );
  refalrts::push_stack( context[28] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[26] );
  refalrts::push_stack( context[23] );
  refalrts::push_stack( context[21] );
  refalrts::link_brackets( context[17], context[20] );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[13] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[28], context[28] );
  res = refalrts::splice_evar( res, context[12], context[1] );
  res = refalrts::splice_evar( res, context[23], context[27] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[17], context[22] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[13], context[16] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchRepeatedTVarSave("PrintMatchRepeatedTVarSave", 2638096229U, 2630503357U, func_PrintMatchRepeatedTVarSave);


static refalrts::FnResult func_PrintMatch(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 44 elems
  refalrts::Iter context[44];
  refalrts::zeros( context, 44 );
  //FAST GEN: ( e.$ ) s.$ s.$ ( e.$ ) e.$
  //GLOBAL GEN: ( e.$ ) s.$ s.$ ( e.$ ) e.$
  // </0 & PrintMatch/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 s.idxTV#0/10 (/13 e.idxTVVB#0/11 )/14 e.idxTVVT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[11] = 0;
  context[12] = 0;
  context[13] = refalrts::brackets_left( context[11], context[12], context[2], context[3] );
  if( ! context[13] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[13], context[14]);
  // closed e.idxTVVB#0 as range 11
  // closed e.idxTVVT#0 as range 2
  do {
    // ( e.idx ) # AlgTerm s.idx ( e.idx ) e.idx
    // </0 & PrintMatch/4 (/7 e.Indent#1/15 )/8 # AlgTerm/9 s.Offset#1/10 (/13 e.Function#1/17 )/14 e.TextRep#1/19 >/1
    context[15] = context[5];
    context[16] = context[6];
    context[17] = context[11];
    context[18] = context[12];
    context[19] = context[2];
    context[20] = context[3];
    if( ! refalrts::ident_term(  ident_AlgTerm, context[9] ) )
      continue;
    // closed e.Indent#1 as range 15
    // closed e.Function#1 as range 17
    // closed e.TextRep#1 as range 19
    //DEBUG: s.Offset#1: 10
    //DEBUG: e.Indent#1: 15
    //DEBUG: e.Function#1: 17
    //DEBUG: e.TextRep#1: 19

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/21 e.Indent#1/15/22"if( ! refalrts:"/24 Tile{ HalfReuse: ':'/13 AsIs: e.Function#1/17 HalfReuse: '_'/14 }"term( "/26 Tile{ AsIs: e.TextRep#1/19 }", "/28 </30 & ContextItem/31 Tile{ AsIs: s.Offset#1/10 } >/32" ) "/33 Tile{ HalfReuse: ')'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/15 HalfReuse: ' '/8 HalfReuse: ' '/9 } </35 & BreakerFromIndent/36 e.Indent#1/15/37 >/39 Tile{ HalfReuse: )/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[22], context[23], context[15], context[16]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[24], context[25], "if( ! refalrts:", 15 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[26], context[27], "term( ", 6 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[28], context[29], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[31], ref_ContextItem.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[32] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[33], context[34], " ) ", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[35] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[36], ref_BreakerFromIndent.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[37], context[38], context[15], context[16]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[39] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[13], ':' );
    refalrts::reinit_char( context[14], '_' );
    refalrts::reinit_char( context[0], ')' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], ' ' );
    refalrts::reinit_char( context[9], ' ' );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::link_brackets( context[7], context[1] );
    refalrts::push_stack( context[39] );
    refalrts::push_stack( context[35] );
    refalrts::link_brackets( context[21], context[4] );
    refalrts::push_stack( context[32] );
    refalrts::push_stack( context[30] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[35], context[39] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[32], context[34] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[28], context[31] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[26], context[27] );
    res = refalrts::splice_evar( res, context[13], context[14] );
    res = refalrts::splice_evar( res, context[21], context[25] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx s.idx ( e.idx ) e.idx
  // </0 & PrintMatch/4 (/7 e.Indent#1/15 )/8 s.Direction#1/9 s.BracketNumber#1/10 (/13 e.Function#1/17 )/14 e.TextRep#1/19 >/1
  context[15] = context[5];
  context[16] = context[6];
  context[17] = context[11];
  context[18] = context[12];
  context[19] = context[2];
  context[20] = context[3];
  // closed e.Indent#1 as range 15
  // closed e.Function#1 as range 17
  // closed e.TextRep#1 as range 19
  //DEBUG: s.Direction#1: 9
  //DEBUG: s.BracketNumber#1: 10
  //DEBUG: e.Indent#1: 15
  //DEBUG: e.Function#1: 17
  //DEBUG: e.TextRep#1: 19

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } (/21 e.Indent#1/15/22"if( ! refalrts:"/24 Tile{ HalfReuse: ':'/13 AsIs: e.Function#1/17 HalfReuse: '_'/14 } </26 & StrFromDirection/27 Tile{ AsIs: s.Direction#1/9 } >/28"( "/29 Tile{ AsIs: e.TextRep#1/19 }", "/31 </33 & ContextRange/34 Tile{ AsIs: s.BracketNumber#1/10 } >/35" ) "/36 Tile{ HalfReuse: ')'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/15 HalfReuse: ' '/8 } ' '/38 </39 & BreakerFromIndent/40 e.Indent#1/15/41 >/43 Tile{ HalfReuse: )/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[21] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[22], context[23], context[15], context[16]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[24], context[25], "if( ! refalrts:", 15 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[26] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[27], ref_StrFromDirection.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[28] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[29], context[30], "( ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[31], context[32], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[33] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[34], ref_ContextRange.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[35] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[36], context[37], " ) ", 3 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[38], ' ' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[39] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[40], ref_BreakerFromIndent.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[41], context[42], context[15], context[16]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[43] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[13], ':' );
  refalrts::reinit_char( context[14], '_' );
  refalrts::reinit_char( context[0], ')' );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::reinit_char( context[8], ' ' );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[7], context[1] );
  refalrts::push_stack( context[43] );
  refalrts::push_stack( context[39] );
  refalrts::link_brackets( context[21], context[4] );
  refalrts::push_stack( context[35] );
  refalrts::push_stack( context[33] );
  refalrts::push_stack( context[28] );
  refalrts::push_stack( context[26] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[38], context[43] );
  res = refalrts::splice_evar( res, context[0], context[8] );
  res = refalrts::splice_evar( res, context[35], context[37] );
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[31], context[34] );
  res = refalrts::splice_evar( res, context[19], context[20] );
  res = refalrts::splice_evar( res, context[28], context[30] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[26], context[27] );
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[21], context[25] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatch("PrintMatch", 2638096229U, 2630503357U, func_PrintMatch);


static refalrts::FnResult func_PrintMatchSave(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 55 elems
  refalrts::Iter context[55];
  refalrts::zeros( context, 55 );
  // </0 & PrintMatchSave/4 (/7 e.Indent#1/5 )/8 s.Offset#1/9 s.Direction#1/10 s.BracketNumber#1/11 (/14 e.Function#1/12 )/15 e.TextRep#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Indent#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[12] = 0;
  context[13] = 0;
  context[14] = refalrts::brackets_left( context[12], context[13], context[2], context[3] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[14], context[15]);
  // closed e.Function#1 as range 12
  // closed e.TextRep#1 as range 2
  //DEBUG: e.Indent#1: 5
  //DEBUG: s.Offset#1: 9
  //DEBUG: s.Direction#1: 10
  //DEBUG: s.BracketNumber#1: 11
  //DEBUG: e.Function#1: 12
  //DEBUG: e.TextRep#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } (/16 e.Indent#1/5/17 </19 & ContextItem/20 s.Offset#1/9/21 >/22" = refalrts:"/23 Tile{ HalfReuse: ':'/14 AsIs: e.Function#1/12 HalfReuse: '_'/15 } </25 & StrFromDirection/26 Tile{ AsIs: s.Direction#1/10 } >/27"( "/28 Tile{ AsIs: e.TextRep#1/2 }", "/30 </32 & ContextRange/33 Tile{ AsIs: s.BracketNumber#1/11 } >/34" )"/35 Tile{ HalfReuse: ';'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/5 HalfReuse: 'i'/8 }"f( ! "/37 </39 & ContextItem/40 Tile{ AsIs: s.Offset#1/9 } >/41" )"/42 )/44 (/45 e.Indent#1/5/46"  "/48 </50 & BreakerFromIndent/51 e.Indent#1/5/52 >/54 Tile{ HalfReuse: )/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[17], context[18], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[20], ref_ContextItem.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[21], context[9]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[23], context[24], " = refalrts:", 12 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[25] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[26], ref_StrFromDirection.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[27] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[28], context[29], "( ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[30], context[31], ", ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[32] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[33], ref_ContextRange.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[34] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[35], context[36], " )", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[37], context[38], "f( ! ", 5 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[39] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[40], ref_ContextItem.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[41] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[42], context[43], " )", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[44] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[45] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[46], context[47], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[48], context[49], "  ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[50] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[51], ref_BreakerFromIndent.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[52], context[53], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[54] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[14], ':' );
  refalrts::reinit_char( context[15], '_' );
  refalrts::reinit_char( context[0], ';' );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::reinit_char( context[8], 'i' );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[45], context[1] );
  refalrts::push_stack( context[54] );
  refalrts::push_stack( context[50] );
  refalrts::link_brackets( context[7], context[44] );
  refalrts::push_stack( context[41] );
  refalrts::push_stack( context[39] );
  refalrts::link_brackets( context[16], context[4] );
  refalrts::push_stack( context[34] );
  refalrts::push_stack( context[32] );
  refalrts::push_stack( context[27] );
  refalrts::push_stack( context[25] );
  refalrts::push_stack( context[22] );
  refalrts::push_stack( context[19] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[41], context[54] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[37], context[40] );
  res = refalrts::splice_evar( res, context[0], context[8] );
  res = refalrts::splice_evar( res, context[34], context[36] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[30], context[33] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[27], context[29] );
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[25], context[26] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[16], context[24] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintMatchSave("PrintMatchSave", 2638096229U, 2630503357U, func_PrintMatchSave);


static refalrts::FnResult func_PrintCreateElem(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 37 elems
  refalrts::Iter context[37];
  refalrts::zeros( context, 37 );
  //FAST GEN: ( e.$ ) s.$ s.$ s.$ e.$
  //GLOBAL GEN: ( e.$ ) s.$ s.$ s.$ e.$
  // </0 & PrintCreateElem/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 s.idxTV#0/10 s.idxTVV#0/11 e.idxTVVV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTVVV#0 as range 2
  do {
    // ( e.idx ) # Allocate s.idx s.idx e.idx
    // </0 & PrintCreateElem/4 (/7 e.Indent#1/12 )/8 # Allocate/9 s.ElemNumber#1/10 s.ElementType#1/11 e.Info#1/14 >/1
    context[12] = context[5];
    context[13] = context[6];
    context[14] = context[2];
    context[15] = context[3];
    if( ! refalrts::ident_term(  ident_Allocate, context[9] ) )
      continue;
    // closed e.Indent#1 as range 12
    // closed e.Info#1 as range 14
    //DEBUG: s.ElemNumber#1: 10
    //DEBUG: s.ElementType#1: 11
    //DEBUG: e.Indent#1: 12
    //DEBUG: e.Info#1: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } (/16 e.Indent#1/12/17"if( ! refalrts::alloc_"/19 </21 & AllocatorFuncName/22 s.ElementType#1/11/23 >/24"( "/25 </27 & ContextItem/28 Tile{ AsIs: s.ElemNumber#1/10 } >/29 </30 & AllocatorFuncArgument/31 Tile{ AsIs: s.ElementType#1/11 AsIs: e.Info#1/14 AsIs: >/1 }" ) "/32 Tile{ HalfReuse: ')'/0 HalfReuse: )/4 AsIs: (/7 AsIs: e.Indent#1/12 HalfReuse: ' '/8 HalfReuse: ' '/9 }"return refalrts::cNoMemory;"/34 )/36 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[17], context[18], context[12], context[13]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[19], context[20], "if( ! refalrts::alloc_", 22 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], ref_AllocatorFuncName.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[23], context[11]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[24] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "( ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[28], ref_ContextItem.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[29] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[31], ref_AllocatorFuncArgument.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[32], context[33], " ) ", 3 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[34], context[35], "return refalrts::cNoMemory;", 27 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[36] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ')' );
    refalrts::reinit_close_bracket( context[4] );
    refalrts::reinit_char( context[8], ' ' );
    refalrts::reinit_char( context[9], ' ' );
    refalrts::link_brackets( context[7], context[36] );
    refalrts::link_brackets( context[16], context[4] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[29] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[21] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[34], context[36] );
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[32], context[33] );
    res = refalrts::splice_evar( res, context[11], context[1] );
    res = refalrts::splice_evar( res, context[29], context[31] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[16], context[28] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx s.idx s.idx e.idx
  // </0 & PrintCreateElem/4 (/7 e.Indent#1/12 )/8 s.CreateMode#1/9 s.ElemNumber#1/10 s.ElementType#1/11 e.Info#1/14 >/1
  context[12] = context[5];
  context[13] = context[6];
  context[14] = context[2];
  context[15] = context[3];
  // closed e.Indent#1 as range 12
  // closed e.Info#1 as range 14
  //DEBUG: s.CreateMode#1: 9
  //DEBUG: s.ElemNumber#1: 10
  //DEBUG: s.ElementType#1: 11
  //DEBUG: e.Indent#1: 12
  //DEBUG: e.Info#1: 14

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Indent#1/12 HalfReuse: 'r'/8 }"efalrts::"/16 </18 & AllocatorMode/19 Tile{ AsIs: s.CreateMode#1/9 } >/20 '_'/21 Tile{ AsIs: </0 Reuse: & AllocatorFuncName/4 } s.ElementType#1/11/22 >/23"( "/24 </26 & ContextItem/27 Tile{ AsIs: s.ElemNumber#1/10 } >/28 </29 & AllocatorFuncArgument/30 Tile{ AsIs: s.ElementType#1/11 AsIs: e.Info#1/14 AsIs: >/1 }" );"/31 )/33 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[16], context[17], "efalrts::", 9 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], ref_AllocatorMode.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[21], '_' ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[22], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[23] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[24], context[25], "( ", 2 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[26] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[27], ref_ContextItem.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[28] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[29] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[30], ref_AllocatorFuncArgument.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[31], context[32], " );", 3 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[33] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[8], 'r' );
  refalrts::update_name( context[4], ref_AllocatorFuncName.ref.function );
  refalrts::link_brackets( context[7], context[33] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[29] );
  refalrts::push_stack( context[28] );
  refalrts::push_stack( context[26] );
  refalrts::push_stack( context[23] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[18] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[31], context[33] );
  res = refalrts::splice_evar( res, context[11], context[1] );
  res = refalrts::splice_evar( res, context[28], context[30] );
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[22], context[27] );
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[20], context[21] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[16], context[19] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_PrintCreateElem("PrintCreateElem", 2638096229U, 2630503357U, func_PrintCreateElem);


static refalrts::FnResult func_AllocatorMode(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & AllocatorMode/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # Reinit
    // </0 & AllocatorMode/4 # Reinit/5 >/1
    if( ! refalrts::ident_term(  ident_Reinit, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'r'/0 HalfReuse: 'e'/4 HalfReuse: 'i'/5 HalfReuse: 'n'/1 }"it"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "it", 2 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'r' );
    refalrts::reinit_char( context[4], 'e' );
    refalrts::reinit_char( context[5], 'i' );
    refalrts::reinit_char( context[1], 'n' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // # Update
  // </0 & AllocatorMode/4 # Update/5 >/1
  if( ! refalrts::ident_term(  ident_Update, context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 'u'/0 HalfReuse: 'p'/4 HalfReuse: 'd'/5 HalfReuse: 'a'/1 }"te"/6 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "te", 2 ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[0], 'u' );
  refalrts::reinit_char( context[4], 'p' );
  refalrts::reinit_char( context[5], 'd' );
  refalrts::reinit_char( context[1], 'a' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_AllocatorMode("AllocatorMode", 2638096229U, 2630503357U, func_AllocatorMode);


static refalrts::FnResult func_AllocatorFuncName(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  //FAST GEN: s.$
  //GLOBAL GEN: s.$
  // </0 & AllocatorFuncName/4 s.idx#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // # ElChar
    // </0 & AllocatorFuncName/4 # ElChar/5 >/1
    if( ! refalrts::ident_term(  ident_ElChar, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'c'/0 HalfReuse: 'h'/4 HalfReuse: 'a'/5 HalfReuse: 'r'/1 ]] }
    refalrts::reinit_char( context[0], 'c' );
    refalrts::reinit_char( context[4], 'h' );
    refalrts::reinit_char( context[5], 'a' );
    refalrts::reinit_char( context[1], 'r' );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElName
    // </0 & AllocatorFuncName/4 # ElName/5 >/1
    if( ! refalrts::ident_term(  ident_ElName, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'n'/0 HalfReuse: 'a'/4 HalfReuse: 'm'/5 HalfReuse: 'e'/1 ]] }
    refalrts::reinit_char( context[0], 'n' );
    refalrts::reinit_char( context[4], 'a' );
    refalrts::reinit_char( context[5], 'm' );
    refalrts::reinit_char( context[1], 'e' );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElNumber
    // </0 & AllocatorFuncName/4 # ElNumber/5 >/1
    if( ! refalrts::ident_term(  ident_ElNumber, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'n'/0 HalfReuse: 'u'/4 HalfReuse: 'm'/5 HalfReuse: 'b'/1 }"er"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "er", 2 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'n' );
    refalrts::reinit_char( context[4], 'u' );
    refalrts::reinit_char( context[5], 'm' );
    refalrts::reinit_char( context[1], 'b' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElIdent
    // </0 & AllocatorFuncName/4 # ElIdent/5 >/1
    if( ! refalrts::ident_term(  ident_ElIdent, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'i'/0 HalfReuse: 'd'/4 HalfReuse: 'e'/5 HalfReuse: 'n'/1 } 't'/6 Tile{ ]] }
    if( ! refalrts::alloc_char( context[6], 't' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'i' );
    refalrts::reinit_char( context[4], 'd' );
    refalrts::reinit_char( context[5], 'e' );
    refalrts::reinit_char( context[1], 'n' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[6] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElOpenADT
    // </0 & AllocatorFuncName/4 # ElOpenADT/5 >/1
    if( ! refalrts::ident_term(  ident_ElOpenADT, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'o'/0 HalfReuse: 'p'/4 HalfReuse: 'e'/5 HalfReuse: 'n'/1 }"_adt"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "_adt", 4 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'o' );
    refalrts::reinit_char( context[4], 'p' );
    refalrts::reinit_char( context[5], 'e' );
    refalrts::reinit_char( context[1], 'n' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElCloseADT
    // </0 & AllocatorFuncName/4 # ElCloseADT/5 >/1
    if( ! refalrts::ident_term(  ident_ElCloseADT, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'c'/0 HalfReuse: 'l'/4 HalfReuse: 'o'/5 HalfReuse: 's'/1 }"e_adt"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "e_adt", 5 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'c' );
    refalrts::reinit_char( context[4], 'l' );
    refalrts::reinit_char( context[5], 'o' );
    refalrts::reinit_char( context[1], 's' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElOpenBracket
    // </0 & AllocatorFuncName/4 # ElOpenBracket/5 >/1
    if( ! refalrts::ident_term(  ident_ElOpenBracket, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'o'/0 HalfReuse: 'p'/4 HalfReuse: 'e'/5 HalfReuse: 'n'/1 }"_bracket"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "_bracket", 8 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'o' );
    refalrts::reinit_char( context[4], 'p' );
    refalrts::reinit_char( context[5], 'e' );
    refalrts::reinit_char( context[1], 'n' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElCloseBracket
    // </0 & AllocatorFuncName/4 # ElCloseBracket/5 >/1
    if( ! refalrts::ident_term(  ident_ElCloseBracket, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'c'/0 HalfReuse: 'l'/4 HalfReuse: 'o'/5 HalfReuse: 's'/1 }"e_bracket"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "e_bracket", 9 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'c' );
    refalrts::reinit_char( context[4], 'l' );
    refalrts::reinit_char( context[5], 'o' );
    refalrts::reinit_char( context[1], 's' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElOpenCall
    // </0 & AllocatorFuncName/4 # ElOpenCall/5 >/1
    if( ! refalrts::ident_term(  ident_ElOpenCall, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'o'/0 HalfReuse: 'p'/4 HalfReuse: 'e'/5 HalfReuse: 'n'/1 }"_call"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "_call", 5 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'o' );
    refalrts::reinit_char( context[4], 'p' );
    refalrts::reinit_char( context[5], 'e' );
    refalrts::reinit_char( context[1], 'n' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElCloseCall
    // </0 & AllocatorFuncName/4 # ElCloseCall/5 >/1
    if( ! refalrts::ident_term(  ident_ElCloseCall, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'c'/0 HalfReuse: 'l'/4 HalfReuse: 'o'/5 HalfReuse: 's'/1 }"e_call"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "e_call", 6 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'c' );
    refalrts::reinit_char( context[4], 'l' );
    refalrts::reinit_char( context[5], 'o' );
    refalrts::reinit_char( context[1], 's' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElClosureHead
    // </0 & AllocatorFuncName/4 # ElClosureHead/5 >/1
    if( ! refalrts::ident_term(  ident_ElClosureHead, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: 'c'/0 HalfReuse: 'l'/4 HalfReuse: 'o'/5 HalfReuse: 's'/1 }"ure_head"/6 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[6], context[7], "ure_head", 8 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], 'c' );
    refalrts::reinit_char( context[4], 'l' );
    refalrts::reinit_char( context[5], 'o' );
    refalrts::reinit_char( context[1], 's' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // # ElUnwrappedClosure
  // </0 & AllocatorFuncName/4 # ElUnwrappedClosure/5 >/1
  if( ! refalrts::ident_term(  ident_ElUnwrappedClosure, context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 'u'/0 HalfReuse: 'n'/4 HalfReuse: 'w'/5 HalfReuse: 'r'/1 }"apped_closure"/6 Tile{ ]] }
  if( ! refalrts::alloc_chars( context[6], context[7], "apped_closure", 13 ) )
    return refalrts::cNoMemory;
  refalrts::reinit_char( context[0], 'u' );
  refalrts::reinit_char( context[4], 'n' );
  refalrts::reinit_char( context[5], 'w' );
  refalrts::reinit_char( context[1], 'r' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_AllocatorFuncName("AllocatorFuncName", 2638096229U, 2630503357U, func_AllocatorFuncName);


static refalrts::FnResult func_AllocatorFuncArgument(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  //FAST GEN: e.$
  //GLOBAL GEN: s.$ e.$
  // </0 & AllocatorFuncArgument/4 s.idx#0/5 e.idxV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxV#0 as range 2
  do {
    // # ElChar s.idx
    // </0 & AllocatorFuncArgument/4 # ElChar/5 s.Char#1/8 >/1
    context[6] = context[2];
    context[7] = context[3];
    if( ! refalrts::ident_term(  ident_ElChar, context[5] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[6], context[7] ) )
      continue;
    if( ! refalrts::empty_seq( context[6], context[7] ) )
      continue;
    //DEBUG: s.Char#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ }", "/9 Tile{ HalfReuse: '\''/0 HalfReuse: </4 HalfReuse: & EscapeChar/5 AsIs: s.Char#1/8 AsIs: >/1 } '\''/11 Tile{ ]] }
    if( ! refalrts::alloc_chars( context[9], context[10], ", ", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[11], '\'' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], '\'' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], ref_EscapeChar.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[11], context[11] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElName e.idx
    // </0 & AllocatorFuncArgument/4 # ElName/5 e.Name#1/6 >/1
    context[6] = context[2];
    context[7] = context[3];
    if( ! refalrts::ident_term(  ident_ElName, context[5] ) )
      continue;
    // closed e.Name#1 as range 6
    //DEBUG: e.Name#1: 6

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } ','/8 Tile{ HalfReuse: ' '/0 HalfReuse: </4 HalfReuse: & CNameAlias/5 AsIs: e.Name#1/6 AsIs: >/1 ]] }
    if( ! refalrts::alloc_char( context[8], ',' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ' ' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], ref_CNameAlias.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[8], context[8] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElNumber s.idx
    // </0 & AllocatorFuncArgument/4 # ElNumber/5 s.Number#1/8 >/1
    context[6] = context[2];
    context[7] = context[3];
    if( ! refalrts::ident_term(  ident_ElNumber, context[5] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[6], context[7] ) )
      continue;
    if( ! refalrts::empty_seq( context[6], context[7] ) )
      continue;
    //DEBUG: s.Number#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } ','/9 Tile{ HalfReuse: ' '/0 HalfReuse: </4 HalfReuse: & StrFromInt/5 AsIs: s.Number#1/8 AsIs: >/1 }"UL"/10 Tile{ ]] }
    if( ! refalrts::alloc_char( context[9], ',' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[10], context[11], "UL", 2 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ' ' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], ref_StrFromInt.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[10], context[11] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[9], context[9] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElIdent e.idx
    // </0 & AllocatorFuncArgument/4 # ElIdent/5 e.Name#1/6 >/1
    context[6] = context[2];
    context[7] = context[3];
    if( ! refalrts::ident_term(  ident_ElIdent, context[5] ) )
      continue;
    // closed e.Name#1 as range 6
    //DEBUG: e.Name#1: 6

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ }", ident"/8 Tile{ HalfReuse: '_'/0 HalfReuse: </4 HalfReuse: & CName/5 AsIs: e.Name#1/6 AsIs: >/1 ]] }
    if( ! refalrts::alloc_chars( context[8], context[9], ", ident", 7 ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], '_' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], ref_CName.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[8], context[9] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // # ElUnwrappedClosure s.idx
    // </0 & AllocatorFuncArgument/4 # ElUnwrappedClosure/5 s.HeadOffset#1/8 >/1
    context[6] = context[2];
    context[7] = context[3];
    if( ! refalrts::ident_term(  ident_ElUnwrappedClosure, context[5] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[6], context[7] ) )
      continue;
    if( ! refalrts::empty_seq( context[6], context[7] ) )
      continue;
    //DEBUG: s.HeadOffset#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } ','/9 Tile{ HalfReuse: ' '/0 HalfReuse: </4 HalfReuse: & ContextItem/5 AsIs: s.HeadOffset#1/8 AsIs: >/1 ]] }
    if( ! refalrts::alloc_char( context[9], ',' ) )
      return refalrts::cNoMemory;
    refalrts::reinit_char( context[0], ' ' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[5], ref_ContextItem.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[9], context[9] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx
  // </0 & AllocatorFuncArgument/4 s.Other#1/5 >/1
  context[6] = context[2];
  context[7] = context[3];
  if( ! refalrts::empty_seq( context[6], context[7] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.Other#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & AllocatorFuncArgument/4 s.Other#1/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_AllocatorFuncArgument("AllocatorFuncArgument", 2638096229U, 2630503357U, func_AllocatorFuncArgument);


//End of file
