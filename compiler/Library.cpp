// Automatically generated file. Don't edit!
#include "refalrts.h"


const refalrts::RefalIdentifier ident_BEGIN = refalrts::ident_from_static("BEGIN");
const refalrts::RefalIdentifier ident_CURRENT = refalrts::ident_from_static("CURRENT");
const refalrts::RefalIdentifier ident_END = refalrts::ident_from_static("END");
const refalrts::RefalIdentifier ident_Fails = refalrts::ident_from_static("Fails");
const refalrts::RefalIdentifier ident_False = refalrts::ident_from_static("False");
const refalrts::RefalIdentifier ident_Success = refalrts::ident_from_static("Success");
const refalrts::RefalIdentifier ident_True = refalrts::ident_from_static("True");
const refalrts::RefalIdentifier ident_stderr = refalrts::ident_from_static("stderr");
const refalrts::RefalIdentifier ident_stdin = refalrts::ident_from_static("stdin");
const refalrts::RefalIdentifier ident_stdout = refalrts::ident_from_static("stdout");
const refalrts::RefalIdentifier ident_stout = refalrts::ident_from_static("stout");
static refalrts::ExternalReference ref_PtrFromName("PtrFromName", 0U, 0U);
static refalrts::ExternalReference ref_gen_Add_S2A1("Add$2=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Add("Add", 0U, 0U);
static refalrts::ExternalReference ref_gen_NormArithmArg_S1A1("NormArithmArg$1=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_NormArithmArg_S2A2("NormArithmArg$2=2", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_NormArithmArg_S2A1("NormArithmArg$2=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_NormArithmArg_S3A2("NormArithmArg$3=2", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_NormArithmArg_S3A1("NormArithmArg$3=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_NormArithmArg("NormArithmArg", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_NormNumber_S7A1("NormNumber$7=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_NormNumber_S8A1("NormNumber$8=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_NormNumber_S9B1("NormNumber$9:1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_NormNumber("NormNumber", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_AllDigits("AllDigits", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_AllDigitsm_SwFirst("AllDigits-SwFirst", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Addm_Normed("Add-Normed", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Addm_Nat_S1B1("Add-Nat$1:1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Addm_Nat("Add-Nat", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Addm_Digits("Add-Digits", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Arg("Arg", 0U, 0U);
static refalrts::ExternalReference ref_Br("Br", 0U, 0U);
static refalrts::ExternalReference ref_Buried("Buried", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Card("Card", 0U, 0U);
static refalrts::ExternalReference ref_Chr("Chr", 0U, 0U);
static refalrts::ExternalReference ref_gen_Cp_B1("Cp:1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Cp("Cp", 0U, 0U);
static refalrts::ExternalReference ref_gen_Dg_B1("Dg:1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Dg("Dg", 0U, 0U);
static refalrts::ExternalReference ref_Dgall("Dgall", 0U, 0U);
static refalrts::ExternalReference ref_gen_Div_S1A1("Div$1=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Div_S2A2("Div$2=2", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Div_S2A1("Div$2=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Div("Div", 0U, 0U);
static refalrts::ExternalReference ref_gen_Divmod_S2A2("Divmod$2=2", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Divmod_S2A1("Divmod$2=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Divmod("Divmod", 0U, 0U);
static refalrts::ExternalReference ref_Divmodm_Digits("Divmod-Digits", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Divmodm_Normed("Divmod-Normed", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Divmodm_Nat_S1A1("Divmod-Nat$1=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Divmodm_Nat_S2A5("Divmod-Nat$2=5", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Divmodm_Nat_S2A4("Divmod-Nat$2=4", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Divmodm_Nat_S2A3("Divmod-Nat$2=3", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Divmodm_Nat_S2A2("Divmod-Nat$2=2", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Divmodm_Nat_S2A1("Divmod-Nat$2=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Divmodm_Nat_S2A1B1("Divmod-Nat$2=1:1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Divmodm_Nat("Divmod-Nat", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Divmodm_Shl("Divmod-Shl", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Divmodm_Natm_Normed("Divmod-Nat-Normed", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Divmodm_Align_S2A1("Divmod-Align$2=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Divmodm_Align("Divmod-Align", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Divmodm_CalcDigits_B1("Divmod-CalcDigits:1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Divmodm_CalcDigits_A1("Divmod-CalcDigits=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Divmodm_CalcDigits("Divmod-CalcDigits", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Divmodm_GetNextDigit_S2A1("Divmod-GetNextDigit$2=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Divmodm_GetNextDigit("Divmod-GetNextDigit", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Divmodm_AdjustDigit("Divmod-AdjustDigit", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Divmodm_GuessDigit("Divmod-GuessDigit", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Explode("Explode", 0U, 0U);
static refalrts::ExternalReference ref_First("First", 0U, 0U);
static refalrts::ExternalReference ref_DoFirst("DoFirst", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Get("Get", 0U, 0U);
static refalrts::ExternalReference ref_gen_Implode_S1B1("Implode$1:1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Implode("Implode", 0U, 0U);
static refalrts::ExternalReference ref_gen_DoImplode_S4B1("DoImplode$4:1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_DoImplode("DoImplode", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Last("Last", 0U, 0U);
static refalrts::ExternalReference ref_DoLast("DoLast", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Lenw("Lenw", 0U, 0U);
static refalrts::ExternalReference ref_DoLenw("DoLenw", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Lower("Lower", 0U, 0U);
static refalrts::ExternalReference ref_gen_Mod_S1A1("Mod$1=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Mod_S2A2("Mod$2=2", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Mod_S2A1("Mod$2=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Mod("Mod", 0U, 0U);
static refalrts::ExternalReference ref_gen_Mul_S2A1("Mul$2=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Mul("Mul", 0U, 0U);
static refalrts::ExternalReference ref_Mulm_Digits("Mul-Digits", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Mulm_Normed("Mul-Normed", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Mulm_Nat("Mul-Nat", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Mulm_Natm_Line_S2B1("Mul-Nat-Line$2:1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Mulm_Natm_Line("Mul-Nat-Line", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Numb("Numb", 0U, 0U);
static refalrts::ExternalReference ref_DoNumb("DoNumb", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Numbm_Ok("Numb-Ok", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Numbm_Fail("Numb-Fail", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Numbm_Wrap("Numb-Wrap", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_DoNumbm_Wrap("DoNumb-Wrap", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Open("Open", 0U, 0U);
static refalrts::ExternalReference ref_Ord("Ord", 0U, 0U);
static refalrts::ExternalReference ref_Print("Print", 0U, 0U);
static refalrts::ExternalReference ref_Prout("Prout", 0U, 0U);
static refalrts::ExternalReference ref_Proud("Proud", 0U, 0U);
static refalrts::ExternalReference ref_Trout("Trout", 0U, 0U);
static refalrts::ExternalReference ref_Put("Put", 0U, 0U);
static refalrts::ExternalReference ref_Putout("Putout", 0U, 0U);
static refalrts::ExternalReference ref_gen_Rp_B1("Rp:1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Rp("Rp", 0U, 0U);
static refalrts::ExternalReference ref_gen_Sub_S2A1("Sub$2=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Sub("Sub", 0U, 0U);
static refalrts::ExternalReference ref_Subm_Digits("Sub-Digits", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Subm_Normed("Sub-Normed", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Neg("Neg", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Subm_Nat_B1("Sub-Nat:1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Subm_Nat("Sub-Nat", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Subm_Natm_Nat("Sub-Nat-Nat", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_DoSubm_Natm_Nat_S1B2("DoSub-Nat-Nat$1:2", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_DoSubm_Natm_Nat_S1B1("DoSub-Nat-Nat$1:1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_DoSubm_Natm_Nat("DoSub-Nat-Nat", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_LeadingZeros("LeadingZeros", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Symb_B1("Symb:1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Symb_A1("Symb=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Symb("Symb", 0U, 0U);
static refalrts::ExternalReference ref_gen_Symbm_Nat_S2A2("Symb-Nat$2=2", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_Symbm_Nat_S2A1("Symb-Nat$2=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Symbm_Nat("Symb-Nat", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Type("Type", 0U, 0U);
static refalrts::ExternalReference ref_Upper("Upper", 0U, 0U);
static refalrts::ExternalReference ref_GetEnv("GetEnv", 0U, 0U);
static refalrts::ExternalReference ref_Close("Close", 0U, 0U);
static refalrts::ExternalReference ref_ExistFile("ExistFile", 0U, 0U);
static refalrts::ExternalReference ref_Implodeu_Ext("Implode_Ext", 0U, 0U);
static refalrts::ExternalReference ref_Explodeu_Ext("Explode_Ext", 0U, 0U);
static refalrts::ExternalReference ref_gen_Compare_S2A1("Compare$2=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Compare("Compare", 0U, 0U);
static refalrts::ExternalReference ref_Comparem_Normed("Compare-Normed", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Comparem_Nat("Compare-Nat", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Comparem_Align("Compare-Align", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Comparem_ByDigits("Compare-ByDigits", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Comparem_Digits("Compare-Digits", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_Write("Write", 0U, 0U);
static refalrts::ExternalReference ref_FClose("FClose", 0U, 0U);
static refalrts::ExternalReference ref_gen_FOpen_A1("FOpen=1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_FOpen("FOpen", 0U, 0U);
static refalrts::ExternalReference ref_FReadLine("FReadLine", 0U, 0U);
static refalrts::ExternalReference ref_FWriteLine("FWriteLine", 0U, 0U);
static refalrts::ExternalReference ref_GetFreeHandle("GetFreeHandle", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_ReadLine("ReadLine", 0U, 0U);
static refalrts::ExternalReference ref_WriteLine("WriteLine", 0U, 0U);
static refalrts::ExternalReference ref_Exit("Exit", 0U, 0U);
static refalrts::ExternalReference ref_System("System", 0U, 0U);
static refalrts::ExternalReference ref_gen_IntFromStr_L1("IntFromStr\\1", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_gen_IntFromStr_L2("IntFromStr\\2", 4190823648U, 3252578238U);
static refalrts::ExternalReference ref_IntFromStr("IntFromStr", 0U, 0U);
static refalrts::ExternalReference ref_StrFromInt("StrFromInt", 0U, 0U);
static refalrts::ExternalReference ref_SymbCompare("SymbCompare", 0U, 0U);
static refalrts::ExternalReference ref_FWriteBytes("FWriteBytes", 0U, 0U);
static refalrts::ExternalReference ref_FReadBytes("FReadBytes", 0U, 0U);
static refalrts::ExternalReference ref_FTell("FTell", 0U, 0U);
static refalrts::ExternalReference ref_FSeek("FSeek", 0U, 0U);
static refalrts::ExternalReference ref_RenameFile("RenameFile", 0U, 0U);
static refalrts::ExternalReference ref_RemoveFile("RemoveFile", 0U, 0U);

#line 2 "Library.sref"
#include <assert.h>
#include <ctype.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <vector>
#include <string>

//FROM refalrts

namespace {

extern refalrts::FnResult arg(refalrts::Iter arg_begin, refalrts::Iter arg_end);

enum {
  cFlags_Autoopen       = 1 << 0,
  cFlags_Read           = 1 << 1,
  cFlags_Write          = 1 << 2,
  cFlags_ReturnHandle   = 1 << 3,
  cFlags_NoHandle       = 1 << 4,
  cFlags_Transparent    = 1 << 5,

  cFlags_StreamMask     = 3 << 6,
  cFlags_StdIn          = 1 << 6,
  cFlags_StdOut         = 2 << 6,
  cFlags_StdErr         = 3 << 6,

  cFlags_NoEOL          = 1 << 8,
};

extern refalrts::FnResult fread_line(
  refalrts::Iter arg_begin, refalrts::Iter arg_end, unsigned flags
);

extern refalrts::FnResult refal_open(
  refalrts::Iter arg_begin, refalrts::Iter arg_end
);

extern bool get_free_handle(refalrts::RefalNumber& free_file);

extern refalrts::FnResult fwrite_line(
  refalrts::Iter arg_begin, refalrts::Iter arg_end, unsigned flags
);

extern refalrts::FnResult refal_getenv(
  refalrts::Iter arg_begin, refalrts::Iter arg_end
);

enum CloseMode { cCloseMode_Silent, cCloseMode_Fail };

extern refalrts::FnResult close(
  refalrts::Iter arg_begin, refalrts::Iter arg_end, CloseMode mode
);

extern refalrts::FnResult exist_file(
  refalrts::Iter arg_begin, refalrts::Iter arg_end
);

extern refalrts::FnResult implode_ext(
  refalrts::Iter arg_begin, refalrts::Iter arg_end
);

extern refalrts::FnResult explode(
  refalrts::Iter arg_begin, refalrts::Iter arg_end
);

}  // unnamed namespace
#line 237 "Library.cpp"
static refalrts::FnResult func_PtrFromName(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 102 "Library.sref"
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  const char *func_name = 0;

  enum { cMaxFuncName = 2000 };
  char func_name_buffer[cMaxFuncName + 1] = { 0 };
  unsigned read;

  refalrts::Iter pcookie1 = 0, pcookie2 = 0;
  if (
    ! refalrts::svar_left(pcookie1, content_b, content_e)
    || refalrts::cDataNumber != pcookie1->tag
    || ! refalrts::svar_left(pcookie2, content_b, content_e)
    || refalrts::cDataNumber != pcookie2->tag
  ) {
    return refalrts::cRecognitionImpossible;
  }

  if (refalrts::cDataIdentifier == content_b->tag) {
    func_name = content_b->ident_info->name();
    move_left(content_b, content_e);
  } else if (
    (
      read = refalrts::read_chars(
        func_name_buffer, cMaxFuncName, content_b, content_e
      )
    ) != 0
    && refalrts::empty_seq(content_b, content_e)
  ) {
    func_name_buffer[read] = '\0';
    func_name = func_name_buffer;
  }

  if (0 == func_name) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalFunction *func_ptr =
    refalrts::RefalFunction::lookup(
      pcookie1->number_info, pcookie2->number_info, func_name
    );

  refalrts::Iter start_garbage = arg_begin;
  if (func_ptr) {
    refalrts::reinit_name(arg_begin, func_ptr);
    start_garbage = pfunc;
  }

  refalrts::splice_to_freelist(start_garbage, arg_end);
  return refalrts::cSuccess;
#line 292 "Library.cpp"
}

static refalrts::NativeReference nat_ref_PtrFromName("PtrFromName", 0U, 0U, func_PtrFromName);

static refalrts::FnResult func_gen_Add_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Add$2=1/4 (/7 e.First#2/5 )/8 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#2 as range 5
  // closed e.Second#2 as range 2
  //DEBUG: e.First#2: 5
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Add-Normed/4 AsIs: (/7 AsIs: e.First#2/5 AsIs: )/8 AsIs: e.Second#2/2 AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Addm_Normed.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Add_S2A1("Add$2=1", 4190823648U, 3252578238U, func_gen_Add_S2A1);

static refalrts::FnResult func_Add(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & Add/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // s.idx s.idx
    // </0 & Add/4 s.First#1/7 s.Second#1/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.First#1: 7
    //DEBUG: s.Second#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Add-Digits/4 AsIs: s.First#1/7 AsIs: s.Second#1/8 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Addm_Digits.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & Add/4 e.ArithmArg#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.ArithmArg#1 as range 5
  //DEBUG: e.ArithmArg#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </7 & Add$2=1/8 Tile{ AsIs: </0 Reuse: & NormArithmArg/4 AsIs: e.ArithmArg#1/5 AsIs: >/1 } >/9 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_gen_Add_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormArithmArg.ref.function );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Add("Add", 0U, 0U, func_Add);

static refalrts::FnResult func_gen_NormArithmArg_S1A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  // </0 & NormArithmArg$1=1/4 s.SecondSign#2/5 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Second#2 as range 2
  //DEBUG: s.SecondSign#2: 5
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: 0/4 } Tile{ HalfReuse: )/1 } Tile{ AsIs: s.SecondSign#2/5 } Tile{ AsIs: e.Second#2/2 } Tile{ ]] }
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_number( context[4], 0UL );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[0], context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[5], context[5] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormArithmArg_S1A1("NormArithmArg$1=1", 4190823648U, 3252578238U, func_gen_NormArithmArg_S1A1);

static refalrts::FnResult func_gen_NormArithmArg_S2A2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 7 elems
  refalrts::Iter context[7];
  refalrts::zeros( context, 7 );
  // </0 & NormArithmArg$2=2/4 s.First#2/5 s.SecondSign#3/6 e.Second#3/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Second#3 as range 2
  //DEBUG: s.First#2: 5
  //DEBUG: s.SecondSign#3: 6
  //DEBUG: e.Second#3: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: '+'/4 AsIs: s.First#2/5 } Tile{ HalfReuse: )/1 } Tile{ AsIs: s.SecondSign#3/6 } Tile{ AsIs: e.Second#3/2 } Tile{ ]] }
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_char( context[4], '+' );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[0], context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[6], context[6] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormArithmArg_S2A2("NormArithmArg$2=2", 4190823648U, 3252578238U, func_gen_NormArithmArg_S2A2);

static refalrts::FnResult func_gen_NormArithmArg_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & NormArithmArg$2=1/4 (/7 e.Second#1/5 )/8 'N'/9 s.SubType#2/10 s.First#2/11 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = refalrts::char_left( 'N', context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  // closed e.Second#1 as range 5
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Second#1: 5
  //DEBUG: s.SubType#2: 10
  //DEBUG: s.First#2: 11

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.SubType#2/10 {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 HalfReuse: </4 HalfReuse: & @create_closure@/7 } & NormArithmArg$2=2/12 Tile{ AsIs: s.First#2/11 AsIs: >/1 } Tile{ HalfReuse: </8 HalfReuse: & NormNumber/9 } Tile{ AsIs: e.Second#1/5 } >/13 >/14 Tile{ ]] }
  if( ! refalrts::alloc_name( context[12], ref_gen_NormArithmArg_S2A2.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_open_call( context[4] );
  refalrts::reinit_name( context[7], refalrts::create_closure );
  refalrts::reinit_open_call( context[8] );
  refalrts::reinit_name( context[9], ref_NormNumber.ref.function );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[8], context[9] );
  res = refalrts::splice_evar( res, context[11], context[1] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  refalrts::splice_to_freelist_open( context[7], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormArithmArg_S2A1("NormArithmArg$2=1", 4190823648U, 3252578238U, func_gen_NormArithmArg_S2A1);

static refalrts::FnResult func_gen_NormArithmArg_S3A2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  // </0 & NormArithmArg$3=2/4 s.FirstSign#2/5 (/8 e.First#2/6 )/9 s.SecondSign#3/10 e.Second#3/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  // closed e.First#2 as range 6
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Second#3 as range 2
  //DEBUG: s.FirstSign#2: 5
  //DEBUG: e.First#2: 6
  //DEBUG: s.SecondSign#3: 10
  //DEBUG: e.Second#3: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & NormArithmArg$3=2/4 s.FirstSign#2/5 {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: (/0 } Tile{ HalfReuse: s.FirstSign2 #5/8 AsIs: e.First#2/6 AsIs: )/9 AsIs: s.SecondSign#3/10 } Tile{ AsIs: e.Second#3/2 } Tile{ ]] }
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_svar( context[8], context[5] );
  refalrts::link_brackets( context[0], context[9] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[8], context[10] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormArithmArg_S3A2("NormArithmArg$3=2", 4190823648U, 3252578238U, func_gen_NormArithmArg_S3A2);

static refalrts::FnResult func_gen_NormArithmArg_S3A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  // </0 & NormArithmArg$3=1/4 (/7 e.Second#1/5 )/8 s.FirstSign#2/9 e.First#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Second#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.First#2 as range 2
  //DEBUG: e.Second#1: 5
  //DEBUG: s.FirstSign#2: 9
  //DEBUG: e.First#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 HalfReuse: </4 HalfReuse: & @create_closure@/7 } Tile{ HalfReuse: & NormArithmArg$3=2/8 AsIs: s.FirstSign#2/9 } (/10 Tile{ AsIs: e.First#2/2 } )/11 >/12 </13 & NormNumber/14 Tile{ AsIs: e.Second#1/5 } >/15 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], ref_NormNumber.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[15] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_open_call( context[4] );
  refalrts::reinit_name( context[7], refalrts::create_closure );
  refalrts::reinit_name( context[8], ref_gen_NormArithmArg_S3A2.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[4] );
  refalrts::link_brackets( context[10], context[11] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[15], context[15] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[11], context[14] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[8], context[9] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormArithmArg_S3A1("NormArithmArg$3=1", 4190823648U, 3252578238U, func_gen_NormArithmArg_S3A1);

static refalrts::FnResult func_NormArithmArg(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 17 elems
  refalrts::Iter context[17];
  refalrts::zeros( context, 17 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & NormArithmArg/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // 0 e.idx
    // </0 & NormArithmArg/4 0/7 e.Second#1/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::number_left( 0UL, context[5], context[6] );
    if( ! context[7] )
      continue;
    // closed e.Second#1 as range 5
    //DEBUG: e.Second#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & NormArithmArg$1=1/4 HalfReuse: </7 } & NormNumber/8 Tile{ AsIs: e.Second#1/5 } >/9 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_name( context[8], ref_NormNumber.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[9] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_gen_NormArithmArg_S1A1.ref.function );
    refalrts::reinit_open_call( context[7] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[7] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[9], context[9] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[8], context[8] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // s.idx e.idx
    // </0 & NormArithmArg/4 s.First#1/7 e.Second#1/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    // closed e.Second#1 as range 5
    //DEBUG: s.First#1: 7
    //DEBUG: e.Second#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </8 </9 & @create_closure@/10 & NormArithmArg$2=1/11 (/12 Tile{ AsIs: e.Second#1/5 } )/13 >/14 Tile{ AsIs: </0 Reuse: & Type/4 AsIs: s.First#1/7 } >/15 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], refalrts::create_closure ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[11], ref_gen_NormArithmArg_S2A1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[15] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Type.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[9] );
    refalrts::link_brackets( context[12], context[13] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[0], context[7] );
    res = refalrts::splice_evar( res, context[13], context[14] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[8], context[12] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) e.idx
    // </0 & NormArithmArg/4 (/9 e.First#1/7 )/10 e.Second#1/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = 0;
    context[8] = 0;
    context[9] = refalrts::brackets_left( context[7], context[8], context[5], context[6] );
    if( ! context[9] )
      continue;
    refalrts::bracket_pointers(context[9], context[10]);
    // closed e.First#1 as range 7
    // closed e.Second#1 as range 5
    //DEBUG: e.First#1: 7
    //DEBUG: e.Second#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 HalfReuse: </4 HalfReuse: & @create_closure@/9 } & NormArithmArg$3=1/11 (/12 Tile{ AsIs: e.Second#1/5 } Tile{ AsIs: )/10 } >/13 </14 & NormNumber/15 Tile{ AsIs: e.First#1/7 } >/16 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_name( context[11], ref_gen_NormArithmArg_S3A1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[15], ref_NormNumber.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[9], refalrts::create_closure );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[12], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[7], context[8] );
    res = refalrts::splice_evar( res, context[13], context[15] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & NormArithmArg/4 e.OtherArg#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.OtherArg#1 as range 5
  //DEBUG: e.OtherArg#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & NormArithmArg/4 e.OtherArg#1/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_NormArithmArg("NormArithmArg", 4190823648U, 3252578238U, func_NormArithmArg);

static refalrts::FnResult func_gen_NormNumber_S7A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  // </0 & NormNumber$7=1/4 (/8 e.Digits#1/6 )/9 # True/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = refalrts::ident_right(  ident_True, context[2], context[3] );
  if( ! context[5] )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Digits#1 as range 6
  //DEBUG: e.Digits#1: 6

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & NormNumber$7=1/4 (/8 {REMOVED TILE} )/9 # True/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: '+'/0 } Tile{ AsIs: e.Digits#1/6 } Tile{ ]] }
  refalrts::reinit_char( context[0], '+' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormNumber_S7A1("NormNumber$7=1", 4190823648U, 3252578238U, func_gen_NormNumber_S7A1);

static refalrts::FnResult func_gen_NormNumber_S8A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  // </0 & NormNumber$8=1/4 (/8 e.Digits#1/6 )/9 # True/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = refalrts::ident_right(  ident_True, context[2], context[3] );
  if( ! context[5] )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Digits#1 as range 6
  //DEBUG: e.Digits#1: 6

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & NormNumber$8=1/4 (/8 {REMOVED TILE} )/9 # True/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: '-'/0 } Tile{ AsIs: e.Digits#1/6 } Tile{ ]] }
  refalrts::reinit_char( context[0], '-' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormNumber_S8A1("NormNumber$8=1", 4190823648U, 3252578238U, func_gen_NormNumber_S8A1);

static refalrts::FnResult func_gen_NormNumber_S9B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  //FAST GEN: s.$ s.$ e.$
  //GLOBAL GEN: s.$ s.$ e.$
  // </0 & NormNumber$9:1/4 s.idx#0/5 s.idxV#0/6 e.idxVV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxVV#0 as range 2
  do {
    // 'N' s.idx e.idx
    // </0 & NormNumber$9:1/4 'N'/5 s.SubType#2/6 e.Digits#2/7 >/1
    context[7] = context[2];
    context[8] = context[3];
    if( ! refalrts::char_term( 'N', context[5] ) )
      continue;
    // closed e.Digits#2 as range 7
    //DEBUG: s.SubType#2: 6
    //DEBUG: e.Digits#2: 7

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.SubType#2/6 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & NormNumber/4 Reuse: '+'/5 } Tile{ AsIs: e.Digits#2/7 } Tile{ AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_NormNumber.ref.function );
    refalrts::update_char( context[5], '+' );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[7], context[8] );
    refalrts::splice_to_freelist_open( context[5], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx s.idx e.idx
  // </0 & NormNumber$9:1/4 s.Type#2/5 s.SubType#2/6 e.NotIsDigits#2/7 >/1
  context[7] = context[2];
  context[8] = context[3];
  // closed e.NotIsDigits#2 as range 7
  //DEBUG: s.Type#2: 5
  //DEBUG: s.SubType#2: 6
  //DEBUG: e.NotIsDigits#2: 7

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & NormNumber$9:1/4 s.Type#2/5 s.SubType#2/6 e.NotIsDigits#2/7 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormNumber_S9B1("NormNumber$9:1", 4190823648U, 3252578238U, func_gen_NormNumber_S9B1);

static refalrts::FnResult func_NormNumber(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 17 elems
  refalrts::Iter context[17];
  refalrts::zeros( context, 17 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & NormNumber/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // '+' 0
    // </0 & NormNumber/4 '+'/7 0/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::char_left( '+', context[5], context[6] );
    if( ! context[7] )
      continue;
    context[8] = refalrts::number_left( 0UL, context[5], context[6] );
    if( ! context[8] )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & NormNumber/4 '+'/7 0/8 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
    refalrts::reinit_number( context[1], 0UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // '+' 0 e.idx
    // </0 & NormNumber/4 '+'/7 0/8 e.Digits#1/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::char_left( '+', context[5], context[6] );
    if( ! context[7] )
      continue;
    context[8] = refalrts::number_left( 0UL, context[5], context[6] );
    if( ! context[8] )
      continue;
    // closed e.Digits#1 as range 5
    //DEBUG: e.Digits#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: </4 HalfReuse: & NormNumber/7 HalfReuse: '+'/8 AsIs: e.Digits#1/5 AsIs: >/1 ]] }
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], ref_NormNumber.ref.function );
    refalrts::reinit_char( context[8], '+' );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[4];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // '-' 0
    // </0 & NormNumber/4 '-'/7 0/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::char_left( '-', context[5], context[6] );
    if( ! context[7] )
      continue;
    context[8] = refalrts::number_left( 0UL, context[5], context[6] );
    if( ! context[8] )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & NormNumber/4 '-'/7 0/8 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
    refalrts::reinit_number( context[1], 0UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // '-' 0 e.idx
    // </0 & NormNumber/4 '-'/7 0/8 e.Digits#1/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::char_left( '-', context[5], context[6] );
    if( ! context[7] )
      continue;
    context[8] = refalrts::number_left( 0UL, context[5], context[6] );
    if( ! context[8] )
      continue;
    // closed e.Digits#1 as range 5
    //DEBUG: e.Digits#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: </4 HalfReuse: & NormNumber/7 HalfReuse: '-'/8 AsIs: e.Digits#1/5 AsIs: >/1 ]] }
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], ref_NormNumber.ref.function );
    refalrts::reinit_char( context[8], '-' );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[4];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // 0
    // </0 & NormNumber/4 0/7 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::number_left( 0UL, context[5], context[6] );
    if( ! context[7] )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & NormNumber/4 0/7 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
    refalrts::reinit_number( context[1], 0UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // 0 e.idx
    // </0 & NormNumber/4 0/7 e.Digits#1/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::number_left( 0UL, context[5], context[6] );
    if( ! context[7] )
      continue;
    // closed e.Digits#1 as range 5
    //DEBUG: e.Digits#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & NormNumber/4 HalfReuse: '+'/7 AsIs: e.Digits#1/5 AsIs: >/1 ]] }
    refalrts::reinit_char( context[7], '+' );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // '+' e.idx
    // </0 & NormNumber/4 '+'/7 e.Digits#1/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::char_left( '+', context[5], context[6] );
    if( ! context[7] )
      continue;
    // closed e.Digits#1 as range 5
    //DEBUG: e.Digits#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </8 </9 & @create_closure@/10 & NormNumber$7=1/11 (/12 e.Digits#1/5/13 )/15 Tile{ HalfReuse: >/0 HalfReuse: </4 HalfReuse: & AllDigits/7 AsIs: e.Digits#1/5 AsIs: >/1 } >/16 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], refalrts::create_closure ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[11], ref_gen_NormNumber_S7A1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[12] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[13], context[14], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_close_call( context[0] );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], ref_AllDigits.ref.function );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[9] );
    refalrts::link_brackets( context[12], context[15] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[8], context[15] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // '-' e.idx
    // </0 & NormNumber/4 '-'/7 e.Digits#1/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::char_left( '-', context[5], context[6] );
    if( ! context[7] )
      continue;
    // closed e.Digits#1 as range 5
    //DEBUG: e.Digits#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </8 </9 & @create_closure@/10 & NormNumber$8=1/11 (/12 e.Digits#1/5/13 )/15 Tile{ HalfReuse: >/0 HalfReuse: </4 HalfReuse: & AllDigits/7 AsIs: e.Digits#1/5 AsIs: >/1 } >/16 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], refalrts::create_closure ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[11], ref_gen_NormNumber_S8A1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[12] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[13], context[14], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_close_call( context[0] );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], ref_AllDigits.ref.function );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[9] );
    refalrts::link_brackets( context[12], context[15] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[8], context[15] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & NormNumber/4 e.Digits#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.Digits#1 as range 5
  //DEBUG: e.Digits#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </7 & NormNumber$9:1/8 Tile{ AsIs: </0 Reuse: & Type/4 AsIs: e.Digits#1/5 AsIs: >/1 } >/9 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_gen_NormNumber_S9B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Type.ref.function );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_NormNumber("NormNumber", 4190823648U, 3252578238U, func_NormNumber);

static refalrts::FnResult func_AllDigits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  // </0 & AllDigits/4 e.Items#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Items#1 as range 2
  //DEBUG: e.Items#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & AllDigits-SwFirst/6 Tile{ AsIs: </0 Reuse: & Type/4 AsIs: e.Items#1/2 AsIs: >/1 } >/7 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_AllDigitsm_SwFirst.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[7] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Type.ref.function );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[7], context[7] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_AllDigits("AllDigits", 4190823648U, 3252578238U, func_AllDigits);

static refalrts::FnResult func_AllDigitsm_SwFirst(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  //FAST GEN: e.$
  //GLOBAL GEN: s.$ s.$ e.$
  // </0 & AllDigits-SwFirst/4 s.idx#0/5 s.idxV#0/6 e.idxVV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxVV#0 as range 2
  do {
    // 'N' s.idx s.idx
    // </0 & AllDigits-SwFirst/4 'N'/5 s.SubType#1/6 s.Digit#1/9 >/1
    context[7] = context[2];
    context[8] = context[3];
    if( ! refalrts::char_term( 'N', context[5] ) )
      continue;
    if( ! refalrts::svar_left( context[9], context[7], context[8] ) )
      continue;
    if( ! refalrts::empty_seq( context[7], context[8] ) )
      continue;
    //DEBUG: s.SubType#1: 6
    //DEBUG: s.Digit#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & AllDigits-SwFirst/4 'N'/5 s.SubType#1/6 s.Digit#1/9 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: # True/1 ]] }
    refalrts::reinit_ident( context[1], ident_True );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // 'N' s.idx s.idx e.idx
    // </0 & AllDigits-SwFirst/4 'N'/5 s.SubType#1/6 s.Digit#1/9 e.Items#1/7 >/1
    context[7] = context[2];
    context[8] = context[3];
    if( ! refalrts::char_term( 'N', context[5] ) )
      continue;
    if( ! refalrts::svar_left( context[9], context[7], context[8] ) )
      continue;
    // closed e.Items#1 as range 7
    //DEBUG: s.SubType#1: 6
    //DEBUG: s.Digit#1: 9
    //DEBUG: e.Items#1: 7

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} 'N'/5 s.SubType#1/6 s.Digit#1/9 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & AllDigits/4 } Tile{ AsIs: e.Items#1/7 } Tile{ AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_AllDigits.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[7], context[8] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx s.idx e.idx
  // </0 & AllDigits-SwFirst/4 s.Type#1/5 s.SubType#1/6 e.Expr#1/7 >/1
  context[7] = context[2];
  context[8] = context[3];
  // closed e.Expr#1 as range 7
  //DEBUG: s.Type#1: 5
  //DEBUG: s.SubType#1: 6
  //DEBUG: e.Expr#1: 7

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & AllDigits-SwFirst/4 s.Type#1/5 s.SubType#1/6 e.Expr#1/7 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: # False/1 ]] }
  refalrts::reinit_ident( context[1], ident_False );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_AllDigitsm_SwFirst("AllDigits-SwFirst", 4190823648U, 3252578238U, func_AllDigitsm_SwFirst);

static refalrts::FnResult func_Addm_Normed(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) e.$
  // </0 & Add-Normed/4 (/7 e.idxB#0/5 )/8 e.idxT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  // closed e.idxT#0 as range 2
  do {
    // ( '+' e.idx ) '+' e.idx
    // </0 & Add-Normed/4 (/7 '+'/13 e.First#1/9 )/8 '+'/14 e.Second#1/11 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '+', context[9], context[10] );
    if( ! context[13] )
      continue;
    context[14] = refalrts::char_left( '+', context[11], context[12] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 9
    // closed e.Second#1 as range 11
    //DEBUG: e.First#1: 9
    //DEBUG: e.Second#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} '+'/13 {REMOVED TILE} )/8 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Add-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/9 } Tile{ HalfReuse: )/14 AsIs: e.Second#1/11 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Addm_Nat.ref.function );
    refalrts::reinit_close_bracket( context[14] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[14] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[14];
    res = refalrts::splice_evar( res, context[9], context[10] );
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '+' e.idx ) '-' e.idx
    // </0 & Add-Normed/4 (/7 '+'/13 e.First#1/9 )/8 '-'/14 e.Second#1/11 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '+', context[9], context[10] );
    if( ! context[13] )
      continue;
    context[14] = refalrts::char_left( '-', context[11], context[12] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 9
    // closed e.Second#1 as range 11
    //DEBUG: e.First#1: 9
    //DEBUG: e.Second#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} '+'/13 {REMOVED TILE} )/8 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sub-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/9 } Tile{ HalfReuse: )/14 AsIs: e.Second#1/11 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Subm_Nat.ref.function );
    refalrts::reinit_close_bracket( context[14] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[14] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[14];
    res = refalrts::splice_evar( res, context[9], context[10] );
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '+' e.idx ) 0
    // </0 & Add-Normed/4 (/7 '+'/13 e.First#1/9 )/8 0/14 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '+', context[9], context[10] );
    if( ! context[13] )
      continue;
    context[14] = refalrts::number_left( 0UL, context[11], context[12] );
    if( ! context[14] )
      continue;
    if( ! refalrts::empty_seq( context[11], context[12] ) )
      continue;
    // closed e.First#1 as range 9
    //DEBUG: e.First#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Add-Normed/4 (/7 '+'/13 {REMOVED TILE} )/8 0/14 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: e.First#1/9 } Tile{ ]] }
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[9], context[10] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '-' e.idx ) '+' e.idx
    // </0 & Add-Normed/4 (/7 '-'/13 e.First#1/9 )/8 '+'/14 e.Second#1/11 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '-', context[9], context[10] );
    if( ! context[13] )
      continue;
    context[14] = refalrts::char_left( '+', context[11], context[12] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 9
    // closed e.Second#1 as range 11
    //DEBUG: e.First#1: 9
    //DEBUG: e.Second#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} '-'/13 {REMOVED TILE} {REMOVED TILE} '+'/14 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sub-Nat/4 AsIs: (/7 } Tile{ AsIs: e.Second#1/11 } Tile{ AsIs: )/8 } Tile{ AsIs: e.First#1/9 } Tile{ AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Subm_Nat.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[8], context[8] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '-' e.idx ) '-' e.idx
    // </0 & Add-Normed/4 (/7 '-'/13 e.First#1/9 )/8 '-'/14 e.Second#1/11 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '-', context[9], context[10] );
    if( ! context[13] )
      continue;
    context[14] = refalrts::char_left( '-', context[11], context[12] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 9
    // closed e.Second#1 as range 11
    //DEBUG: e.First#1: 9
    //DEBUG: e.Second#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} '-'/14 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: '-'/0 HalfReuse: </4 HalfReuse: & Add-Nat/7 HalfReuse: (/13 AsIs: e.First#1/9 AsIs: )/8 } Tile{ AsIs: e.Second#1/11 } Tile{ AsIs: >/1 ]] }
    refalrts::reinit_char( context[0], '-' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], ref_Addm_Nat.ref.function );
    refalrts::reinit_open_bracket( context[13] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[13], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[11], context[12] );
    refalrts::splice_to_freelist_open( context[8], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '-' e.idx ) 0
    // </0 & Add-Normed/4 (/7 '-'/13 e.First#1/9 )/8 0/14 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '-', context[9], context[10] );
    if( ! context[13] )
      continue;
    context[14] = refalrts::number_left( 0UL, context[11], context[12] );
    if( ! context[14] )
      continue;
    if( ! refalrts::empty_seq( context[11], context[12] ) )
      continue;
    // closed e.First#1 as range 9
    //DEBUG: e.First#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} & Add-Normed/4 (/7 '-'/13 {REMOVED TILE} )/8 0/14 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: '-'/0 } Tile{ AsIs: e.First#1/9 } Tile{ ]] }
    refalrts::reinit_char( context[0], '-' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[9], context[10] );
    refalrts::splice_to_freelist_open( context[0], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( 0 ) '+' e.idx
    // </0 & Add-Normed/4 (/7 0/14 )/8 '+'/13 e.Second#1/11 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '+', context[11], context[12] );
    if( ! context[13] )
      continue;
    context[14] = refalrts::number_left( 0UL, context[9], context[10] );
    if( ! context[14] )
      continue;
    if( ! refalrts::empty_seq( context[9], context[10] ) )
      continue;
    // closed e.Second#1 as range 11
    //DEBUG: e.Second#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Add-Normed/4 (/7 0/14 )/8 '+'/13 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: e.Second#1/11 } Tile{ ]] }
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[11], context[12] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( 0 ) e.idx
  // </0 & Add-Normed/4 (/7 0/13 )/8 e.NegOrZero#1/11 >/1
  context[9] = context[5];
  context[10] = context[6];
  context[11] = context[2];
  context[12] = context[3];
  context[13] = refalrts::number_left( 0UL, context[9], context[10] );
  if( ! context[13] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[9], context[10] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.NegOrZero#1 as range 11
  //DEBUG: e.NegOrZero#1: 11

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Add-Normed/4 (/7 0/13 )/8 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.NegOrZero#1/11 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[11], context[12] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Addm_Normed("Add-Normed", 4190823648U, 3252578238U, func_Addm_Normed);

static refalrts::FnResult func_gen_Addm_Nat_S1B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 25 elems
  refalrts::Iter context[25];
  refalrts::zeros( context, 25 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) ( e.$ ) s.$ e.$
  // </0 & Add-Nat$1:1/4 (/7 e.idxB#0/5 )/8 (/11 e.idxTB#0/9 )/12 s.idxTT#0/13 e.idxTTV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.idxB#0 as range 5
  // closed e.idxTB#0 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTTV#0 as range 2
  do {
    // ( e.idx ) ( e.idx ) s.idx
    // </0 & Add-Nat$1:1/4 (/7 e.First#1/14 )/8 (/11 e.Second#1/16 )/12 s.LastSum#2/13 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    context[18] = context[2];
    context[19] = context[3];
    if( ! refalrts::empty_seq( context[18], context[19] ) )
      continue;
    // closed e.First#1 as range 14
    // closed e.Second#1 as range 16
    //DEBUG: s.LastSum#2: 13
    //DEBUG: e.First#1: 14
    //DEBUG: e.Second#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} (/11 {REMOVED TILE} {REMOVED TILE} s.LastSum#2/13 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Add-Nat/4 AsIs: (/7 AsIs: e.First#1/14 AsIs: )/8 } Tile{ AsIs: e.Second#1/16 } Tile{ HalfReuse: >/12 } Tile{ HalfReuse: s.LastSum2 #13/1 ]] }
    refalrts::update_name( context[4], ref_Addm_Nat.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_svar( context[1], context[13] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    refalrts::splice_to_freelist_open( context[8], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) ( e.idx ) 1 s.idx
  // </0 & Add-Nat$1:1/4 (/7 e.First#1/14 )/8 (/11 e.Second#1/16 )/12 1/13 s.LastSum#2/20 >/1
  context[14] = context[5];
  context[15] = context[6];
  context[16] = context[9];
  context[17] = context[10];
  context[18] = context[2];
  context[19] = context[3];
  if( ! refalrts::number_term( 1UL, context[13] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.First#1 as range 14
  // closed e.Second#1 as range 16
  if( ! refalrts::svar_left( context[20], context[18], context[19] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[18], context[19] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.First#1: 14
  //DEBUG: e.Second#1: 16
  //DEBUG: s.LastSum#2: 20

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LastSum#2/20 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Add-Nat/4 AsIs: (/7 AsIs: e.First#1/14 AsIs: )/8 HalfReuse: </11 } & Add-Nat/21 (/22 Tile{ AsIs: e.Second#1/16 } Tile{ AsIs: )/12 AsIs: 1/13 } >/23 >/24 Tile{ HalfReuse: s.LastSum2 #20/1 ]] }
  if( ! refalrts::alloc_name( context[21], ref_Addm_Nat.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[23] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[24] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Addm_Nat.ref.function );
  refalrts::reinit_open_call( context[11] );
  refalrts::reinit_svar( context[1], context[20] );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[23] );
  refalrts::push_stack( context[11] );
  refalrts::link_brackets( context[22], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[23], context[24] );
  res = refalrts::splice_evar( res, context[12], context[13] );
  res = refalrts::splice_evar( res, context[16], context[17] );
  res = refalrts::splice_evar( res, context[21], context[22] );
  refalrts::splice_to_freelist_open( context[11], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Addm_Nat_S1B1("Add-Nat$1:1", 4190823648U, 3252578238U, func_gen_Addm_Nat_S1B1);

static refalrts::FnResult func_Addm_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 23 elems
  refalrts::Iter context[23];
  refalrts::zeros( context, 23 );
  //FAST GEN: ( e.$ ) e.$
  //GLOBAL GEN: ( e.$ ) e.$
  // </0 & Add-Nat/4 (/7 e.idxB#0/5 )/8 e.idxT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  // closed e.idxT#0 as range 2
  do {
    // ( e.idx s.idx ) e.idx s.idx
    // </0 & Add-Nat/4 (/7 e.First#1/9 s.FirstLast#1/13 )/8 e.Second#1/11 s.SecondLast#1/14 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    if( ! refalrts::svar_right( context[13], context[9], context[10] ) )
      continue;
    // closed e.First#1 as range 9
    if( ! refalrts::svar_right( context[14], context[11], context[12] ) )
      continue;
    // closed e.Second#1 as range 11
    //DEBUG: s.FirstLast#1: 13
    //DEBUG: e.First#1: 9
    //DEBUG: s.SecondLast#1: 14
    //DEBUG: e.Second#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 HalfReuse: </4 HalfReuse: & @create_closure@/7 } & Add-Nat$1:1/15 (/16 Tile{ AsIs: e.First#1/9 } )/17 (/18 Tile{ AsIs: e.Second#1/11 } Tile{ AsIs: )/8 } >/19 </20 & Add-Digits/21 Tile{ AsIs: s.FirstLast#1/13 } Tile{ AsIs: s.SecondLast#1/14 AsIs: >/1 } >/22 Tile{ ]] }
    if( ! refalrts::alloc_name( context[15], ref_gen_Addm_Nat_S1B1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[21], ref_Addm_Digits.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], refalrts::create_closure );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[18], context[8] );
    refalrts::link_brackets( context[16], context[17] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[22], context[22] );
    res = refalrts::splice_evar( res, context[14], context[1] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[19], context[21] );
    res = refalrts::splice_evar( res, context[8], context[8] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) e.idx
  // </0 & Add-Nat/4 (/7 e.First#1/9 )/8 e.Second#1/11 >/1
  context[9] = context[5];
  context[10] = context[6];
  context[11] = context[2];
  context[12] = context[3];
  // closed e.First#1 as range 9
  // closed e.Second#1 as range 11
  //DEBUG: e.First#1: 9
  //DEBUG: e.Second#1: 11

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Add-Nat/4 (/7 {REMOVED TILE} )/8 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.First#1/9 } Tile{ AsIs: e.Second#1/11 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[11], context[12] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Addm_Nat("Add-Nat", 4190823648U, 3252578238U, func_Addm_Nat);

#line 258 "Library.sref"

#define ARITHM_PRELUDE \
  refalrts::Iter pFirst = 0, pSecond = 0; \
  refalrts::Iter pFunc \
    = refalrts::call_left(pFirst, pSecond, arg_begin, arg_end); \
  \
  if (pFirst->next != pSecond) { \
    return refalrts::cRecognitionImpossible; \
  } \
  \
  if ( \
    refalrts::cDataNumber != pFirst->tag \
    || refalrts::cDataNumber != pSecond->tag \
  ) { \
    return refalrts::cRecognitionImpossible; \
  } \
  \
  refalrts::RefalNumber first = pFirst->number_info; \
  refalrts::RefalNumber second = pSecond->number_info;

#line 1940 "Library.cpp"
static refalrts::FnResult func_Addm_Digits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 282 "Library.sref"
  ARITHM_PRELUDE

  refalrts::RefalNumber sum = first + second;

  if (sum >= first) {
    pFirst->number_info = sum;
    refalrts::splice_to_freelist(arg_begin, pFunc);
    refalrts::splice_to_freelist(pSecond, arg_end);
  } else {
    pFirst->number_info = 1;
    pSecond->number_info = sum;
    refalrts::splice_to_freelist(arg_begin, pFunc);
    refalrts::splice_to_freelist(arg_end, arg_end);
  }

  return refalrts::cSuccess;
#line 1959 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Addm_Digits("Add-Digits", 4190823648U, 3252578238U, func_Addm_Digits);

static refalrts::FnResult func_Arg(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 308 "Library.sref"
  return arg(arg_begin, arg_end);
#line 1967 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Arg("Arg", 0U, 0U, func_Arg);

static refalrts::FnResult func_Br(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & Br/4 e.Key#1/5 '='/9 e.Value#1/7 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  refalrts::start_e_loop();
  do {
    context[7] = context[2];
    context[8] = context[3];
    context[9] = refalrts::char_left( '=', context[7], context[8] );
    if( ! context[9] )
      continue;
    // closed e.Value#1 as range 7
    //DEBUG: e.Key#1: 5
    //DEBUG: e.Value#1: 7

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </10 Tile{ HalfReuse: & Buried/0 HalfReuse: (/4 AsIs: e.Key#1/5 AsIs: '='/9 AsIs: e.Value#1/7 HalfReuse: )/1 } </11 & Buried/12 >/13 >/14 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[12], ref_Buried.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[14] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_name( context[0], ref_Buried.ref.function );
    refalrts::reinit_open_bracket( context[4] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[10] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[11] );
    refalrts::link_brackets( context[4], context[1] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[11], context[14] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( refalrts::open_evar_advance( context[5], context[6], context[2], context[3] ) );
  return refalrts::cRecognitionImpossible;
}

static refalrts::NativeReference nat_ref_Br("Br", 0U, 0U, func_Br);

static refalrts::FnResult func_Card(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 328 "Library.sref"
  return fread_line(arg_begin, arg_end, cFlags_NoHandle | cFlags_StdIn);
#line 2034 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Card("Card", 0U, 0U, func_Card);

#line 337 "Library.sref"
namespace {

template <typename Conv>
refalrts::FnResult convert(
  refalrts::Iter arg_begin, refalrts::Iter arg_end, Conv conv
) {
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  while (! refalrts::empty_seq(content_b, content_e)) {
    if (conv.for_convert(content_b)) {
      conv.convert(content_b);
    }

    if (content_b->tag != refalrts::cDataOpenADT) {
      refalrts::move_left(content_b, content_e);
    } else {
      refalrts::Iter dummy;
      refalrts::tvar_left(dummy, content_b, content_e);
    }
  }

  refalrts::splice_to_freelist(arg_begin, pfunc);
  refalrts::splice_to_freelist(arg_end, arg_end);

  return refalrts::cSuccess;
}

struct ChrConv {
  bool for_convert(refalrts::Iter item) {
    return refalrts::cDataNumber == item->tag;
  }

  void convert(refalrts::Iter item) {
    item->tag = refalrts::cDataChar;
    item->char_info = static_cast<char>(item->number_info);
  }
};

}  // unnamed namespace
#line 2081 "Library.cpp"
static refalrts::FnResult func_Chr(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 382 "Library.sref"
  return convert(arg_begin, arg_end, ChrConv());
#line 2085 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Chr("Chr", 0U, 0U, func_Chr);

static refalrts::FnResult func_gen_Cp_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 26 elems
  refalrts::Iter context[26];
  refalrts::zeros( context, 26 );
  //FAST GEN: ( e.$ ) e.$
  //GLOBAL GEN: ( e.$ ) e.$
  // </0 & Cp:1/4 (/7 e.idxB#0/5 )/8 e.idxT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  // closed e.idxT#0 as range 2
  do {
    // ( e.idx ) e.idx
    // </0 & Cp:1/4 (/7 e.Key#1/9 )/8 e.Values-B#2/13 (/19 e.Key#1/21 '='/23 e.Value#2/17 )/20 e.Values-E#2/15 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    // closed e.Key#1 as range 9
    context[13] = 0;
    context[14] = 0;
    refalrts::start_e_loop();
    do {
      context[15] = context[11];
      context[16] = context[12];
      context[17] = 0;
      context[18] = 0;
      context[19] = refalrts::brackets_left( context[17], context[18], context[15], context[16] );
      if( ! context[19] )
        continue;
      refalrts::bracket_pointers(context[19], context[20]);
      if( ! refalrts::repeated_evar_left( context[21], context[22], context[9], context[10], context[17], context[18] ) )
        continue;
      context[23] = refalrts::char_left( '=', context[17], context[18] );
      if( ! context[23] )
        continue;
      // closed e.Value#2 as range 17
      // closed e.Values-E#2 as range 15
      //DEBUG: e.Key#1: 9
      //DEBUG: e.Values-B#2: 13
      //DEBUG: e.Value#2: 17
      //DEBUG: e.Values-E#2: 15

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} & Cp:1/4 (/7 e.Key#1/9 {REMOVED TILE}
      //RESULT: Tile{ [[ } e.Value#2/17/24 Tile{ AsIs: </0 } Tile{ HalfReuse: & Buried/8 AsIs: e.Values-B#2/13 AsIs: (/19 AsIs: e.Key#1/21 AsIs: '='/23 AsIs: e.Value#2/17 AsIs: )/20 AsIs: e.Values-E#2/15 AsIs: >/1 ]] }
      if (! refalrts::copy_evar(context[24], context[25], context[17], context[18]))
        return refalrts::cNoMemory;
      refalrts::reinit_name( context[8], ref_Buried.ref.function );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[19], context[20] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[8];
      res = refalrts::splice_evar( res, context[0], context[0] );
      res = refalrts::splice_evar( res, context[24], context[25] );
      refalrts::splice_to_freelist_open( trash_prev, res );
      return refalrts::cSuccess;
    } while ( refalrts::open_evar_advance( context[13], context[14], context[11], context[12] ) );
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) e.idx
  // </0 & Cp:1/4 (/7 e.Key#1/9 )/8 e.Values#2/11 >/1
  context[9] = context[5];
  context[10] = context[6];
  context[11] = context[2];
  context[12] = context[3];
  // closed e.Key#1 as range 9
  // closed e.Values#2 as range 11
  //DEBUG: e.Key#1: 9
  //DEBUG: e.Values#2: 11

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & Cp:1/4 (/7 e.Key#1/9 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 } Tile{ HalfReuse: & Buried/8 AsIs: e.Values#2/11 AsIs: >/1 ]] }
  refalrts::reinit_name( context[8], ref_Buried.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[8];
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Cp_B1("Cp:1", 4190823648U, 3252578238U, func_gen_Cp_B1);

static refalrts::FnResult func_Cp(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  // </0 & Cp/4 e.Key#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Key#1 as range 2
  //DEBUG: e.Key#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 HalfReuse: </4 } & @create_closure@/5 & Cp:1/6 (/7 Tile{ AsIs: e.Key#1/2 } )/8 >/9 </10 & Buried/11 >/12 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_name( context[5], refalrts::create_closure ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_gen_Cp_B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], ref_Buried.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_open_call( context[4] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[4] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[8], context[12] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[5], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Cp("Cp", 0U, 0U, func_Cp);

static refalrts::FnResult func_gen_Dg_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 24 elems
  refalrts::Iter context[24];
  refalrts::zeros( context, 24 );
  //FAST GEN: ( e.$ ) e.$
  //GLOBAL GEN: ( e.$ ) e.$
  // </0 & Dg:1/4 (/7 e.idxB#0/5 )/8 e.idxT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  // closed e.idxT#0 as range 2
  do {
    // ( e.idx ) e.idx
    // </0 & Dg:1/4 (/7 e.Key#1/9 )/8 e.Values-B#2/13 (/19 e.Key#1/21 '='/23 e.Value#2/17 )/20 e.Values-E#2/15 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    // closed e.Key#1 as range 9
    context[13] = 0;
    context[14] = 0;
    refalrts::start_e_loop();
    do {
      context[15] = context[11];
      context[16] = context[12];
      context[17] = 0;
      context[18] = 0;
      context[19] = refalrts::brackets_left( context[17], context[18], context[15], context[16] );
      if( ! context[19] )
        continue;
      refalrts::bracket_pointers(context[19], context[20]);
      if( ! refalrts::repeated_evar_left( context[21], context[22], context[9], context[10], context[17], context[18] ) )
        continue;
      context[23] = refalrts::char_left( '=', context[17], context[18] );
      if( ! context[23] )
        continue;
      // closed e.Value#2 as range 17
      // closed e.Values-E#2 as range 15
      //DEBUG: e.Key#1: 9
      //DEBUG: e.Values-B#2: 13
      //DEBUG: e.Value#2: 17
      //DEBUG: e.Values-E#2: 15

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} (/7 e.Key#1/9 )/8 {REMOVED TILE} (/19 e.Key#1/21 '='/23 {REMOVED TILE} )/20 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: e.Value#2/17 } Tile{ AsIs: </0 Reuse: & Buried/4 } Tile{ AsIs: e.Values-B#2/13 } Tile{ AsIs: e.Values-E#2/15 } Tile{ AsIs: >/1 ]] }
      refalrts::update_name( context[4], ref_Buried.ref.function );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[15], context[16] );
      res = refalrts::splice_evar( res, context[13], context[14] );
      res = refalrts::splice_evar( res, context[0], context[4] );
      res = refalrts::splice_evar( res, context[17], context[18] );
      refalrts::splice_to_freelist_open( trash_prev, res );
      return refalrts::cSuccess;
    } while ( refalrts::open_evar_advance( context[13], context[14], context[11], context[12] ) );
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) e.idx
  // </0 & Dg:1/4 (/7 e.Key#1/9 )/8 e.Values#2/11 >/1
  context[9] = context[5];
  context[10] = context[6];
  context[11] = context[2];
  context[12] = context[3];
  // closed e.Key#1 as range 9
  // closed e.Values#2 as range 11
  //DEBUG: e.Key#1: 9
  //DEBUG: e.Values#2: 11

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & Dg:1/4 (/7 e.Key#1/9 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 } Tile{ HalfReuse: & Buried/8 AsIs: e.Values#2/11 AsIs: >/1 ]] }
  refalrts::reinit_name( context[8], ref_Buried.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[8];
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Dg_B1("Dg:1", 4190823648U, 3252578238U, func_gen_Dg_B1);

static refalrts::FnResult func_Dg(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  // </0 & Dg/4 e.Key#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Key#1 as range 2
  //DEBUG: e.Key#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 HalfReuse: </4 } & @create_closure@/5 & Dg:1/6 (/7 Tile{ AsIs: e.Key#1/2 } )/8 >/9 </10 & Buried/11 >/12 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_name( context[5], refalrts::create_closure ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_gen_Dg_B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], ref_Buried.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_open_call( context[4] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[4] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[8], context[12] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[5], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Dg("Dg", 0U, 0U, func_Dg);

static refalrts::FnResult func_Dgall(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 5 elems
  refalrts::Iter context[5];
  refalrts::zeros( context, 5 );
  // </0 & Dgall/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Buried/4 AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Buried.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Dgall("Dgall", 0U, 0U, func_Dgall);

static refalrts::FnResult func_gen_Div_S1A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  // </0 & Div$1=1/4 (/7 s.Div#2/9 )/8 s.Rem#2/10 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.Div#2: 9
  //DEBUG: s.Rem#2: 10

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Div$1=1/4 (/7 s.Div#2/9 )/8 s.Rem#2/10 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: s.Div2 #9/1 ]] }
  refalrts::reinit_svar( context[1], context[9] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Div_S1A1("Div$1=1", 4190823648U, 3252578238U, func_gen_Div_S1A1);

static refalrts::FnResult func_gen_Div_S2A2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Div$2=2/4 (/7 e.Div#3/5 )/8 e.Mod#3/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Div#3 as range 5
  // closed e.Mod#3 as range 2
  //DEBUG: e.Div#3: 5
  //DEBUG: e.Mod#3: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Div$2=2/4 (/7 {REMOVED TILE} )/8 e.Mod#3/2 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.Div#3/5 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Div_S2A2("Div$2=2", 4190823648U, 3252578238U, func_gen_Div_S2A2);

static refalrts::FnResult func_gen_Div_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & Div$2=1/4 (/7 e.First#2/5 )/8 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#2 as range 5
  // closed e.Second#2 as range 2
  //DEBUG: e.First#2: 5
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </9 & Div$2=2/10 Tile{ AsIs: </0 Reuse: & Divmod-Normed/4 AsIs: (/7 AsIs: e.First#2/5 AsIs: )/8 AsIs: e.Second#2/2 AsIs: >/1 } >/11 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_gen_Div_S2A2.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Divmodm_Normed.ref.function );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Div_S2A1("Div$2=1", 4190823648U, 3252578238U, func_gen_Div_S2A1);

static refalrts::FnResult func_Div(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & Div/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // s.idx s.idx
    // </0 & Div/4 s.First#1/7 s.Second#1/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.First#1: 7
    //DEBUG: s.Second#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </9 & Div$1=1/10 Tile{ AsIs: </0 Reuse: & Divmod-Digits/4 AsIs: s.First#1/7 AsIs: s.Second#1/8 AsIs: >/1 } >/11 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], ref_gen_Div_S1A1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[11] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Divmodm_Digits.ref.function );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[11], context[11] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & Div/4 e.ArithmArg#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.ArithmArg#1 as range 5
  //DEBUG: e.ArithmArg#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </7 & Div$2=1/8 Tile{ AsIs: </0 Reuse: & NormArithmArg/4 AsIs: e.ArithmArg#1/5 AsIs: >/1 } >/9 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_gen_Div_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormArithmArg.ref.function );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Div("Div", 0U, 0U, func_Div);

static refalrts::FnResult func_gen_Divmod_S2A2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  // </0 & Divmod$2=2/4 s.Sign#2/5 (/8 e.First#2/6 )/9 (/12 e.Second#2/10 )/13 e.Signs-B#3/14 s.Sign#2/18 e.Signs-E#3/16 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  context[10] = 0;
  context[11] = 0;
  context[12] = refalrts::brackets_left( context[10], context[11], context[2], context[3] );
  if( ! context[12] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[12], context[13]);
  // closed e.First#2 as range 6
  // closed e.Second#2 as range 10
  context[14] = 0;
  context[15] = 0;
  refalrts::start_e_loop();
  do {
    context[16] = context[2];
    context[17] = context[3];
    if( ! refalrts::repeated_stvar_left( context[18], context[5], context[16], context[17] ) )
      continue;
    // closed e.Signs-E#3 as range 16
    //DEBUG: s.Sign#2: 5
    //DEBUG: e.First#2: 6
    //DEBUG: e.Second#2: 10
    //DEBUG: e.Signs-B#3: 14
    //DEBUG: e.Signs-E#3: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.Sign#2/5 {REMOVED TILE} e.Signs-B#3/14 s.Sign#2/18 e.Signs-E#3/16 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Divmod-Normed/4 } Tile{ AsIs: (/8 AsIs: e.First#2/6 AsIs: )/9 HalfReuse: s.Sign2 #18/12 AsIs: e.Second#2/10 HalfReuse: >/13 } Tile{ ]] }
    refalrts::update_name( context[4], ref_Divmodm_Normed.ref.function );
    refalrts::reinit_svar( context[12], context[18] );
    refalrts::reinit_close_call( context[13] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[8], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[8], context[13] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( refalrts::open_evar_advance( context[14], context[15], context[2], context[3] ) );
  return refalrts::cRecognitionImpossible;
}

static refalrts::NativeReference nat_ref_gen_Divmod_S2A2("Divmod$2=2", 4190823648U, 3252578238U, func_gen_Divmod_S2A2);

static refalrts::FnResult func_gen_Divmod_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 18 elems
  refalrts::Iter context[18];
  refalrts::zeros( context, 18 );
  // </0 & Divmod$2=1/4 (/7 e.First#2/5 )/8 s.Sign#2/9 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#2 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Second#2 as range 2
  //DEBUG: e.First#2: 5
  //DEBUG: s.Sign#2: 9
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} s.Sign#2/9 {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </10 </11 & @create_closure@/12 Tile{ HalfReuse: & Divmod$2=2/0 HalfReuse: s.Sign2 #9/4 AsIs: (/7 AsIs: e.First#2/5 AsIs: )/8 } (/13 Tile{ AsIs: e.Second#2/2 } )/14 >/15"+-"/16 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[12], refalrts::create_closure ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[16], context[17], "+-", 2 ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[0], ref_gen_Divmod_S2A2.ref.function );
  refalrts::reinit_svar( context[4], context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[11] );
  refalrts::link_brackets( context[13], context[14] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[14], context[17] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[13], context[13] );
  res = refalrts::splice_evar( res, context[0], context[8] );
  res = refalrts::splice_evar( res, context[10], context[12] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmod_S2A1("Divmod$2=1", 4190823648U, 3252578238U, func_gen_Divmod_S2A1);

static refalrts::FnResult func_Divmod(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & Divmod/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // s.idx s.idx
    // </0 & Divmod/4 s.First#1/7 s.Second#1/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.First#1: 7
    //DEBUG: s.Second#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Divmod-Digits/4 AsIs: s.First#1/7 AsIs: s.Second#1/8 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Divmodm_Digits.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & Divmod/4 e.ArithmArg#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.ArithmArg#1 as range 5
  //DEBUG: e.ArithmArg#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </7 & Divmod$2=1/8 Tile{ AsIs: </0 Reuse: & NormArithmArg/4 AsIs: e.ArithmArg#1/5 AsIs: >/1 } >/9 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_gen_Divmod_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormArithmArg.ref.function );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmod("Divmod", 0U, 0U, func_Divmod);

static refalrts::FnResult func_Divmodm_Digits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 461 "Library.sref"
  ARITHM_PRELUDE

  if (0 == second) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter pleft_bracket = arg_begin;
  refalrts::Iter pdiv = pFunc;
  refalrts::Iter pright_bracket = pFirst;
  refalrts::Iter pmod = pSecond;
  refalrts::link_brackets(pleft_bracket, pright_bracket);

  refalrts::reinit_open_bracket(pleft_bracket);
  refalrts::reinit_number(pdiv, first / second);
  refalrts::reinit_close_bracket(pright_bracket);
  refalrts::update_number(pmod, first % second);
  refalrts::splice_to_freelist(arg_end, arg_end);

  return refalrts::cSuccess;
#line 2848 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Divmodm_Digits("Divmod-Digits", 4190823648U, 3252578238U, func_Divmodm_Digits);

static refalrts::FnResult func_Divmodm_Normed(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  //FAST GEN: ( e.$ ) e.$
  //GLOBAL GEN: ( s.$ e.$ ) e.$
  // </0 & Divmod-Normed/4 (/7 s.idxB#0/9 e.idxBV#0/5 )/8 e.idxT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxT#0 as range 2
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxBV#0 as range 5
  do {
    // ( '+' e.idx ) '+' e.idx
    // </0 & Divmod-Normed/4 (/7 '+'/9 e.First#1/10 )/8 '+'/14 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '+', context[9] ) )
      continue;
    context[14] = refalrts::char_left( '+', context[12], context[13] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 10
    // closed e.Second#1 as range 12
    //DEBUG: e.First#1: 10
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Divmod-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/10 } Tile{ HalfReuse: )/9 } Tile{ AsIs: e.Second#1/12 } (/15 Tile{ AsIs: )/8 HalfReuse: (/14 } )/16 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[16] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Divmodm_Nat.ref.function );
    refalrts::reinit_close_bracket( context[9] );
    refalrts::reinit_open_bracket( context[14] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[14], context[16] );
    refalrts::link_brackets( context[15], context[8] );
    refalrts::link_brackets( context[7], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[8], context[14] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[12], context[13] );
    res = refalrts::splice_evar( res, context[9], context[9] );
    res = refalrts::splice_evar( res, context[10], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '+' e.idx ) '-' e.idx
    // </0 & Divmod-Normed/4 (/7 '+'/9 e.First#1/10 )/8 '-'/14 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '+', context[9] ) )
      continue;
    context[14] = refalrts::char_left( '-', context[12], context[13] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 10
    // closed e.Second#1 as range 12
    //DEBUG: e.First#1: 10
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Divmod-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/10 } Tile{ HalfReuse: )/9 } Tile{ AsIs: e.Second#1/12 } Tile{ HalfReuse: (/8 AsIs: '-'/14 } )/15 (/16 )/17 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_bracket( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[17] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Divmodm_Nat.ref.function );
    refalrts::reinit_close_bracket( context[9] );
    refalrts::reinit_open_bracket( context[8] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[16], context[17] );
    refalrts::link_brackets( context[8], context[15] );
    refalrts::link_brackets( context[7], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[15], context[17] );
    res = refalrts::splice_evar( res, context[8], context[14] );
    res = refalrts::splice_evar( res, context[12], context[13] );
    res = refalrts::splice_evar( res, context[9], context[9] );
    res = refalrts::splice_evar( res, context[10], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '-' e.idx ) '+' e.idx
    // </0 & Divmod-Normed/4 (/7 '-'/9 e.First#1/10 )/8 '+'/14 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '-', context[9] ) )
      continue;
    context[14] = refalrts::char_left( '+', context[12], context[13] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 10
    // closed e.Second#1 as range 12
    //DEBUG: e.First#1: 10
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Divmod-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/10 } )/15 Tile{ AsIs: e.Second#1/12 } (/16 Tile{ AsIs: '-'/9 } Tile{ AsIs: )/8 HalfReuse: (/14 } '-'/17 )/18 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_bracket( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[17], '-' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[18] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Divmodm_Nat.ref.function );
    refalrts::reinit_open_bracket( context[14] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[14], context[18] );
    refalrts::link_brackets( context[16], context[8] );
    refalrts::link_brackets( context[7], context[15] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[8], context[14] );
    res = refalrts::splice_evar( res, context[9], context[9] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[12], context[13] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[10], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '-' e.idx ) '-' e.idx
    // </0 & Divmod-Normed/4 (/7 '-'/9 e.First#1/10 )/8 '-'/14 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '-', context[9] ) )
      continue;
    context[14] = refalrts::char_left( '-', context[12], context[13] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 10
    // closed e.Second#1 as range 12
    //DEBUG: e.First#1: 10
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Divmod-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/10 } )/15 Tile{ AsIs: e.Second#1/12 } (/16 Tile{ AsIs: )/8 HalfReuse: (/14 } Tile{ AsIs: '-'/9 } )/17 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_bracket( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[17] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Divmodm_Nat.ref.function );
    refalrts::reinit_open_bracket( context[14] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[14], context[17] );
    refalrts::link_brackets( context[16], context[8] );
    refalrts::link_brackets( context[7], context[15] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[17], context[17] );
    res = refalrts::splice_evar( res, context[9], context[9] );
    res = refalrts::splice_evar( res, context[8], context[14] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[12], context[13] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[10], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( 0 ) e.idx
  // </0 & Divmod-Normed/4 (/7 0/9 )/8 e.AnySecond#1/12 >/1
  context[10] = context[5];
  context[11] = context[6];
  context[12] = context[2];
  context[13] = context[3];
  if( ! refalrts::number_term( 0UL, context[9] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[10], context[11] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.AnySecond#1 as range 12
  //DEBUG: e.AnySecond#1: 12

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Divmod-Normed/4 {REMOVED TILE} e.AnySecond#1/12 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: 0/9 AsIs: )/8 } Tile{ HalfReuse: 0/1 ]] }
  refalrts::reinit_number( context[1], 0UL );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmodm_Normed("Divmod-Normed", 4190823648U, 3252578238U, func_Divmodm_Normed);

static refalrts::FnResult func_gen_Divmodm_Nat_S1A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  // </0 & Divmod-Nat$1=1/4 (/7 e.QuotSign#1/5 )/8 (/11 e.RemSing#1/9 )/12 (/15 s.Quot#2/17 )/16 s.Rem#2/18 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  context[13] = 0;
  context[14] = 0;
  context[15] = refalrts::brackets_left( context[13], context[14], context[2], context[3] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[15], context[16]);
  // closed e.QuotSign#1 as range 5
  // closed e.RemSing#1 as range 9
  if( ! refalrts::svar_left( context[17], context[13], context[14] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[13], context[14] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[18], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.QuotSign#1: 5
  //DEBUG: e.RemSing#1: 9
  //DEBUG: s.Quot#2: 17
  //DEBUG: s.Rem#2: 18

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Divmod-Nat$1=1/4 {REMOVED TILE} (/15 s.Quot#2/17 )/16 s.Rem#2/18 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.QuotSign#1/5 HalfReuse: s.Quot2 #17/8 HalfReuse: )/11 AsIs: e.RemSing#1/9 HalfReuse: s.Rem2 #18/12 } Tile{ ]] }
  refalrts::reinit_svar( context[8], context[17] );
  refalrts::reinit_close_bracket( context[11] );
  refalrts::reinit_svar( context[12], context[18] );
  refalrts::link_brackets( context[7], context[11] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[7], context[12] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Nat_S1A1("Divmod-Nat$1=1", 4190823648U, 3252578238U, func_gen_Divmodm_Nat_S1A1);

static refalrts::FnResult func_gen_Divmodm_Nat_S2A5(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 18 elems
  refalrts::Iter context[18];
  refalrts::zeros( context, 18 );
  // </0 & Divmod-Nat$2=5/4 (/8 e.QuotSign#1/6 )/9 (/12 e.Quot#5/10 )/13 (/16 e.RemSing#1/14 )/17 e.Rem#6/2 0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = refalrts::number_right( 0UL, context[2], context[3] );
  if( ! context[5] )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  context[10] = 0;
  context[11] = 0;
  context[12] = refalrts::brackets_left( context[10], context[11], context[2], context[3] );
  if( ! context[12] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[12], context[13]);
  context[14] = 0;
  context[15] = 0;
  context[16] = refalrts::brackets_left( context[14], context[15], context[2], context[3] );
  if( ! context[16] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[16], context[17]);
  // closed e.QuotSign#1 as range 6
  // closed e.Quot#5 as range 10
  // closed e.RemSing#1 as range 14
  // closed e.Rem#6 as range 2
  //DEBUG: e.QuotSign#1: 6
  //DEBUG: e.Quot#5: 10
  //DEBUG: e.RemSing#1: 14
  //DEBUG: e.Rem#6: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & Divmod-Nat$2=5/4 (/8 {REMOVED TILE} )/9 (/12 {REMOVED TILE} )/13 (/16 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} 0/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: (/0 } Tile{ AsIs: e.QuotSign#1/6 } Tile{ AsIs: e.Quot#5/10 } Tile{ AsIs: )/17 } Tile{ AsIs: e.RemSing#1/14 } Tile{ AsIs: e.Rem#6/2 } Tile{ ]] }
  refalrts::reinit_open_bracket( context[0] );
  refalrts::link_brackets( context[0], context[17] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[17], context[17] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Nat_S2A5("Divmod-Nat$2=5", 4190823648U, 3252578238U, func_gen_Divmodm_Nat_S2A5);

static refalrts::FnResult func_gen_Divmodm_Nat_S2A4(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 25 elems
  refalrts::Iter context[25];
  refalrts::zeros( context, 25 );
  // </0 & Divmod-Nat$2=4/4 (/7 e.QuotSign#1/5 )/8 (/11 e.RemSing#1/9 )/12 s.RestoreShift#2/13 (/16 e.Quot#5/14 )/17 e.Rem#5/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.QuotSign#1 as range 5
  // closed e.RemSing#1 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[14] = 0;
  context[15] = 0;
  context[16] = refalrts::brackets_left( context[14], context[15], context[2], context[3] );
  if( ! context[16] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[16], context[17]);
  // closed e.Quot#5 as range 14
  // closed e.Rem#5 as range 2
  //DEBUG: e.QuotSign#1: 5
  //DEBUG: e.RemSing#1: 9
  //DEBUG: s.RestoreShift#2: 13
  //DEBUG: e.Quot#5: 14
  //DEBUG: e.Rem#5: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.RestoreShift#2/13 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </18 </19 Tile{ HalfReuse: & @create_closure@/0 Reuse: & Divmod-Nat$2=5/4 AsIs: (/7 AsIs: e.QuotSign#1/5 AsIs: )/8 AsIs: (/11 } Tile{ AsIs: e.Quot#5/14 } Tile{ AsIs: )/12 } Tile{ AsIs: (/16 } Tile{ AsIs: e.RemSing#1/9 } )/20 >/21 </22 & Divmod-Shl/23 Tile{ HalfReuse: s.RestoreShift2 #13/17 AsIs: e.Rem#5/2 AsIs: >/1 } >/24 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[23], ref_Divmodm_Shl.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[24] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[0], refalrts::create_closure );
  refalrts::update_name( context[4], ref_gen_Divmodm_Nat_S2A5.ref.function );
  refalrts::reinit_svar( context[17], context[13] );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[22] );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[19] );
  refalrts::link_brackets( context[16], context[20] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[24], context[24] );
  res = refalrts::splice_evar( res, context[17], context[1] );
  res = refalrts::splice_evar( res, context[20], context[23] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[16], context[16] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[0], context[11] );
  res = refalrts::splice_evar( res, context[18], context[19] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Nat_S2A4("Divmod-Nat$2=4", 4190823648U, 3252578238U, func_gen_Divmodm_Nat_S2A4);

static refalrts::FnResult func_gen_Divmodm_Nat_S2A3(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 24 elems
  refalrts::Iter context[24];
  refalrts::zeros( context, 24 );
  // </0 & Divmod-Nat$2=3/4 (/7 e.QuotSign#1/5 )/8 (/11 e.RemSing#1/9 )/12 s.RestoreShift#2/13 (/16 e.Numerator#3/14 )/17 e.Denominator#4/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.QuotSign#1 as range 5
  // closed e.RemSing#1 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[14] = 0;
  context[15] = 0;
  context[16] = refalrts::brackets_left( context[14], context[15], context[2], context[3] );
  if( ! context[16] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[16], context[17]);
  // closed e.Numerator#3 as range 14
  // closed e.Denominator#4 as range 2
  //DEBUG: e.QuotSign#1: 5
  //DEBUG: e.RemSing#1: 9
  //DEBUG: s.RestoreShift#2: 13
  //DEBUG: e.Numerator#3: 14
  //DEBUG: e.Denominator#4: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </18 </19 Tile{ HalfReuse: & @create_closure@/0 Reuse: & Divmod-Nat$2=4/4 AsIs: (/7 AsIs: e.QuotSign#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.RemSing#1/9 AsIs: )/12 AsIs: s.RestoreShift#2/13 HalfReuse: >/16 } </20 & Divmod-Nat-Normed/21 (/22 Tile{ AsIs: e.Numerator#3/14 } Tile{ AsIs: )/17 AsIs: e.Denominator#4/2 AsIs: >/1 } >/23 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[21], ref_Divmodm_Natm_Normed.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[23] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[0], refalrts::create_closure );
  refalrts::update_name( context[4], ref_gen_Divmodm_Nat_S2A4.ref.function );
  refalrts::reinit_close_call( context[16] );
  refalrts::push_stack( context[23] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[20] );
  refalrts::link_brackets( context[22], context[17] );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[19] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[23], context[23] );
  res = refalrts::splice_evar( res, context[17], context[1] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[20], context[22] );
  res = refalrts::splice_evar( res, context[0], context[16] );
  res = refalrts::splice_evar( res, context[18], context[19] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Nat_S2A3("Divmod-Nat$2=3", 4190823648U, 3252578238U, func_gen_Divmodm_Nat_S2A3);

static refalrts::FnResult func_gen_Divmodm_Nat_S2A2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 26 elems
  refalrts::Iter context[26];
  refalrts::zeros( context, 26 );
  // </0 & Divmod-Nat$2=2/4 (/7 e.QuotSign#1/5 )/8 (/11 e.RemSing#1/9 )/12 s.RestoreShift#2/13 s.NormShift#2/14 s.DenomFirst#1/15 (/18 e.Denominator#1/16 )/19 e.Numerator#3/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.QuotSign#1 as range 5
  // closed e.RemSing#1 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[14], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[15], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[16] = 0;
  context[17] = 0;
  context[18] = refalrts::brackets_left( context[16], context[17], context[2], context[3] );
  if( ! context[18] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[18], context[19]);
  // closed e.Denominator#1 as range 16
  // closed e.Numerator#3 as range 2
  //DEBUG: e.QuotSign#1: 5
  //DEBUG: e.RemSing#1: 9
  //DEBUG: s.RestoreShift#2: 13
  //DEBUG: s.NormShift#2: 14
  //DEBUG: s.DenomFirst#1: 15
  //DEBUG: e.Denominator#1: 16
  //DEBUG: e.Numerator#3: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </20 </21 Tile{ HalfReuse: & @create_closure@/0 Reuse: & Divmod-Nat$2=3/4 AsIs: (/7 AsIs: e.QuotSign#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.RemSing#1/9 AsIs: )/12 AsIs: s.RestoreShift#2/13 } Tile{ AsIs: (/18 } Tile{ AsIs: e.Numerator#3/2 } Tile{ AsIs: )/19 } >/22 </23 & Divmod-Shl/24 Tile{ AsIs: s.NormShift#2/14 AsIs: s.DenomFirst#1/15 } Tile{ AsIs: e.Denominator#1/16 } >/25 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[23] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[24], ref_Divmodm_Shl.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[25] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[0], refalrts::create_closure );
  refalrts::update_name( context[4], ref_gen_Divmodm_Nat_S2A3.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[25] );
  refalrts::push_stack( context[23] );
  refalrts::push_stack( context[22] );
  refalrts::push_stack( context[21] );
  refalrts::link_brackets( context[18], context[19] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[25], context[25] );
  res = refalrts::splice_evar( res, context[16], context[17] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[22], context[24] );
  res = refalrts::splice_evar( res, context[19], context[19] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[18], context[18] );
  res = refalrts::splice_evar( res, context[0], context[13] );
  res = refalrts::splice_evar( res, context[20], context[21] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Nat_S2A2("Divmod-Nat$2=2", 4190823648U, 3252578238U, func_gen_Divmodm_Nat_S2A2);

static refalrts::FnResult func_gen_Divmodm_Nat_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 29 elems
  refalrts::Iter context[29];
  refalrts::zeros( context, 29 );
  // </0 & Divmod-Nat$2=1/4 (/7 e.QuotSign#1/5 )/8 (/11 e.RemSing#1/9 )/12 s.DenomFirst#1/13 (/16 e.Denominator#1/14 )/17 (/20 e.Numerator#1/18 )/21 s.NormShift#2/22 s.RestoreShift#2/23 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.QuotSign#1 as range 5
  // closed e.RemSing#1 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[14] = 0;
  context[15] = 0;
  context[16] = refalrts::brackets_left( context[14], context[15], context[2], context[3] );
  if( ! context[16] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[16], context[17]);
  context[18] = 0;
  context[19] = 0;
  context[20] = refalrts::brackets_left( context[18], context[19], context[2], context[3] );
  if( ! context[20] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[20], context[21]);
  // closed e.Denominator#1 as range 14
  // closed e.Numerator#1 as range 18
  if( ! refalrts::svar_left( context[22], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[23], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.QuotSign#1: 5
  //DEBUG: e.RemSing#1: 9
  //DEBUG: s.DenomFirst#1: 13
  //DEBUG: e.Denominator#1: 14
  //DEBUG: e.Numerator#1: 18
  //DEBUG: s.NormShift#2: 22
  //DEBUG: s.RestoreShift#2: 23

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </24 </25 Tile{ HalfReuse: & @create_closure@/0 Reuse: & Divmod-Nat$2=2/4 AsIs: (/7 AsIs: e.QuotSign#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.RemSing#1/9 AsIs: )/12 } Tile{ AsIs: s.RestoreShift#2/23 } s.NormShift#2/22/26 Tile{ AsIs: s.DenomFirst#1/13 AsIs: (/16 AsIs: e.Denominator#1/14 AsIs: )/17 HalfReuse: >/20 } </27 Tile{ HalfReuse: & Divmod-Shl/21 AsIs: s.NormShift#2/22 } Tile{ AsIs: e.Numerator#1/18 } >/28 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[24] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[25] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[26], context[22]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[27] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[28] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[0], refalrts::create_closure );
  refalrts::update_name( context[4], ref_gen_Divmodm_Nat_S2A2.ref.function );
  refalrts::reinit_close_call( context[20] );
  refalrts::reinit_name( context[21], ref_Divmodm_Shl.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[28] );
  refalrts::push_stack( context[27] );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[25] );
  refalrts::link_brackets( context[16], context[17] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[28], context[28] );
  res = refalrts::splice_evar( res, context[18], context[19] );
  res = refalrts::splice_evar( res, context[21], context[22] );
  res = refalrts::splice_evar( res, context[27], context[27] );
  res = refalrts::splice_evar( res, context[13], context[20] );
  res = refalrts::splice_evar( res, context[26], context[26] );
  res = refalrts::splice_evar( res, context[23], context[23] );
  res = refalrts::splice_evar( res, context[0], context[12] );
  res = refalrts::splice_evar( res, context[24], context[25] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Nat_S2A1("Divmod-Nat$2=1", 4190823648U, 3252578238U, func_gen_Divmodm_Nat_S2A1);

static refalrts::FnResult func_gen_Divmodm_Nat_S2A1B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 500 "Library.sref"
        refalrts::Iter pfunc = arg_begin->next;
        assert(refalrts::cDataFunction == pfunc->tag);

        refalrts::Iter pvalue = pfunc->next;
        assert(refalrts::cDataNumber == pvalue->tag);

        refalrts::RefalNumber value = pvalue->number_info;
        assert(value != 0);

        int shift = 0;
        while ((value & (1 << 31)) == 0) {
          ++shift;
          value <<= 1;
        }

        refalrts::reinit_number(arg_begin, shift);
        refalrts::reinit_number(pfunc, 32 - shift);
        refalrts::splice_to_freelist(pvalue, arg_end);
        return refalrts::cSuccess;
#line 3598 "Library.cpp"
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Nat_S2A1B1("Divmod-Nat$2=1:1", 4190823648U, 3252578238U, func_gen_Divmodm_Nat_S2A1B1);

static refalrts::FnResult func_Divmodm_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 35 elems
  refalrts::Iter context[35];
  refalrts::zeros( context, 35 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) s.$ e.$ ( e.$ ) ( e.$ )
  // </0 & Divmod-Nat/4 (/7 e.idxB#0/5 )/8 s.idxT#0/17 e.idxTV#0/2 (/15 e.idxTVVB#0/13 )/16 (/11 e.idxTVVTB#0/9 )/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_right( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  context[13] = 0;
  context[14] = 0;
  context[15] = refalrts::brackets_right( context[13], context[14], context[2], context[3] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[15], context[16]);
  // closed e.idxB#0 as range 5
  // closed e.idxTVVB#0 as range 13
  // closed e.idxTVVTB#0 as range 9
  if( ! refalrts::svar_left( context[17], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTV#0 as range 2
  do {
    // ( s.idx ) s.idx ( e.idx ) ( e.idx )
    // </0 & Divmod-Nat/4 (/7 s.Numerator#1/26 )/8 s.Denominator#1/17 (/15 e.QuotSign#1/22 )/16 (/11 e.RemSing#1/24 )/12 >/1
    context[18] = context[5];
    context[19] = context[6];
    context[20] = context[2];
    context[21] = context[3];
    context[22] = context[13];
    context[23] = context[14];
    context[24] = context[9];
    context[25] = context[10];
    if( ! refalrts::empty_seq( context[20], context[21] ) )
      continue;
    // closed e.QuotSign#1 as range 22
    // closed e.RemSing#1 as range 24
    if( ! refalrts::svar_left( context[26], context[18], context[19] ) )
      continue;
    if( ! refalrts::empty_seq( context[18], context[19] ) )
      continue;
    //DEBUG: s.Denominator#1: 17
    //DEBUG: e.QuotSign#1: 22
    //DEBUG: e.RemSing#1: 24
    //DEBUG: s.Numerator#1: 26

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.Numerator#1/26 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 HalfReuse: </4 HalfReuse: & @create_closure@/7 } & Divmod-Nat$1=1/27 Tile{ AsIs: (/15 AsIs: e.QuotSign#1/22 AsIs: )/16 AsIs: (/11 AsIs: e.RemSing#1/24 AsIs: )/12 AsIs: >/1 } </28 & Divmod-Digits/29 Tile{ HalfReuse: s.Numerator1 #26/8 AsIs: s.Denominator#1/17 } >/30 >/31 Tile{ ]] }
    if( ! refalrts::alloc_name( context[27], ref_gen_Divmodm_Nat_S1A1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[28] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[29], ref_Divmodm_Digits.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[30] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[31] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], refalrts::create_closure );
    refalrts::reinit_svar( context[8], context[26] );
    refalrts::push_stack( context[31] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[30] );
    refalrts::push_stack( context[28] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::link_brackets( context[15], context[16] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[30], context[31] );
    res = refalrts::splice_evar( res, context[8], context[17] );
    res = refalrts::splice_evar( res, context[28], context[29] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[27], context[27] );
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx e.idx ( e.idx ) ( e.idx )
  // </0 & Divmod-Nat/4 (/7 e.Numerator#1/18 )/8 s.DenomFirst#1/17 e.Denominator#1/20 (/15 e.QuotSign#1/22 )/16 (/11 e.RemSing#1/24 )/12 >/1
  context[18] = context[5];
  context[19] = context[6];
  context[20] = context[2];
  context[21] = context[3];
  context[22] = context[13];
  context[23] = context[14];
  context[24] = context[9];
  context[25] = context[10];
  // closed e.Numerator#1 as range 18
  // closed e.Denominator#1 as range 20
  // closed e.QuotSign#1 as range 22
  // closed e.RemSing#1 as range 24
  //DEBUG: s.DenomFirst#1: 17
  //DEBUG: e.Numerator#1: 18
  //DEBUG: e.Denominator#1: 20
  //DEBUG: e.QuotSign#1: 22
  //DEBUG: e.RemSing#1: 24

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 } </26 & @create_closure@/27 & Divmod-Nat$2=1/28 Tile{ AsIs: (/15 AsIs: e.QuotSign#1/22 AsIs: )/16 AsIs: (/11 AsIs: e.RemSing#1/24 AsIs: )/12 HalfReuse: s.DenomFirst1 #17/1 } (/29 Tile{ AsIs: e.Denominator#1/20 } Tile{ HalfReuse: )/4 AsIs: (/7 AsIs: e.Numerator#1/18 AsIs: )/8 } >/30 </31 & Divmod-Nat$2=1:1/32 Tile{ AsIs: s.DenomFirst#1/17 } >/33 >/34 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[26] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[27], refalrts::create_closure ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[28], ref_gen_Divmodm_Nat_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[29] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[30] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[31] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[32], ref_gen_Divmodm_Nat_S2A1B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[33] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[34] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_svar( context[1], context[17] );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::push_stack( context[34] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[33] );
  refalrts::push_stack( context[31] );
  refalrts::push_stack( context[30] );
  refalrts::push_stack( context[26] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::link_brackets( context[29], context[4] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[15], context[16] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[33], context[34] );
  res = refalrts::splice_evar( res, context[17], context[17] );
  res = refalrts::splice_evar( res, context[30], context[32] );
  res = refalrts::splice_evar( res, context[4], context[8] );
  res = refalrts::splice_evar( res, context[20], context[21] );
  res = refalrts::splice_evar( res, context[29], context[29] );
  res = refalrts::splice_evar( res, context[15], context[1] );
  res = refalrts::splice_evar( res, context[26], context[28] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmodm_Nat("Divmod-Nat", 4190823648U, 3252578238U, func_Divmodm_Nat);

static refalrts::FnResult func_Divmodm_Shl(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 531 "Library.sref"
  refalrts::Iter digits_b = 0, digits_e = 0;
  refalrts::call_left(digits_b, digits_e, arg_begin, arg_end);

  refalrts::Iter pshift;
  if (
    ! refalrts::svar_left(pshift, digits_b, digits_e)
    && refalrts::cDataNumber != pshift->tag
    && refalrts::empty_seq(digits_b, digits_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber shift = pshift->number_info;
  if (shift > 32) {
    return refalrts::cRecognitionImpossible;
  }

  if (0 == shift) {
    refalrts::splice_to_freelist(arg_begin, pshift);
    refalrts::splice_to_freelist(arg_end, arg_end);
    return refalrts::cSuccess;
  }

  refalrts::Iter garbage_end = pshift;
  refalrts::reinit_number(arg_end, 0);
  if (shift < 32) {
    refalrts::Iter current = digits_e;
    while (current != pshift) {
      current->next->number_info |= current->number_info << shift;
      current->number_info >>= 32 - shift;
      current = current->prev;
    }

    if (0 == digits_b->number_info) {
      garbage_end = digits_b;
    }
  }

  refalrts::splice_to_freelist(arg_begin, garbage_end);
  return refalrts::cSuccess;
#line 3813 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Divmodm_Shl("Divmod-Shl", 4190823648U, 3252578238U, func_Divmodm_Shl);

static refalrts::FnResult func_Divmodm_Natm_Normed(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  // </0 & Divmod-Nat-Normed/4 (/7 e.Numerator#1/5 )/8 e.Denominator#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Numerator#1 as range 5
  // closed e.Denominator#1 as range 2
  //DEBUG: e.Numerator#1: 5
  //DEBUG: e.Denominator#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Divmod-Align/4 AsIs: (/7 } 0/9 )/10 (/11 Tile{ AsIs: e.Numerator#1/5 } )/12 (/13 Tile{ AsIs: )/8 AsIs: e.Denominator#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_number( context[9], 0UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Divmodm_Align.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[13], context[8] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[8];
  res = refalrts::splice_evar( res, context[12], context[13] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[9], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmodm_Natm_Normed("Divmod-Nat-Normed", 4190823648U, 3252578238U, func_Divmodm_Natm_Normed);

static refalrts::FnResult func_gen_Divmodm_Align_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Divmod-Align$2=1/4 e.Quot#2/2 (/7 e.Rest#2/5 )/8 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_right( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Quot#2 as range 2
  // closed e.Rest#2 as range 5
  //DEBUG: e.Quot#2: 2
  //DEBUG: e.Rest#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: (/1 } Tile{ AsIs: </0 Reuse: & LeadingZeros/4 AsIs: e.Quot#2/2 HalfReuse: >/7 } Tile{ AsIs: )/8 } Tile{ AsIs: e.Rest#2/5 } Tile{ ]] }
  refalrts::reinit_open_bracket( context[1] );
  refalrts::update_name( context[4], ref_LeadingZeros.ref.function );
  refalrts::reinit_close_call( context[7] );
  refalrts::link_brackets( context[1], context[8] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[8], context[8] );
  res = refalrts::splice_evar( res, context[0], context[7] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Align_S2A1("Divmod-Align$2=1", 4190823648U, 3252578238U, func_gen_Divmodm_Align_S2A1);

static refalrts::FnResult func_Divmodm_Align(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 29 elems
  refalrts::Iter context[29];
  refalrts::zeros( context, 29 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) ( e.$ ) ( e.$ ) e.$
  // </0 & Divmod-Align/4 (/7 e.idxB#0/5 )/8 (/11 e.idxTB#0/9 )/12 (/15 e.idxTTB#0/13 )/16 e.idxTTT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  context[13] = 0;
  context[14] = 0;
  context[15] = refalrts::brackets_left( context[13], context[14], context[2], context[3] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[15], context[16]);
  // closed e.idxB#0 as range 5
  // closed e.idxTB#0 as range 9
  // closed e.idxTTB#0 as range 13
  // closed e.idxTTT#0 as range 2
  do {
    // ( e.idx ) ( s.idx e.idx ) ( e.idx ) s.idx e.idx
    // </0 & Divmod-Align/4 (/7 e.Numerator#1/17 )/8 (/11 s.N#1/25 e.NumerRest#1/19 )/12 (/15 e.Denominator#1/21 )/16 s.D#1/26 e.DenominRest#1/23 >/1
    context[17] = context[5];
    context[18] = context[6];
    context[19] = context[9];
    context[20] = context[10];
    context[21] = context[13];
    context[22] = context[14];
    context[23] = context[2];
    context[24] = context[3];
    // closed e.Numerator#1 as range 17
    // closed e.Denominator#1 as range 21
    if( ! refalrts::svar_left( context[25], context[19], context[20] ) )
      continue;
    // closed e.NumerRest#1 as range 19
    if( ! refalrts::svar_left( context[26], context[23], context[24] ) )
      continue;
    // closed e.DenominRest#1 as range 23
    //DEBUG: e.Numerator#1: 17
    //DEBUG: e.Denominator#1: 21
    //DEBUG: s.N#1: 25
    //DEBUG: e.NumerRest#1: 19
    //DEBUG: s.D#1: 26
    //DEBUG: e.DenominRest#1: 23

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.N#1/25 {REMOVED TILE} {REMOVED TILE} s.D#1/26 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & Divmod-Align/4 AsIs: (/7 AsIs: e.Numerator#1/17 HalfReuse: s.N1 #25/8 HalfReuse: )/11 } (/27 Tile{ AsIs: e.NumerRest#1/19 } Tile{ AsIs: )/12 AsIs: (/15 AsIs: e.Denominator#1/21 HalfReuse: s.D1 #26/16 } )/28 Tile{ AsIs: e.DenominRest#1/23 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[27] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[28] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_svar( context[8], context[25] );
    refalrts::reinit_close_bracket( context[11] );
    refalrts::reinit_svar( context[16], context[26] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[15], context[28] );
    refalrts::link_brackets( context[27], context[12] );
    refalrts::link_brackets( context[7], context[11] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[28], context[28] );
    res = refalrts::splice_evar( res, context[12], context[16] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[27], context[27] );
    refalrts::splice_to_freelist_open( context[11], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( e.idx ) ( e.idx )
    // </0 & Divmod-Align/4 (/7 e.Numerator#1/17 )/8 (/11 e.NumerRest#1/19 )/12 (/15 e.Denominator#1/21 )/16 >/1
    context[17] = context[5];
    context[18] = context[6];
    context[19] = context[9];
    context[20] = context[10];
    context[21] = context[13];
    context[22] = context[14];
    context[23] = context[2];
    context[24] = context[3];
    if( ! refalrts::empty_seq( context[23], context[24] ) )
      continue;
    // closed e.Numerator#1 as range 17
    // closed e.NumerRest#1 as range 19
    // closed e.Denominator#1 as range 21
    //DEBUG: e.Numerator#1: 17
    //DEBUG: e.NumerRest#1: 19
    //DEBUG: e.Denominator#1: 21

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: </15 } & Divmod-Align$2=1/25 Tile{ AsIs: </0 Reuse: & Divmod-CalcDigits/4 AsIs: (/7 AsIs: e.Numerator#1/17 AsIs: )/8 AsIs: (/11 AsIs: e.NumerRest#1/19 AsIs: )/12 } Tile{ AsIs: e.Denominator#1/21 } Tile{ HalfReuse: >/16 AsIs: >/1 ]] }
    if( ! refalrts::alloc_name( context[25], ref_gen_Divmodm_Align_S2A1.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[15] );
    refalrts::update_name( context[4], ref_Divmodm_CalcDigits.ref.function );
    refalrts::reinit_close_call( context[16] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[16];
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[0], context[12] );
    res = refalrts::splice_evar( res, context[25], context[25] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( 0 e.idx ) ( ) ( e.idx ) e.idx
  // </0 & Divmod-Align/4 (/7 0/25 e.Numerator#1/17 )/8 (/11 )/12 (/15 e.Denominator#1/21 )/16 e.DenominRest#1/23 >/1
  context[17] = context[5];
  context[18] = context[6];
  context[19] = context[9];
  context[20] = context[10];
  context[21] = context[13];
  context[22] = context[14];
  context[23] = context[2];
  context[24] = context[3];
  context[25] = refalrts::number_left( 0UL, context[17], context[18] );
  if( ! context[25] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[19], context[20] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Numerator#1 as range 17
  // closed e.Denominator#1 as range 21
  // closed e.DenominRest#1 as range 23
  //DEBUG: e.Numerator#1: 17
  //DEBUG: e.Denominator#1: 21
  //DEBUG: e.DenominRest#1: 23

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Divmod-Align/4 {REMOVED TILE} {REMOVED TILE} )/8 (/11 )/12 (/15 e.Denominator#1/21 {REMOVED TILE} e.DenominRest#1/23 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: 0/25 } Tile{ AsIs: )/16 } Tile{ AsIs: e.Numerator#1/17 } Tile{ ]] }
  refalrts::link_brackets( context[7], context[16] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[17], context[18] );
  res = refalrts::splice_evar( res, context[16], context[16] );
  res = refalrts::splice_evar( res, context[7], context[25] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmodm_Align("Divmod-Align", 4190823648U, 3252578238U, func_Divmodm_Align);

static refalrts::FnResult func_gen_Divmodm_CalcDigits_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 23 elems
  refalrts::Iter context[23];
  refalrts::zeros( context, 23 );
  //FAST GEN: e.$
  //GLOBAL GEN: s.$ ( e.$ ) ( e.$ ) e.$
  // </0 & Divmod-CalcDigits:1/4 s.idx#0/5 (/8 e.idxVB#0/6 )/9 (/12 e.idxVTB#0/10 )/13 e.idxVTT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  context[10] = 0;
  context[11] = 0;
  context[12] = refalrts::brackets_left( context[10], context[11], context[2], context[3] );
  if( ! context[12] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[12], context[13]);
  // closed e.idxVB#0 as range 6
  // closed e.idxVTB#0 as range 10
  // closed e.idxVTT#0 as range 2
  do {
    // s.idx ( e.idx ) ( e.idx ) s.idx e.idx
    // </0 & Divmod-CalcDigits:1/4 s.QuotDigit#2/5 (/8 e.Rem#2/14 )/9 (/12 e.Denominator#1/16 )/13 s.NextDigit#3/20 e.NumerRest#3/18 >/1
    context[14] = context[6];
    context[15] = context[7];
    context[16] = context[10];
    context[17] = context[11];
    context[18] = context[2];
    context[19] = context[3];
    // closed e.Rem#2 as range 14
    // closed e.Denominator#1 as range 16
    if( ! refalrts::svar_left( context[20], context[18], context[19] ) )
      continue;
    // closed e.NumerRest#3 as range 18
    //DEBUG: s.QuotDigit#2: 5
    //DEBUG: e.Rem#2: 14
    //DEBUG: e.Denominator#1: 16
    //DEBUG: s.NextDigit#3: 20
    //DEBUG: e.NumerRest#3: 18

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.QuotDigit#2/5 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.NextDigit#3/20 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: s.QuotDigit2 #5/0 HalfReuse: </4 } & Divmod-CalcDigits/21 Tile{ AsIs: (/8 AsIs: e.Rem#2/14 HalfReuse: s.NextDigit3 #20/9 HalfReuse: )/12 } (/22 Tile{ AsIs: e.NumerRest#3/18 } Tile{ AsIs: )/13 } Tile{ AsIs: e.Denominator#1/16 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_name( context[21], ref_Divmodm_CalcDigits.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[22] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_svar( context[0], context[5] );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_svar( context[9], context[20] );
    refalrts::reinit_close_bracket( context[12] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[22], context[13] );
    refalrts::link_brackets( context[8], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[22], context[22] );
    res = refalrts::splice_evar( res, context[8], context[12] );
    res = refalrts::splice_evar( res, context[21], context[21] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx ( e.idx ) ( e.idx )
  // </0 & Divmod-CalcDigits:1/4 s.QuotDigit#2/5 (/8 e.Rem#2/14 )/9 (/12 e.Denominator#1/16 )/13 >/1
  context[14] = context[6];
  context[15] = context[7];
  context[16] = context[10];
  context[17] = context[11];
  context[18] = context[2];
  context[19] = context[3];
  if( ! refalrts::empty_seq( context[18], context[19] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Rem#2 as range 14
  // closed e.Denominator#1 as range 16
  //DEBUG: s.QuotDigit#2: 5
  //DEBUG: e.Rem#2: 14
  //DEBUG: e.Denominator#1: 16

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Divmod-CalcDigits:1/4 {REMOVED TILE} (/12 e.Denominator#1/16 )/13 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: s.QuotDigit#2/5 AsIs: (/8 AsIs: e.Rem#2/14 AsIs: )/9 } Tile{ ]] }
  refalrts::link_brackets( context[8], context[9] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[9] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_CalcDigits_B1("Divmod-CalcDigits:1", 4190823648U, 3252578238U, func_gen_Divmodm_CalcDigits_B1);

static refalrts::FnResult func_gen_Divmodm_CalcDigits_A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 17 elems
  refalrts::Iter context[17];
  refalrts::zeros( context, 17 );
  // </0 & Divmod-CalcDigits=1/4 (/7 e.Denominator#1/5 )/8 (/11 e.NumerRest#1/9 )/12 s.QuotDigit#2/13 e.Rem#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.Denominator#1 as range 5
  // closed e.NumerRest#1 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Rem#2 as range 2
  //DEBUG: e.Denominator#1: 5
  //DEBUG: e.NumerRest#1: 9
  //DEBUG: s.QuotDigit#2: 13
  //DEBUG: e.Rem#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 } Tile{ HalfReuse: </1 } & @create_closure@/14 & Divmod-CalcDigits:1/15 Tile{ AsIs: s.QuotDigit#2/13 } (/16 Tile{ AsIs: e.Rem#2/2 } Tile{ HalfReuse: )/4 AsIs: (/7 AsIs: e.Denominator#1/5 AsIs: )/8 HalfReuse: >/11 AsIs: e.NumerRest#1/9 HalfReuse: >/12 } Tile{ ]] }
  if( ! refalrts::alloc_name( context[14], refalrts::create_closure ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[15], ref_gen_Divmodm_CalcDigits_B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[16] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_open_call( context[1] );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::reinit_close_call( context[11] );
  refalrts::reinit_close_call( context[12] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[1] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::link_brackets( context[16], context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[4], context[12] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[16], context[16] );
  res = refalrts::splice_evar( res, context[13], context[13] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_CalcDigits_A1("Divmod-CalcDigits=1", 4190823648U, 3252578238U, func_gen_Divmodm_CalcDigits_A1);

static refalrts::FnResult func_Divmodm_CalcDigits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 23 elems
  refalrts::Iter context[23];
  refalrts::zeros( context, 23 );
  // </0 & Divmod-CalcDigits/4 (/7 e.Numerator#1/5 )/8 (/11 e.NumerRest#1/9 )/12 e.Denominator#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.Numerator#1 as range 5
  // closed e.NumerRest#1 as range 9
  // closed e.Denominator#1 as range 2
  //DEBUG: e.Numerator#1: 5
  //DEBUG: e.NumerRest#1: 9
  //DEBUG: e.Denominator#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </13 </14 & @create_closure@/15 & Divmod-CalcDigits=1/16 (/17 e.Denominator#1/2/18 )/20 Tile{ AsIs: (/11 AsIs: e.NumerRest#1/9 AsIs: )/12 } >/21 Tile{ AsIs: </0 Reuse: & Divmod-GetNextDigit/4 AsIs: (/7 AsIs: e.Numerator#1/5 AsIs: )/8 } Tile{ AsIs: e.Denominator#1/2 } >/22 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[15], refalrts::create_closure ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[16], ref_gen_Divmodm_CalcDigits_A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[17] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[18], context[19], context[2], context[3]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[22] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Divmodm_GetNextDigit.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[22] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[14] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[17], context[20] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[22], context[22] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[0], context[8] );
  res = refalrts::splice_evar( res, context[21], context[21] );
  res = refalrts::splice_evar( res, context[11], context[12] );
  res = refalrts::splice_evar( res, context[13], context[20] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmodm_CalcDigits("Divmod-CalcDigits", 4190823648U, 3252578238U, func_Divmodm_CalcDigits);

static refalrts::FnResult func_gen_Divmodm_GetNextDigit_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 33 elems
  refalrts::Iter context[33];
  refalrts::zeros( context, 33 );
  // </0 & Divmod-GetNextDigit$2=1/4 s.N1#1/5 s.N2#1/6 (/9 e.Numerator#1/7 )/10 s.D#1/11 (/14 e.Denominator#1/12 )/15 s.QuotDigit#2/16 s.RemDigit#2/17 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[7] = 0;
  context[8] = 0;
  context[9] = refalrts::brackets_left( context[7], context[8], context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[9], context[10]);
  // closed e.Numerator#1 as range 7
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[12] = 0;
  context[13] = 0;
  context[14] = refalrts::brackets_left( context[12], context[13], context[2], context[3] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[14], context[15]);
  // closed e.Denominator#1 as range 12
  if( ! refalrts::svar_left( context[16], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[17], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.N1#1: 5
  //DEBUG: s.N2#1: 6
  //DEBUG: e.Numerator#1: 7
  //DEBUG: s.D#1: 11
  //DEBUG: e.Denominator#1: 12
  //DEBUG: s.QuotDigit#2: 16
  //DEBUG: s.RemDigit#2: 17

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.RemDigit#2/17 {REMOVED TILE}
  //RESULT: Tile{ [[ } </18 & Divmod-AdjustDigit/19 s.QuotDigit#2/16/20 </21 & Sub-Normed/22 Tile{ AsIs: (/9 } '+'/23 Tile{ AsIs: </0 Reuse: & LeadingZeros/4 AsIs: s.N1#1/5 AsIs: s.N2#1/6 } Tile{ AsIs: e.Numerator#1/7 } >/24 )/25 '+'/26 </27 Tile{ HalfReuse: & Mul-Nat-Line/10 AsIs: s.D#1/11 } e.Denominator#1/12/28 Tile{ AsIs: s.QuotDigit#2/16 } >/30 >/31 (/32 Tile{ HalfReuse: s.D1 #11/14 AsIs: e.Denominator#1/12 AsIs: )/15 } Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], ref_Divmodm_AdjustDigit.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[20], context[16]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[22], ref_Subm_Normed.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[23], '+' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[24] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[25] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[26], '+' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[27] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[28], context[29], context[12], context[13]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[30] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[31] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[32] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_LeadingZeros.ref.function );
  refalrts::reinit_name( context[10], ref_Mulm_Natm_Line.ref.function );
  refalrts::reinit_svar( context[14], context[11] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[18] );
  refalrts::link_brackets( context[32], context[15] );
  refalrts::push_stack( context[31] );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[30] );
  refalrts::push_stack( context[27] );
  refalrts::link_brackets( context[9], context[25] );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[30], context[32] );
  res = refalrts::splice_evar( res, context[16], context[16] );
  res = refalrts::splice_evar( res, context[28], context[29] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  res = refalrts::splice_evar( res, context[24], context[27] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  res = refalrts::splice_evar( res, context[0], context[6] );
  res = refalrts::splice_evar( res, context[23], context[23] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[18], context[22] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_GetNextDigit_S2A1("Divmod-GetNextDigit$2=1", 4190823648U, 3252578238U, func_gen_Divmodm_GetNextDigit_S2A1);

static refalrts::FnResult func_Divmodm_GetNextDigit(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 27 elems
  refalrts::Iter context[27];
  refalrts::zeros( context, 27 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) s.$ e.$
  // </0 & Divmod-GetNextDigit/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 e.idxTV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTV#0 as range 2
  do {
    // ( s.idx s.idx ) s.idx
    // </0 & Divmod-GetNextDigit/4 (/7 s.N1#1/14 s.N2#1/15 )/8 s.D#1/9 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::empty_seq( context[12], context[13] ) )
      continue;
    if( ! refalrts::svar_left( context[14], context[10], context[11] ) )
      continue;
    if( ! refalrts::svar_left( context[15], context[10], context[11] ) )
      continue;
    if( ! refalrts::empty_seq( context[10], context[11] ) )
      continue;
    //DEBUG: s.D#1: 9
    //DEBUG: s.N1#1: 14
    //DEBUG: s.N2#1: 15

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.N1#1/14 s.N2#1/15 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Divmod-GuessDigit/4 HalfReuse: s.N11 #14/7 } Tile{ HalfReuse: s.N21 #15/8 AsIs: s.D#1/9 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Divmodm_GuessDigit.ref.function );
    refalrts::reinit_svar( context[7], context[14] );
    refalrts::reinit_svar( context[8], context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[8];
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( s.idx s.idx e.idx ) s.idx e.idx
  // </0 & Divmod-GetNextDigit/4 (/7 s.N1#1/14 s.N2#1/15 e.Numerator#1/10 )/8 s.D#1/9 e.Denominator#1/12 >/1
  context[10] = context[5];
  context[11] = context[6];
  context[12] = context[2];
  context[13] = context[3];
  // closed e.Denominator#1 as range 12
  if( ! refalrts::svar_left( context[14], context[10], context[11] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[15], context[10], context[11] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Numerator#1 as range 10
  //DEBUG: s.D#1: 9
  //DEBUG: e.Denominator#1: 12
  //DEBUG: s.N1#1: 14
  //DEBUG: s.N2#1: 15
  //DEBUG: e.Numerator#1: 10

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </16 Tile{ AsIs: </0 Reuse: & @create_closure@/4 HalfReuse: & Divmod-GetNextDigit$2=1/7 AsIs: s.N1#1/14 AsIs: s.N2#1/15 } (/17 Tile{ AsIs: e.Numerator#1/10 } Tile{ AsIs: )/8 AsIs: s.D#1/9 } (/18 Tile{ AsIs: e.Denominator#1/12 } )/19 >/20 </21 & Divmod-GuessDigit/22 s.N1#1/14/23 s.N2#1/15/24 s.D#1/9/25 >/26 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[22], ref_Divmodm_GuessDigit.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[23], context[14]))
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[24], context[15]))
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[25], context[9]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[26] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], refalrts::create_closure );
  refalrts::reinit_name( context[7], ref_gen_Divmodm_GetNextDigit_S2A1.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[26] );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[18], context[19] );
  refalrts::link_brackets( context[17], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[19], context[26] );
  res = refalrts::splice_evar( res, context[12], context[13] );
  res = refalrts::splice_evar( res, context[18], context[18] );
  res = refalrts::splice_evar( res, context[8], context[9] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  res = refalrts::splice_evar( res, context[17], context[17] );
  res = refalrts::splice_evar( res, context[0], context[15] );
  res = refalrts::splice_evar( res, context[16], context[16] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmodm_GetNextDigit("Divmod-GetNextDigit", 4190823648U, 3252578238U, func_Divmodm_GetNextDigit);

static refalrts::FnResult func_Divmodm_AdjustDigit(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 25 elems
  refalrts::Iter context[25];
  refalrts::zeros( context, 25 );
  //FAST GEN: s.$ e.$ ( e.$ )
  //GLOBAL GEN: s.$ e.$ ( e.$ )
  // </0 & Divmod-AdjustDigit/4 s.idx#0/9 e.idxV#0/2 (/7 e.idxVVB#0/5 )/8 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_right( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxVVB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxV#0 as range 2
  do {
    // s.idx '-' e.idx ( e.idx )
    // </0 & Divmod-AdjustDigit/4 s.QuotDigit#1/9 '-'/14 e.Rem#1/10 (/7 e.Denominator#1/12 )/8 >/1
    context[10] = context[2];
    context[11] = context[3];
    context[12] = context[5];
    context[13] = context[6];
    context[14] = refalrts::char_left( '-', context[10], context[11] );
    if( ! context[14] )
      continue;
    // closed e.Rem#1 as range 10
    // closed e.Denominator#1 as range 12
    //DEBUG: s.QuotDigit#1: 9
    //DEBUG: e.Rem#1: 10
    //DEBUG: e.Denominator#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </15 & Divmod-AdjustDigit/16 Tile{ AsIs: </0 Reuse: & Sub-Digits/4 AsIs: s.QuotDigit#1/9 HalfReuse: 1/14 } >/17 </18 & Sub-Nat/19 (/20 e.Denominator#1/12/21 )/23 Tile{ AsIs: e.Rem#1/10 } >/24 Tile{ AsIs: (/7 AsIs: e.Denominator#1/12 AsIs: )/8 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[16], ref_Divmodm_AdjustDigit.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[19], ref_Subm_Nat.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[20] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[21], context[22], context[12], context[13]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[24] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Subm_Digits.ref.function );
    refalrts::reinit_number( context[14], 1UL );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[15] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[18] );
    refalrts::link_brackets( context[20], context[23] );
    refalrts::push_stack( context[17] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[7];
    res = refalrts::splice_evar( res, context[24], context[24] );
    res = refalrts::splice_evar( res, context[10], context[11] );
    res = refalrts::splice_evar( res, context[17], context[23] );
    res = refalrts::splice_evar( res, context[0], context[14] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx e.idx ( e.idx )
  // </0 & Divmod-AdjustDigit/4 s.QuotDigit#1/9 e.Rem#1/10 (/7 e.Denominator#1/12 )/8 >/1
  context[10] = context[2];
  context[11] = context[3];
  context[12] = context[5];
  context[13] = context[6];
  // closed e.Rem#1 as range 10
  // closed e.Denominator#1 as range 12
  //DEBUG: s.QuotDigit#1: 9
  //DEBUG: e.Rem#1: 10
  //DEBUG: e.Denominator#1: 12

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & Divmod-AdjustDigit/4 s.QuotDigit#1/9 {REMOVED TILE} (/7 e.Denominator#1/12 )/8 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: s.QuotDigit1 #9/0 } Tile{ AsIs: e.Rem#1/10 } Tile{ ]] }
  refalrts::reinit_svar( context[0], context[9] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[10], context[11] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmodm_AdjustDigit("Divmod-AdjustDigit", 4190823648U, 3252578238U, func_Divmodm_AdjustDigit);

#line 634 "Library.sref"
namespace {

void long_mul(
  refalrts::UInt32& res_high, refalrts::UInt32& res_low,
  refalrts::UInt32 first, refalrts::UInt32 second
);

}  // unnamed namespace
#line 4695 "Library.cpp"
static refalrts::FnResult func_Divmodm_GuessDigit(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 646 "Library.sref"
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pN1 = 0, pN2 = 0, pD = 0;
  if (
    ! refalrts::svar_left(pN1, content_b, content_e)
    || refalrts::cDataNumber != pN1->tag
    || ! refalrts::svar_left(pN2, content_b, content_e)
    || refalrts::cDataNumber != pN2->tag
    || ! refalrts::svar_left(pD, content_b, content_e)
    || refalrts::cDataNumber != pD->tag
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }


  using refalrts::UInt32;
  UInt32 num_hi = pN1->number_info;
  UInt32 num_lo = pN2->number_info;
  UInt32 denom = pD->number_info;

  if (num_hi >= denom) {
    refalrts::reinit_number(arg_begin, 4294967295);
    refalrts::reinit_char(pfunc, '*');
    refalrts::splice_to_freelist(pN1, arg_end);
    return refalrts::cSuccess;
  }

  if (num_hi >= denom || (denom & (1 << 31)) == 0) {
    return refalrts::cRecognitionImpossible;
  }

  UInt32 denom_half_hi = denom >> 16;
  UInt32 quot_hi = num_hi / denom_half_hi;
  if (quot_hi >= 65536) {
    quot_hi = 65535;
  }

  UInt32 subst_hi, subst_lo;
  while (true) {
    long_mul(subst_hi, subst_lo, quot_hi << 16, denom);

    if (subst_hi < num_hi || (subst_hi == num_hi && subst_lo <= num_lo)) {
      break;
    }
    --quot_hi;
  }

  if (subst_lo > num_lo) {
    --num_hi;
  }
  num_lo -= subst_lo;
  num_hi -= subst_hi;

  assert(num_hi < 65536);

  UInt32 num_major = (num_hi << 16) | (num_lo >> 16);
  assert(num_major < denom);
  UInt32 quot_lo = (num_major) / denom_half_hi;

  while (true) {
    long_mul(subst_hi, subst_lo, quot_lo, denom);

    if (subst_hi < num_hi || (subst_hi == num_hi && subst_lo <= num_lo)) {
      break;
    }
    --quot_lo;
  }

  if (subst_lo > num_lo) {
    --num_hi;
  }
  num_lo -= subst_lo;
  num_hi -= subst_hi;

  assert(num_hi == 0);

  UInt32 quot = (quot_hi << 16) + quot_lo;
  UInt32 rem = num_lo;

  refalrts::reinit_number(arg_begin, quot);
  refalrts::reinit_number(pfunc, rem);
  refalrts::splice_to_freelist(pN1, arg_end);

  return refalrts::cSuccess;
#line 4785 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Divmodm_GuessDigit("Divmod-GuessDigit", 4190823648U, 3252578238U, func_Divmodm_GuessDigit);

static refalrts::FnResult func_Explode(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 743 "Library.sref"
  return explode(arg_begin, arg_end);
#line 4793 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Explode("Explode", 0U, 0U, func_Explode);

static refalrts::FnResult func_First(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  // </0 & First/4 s.N#1/5 e.Expr#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Expr#1 as range 2
  //DEBUG: s.N#1: 5
  //DEBUG: e.Expr#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & DoFirst/4 AsIs: s.N#1/5 } (/6 )/7 Tile{ AsIs: e.Expr#1/2 } Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[7] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_DoFirst.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[6], context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_First("First", 0U, 0U, func_First);

static refalrts::FnResult func_DoFirst(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 20 elems
  refalrts::Iter context[20];
  refalrts::zeros( context, 20 );
  //FAST GEN: e.$
  //GLOBAL GEN: s.$ ( e.$ ) e.$
  // </0 & DoFirst/4 s.idx#0/5 (/8 e.idxVB#0/6 )/9 e.idxVT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  // closed e.idxVB#0 as range 6
  // closed e.idxVT#0 as range 2
  do {
    // 0 ( e.idx ) e.idx
    // </0 & DoFirst/4 0/5 (/8 e.Prefix#1/10 )/9 e.Suffix#1/12 >/1
    context[10] = context[6];
    context[11] = context[7];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::number_term( 0UL, context[5] ) )
      continue;
    // closed e.Prefix#1 as range 10
    // closed e.Suffix#1 as range 12
    //DEBUG: e.Prefix#1: 10
    //DEBUG: e.Suffix#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & DoFirst/4 0/5 {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/8 AsIs: e.Prefix#1/10 AsIs: )/9 } Tile{ AsIs: e.Suffix#1/12 } Tile{ ]] }
    refalrts::link_brackets( context[8], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[12], context[13] );
    res = refalrts::splice_evar( res, context[8], context[9] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // s.idx ( e.idx )
    // </0 & DoFirst/4 s.N#1/5 (/8 e.Prefix#1/10 )/9 >/1
    context[10] = context[6];
    context[11] = context[7];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::empty_seq( context[12], context[13] ) )
      continue;
    // closed e.Prefix#1 as range 10
    //DEBUG: s.N#1: 5
    //DEBUG: e.Prefix#1: 10

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & DoFirst/4 s.N#1/5 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/8 AsIs: e.Prefix#1/10 AsIs: )/9 } Tile{ ]] }
    refalrts::link_brackets( context[8], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[8], context[9] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx ( e.idx ) t.idx e.idx
  // </0 & DoFirst/4 s.N#1/5 (/8 e.Prefix#1/10 )/9 t.Next#1/14 e.Suffix#1/12 >/1
  context[10] = context[6];
  context[11] = context[7];
  context[12] = context[2];
  context[13] = context[3];
  // closed e.Prefix#1 as range 10
  context[15] = refalrts::tvar_left( context[14], context[12], context[13] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  // closed e.Suffix#1 as range 12
  //DEBUG: s.N#1: 5
  //DEBUG: e.Prefix#1: 10
  //DEBUG: t.Next#1: 14
  //DEBUG: e.Suffix#1: 12

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoFirst/4 } </16 & Sub-Digits/17 Tile{ AsIs: s.N#1/5 HalfReuse: 1/8 } >/18 (/19 Tile{ AsIs: e.Prefix#1/10 } Tile{ AsIs: t.Next#1/14 } Tile{ AsIs: )/9 } Tile{ AsIs: e.Suffix#1/12 } Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[17], ref_Subm_Digits.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[19] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_number( context[8], 1UL );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[19], context[9] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[16] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[12], context[13] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  res = refalrts::splice_evar( res, context[18], context[19] );
  res = refalrts::splice_evar( res, context[5], context[8] );
  res = refalrts::splice_evar( res, context[16], context[17] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DoFirst("DoFirst", 4190823648U, 3252578238U, func_DoFirst);

static refalrts::FnResult func_Get(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 772 "Library.sref"
  return fread_line(
    arg_begin, arg_end, cFlags_Autoopen | cFlags_Read | cFlags_StdIn
  );
#line 4968 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Get("Get", 0U, 0U, func_Get);

static refalrts::FnResult func_gen_Implode_S1B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  //FAST GEN: ( e.$ ) s.$ s.$ s.$
  //GLOBAL GEN: ( e.$ ) s.$ s.$ s.$
  // </0 & Implode$1:1/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 s.idxTV#0/10 s.idxTVV#0/11 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // ( e.idx ) 'L' s.idx s.idx
    // </0 & Implode$1:1/4 (/7 e.Tail#1/12 )/8 'L'/9 s.SubType#2/10 s.Init#2/11 >/1
    context[12] = context[5];
    context[13] = context[6];
    if( ! refalrts::char_term( 'L', context[9] ) )
      continue;
    // closed e.Tail#1 as range 12
    //DEBUG: s.SubType#2: 10
    //DEBUG: s.Init#2: 11
    //DEBUG: e.Tail#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} 'L'/9 s.SubType#2/10 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & DoImplode/4 AsIs: (/7 } Tile{ AsIs: s.Init#2/11 } Tile{ AsIs: )/8 } Tile{ AsIs: e.Tail#1/12 } Tile{ AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_DoImplode.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[12], context[13] );
    res = refalrts::splice_evar( res, context[8], context[8] );
    res = refalrts::splice_evar( res, context[11], context[11] );
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx s.idx s.idx
  // </0 & Implode$1:1/4 (/7 e.Tail#1/12 )/8 s.Type#2/9 s.SubType#2/10 s.Init#2/11 >/1
  context[12] = context[5];
  context[13] = context[6];
  // closed e.Tail#1 as range 12
  //DEBUG: s.Type#2: 9
  //DEBUG: s.SubType#2: 10
  //DEBUG: s.Init#2: 11
  //DEBUG: e.Tail#1: 12

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 s.Type#2/9 s.SubType#2/10 s.Init#2/11 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 0/0 HalfReuse: s.Init2 #11/4 } Tile{ AsIs: e.Tail#1/12 } Tile{ ]] }
  refalrts::reinit_number( context[0], 0UL );
  refalrts::reinit_svar( context[4], context[11] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[12], context[13] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Implode_S1B1("Implode$1:1", 4190823648U, 3252578238U, func_gen_Implode_S1B1);

static refalrts::FnResult func_Implode(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & Implode/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // s.idx e.idx
    // </0 & Implode/4 s.Init#1/7 e.Tail#1/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    // closed e.Tail#1 as range 5
    //DEBUG: s.Init#1: 7
    //DEBUG: e.Tail#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </8 </9 & @create_closure@/10 & Implode$1:1/11 (/12 Tile{ AsIs: e.Tail#1/5 } )/13 >/14 Tile{ AsIs: </0 Reuse: & Type/4 AsIs: s.Init#1/7 } >/15 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], refalrts::create_closure ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[11], ref_gen_Implode_S1B1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[15] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Type.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[9] );
    refalrts::link_brackets( context[12], context[13] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[0], context[7] );
    res = refalrts::splice_evar( res, context[13], context[14] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[8], context[12] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & Implode/4 e.InvalidExpr#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.InvalidExpr#1 as range 5
  //DEBUG: e.InvalidExpr#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & Implode/4 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 0/0 } Tile{ AsIs: e.InvalidExpr#1/5 } Tile{ ]] }
  refalrts::reinit_number( context[0], 0UL );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Implode("Implode", 0U, 0U, func_Implode);

static refalrts::FnResult func_gen_DoImplode_S4B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 20 elems
  refalrts::Iter context[20];
  refalrts::zeros( context, 20 );
  //FAST GEN: ( e.$ ) ( e.$ ) s.$ s.$ s.$
  //GLOBAL GEN: ( e.$ ) ( e.$ ) s.$ s.$ s.$
  // </0 & DoImplode$4:1/4 (/7 e.idxB#0/5 )/8 (/11 e.idxTB#0/9 )/12 s.idxTT#0/13 s.idxTTV#0/14 s.idxTTVV#0/15 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.idxB#0 as range 5
  // closed e.idxTB#0 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[14], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[15], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // ( e.idx ) ( e.idx ) 'L' s.idx s.idx
    // </0 & DoImplode$4:1/4 (/7 e.Scanned#1/16 )/8 (/11 e.Tail#1/18 )/12 'L'/13 s.SubType#2/14 s.Lettern#2/15 >/1
    context[16] = context[5];
    context[17] = context[6];
    context[18] = context[9];
    context[19] = context[10];
    if( ! refalrts::char_term( 'L', context[13] ) )
      continue;
    // closed e.Scanned#1 as range 16
    // closed e.Tail#1 as range 18
    //DEBUG: s.SubType#2: 14
    //DEBUG: s.Lettern#2: 15
    //DEBUG: e.Scanned#1: 16
    //DEBUG: e.Tail#1: 18

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} 'L'/13 s.SubType#2/14 s.Lettern#2/15 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & DoImplode/4 AsIs: (/7 AsIs: e.Scanned#1/16 HalfReuse: s.Lettern2 #15/8 HalfReuse: )/11 AsIs: e.Tail#1/18 HalfReuse: >/12 } Tile{ ]] }
    refalrts::update_name( context[4], ref_DoImplode.ref.function );
    refalrts::reinit_svar( context[8], context[15] );
    refalrts::reinit_close_bracket( context[11] );
    refalrts::reinit_close_call( context[12] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[11] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    refalrts::splice_to_freelist_open( context[12], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( e.idx ) 'D' s.idx s.idx
    // </0 & DoImplode$4:1/4 (/7 e.Scanned#1/16 )/8 (/11 e.Tail#1/18 )/12 'D'/13 s.SubType#2/14 s.Digit#2/15 >/1
    context[16] = context[5];
    context[17] = context[6];
    context[18] = context[9];
    context[19] = context[10];
    if( ! refalrts::char_term( 'D', context[13] ) )
      continue;
    // closed e.Scanned#1 as range 16
    // closed e.Tail#1 as range 18
    //DEBUG: s.SubType#2: 14
    //DEBUG: s.Digit#2: 15
    //DEBUG: e.Scanned#1: 16
    //DEBUG: e.Tail#1: 18

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} 'D'/13 s.SubType#2/14 s.Digit#2/15 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & DoImplode/4 AsIs: (/7 AsIs: e.Scanned#1/16 HalfReuse: s.Digit2 #15/8 HalfReuse: )/11 AsIs: e.Tail#1/18 HalfReuse: >/12 } Tile{ ]] }
    refalrts::update_name( context[4], ref_DoImplode.ref.function );
    refalrts::reinit_svar( context[8], context[15] );
    refalrts::reinit_close_bracket( context[11] );
    refalrts::reinit_close_call( context[12] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[11] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    refalrts::splice_to_freelist_open( context[12], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) ( e.idx ) s.idx s.idx s.idx
  // </0 & DoImplode$4:1/4 (/7 e.Scanned#1/16 )/8 (/11 e.Tail#1/18 )/12 s.Type#2/13 s.SubType#2/14 s.Other#2/15 >/1
  context[16] = context[5];
  context[17] = context[6];
  context[18] = context[9];
  context[19] = context[10];
  // closed e.Scanned#1 as range 16
  // closed e.Tail#1 as range 18
  //DEBUG: s.Type#2: 13
  //DEBUG: s.SubType#2: 14
  //DEBUG: s.Other#2: 15
  //DEBUG: e.Scanned#1: 16
  //DEBUG: e.Tail#1: 18

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 (/11 {REMOVED TILE} )/12 s.Type#2/13 s.SubType#2/14 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Implode_Ext/4 } Tile{ AsIs: e.Scanned#1/16 } Tile{ AsIs: >/1 } Tile{ AsIs: s.Other#2/15 } Tile{ AsIs: e.Tail#1/18 } Tile{ ]] }
  refalrts::update_name( context[4], ref_Implodeu_Ext.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[18], context[19] );
  res = refalrts::splice_evar( res, context[15], context[15] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[16], context[17] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_DoImplode_S4B1("DoImplode$4:1", 4190823648U, 3252578238U, func_gen_DoImplode_S4B1);

static refalrts::FnResult func_DoImplode(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 22 elems
  refalrts::Iter context[22];
  refalrts::zeros( context, 22 );
  //FAST GEN: ( e.$ ) e.$
  //GLOBAL GEN: ( e.$ ) e.$
  // </0 & DoImplode/4 (/7 e.idxB#0/5 )/8 e.idxT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  // closed e.idxT#0 as range 2
  do {
    // ( e.idx ) '-' e.idx
    // </0 & DoImplode/4 (/7 e.Scanned#1/9 )/8 '-'/13 e.Tail#1/11 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '-', context[11], context[12] );
    if( ! context[13] )
      continue;
    // closed e.Scanned#1 as range 9
    // closed e.Tail#1 as range 11
    //DEBUG: e.Scanned#1: 9
    //DEBUG: e.Tail#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoImplode/4 AsIs: (/7 AsIs: e.Scanned#1/9 HalfReuse: '-'/8 HalfReuse: )/13 AsIs: e.Tail#1/11 AsIs: >/1 ]] }
    refalrts::reinit_char( context[8], '-' );
    refalrts::reinit_close_bracket( context[13] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[13] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) '_' e.idx
    // </0 & DoImplode/4 (/7 e.Scanned#1/9 )/8 '_'/13 e.Tail#1/11 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '_', context[11], context[12] );
    if( ! context[13] )
      continue;
    // closed e.Scanned#1 as range 9
    // closed e.Tail#1 as range 11
    //DEBUG: e.Scanned#1: 9
    //DEBUG: e.Tail#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoImplode/4 AsIs: (/7 AsIs: e.Scanned#1/9 HalfReuse: '_'/8 HalfReuse: )/13 AsIs: e.Tail#1/11 AsIs: >/1 ]] }
    refalrts::reinit_char( context[8], '_' );
    refalrts::reinit_close_bracket( context[13] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[13] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) '$' e.idx
    // </0 & DoImplode/4 (/7 e.Scanned#1/9 )/8 '$'/13 e.Tail#1/11 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '$', context[11], context[12] );
    if( ! context[13] )
      continue;
    // closed e.Scanned#1 as range 9
    // closed e.Tail#1 as range 11
    //DEBUG: e.Scanned#1: 9
    //DEBUG: e.Tail#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoImplode/4 AsIs: (/7 AsIs: e.Scanned#1/9 HalfReuse: '$'/8 HalfReuse: )/13 AsIs: e.Tail#1/11 AsIs: >/1 ]] }
    refalrts::reinit_char( context[8], '$' );
    refalrts::reinit_close_bracket( context[13] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[13] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) s.idx e.idx
    // </0 & DoImplode/4 (/7 e.Scanned#1/9 )/8 s.Next#1/13 e.Tail#1/11 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    // closed e.Scanned#1 as range 9
    if( ! refalrts::svar_left( context[13], context[11], context[12] ) )
      continue;
    // closed e.Tail#1 as range 11
    //DEBUG: e.Scanned#1: 9
    //DEBUG: s.Next#1: 13
    //DEBUG: e.Tail#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </14 </15 Tile{ HalfReuse: & @create_closure@/0 Reuse: & DoImplode$4:1/4 AsIs: (/7 AsIs: e.Scanned#1/9 AsIs: )/8 } (/16 Tile{ AsIs: e.Tail#1/11 } )/17 >/18 </19 & Type/20 Tile{ AsIs: s.Next#1/13 } >/21 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[20], ref_Type.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_name( context[0], refalrts::create_closure );
    refalrts::update_name( context[4], ref_gen_DoImplode_S4B1.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[15] );
    refalrts::link_brackets( context[16], context[17] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[21], context[21] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[17], context[20] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[0], context[8] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) e.idx
  // </0 & DoImplode/4 (/7 e.Scanned#1/9 )/8 e.Other#1/11 >/1
  context[9] = context[5];
  context[10] = context[6];
  context[11] = context[2];
  context[12] = context[3];
  // closed e.Scanned#1 as range 9
  // closed e.Other#1 as range 11
  //DEBUG: e.Scanned#1: 9
  //DEBUG: e.Other#1: 11

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Implode_Ext/4 } Tile{ AsIs: e.Scanned#1/9 } Tile{ AsIs: >/1 } Tile{ AsIs: e.Other#1/11 } Tile{ ]] }
  refalrts::update_name( context[4], ref_Implodeu_Ext.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[11], context[12] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DoImplode("DoImplode", 4190823648U, 3252578238U, func_DoImplode);

static refalrts::FnResult func_Last(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  // </0 & Last/4 s.N#1/5 e.Expr#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Expr#1 as range 2
  //DEBUG: s.N#1: 5
  //DEBUG: e.Expr#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & DoLast/4 AsIs: s.N#1/5 } (/6 Tile{ AsIs: e.Expr#1/2 } )/7 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[7] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_DoLast.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[6], context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[7], context[7] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[6], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Last("Last", 0U, 0U, func_Last);

static refalrts::FnResult func_DoLast(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 20 elems
  refalrts::Iter context[20];
  refalrts::zeros( context, 20 );
  //FAST GEN: s.$ ( e.$ ) e.$
  //GLOBAL GEN: s.$ ( e.$ ) e.$
  // </0 & DoLast/4 s.idx#0/5 (/8 e.idxVB#0/6 )/9 e.idxVT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  // closed e.idxVB#0 as range 6
  // closed e.idxVT#0 as range 2
  do {
    // 0 ( e.idx ) e.idx
    // </0 & DoLast/4 0/5 (/8 e.Prefix#1/10 )/9 e.Suffix#1/12 >/1
    context[10] = context[6];
    context[11] = context[7];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::number_term( 0UL, context[5] ) )
      continue;
    // closed e.Prefix#1 as range 10
    // closed e.Suffix#1 as range 12
    //DEBUG: e.Prefix#1: 10
    //DEBUG: e.Suffix#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & DoLast/4 0/5 {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/8 AsIs: e.Prefix#1/10 AsIs: )/9 } Tile{ AsIs: e.Suffix#1/12 } Tile{ ]] }
    refalrts::link_brackets( context[8], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[12], context[13] );
    res = refalrts::splice_evar( res, context[8], context[9] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // s.idx ( ) e.idx
    // </0 & DoLast/4 s.N#1/5 (/8 )/9 e.Suffix#1/12 >/1
    context[10] = context[6];
    context[11] = context[7];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::empty_seq( context[10], context[11] ) )
      continue;
    // closed e.Suffix#1 as range 12
    //DEBUG: s.N#1: 5
    //DEBUG: e.Suffix#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & DoLast/4 s.N#1/5 {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/8 AsIs: )/9 } Tile{ AsIs: e.Suffix#1/12 } Tile{ ]] }
    refalrts::link_brackets( context[8], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[12], context[13] );
    res = refalrts::splice_evar( res, context[8], context[9] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx ( e.idx t.idx ) e.idx
  // </0 & DoLast/4 s.N#1/5 (/8 e.Prefix#1/10 t.Next#1/14 )/9 e.Suffix#1/12 >/1
  context[10] = context[6];
  context[11] = context[7];
  context[12] = context[2];
  context[13] = context[3];
  // closed e.Suffix#1 as range 12
  context[15] = refalrts::tvar_right( context[14], context[10], context[11] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  // closed e.Prefix#1 as range 10
  //DEBUG: s.N#1: 5
  //DEBUG: e.Suffix#1: 12
  //DEBUG: t.Next#1: 14
  //DEBUG: e.Prefix#1: 10

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoLast/4 } </16 & Sub-Digits/17 Tile{ AsIs: s.N#1/5 HalfReuse: 1/8 } >/18 (/19 Tile{ AsIs: e.Prefix#1/10 } Tile{ AsIs: )/9 } Tile{ AsIs: t.Next#1/14 } Tile{ AsIs: e.Suffix#1/12 } Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[17], ref_Subm_Digits.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[19] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_number( context[8], 1UL );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[19], context[9] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[16] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[12], context[13] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  res = refalrts::splice_evar( res, context[18], context[19] );
  res = refalrts::splice_evar( res, context[5], context[8] );
  res = refalrts::splice_evar( res, context[16], context[17] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DoLast("DoLast", 4190823648U, 3252578238U, func_DoLast);

static refalrts::FnResult func_Lenw(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  // </0 & Lenw/4 e.Expr#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Expr#1 as range 2
  //DEBUG: e.Expr#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 Tile{ HalfReuse: & DoLenw/0 HalfReuse: 0/4 AsIs: e.Expr#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[0], ref_DoLenw.ref.function );
  refalrts::reinit_number( context[4], 0UL );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[5] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[0];
  res = refalrts::splice_evar( res, context[5], context[5] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Lenw("Lenw", 0U, 0U, func_Lenw);

static refalrts::FnResult func_DoLenw(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  //FAST GEN: e.$
  //GLOBAL GEN: s.$ e.$
  // </0 & DoLenw/4 s.idx#0/5 e.idxV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxV#0 as range 2
  do {
    // s.idx
    // </0 & DoLenw/4 s.Len#1/5 >/1
    context[6] = context[2];
    context[7] = context[3];
    if( ! refalrts::empty_seq( context[6], context[7] ) )
      continue;
    //DEBUG: s.Len#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & DoLenw/4 s.Len#1/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: s.Len1 #5/1 ]] }
    refalrts::reinit_svar( context[1], context[5] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx e.idx t.idx
  // </0 & DoLenw/4 s.Len#1/5 e.Expr#1/6 t.Term#1/8 >/1
  context[6] = context[2];
  context[7] = context[3];
  context[9] = refalrts::tvar_right( context[8], context[6], context[7] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  // closed e.Expr#1 as range 6
  //DEBUG: s.Len#1: 5
  //DEBUG: t.Term#1: 8
  //DEBUG: e.Expr#1: 6

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoLenw/4 } </10 & Add-Digits/11 Tile{ AsIs: s.Len#1/5 } 1/12 Tile{ AsIs: >/1 } Tile{ AsIs: e.Expr#1/6 } >/13 Tile{ AsIs: t.Term#1/8 } Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], ref_Addm_Digits.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[12], 1UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[8], context[9] );
  res = refalrts::splice_evar( res, context[13], context[13] );
  res = refalrts::splice_evar( res, context[6], context[7] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[5], context[5] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DoLenw("DoLenw", 4190823648U, 3252578238U, func_DoLenw);

#line 850 "Library.sref"
namespace {

struct LowerConv {
  bool for_convert(refalrts::Iter item) {
    return refalrts::cDataChar == item->tag;
  }

  void convert(refalrts::Iter item) {
    item->char_info = static_cast<char>(tolower(item->char_info));
  }
};

}  // unnamed namespace
#line 5762 "Library.cpp"
static refalrts::FnResult func_Lower(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 867 "Library.sref"
  return convert(arg_begin, arg_end, LowerConv());
#line 5766 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Lower("Lower", 0U, 0U, func_Lower);

static refalrts::FnResult func_gen_Mod_S1A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  // </0 & Mod$1=1/4 (/7 s.Div#2/9 )/8 s.Mod#2/10 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.Div#2: 9
  //DEBUG: s.Mod#2: 10

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Mod$1=1/4 (/7 s.Div#2/9 )/8 s.Mod#2/10 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: s.Mod2 #10/1 ]] }
  refalrts::reinit_svar( context[1], context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Mod_S1A1("Mod$1=1", 4190823648U, 3252578238U, func_gen_Mod_S1A1);

static refalrts::FnResult func_gen_Mod_S2A2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Mod$2=2/4 (/7 e.Div#3/5 )/8 e.Mod#3/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Div#3 as range 5
  // closed e.Mod#3 as range 2
  //DEBUG: e.Div#3: 5
  //DEBUG: e.Mod#3: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Mod$2=2/4 (/7 e.Div#3/5 )/8 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.Mod#3/2 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Mod_S2A2("Mod$2=2", 4190823648U, 3252578238U, func_gen_Mod_S2A2);

static refalrts::FnResult func_gen_Mod_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & Mod$2=1/4 (/7 e.First#2/5 )/8 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#2 as range 5
  // closed e.Second#2 as range 2
  //DEBUG: e.First#2: 5
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </9 & Mod$2=2/10 Tile{ AsIs: </0 Reuse: & Divmod-Normed/4 AsIs: (/7 AsIs: e.First#2/5 AsIs: )/8 AsIs: e.Second#2/2 AsIs: >/1 } >/11 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_gen_Mod_S2A2.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Divmodm_Normed.ref.function );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Mod_S2A1("Mod$2=1", 4190823648U, 3252578238U, func_gen_Mod_S2A1);

static refalrts::FnResult func_Mod(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & Mod/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // s.idx s.idx
    // </0 & Mod/4 s.First#1/7 s.Second#1/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.First#1: 7
    //DEBUG: s.Second#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </9 & Mod$1=1/10 Tile{ AsIs: </0 Reuse: & Divmod-Digits/4 AsIs: s.First#1/7 AsIs: s.Second#1/8 AsIs: >/1 } >/11 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], ref_gen_Mod_S1A1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[11] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Divmodm_Digits.ref.function );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[11], context[11] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & Mod/4 e.ArithmArg#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.ArithmArg#1 as range 5
  //DEBUG: e.ArithmArg#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </7 & Mod$2=1/8 Tile{ AsIs: </0 Reuse: & NormArithmArg/4 AsIs: e.ArithmArg#1/5 AsIs: >/1 } >/9 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_gen_Mod_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormArithmArg.ref.function );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Mod("Mod", 0U, 0U, func_Mod);

static refalrts::FnResult func_gen_Mul_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Mul$2=1/4 (/7 e.First#2/5 )/8 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#2 as range 5
  // closed e.Second#2 as range 2
  //DEBUG: e.First#2: 5
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Mul-Normed/4 AsIs: (/7 AsIs: e.First#2/5 AsIs: )/8 AsIs: e.Second#2/2 AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Mulm_Normed.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Mul_S2A1("Mul$2=1", 4190823648U, 3252578238U, func_gen_Mul_S2A1);

static refalrts::FnResult func_Mul(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & Mul/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // s.idx s.idx
    // </0 & Mul/4 s.First#1/7 s.Second#1/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.First#1: 7
    //DEBUG: s.Second#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Mul-Digits/4 AsIs: s.First#1/7 AsIs: s.Second#1/8 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Mulm_Digits.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & Mul/4 e.ArithmArg#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.ArithmArg#1 as range 5
  //DEBUG: e.ArithmArg#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </7 & Mul$2=1/8 Tile{ AsIs: </0 Reuse: & NormArithmArg/4 AsIs: e.ArithmArg#1/5 AsIs: >/1 } >/9 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_gen_Mul_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormArithmArg.ref.function );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Mul("Mul", 0U, 0U, func_Mul);

#line 904 "Library.sref"
namespace {

void long_mul(
  refalrts::UInt32& res_high, refalrts::UInt32& res_low,
  refalrts::UInt32 first, refalrts::UInt32 second
) {
  /*
    Double-word multiplication scheme:

    (x,y,z,t) = (F,i)*(S,e)     -- first * second

       S   e        (A,a) = F * S
     ---------      (B,b) = i * S
     |\ b|\ d|      (C,c) = F * e
    i| \ | \ |t     (D,d) = i * e
     |B \|D \|
     ---------      t = d
     |\ a|\ c|      (Z,z) = b + D + c
    F| \ | \ |z     (Y,y) = B + a + C + Z
     |A \|C \|      x = A + Y
     ---------
       x   y        (x,y) = (A, a) + B + C + Z
  */

  using refalrts::UInt32;

  UInt32 F = first >> 16;
  UInt32 i = first & 0xFFFFU;
  UInt32 S = second >> 16;
  UInt32 e = second & 0xFFFFU;

  UInt32 Aa = F * S;
  UInt32 Bb = i * S;
  UInt32 Cc = F * e;
  UInt32 Dd = i * e;

  UInt32 Zz = (Bb & 0xFFFFU) + (Dd >> 16) + (Cc & 0xFFFFU);
  res_low = (Zz << 16) + (Dd & 0xFFFFU);
  res_high = Aa + (Bb >> 16) + (Cc >> 16) + (Zz >> 16);
}

}  // unnamed namespace
#line 6130 "Library.cpp"
static refalrts::FnResult func_Mulm_Digits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 950 "Library.sref"
  ARITHM_PRELUDE

  refalrts::UInt32 res_high, res_low;
  long_mul(res_high, res_low, first, second);

  if (res_high > 0) {
    refalrts::reinit_number(arg_begin, res_high);
    refalrts::reinit_number(pFunc, res_low);
    refalrts::splice_to_freelist(pFirst, arg_end);
  } else {
    refalrts::reinit_number(arg_begin, res_low);
    refalrts::splice_to_freelist(pFunc, arg_end);
  }

  return refalrts::cSuccess;
#line 6148 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Mulm_Digits("Mul-Digits", 4190823648U, 3252578238U, func_Mulm_Digits);

static refalrts::FnResult func_Mulm_Normed(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) e.$
  // </0 & Mul-Normed/4 (/7 e.idxB#0/5 )/8 e.idxT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  // closed e.idxT#0 as range 2
  do {
    // ( '+' e.idx ) '+' e.idx
    // </0 & Mul-Normed/4 (/7 '+'/13 e.First#1/9 )/8 '+'/14 e.Second#1/11 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '+', context[9], context[10] );
    if( ! context[13] )
      continue;
    context[14] = refalrts::char_left( '+', context[11], context[12] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 9
    // closed e.Second#1 as range 11
    //DEBUG: e.First#1: 9
    //DEBUG: e.Second#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} '+'/13 {REMOVED TILE} )/8 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Mul-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/9 } Tile{ HalfReuse: )/14 AsIs: e.Second#1/11 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Mulm_Nat.ref.function );
    refalrts::reinit_close_bracket( context[14] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[14] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[14];
    res = refalrts::splice_evar( res, context[9], context[10] );
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '+' e.idx ) '-' e.idx
    // </0 & Mul-Normed/4 (/7 '+'/13 e.First#1/9 )/8 '-'/14 e.Second#1/11 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '+', context[9], context[10] );
    if( ! context[13] )
      continue;
    context[14] = refalrts::char_left( '-', context[11], context[12] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 9
    // closed e.Second#1 as range 11
    //DEBUG: e.First#1: 9
    //DEBUG: e.Second#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} '-'/14 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: '-'/0 HalfReuse: </4 HalfReuse: & Mul-Nat/7 HalfReuse: (/13 AsIs: e.First#1/9 AsIs: )/8 } Tile{ AsIs: e.Second#1/11 } Tile{ AsIs: >/1 ]] }
    refalrts::reinit_char( context[0], '-' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], ref_Mulm_Nat.ref.function );
    refalrts::reinit_open_bracket( context[13] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[13], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[11], context[12] );
    refalrts::splice_to_freelist_open( context[8], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '+' e.idx ) 0
    // </0 & Mul-Normed/4 (/7 '+'/13 e.First#1/9 )/8 0/14 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '+', context[9], context[10] );
    if( ! context[13] )
      continue;
    context[14] = refalrts::number_left( 0UL, context[11], context[12] );
    if( ! context[14] )
      continue;
    if( ! refalrts::empty_seq( context[11], context[12] ) )
      continue;
    // closed e.First#1 as range 9
    //DEBUG: e.First#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Mul-Normed/4 (/7 '+'/13 e.First#1/9 )/8 0/14 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
    refalrts::reinit_number( context[1], 0UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '-' e.idx ) '+' e.idx
    // </0 & Mul-Normed/4 (/7 '-'/13 e.First#1/9 )/8 '+'/14 e.Second#1/11 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '-', context[9], context[10] );
    if( ! context[13] )
      continue;
    context[14] = refalrts::char_left( '+', context[11], context[12] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 9
    // closed e.Second#1 as range 11
    //DEBUG: e.First#1: 9
    //DEBUG: e.Second#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} '+'/14 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: '-'/0 HalfReuse: </4 HalfReuse: & Mul-Nat/7 HalfReuse: (/13 AsIs: e.First#1/9 AsIs: )/8 } Tile{ AsIs: e.Second#1/11 } Tile{ AsIs: >/1 ]] }
    refalrts::reinit_char( context[0], '-' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], ref_Mulm_Nat.ref.function );
    refalrts::reinit_open_bracket( context[13] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[13], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[11], context[12] );
    refalrts::splice_to_freelist_open( context[8], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '-' e.idx ) '-' e.idx
    // </0 & Mul-Normed/4 (/7 '-'/13 e.First#1/9 )/8 '-'/14 e.Second#1/11 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '-', context[9], context[10] );
    if( ! context[13] )
      continue;
    context[14] = refalrts::char_left( '-', context[11], context[12] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 9
    // closed e.Second#1 as range 11
    //DEBUG: e.First#1: 9
    //DEBUG: e.Second#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} '-'/13 {REMOVED TILE} )/8 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Mul-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/9 } Tile{ HalfReuse: )/14 AsIs: e.Second#1/11 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Mulm_Nat.ref.function );
    refalrts::reinit_close_bracket( context[14] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[14] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[14];
    res = refalrts::splice_evar( res, context[9], context[10] );
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '-' e.idx ) 0
    // </0 & Mul-Normed/4 (/7 '-'/13 e.First#1/9 )/8 0/14 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    context[13] = refalrts::char_left( '-', context[9], context[10] );
    if( ! context[13] )
      continue;
    context[14] = refalrts::number_left( 0UL, context[11], context[12] );
    if( ! context[14] )
      continue;
    if( ! refalrts::empty_seq( context[11], context[12] ) )
      continue;
    // closed e.First#1 as range 9
    //DEBUG: e.First#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Mul-Normed/4 (/7 '-'/13 e.First#1/9 )/8 0/14 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
    refalrts::reinit_number( context[1], 0UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( 0 ) e.idx
  // </0 & Mul-Normed/4 (/7 0/13 )/8 e.AnySecond#1/11 >/1
  context[9] = context[5];
  context[10] = context[6];
  context[11] = context[2];
  context[12] = context[3];
  context[13] = refalrts::number_left( 0UL, context[9], context[10] );
  if( ! context[13] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[9], context[10] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.AnySecond#1 as range 11
  //DEBUG: e.AnySecond#1: 11

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Mul-Normed/4 (/7 0/13 )/8 e.AnySecond#1/11 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
  refalrts::reinit_number( context[1], 0UL );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Mulm_Normed("Mul-Normed", 4190823648U, 3252578238U, func_Mulm_Normed);

static refalrts::FnResult func_Mulm_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 25 elems
  refalrts::Iter context[25];
  refalrts::zeros( context, 25 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) e.$ s.$
  // </0 & Mul-Nat/4 (/7 e.idxB#0/5 )/8 e.idxT#0/2 s.idxTV#0/9 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_right( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxT#0 as range 2
  do {
    // ( e.idx ) s.idx
    // </0 & Mul-Nat/4 (/7 e.First#1/10 )/8 s.SecondLast#1/9 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::empty_seq( context[12], context[13] ) )
      continue;
    // closed e.First#1 as range 10
    //DEBUG: s.SecondLast#1: 9
    //DEBUG: e.First#1: 10

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Mul-Nat-Line/4 } Tile{ AsIs: e.First#1/10 } Tile{ AsIs: s.SecondLast#1/9 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Mulm_Natm_Line.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[9];
    res = refalrts::splice_evar( res, context[10], context[11] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) e.idx s.idx
  // </0 & Mul-Nat/4 (/7 e.First#1/10 )/8 e.Second#1/12 s.SecondLast#1/9 >/1
  context[10] = context[5];
  context[11] = context[6];
  context[12] = context[2];
  context[13] = context[3];
  // closed e.First#1 as range 10
  // closed e.Second#1 as range 12
  //DEBUG: s.SecondLast#1: 9
  //DEBUG: e.First#1: 10
  //DEBUG: e.Second#1: 12

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </14 & Add-Nat/15 (/16 Tile{ AsIs: </0 AsIs: & Mul-Nat/4 AsIs: (/7 AsIs: e.First#1/10 AsIs: )/8 } Tile{ AsIs: e.Second#1/12 } >/17 0/18 )/19 </20 & Mul-Nat-Line/21 e.First#1/10/22 Tile{ AsIs: s.SecondLast#1/9 AsIs: >/1 } >/24 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[15], ref_Addm_Nat.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[18], 0UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[21], ref_Mulm_Natm_Line.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[22], context[23], context[10], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[24] ) )
    return refalrts::cNoMemory;
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[20] );
  refalrts::link_brackets( context[16], context[19] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[24], context[24] );
  res = refalrts::splice_evar( res, context[9], context[1] );
  res = refalrts::splice_evar( res, context[22], context[23] );
  res = refalrts::splice_evar( res, context[17], context[21] );
  res = refalrts::splice_evar( res, context[12], context[13] );
  res = refalrts::splice_evar( res, context[0], context[8] );
  res = refalrts::splice_evar( res, context[14], context[16] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Mulm_Nat("Mul-Nat", 4190823648U, 3252578238U, func_Mulm_Nat);

static refalrts::FnResult func_gen_Mulm_Natm_Line_S2B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 20 elems
  refalrts::Iter context[20];
  refalrts::zeros( context, 20 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) s.$ s.$ e.$
  // </0 & Mul-Nat-Line$2:1/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 s.idxTV#0/10 e.idxTVV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTVV#0 as range 2
  do {
    // ( e.idx ) s.idx s.idx s.idx
    // </0 & Mul-Nat-Line$2:1/4 (/7 e.First#1/11 )/8 s.Second#1/9 s.MulHigh#2/10 s.MulLow#2/15 >/1
    context[11] = context[5];
    context[12] = context[6];
    context[13] = context[2];
    context[14] = context[3];
    // closed e.First#1 as range 11
    if( ! refalrts::svar_left( context[15], context[13], context[14] ) )
      continue;
    if( ! refalrts::empty_seq( context[13], context[14] ) )
      continue;
    //DEBUG: s.Second#1: 9
    //DEBUG: s.MulHigh#2: 10
    //DEBUG: e.First#1: 11
    //DEBUG: s.MulLow#2: 15

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.MulLow#2/15 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Add-Nat/4 AsIs: (/7 } </16 & Mul-Nat-Line/17 Tile{ AsIs: e.First#1/11 } Tile{ AsIs: s.Second#1/9 } >/18 Tile{ AsIs: )/8 } Tile{ AsIs: s.MulHigh#2/10 } >/19 Tile{ HalfReuse: s.MulLow2 #15/1 ]] }
    if( ! refalrts::alloc_open_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[17], ref_Mulm_Natm_Line.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[19] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Addm_Nat.ref.function );
    refalrts::reinit_svar( context[1], context[15] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[16] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[19], context[19] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[8], context[8] );
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[9], context[9] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx s.idx
  // </0 & Mul-Nat-Line$2:1/4 (/7 e.First#1/11 )/8 s.Second#1/9 s.MulLow#2/10 >/1
  context[11] = context[5];
  context[12] = context[6];
  context[13] = context[2];
  context[14] = context[3];
  if( ! refalrts::empty_seq( context[13], context[14] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.First#1 as range 11
  //DEBUG: s.Second#1: 9
  //DEBUG: s.MulLow#2: 10
  //DEBUG: e.First#1: 11

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.MulLow#2/10 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Mul-Nat-Line/4 } Tile{ AsIs: e.First#1/11 } Tile{ AsIs: s.Second#1/9 } Tile{ HalfReuse: >/8 } Tile{ HalfReuse: s.MulLow2 #10/1 ]] }
  refalrts::update_name( context[4], ref_Mulm_Natm_Line.ref.function );
  refalrts::reinit_close_call( context[8] );
  refalrts::reinit_svar( context[1], context[10] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[8], context[8] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[11], context[12] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Mulm_Natm_Line_S2B1("Mul-Nat-Line$2:1", 4190823648U, 3252578238U, func_gen_Mulm_Natm_Line_S2B1);

static refalrts::FnResult func_Mulm_Natm_Line(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 18 elems
  refalrts::Iter context[18];
  refalrts::zeros( context, 18 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$ s.$ s.$
  // </0 & Mul-Nat-Line/4 e.idx#0/2 s.idxV#0/6 s.idxVV#0/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_right( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_right( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idx#0 as range 2
  do {
    // s.idx s.idx
    // </0 & Mul-Nat-Line/4 s.FirstLast#1/6 s.Second#1/5 >/1
    context[7] = context[2];
    context[8] = context[3];
    if( ! refalrts::empty_seq( context[7], context[8] ) )
      continue;
    //DEBUG: s.FirstLast#1: 6
    //DEBUG: s.Second#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Mul-Digits/4 AsIs: s.FirstLast#1/6 AsIs: s.Second#1/5 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Mulm_Digits.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx s.idx s.idx
  // </0 & Mul-Nat-Line/4 e.First#1/7 s.FirstLast#1/6 s.Second#1/5 >/1
  context[7] = context[2];
  context[8] = context[3];
  // closed e.First#1 as range 7
  //DEBUG: s.FirstLast#1: 6
  //DEBUG: s.Second#1: 5
  //DEBUG: e.First#1: 7

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 HalfReuse: </4 } & @create_closure@/9 & Mul-Nat-Line$2:1/10 (/11 Tile{ AsIs: e.First#1/7 } )/12 s.Second#1/5/13 >/14 </15 & Mul-Digits/16 Tile{ AsIs: s.FirstLast#1/6 AsIs: s.Second#1/5 AsIs: >/1 } >/17 Tile{ ]] }
  if( ! refalrts::alloc_name( context[9], refalrts::create_closure ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_gen_Mulm_Natm_Line_S2B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[13], context[5]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[16], ref_Mulm_Digits.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[17] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_open_call( context[4] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[4] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[17], context[17] );
  res = refalrts::splice_evar( res, context[6], context[1] );
  res = refalrts::splice_evar( res, context[12], context[16] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  res = refalrts::splice_evar( res, context[9], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Mulm_Natm_Line("Mul-Nat-Line", 4190823648U, 3252578238U, func_Mulm_Natm_Line);

static refalrts::FnResult func_Numb(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & Numb/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // '-' e.idx
    // </0 & Numb/4 '-'/7 e.String#1/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::char_left( '-', context[5], context[6] );
    if( ! context[7] )
      continue;
    // closed e.String#1 as range 5
    //DEBUG: e.String#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Neg/4 HalfReuse: </7 } & DoNumb/8 & Numb-Ok/9 & Numb-Fail/10 (/11 )/12 Tile{ AsIs: e.String#1/5 } >/13 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_name( context[8], ref_DoNumb.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[9], ref_Numbm_Ok.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], ref_Numbm_Fail.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[13] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Neg.ref.function );
    refalrts::reinit_open_call( context[7] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[7] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[8], context[12] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // '+' e.idx
    // </0 & Numb/4 '+'/7 e.String#1/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::char_left( '+', context[5], context[6] );
    if( ! context[7] )
      continue;
    // closed e.String#1 as range 5
    //DEBUG: e.String#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </8 & DoNumb/9 & Numb-Ok/10 Tile{ HalfReuse: & Numb-Fail/0 HalfReuse: (/4 HalfReuse: )/7 AsIs: e.String#1/5 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[9], ref_DoNumb.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], ref_Numbm_Ok.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::reinit_name( context[0], ref_Numbm_Fail.ref.function );
    refalrts::reinit_open_bracket( context[4] );
    refalrts::reinit_close_bracket( context[7] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[8] );
    refalrts::link_brackets( context[4], context[7] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[0];
    res = refalrts::splice_evar( res, context[8], context[10] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & Numb/4 e.String#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.String#1 as range 5
  //DEBUG: e.String#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </7 & DoNumb/8 & Numb-Ok/9 & Numb-Fail/10 Tile{ HalfReuse: (/0 HalfReuse: )/4 AsIs: e.String#1/5 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_DoNumb.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], ref_Numbm_Ok.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_Numbm_Fail.ref.function ) )
    return refalrts::cNoMemory;
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[7] );
  refalrts::link_brackets( context[0], context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[0];
  res = refalrts::splice_evar( res, context[7], context[10] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Numb("Numb", 0U, 0U, func_Numb);

static refalrts::FnResult func_DoNumb(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 18 elems
  refalrts::Iter context[18];
  refalrts::zeros( context, 18 );
  //FAST GEN: s.$ s.$ ( e.$ ) e.$
  //GLOBAL GEN: s.$ s.$ ( e.$ ) e.$
  // </0 & DoNumb/4 s.idx#0/5 s.idxV#0/6 (/9 e.idxVVB#0/7 )/10 e.idxVVT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[7] = 0;
  context[8] = 0;
  context[9] = refalrts::brackets_left( context[7], context[8], context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[9], context[10]);
  // closed e.idxVVB#0 as range 7
  // closed e.idxVVT#0 as range 2
  do {
    // s.idx s.idx ( e.idx ) '0' e.idx
    // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/11 )/10 '0'/15 e.Rest#1/13 >/1
    context[11] = context[7];
    context[12] = context[8];
    context[13] = context[2];
    context[14] = context[3];
    context[15] = refalrts::char_left( '0', context[13], context[14] );
    if( ! context[15] )
      continue;
    // closed e.Digits#1 as range 11
    // closed e.Rest#1 as range 13
    //DEBUG: s.Ok#1: 5
    //DEBUG: s.Fail#1: 6
    //DEBUG: e.Digits#1: 11
    //DEBUG: e.Rest#1: 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/11 HalfReuse: 0/10 HalfReuse: )/15 AsIs: e.Rest#1/13 AsIs: >/1 ]] }
    refalrts::reinit_number( context[10], 0UL );
    refalrts::reinit_close_bracket( context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[9], context[15] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // s.idx s.idx ( e.idx ) '1' e.idx
    // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/11 )/10 '1'/15 e.Rest#1/13 >/1
    context[11] = context[7];
    context[12] = context[8];
    context[13] = context[2];
    context[14] = context[3];
    context[15] = refalrts::char_left( '1', context[13], context[14] );
    if( ! context[15] )
      continue;
    // closed e.Digits#1 as range 11
    // closed e.Rest#1 as range 13
    //DEBUG: s.Ok#1: 5
    //DEBUG: s.Fail#1: 6
    //DEBUG: e.Digits#1: 11
    //DEBUG: e.Rest#1: 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/11 HalfReuse: 1/10 HalfReuse: )/15 AsIs: e.Rest#1/13 AsIs: >/1 ]] }
    refalrts::reinit_number( context[10], 1UL );
    refalrts::reinit_close_bracket( context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[9], context[15] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // s.idx s.idx ( e.idx ) '2' e.idx
    // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/11 )/10 '2'/15 e.Rest#1/13 >/1
    context[11] = context[7];
    context[12] = context[8];
    context[13] = context[2];
    context[14] = context[3];
    context[15] = refalrts::char_left( '2', context[13], context[14] );
    if( ! context[15] )
      continue;
    // closed e.Digits#1 as range 11
    // closed e.Rest#1 as range 13
    //DEBUG: s.Ok#1: 5
    //DEBUG: s.Fail#1: 6
    //DEBUG: e.Digits#1: 11
    //DEBUG: e.Rest#1: 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/11 HalfReuse: 2/10 HalfReuse: )/15 AsIs: e.Rest#1/13 AsIs: >/1 ]] }
    refalrts::reinit_number( context[10], 2UL );
    refalrts::reinit_close_bracket( context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[9], context[15] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // s.idx s.idx ( e.idx ) '3' e.idx
    // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/11 )/10 '3'/15 e.Rest#1/13 >/1
    context[11] = context[7];
    context[12] = context[8];
    context[13] = context[2];
    context[14] = context[3];
    context[15] = refalrts::char_left( '3', context[13], context[14] );
    if( ! context[15] )
      continue;
    // closed e.Digits#1 as range 11
    // closed e.Rest#1 as range 13
    //DEBUG: s.Ok#1: 5
    //DEBUG: s.Fail#1: 6
    //DEBUG: e.Digits#1: 11
    //DEBUG: e.Rest#1: 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/11 HalfReuse: 3/10 HalfReuse: )/15 AsIs: e.Rest#1/13 AsIs: >/1 ]] }
    refalrts::reinit_number( context[10], 3UL );
    refalrts::reinit_close_bracket( context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[9], context[15] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // s.idx s.idx ( e.idx ) '4' e.idx
    // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/11 )/10 '4'/15 e.Rest#1/13 >/1
    context[11] = context[7];
    context[12] = context[8];
    context[13] = context[2];
    context[14] = context[3];
    context[15] = refalrts::char_left( '4', context[13], context[14] );
    if( ! context[15] )
      continue;
    // closed e.Digits#1 as range 11
    // closed e.Rest#1 as range 13
    //DEBUG: s.Ok#1: 5
    //DEBUG: s.Fail#1: 6
    //DEBUG: e.Digits#1: 11
    //DEBUG: e.Rest#1: 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/11 HalfReuse: 4/10 HalfReuse: )/15 AsIs: e.Rest#1/13 AsIs: >/1 ]] }
    refalrts::reinit_number( context[10], 4UL );
    refalrts::reinit_close_bracket( context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[9], context[15] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // s.idx s.idx ( e.idx ) '5' e.idx
    // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/11 )/10 '5'/15 e.Rest#1/13 >/1
    context[11] = context[7];
    context[12] = context[8];
    context[13] = context[2];
    context[14] = context[3];
    context[15] = refalrts::char_left( '5', context[13], context[14] );
    if( ! context[15] )
      continue;
    // closed e.Digits#1 as range 11
    // closed e.Rest#1 as range 13
    //DEBUG: s.Ok#1: 5
    //DEBUG: s.Fail#1: 6
    //DEBUG: e.Digits#1: 11
    //DEBUG: e.Rest#1: 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/11 HalfReuse: 5/10 HalfReuse: )/15 AsIs: e.Rest#1/13 AsIs: >/1 ]] }
    refalrts::reinit_number( context[10], 5UL );
    refalrts::reinit_close_bracket( context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[9], context[15] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // s.idx s.idx ( e.idx ) '6' e.idx
    // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/11 )/10 '6'/15 e.Rest#1/13 >/1
    context[11] = context[7];
    context[12] = context[8];
    context[13] = context[2];
    context[14] = context[3];
    context[15] = refalrts::char_left( '6', context[13], context[14] );
    if( ! context[15] )
      continue;
    // closed e.Digits#1 as range 11
    // closed e.Rest#1 as range 13
    //DEBUG: s.Ok#1: 5
    //DEBUG: s.Fail#1: 6
    //DEBUG: e.Digits#1: 11
    //DEBUG: e.Rest#1: 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/11 HalfReuse: 6/10 HalfReuse: )/15 AsIs: e.Rest#1/13 AsIs: >/1 ]] }
    refalrts::reinit_number( context[10], 6UL );
    refalrts::reinit_close_bracket( context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[9], context[15] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // s.idx s.idx ( e.idx ) '7' e.idx
    // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/11 )/10 '7'/15 e.Rest#1/13 >/1
    context[11] = context[7];
    context[12] = context[8];
    context[13] = context[2];
    context[14] = context[3];
    context[15] = refalrts::char_left( '7', context[13], context[14] );
    if( ! context[15] )
      continue;
    // closed e.Digits#1 as range 11
    // closed e.Rest#1 as range 13
    //DEBUG: s.Ok#1: 5
    //DEBUG: s.Fail#1: 6
    //DEBUG: e.Digits#1: 11
    //DEBUG: e.Rest#1: 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/11 HalfReuse: 7/10 HalfReuse: )/15 AsIs: e.Rest#1/13 AsIs: >/1 ]] }
    refalrts::reinit_number( context[10], 7UL );
    refalrts::reinit_close_bracket( context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[9], context[15] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // s.idx s.idx ( e.idx ) '8' e.idx
    // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/11 )/10 '8'/15 e.Rest#1/13 >/1
    context[11] = context[7];
    context[12] = context[8];
    context[13] = context[2];
    context[14] = context[3];
    context[15] = refalrts::char_left( '8', context[13], context[14] );
    if( ! context[15] )
      continue;
    // closed e.Digits#1 as range 11
    // closed e.Rest#1 as range 13
    //DEBUG: s.Ok#1: 5
    //DEBUG: s.Fail#1: 6
    //DEBUG: e.Digits#1: 11
    //DEBUG: e.Rest#1: 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/11 HalfReuse: 8/10 HalfReuse: )/15 AsIs: e.Rest#1/13 AsIs: >/1 ]] }
    refalrts::reinit_number( context[10], 8UL );
    refalrts::reinit_close_bracket( context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[9], context[15] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // s.idx s.idx ( e.idx ) '9' e.idx
    // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/11 )/10 '9'/15 e.Rest#1/13 >/1
    context[11] = context[7];
    context[12] = context[8];
    context[13] = context[2];
    context[14] = context[3];
    context[15] = refalrts::char_left( '9', context[13], context[14] );
    if( ! context[15] )
      continue;
    // closed e.Digits#1 as range 11
    // closed e.Rest#1 as range 13
    //DEBUG: s.Ok#1: 5
    //DEBUG: s.Fail#1: 6
    //DEBUG: e.Digits#1: 11
    //DEBUG: e.Rest#1: 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/11 HalfReuse: 9/10 HalfReuse: )/15 AsIs: e.Rest#1/13 AsIs: >/1 ]] }
    refalrts::reinit_number( context[10], 9UL );
    refalrts::reinit_close_bracket( context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[9], context[15] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // s.idx s.idx ( ) e.idx
    // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 )/10 e.Rest#1/13 >/1
    context[11] = context[7];
    context[12] = context[8];
    context[13] = context[2];
    context[14] = context[3];
    if( ! refalrts::empty_seq( context[11], context[12] ) )
      continue;
    // closed e.Rest#1 as range 13
    //DEBUG: s.Ok#1: 5
    //DEBUG: s.Fail#1: 6
    //DEBUG: e.Rest#1: 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: </9 HalfReuse: s.Fail1 #6/10 AsIs: e.Rest#1/13 AsIs: >/1 ]] }
    refalrts::reinit_open_call( context[9] );
    refalrts::reinit_svar( context[10], context[6] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[9];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx s.idx ( e.idx ) e.idx
  // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/11 )/10 e.Rest#1/13 >/1
  context[11] = context[7];
  context[12] = context[8];
  context[13] = context[2];
  context[14] = context[3];
  // closed e.Digits#1 as range 11
  // closed e.Rest#1 as range 13
  //DEBUG: s.Ok#1: 5
  //DEBUG: s.Fail#1: 6
  //DEBUG: e.Digits#1: 11
  //DEBUG: e.Rest#1: 13

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Ok#1/5 s.Fail#1/6 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 HalfReuse: s.Ok1 #5/4 } Tile{ AsIs: (/9 } </15 & Numb-Wrap/16 Tile{ AsIs: e.Digits#1/11 } >/17 Tile{ AsIs: )/10 AsIs: e.Rest#1/13 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[16], ref_Numbm_Wrap.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[17] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_svar( context[4], context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[9], context[10] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[15] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[10];
  res = refalrts::splice_evar( res, context[17], context[17] );
  res = refalrts::splice_evar( res, context[11], context[12] );
  res = refalrts::splice_evar( res, context[15], context[16] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DoNumb("DoNumb", 4190823648U, 3252578238U, func_DoNumb);

static refalrts::FnResult func_Numbm_Ok(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Numb-Ok/4 (/7 e.Number#1/5 )/8 e.Rest#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Number#1 as range 5
  // closed e.Rest#1 as range 2
  //DEBUG: e.Number#1: 5
  //DEBUG: e.Rest#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Numb-Ok/4 (/7 {REMOVED TILE} )/8 e.Rest#1/2 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.Number#1/5 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Numbm_Ok("Numb-Ok", 4190823648U, 3252578238U, func_Numbm_Ok);

static refalrts::FnResult func_Numbm_Fail(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 5 elems
  refalrts::Iter context[5];
  refalrts::zeros( context, 5 );
  // </0 & Numb-Fail/4 e.Rest#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Rest#1 as range 2
  //DEBUG: e.Rest#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Numb-Fail/4 e.Rest#1/2 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
  refalrts::reinit_number( context[1], 0UL );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Numbm_Fail("Numb-Fail", 4190823648U, 3252578238U, func_Numbm_Fail);

static refalrts::FnResult func_Numbm_Wrap(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  // </0 & Numb-Wrap/4 e.Digits#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Digits#1 as range 2
  //DEBUG: e.Digits#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & DoNumb-Wrap/6 (/7 Tile{ HalfReuse: 0/0 HalfReuse: )/4 AsIs: e.Digits#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_DoNumbm_Wrap.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[7] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_number( context[0], 0UL );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[5] );
  refalrts::link_brackets( context[7], context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[0];
  res = refalrts::splice_evar( res, context[5], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Numbm_Wrap("Numb-Wrap", 4190823648U, 3252578238U, func_Numbm_Wrap);

static refalrts::FnResult func_DoNumbm_Wrap(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 23 elems
  refalrts::Iter context[23];
  refalrts::zeros( context, 23 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) e.$
  // </0 & DoNumb-Wrap/4 (/7 e.idxB#0/5 )/8 e.idxT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  // closed e.idxT#0 as range 2
  do {
    // ( e.idx ) s.idx e.idx
    // </0 & DoNumb-Wrap/4 (/7 e.Result#1/9 )/8 s.NextDigit#1/13 e.Digits#1/11 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    // closed e.Result#1 as range 9
    if( ! refalrts::svar_left( context[13], context[11], context[12] ) )
      continue;
    // closed e.Digits#1 as range 11
    //DEBUG: e.Result#1: 9
    //DEBUG: s.NextDigit#1: 13
    //DEBUG: e.Digits#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb-Wrap/4 AsIs: (/7 } </14 & Add-Nat/15 (/16 </17 & Mul-Nat-Line/18 Tile{ AsIs: e.Result#1/9 } 10/19 >/20 Tile{ AsIs: )/8 AsIs: s.NextDigit#1/13 } >/21 )/22 Tile{ AsIs: e.Digits#1/11 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[15], ref_Addm_Nat.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[18], ref_Mulm_Natm_Line.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[19], 10UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[22] ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[22] );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[14] );
    refalrts::link_brackets( context[16], context[8] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[17] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[8], context[13] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[14], context[18] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx )
  // </0 & DoNumb-Wrap/4 (/7 e.Result#1/9 )/8 >/1
  context[9] = context[5];
  context[10] = context[6];
  context[11] = context[2];
  context[12] = context[3];
  if( ! refalrts::empty_seq( context[11], context[12] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Result#1 as range 9
  //DEBUG: e.Result#1: 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & DoNumb-Wrap/4 (/7 {REMOVED TILE} )/8 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.Result#1/9 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[9], context[10] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DoNumbm_Wrap("DoNumb-Wrap", 4190823648U, 3252578238U, func_DoNumbm_Wrap);

static refalrts::FnResult func_Open(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1054 "Library.sref"
  return refal_open(arg_begin, arg_end);
#line 7430 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Open("Open", 0U, 0U, func_Open);

#line 1063 "Library.sref"
namespace {

struct OrdConv {
  bool for_convert(refalrts::Iter item) {
    return refalrts::cDataChar == item->tag;
  }

  void convert(refalrts::Iter item) {
    item->tag = refalrts::cDataNumber;
    item->number_info = static_cast<unsigned char>(item->char_info);
  }
};

}  // unnamed namespace
#line 7450 "Library.cpp"
static refalrts::FnResult func_Ord(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1081 "Library.sref"
  return convert(arg_begin, arg_end, OrdConv());
#line 7454 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Ord("Ord", 0U, 0U, func_Ord);

static refalrts::FnResult func_Print(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1091 "Library.sref"
  return fwrite_line(
    arg_begin, arg_end, cFlags_NoHandle | cFlags_StdOut | cFlags_Transparent
  );
#line 7464 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Print("Print", 0U, 0U, func_Print);

static refalrts::FnResult func_Prout(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1103 "Library.sref"
  return fwrite_line(arg_begin, arg_end, cFlags_NoHandle | cFlags_StdOut);
#line 7472 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Prout("Prout", 0U, 0U, func_Prout);

static refalrts::FnResult func_Proud(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 5 elems
  refalrts::Iter context[5];
  refalrts::zeros( context, 5 );
  // </0 & Proud/4 e.AnyExpression#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.AnyExpression#1 as range 2
  //DEBUG: e.AnyExpression#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Prout/4 AsIs: e.AnyExpression#1/2 AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Prout.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Proud("Proud", 0U, 0U, func_Proud);

static refalrts::FnResult func_Trout(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 5 elems
  refalrts::Iter context[5];
  refalrts::zeros( context, 5 );
  // </0 & Trout/4 e.AnyExpression#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.AnyExpression#1 as range 2
  //DEBUG: e.AnyExpression#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Prout/4 AsIs: e.AnyExpression#1/2 AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Prout.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Trout("Trout", 0U, 0U, func_Trout);

static refalrts::FnResult func_Put(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1119 "Library.sref"
  return fwrite_line(
    arg_begin, arg_end,
    cFlags_Autoopen | cFlags_Write | cFlags_StdErr | cFlags_Transparent
  );
#line 7533 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Put("Put", 0U, 0U, func_Put);

static refalrts::FnResult func_Putout(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1132 "Library.sref"
  return fwrite_line(
    arg_begin, arg_end, cFlags_Autoopen | cFlags_Write | cFlags_StdErr
  );
#line 7543 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Putout("Putout", 0U, 0U, func_Putout);

static refalrts::FnResult func_gen_Rp_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 30 elems
  refalrts::Iter context[30];
  refalrts::zeros( context, 30 );
  //FAST GEN: ( e.$ ) ( e.$ ) e.$
  //GLOBAL GEN: ( e.$ ) ( e.$ ) e.$
  // </0 & Rp:1/4 (/7 e.idxB#0/5 )/8 (/11 e.idxTB#0/9 )/12 e.idxTT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.idxB#0 as range 5
  // closed e.idxTB#0 as range 9
  // closed e.idxTT#0 as range 2
  do {
    // ( e.idx ) ( e.idx ) e.idx
    // </0 & Rp:1/4 (/7 e.Key#1/13 )/8 (/11 e.NewValue#1/15 )/12 e.Values-B#2/19 (/25 e.Key#1/27 '='/29 e.OldValue#2/23 )/26 e.Values-E#2/21 >/1
    context[13] = context[5];
    context[14] = context[6];
    context[15] = context[9];
    context[16] = context[10];
    context[17] = context[2];
    context[18] = context[3];
    // closed e.Key#1 as range 13
    // closed e.NewValue#1 as range 15
    context[19] = 0;
    context[20] = 0;
    refalrts::start_e_loop();
    do {
      context[21] = context[17];
      context[22] = context[18];
      context[23] = 0;
      context[24] = 0;
      context[25] = refalrts::brackets_left( context[23], context[24], context[21], context[22] );
      if( ! context[25] )
        continue;
      refalrts::bracket_pointers(context[25], context[26]);
      if( ! refalrts::repeated_evar_left( context[27], context[28], context[13], context[14], context[23], context[24] ) )
        continue;
      context[29] = refalrts::char_left( '=', context[23], context[24] );
      if( ! context[29] )
        continue;
      // closed e.OldValue#2 as range 23
      // closed e.Values-E#2 as range 21
      //DEBUG: e.Key#1: 13
      //DEBUG: e.NewValue#1: 15
      //DEBUG: e.Values-B#2: 19
      //DEBUG: e.OldValue#2: 23
      //DEBUG: e.Values-E#2: 21

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} & Rp:1/4 (/7 e.Key#1/13 )/8 (/11 {REMOVED TILE} {REMOVED TILE} e.OldValue#2/23 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 } Tile{ HalfReuse: & Buried/12 AsIs: e.Values-B#2/19 AsIs: (/25 AsIs: e.Key#1/27 AsIs: '='/29 } Tile{ AsIs: e.NewValue#1/15 } Tile{ AsIs: )/26 AsIs: e.Values-E#2/21 AsIs: >/1 ]] }
      refalrts::reinit_name( context[12], ref_Buried.ref.function );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[25], context[26] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[26];
      res = refalrts::splice_evar( res, context[15], context[16] );
      res = refalrts::splice_evar( res, context[12], context[29] );
      refalrts::splice_to_freelist_open( context[0], res );
      return refalrts::cSuccess;
    } while ( refalrts::open_evar_advance( context[19], context[20], context[17], context[18] ) );
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) ( e.idx ) e.idx
  // </0 & Rp:1/4 (/7 e.Key#1/13 )/8 (/11 e.NewValue#1/15 )/12 e.Values#2/17 >/1
  context[13] = context[5];
  context[14] = context[6];
  context[15] = context[9];
  context[16] = context[10];
  context[17] = context[2];
  context[18] = context[3];
  // closed e.Key#1 as range 13
  // closed e.NewValue#1 as range 15
  // closed e.Values#2 as range 17
  //DEBUG: e.Key#1: 13
  //DEBUG: e.NewValue#1: 15
  //DEBUG: e.Values#2: 17

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} )/8 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Buried/4 AsIs: (/7 } Tile{ AsIs: e.Key#1/13 } Tile{ HalfReuse: '='/11 AsIs: e.NewValue#1/15 AsIs: )/12 AsIs: e.Values#2/17 AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Buried.ref.function );
  refalrts::reinit_char( context[11], '=' );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[12] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[11];
  res = refalrts::splice_evar( res, context[13], context[14] );
  refalrts::splice_to_freelist_open( context[7], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Rp_B1("Rp:1", 4190823648U, 3252578238U, func_gen_Rp_B1);

static refalrts::FnResult func_Rp(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  // </0 & Rp/4 e.Key#1/5 '='/9 e.NewValue#1/7 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  refalrts::start_e_loop();
  do {
    context[7] = context[2];
    context[8] = context[3];
    context[9] = refalrts::char_left( '=', context[7], context[8] );
    if( ! context[9] )
      continue;
    // closed e.NewValue#1 as range 7
    //DEBUG: e.Key#1: 5
    //DEBUG: e.NewValue#1: 7

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 HalfReuse: </4 } & @create_closure@/10 & Rp:1/11 Tile{ HalfReuse: (/9 } Tile{ AsIs: e.Key#1/5 } )/12 (/13 Tile{ AsIs: e.NewValue#1/7 } )/14 >/15 </16 & Buried/17 >/18 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_name( context[10], refalrts::create_closure ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[11], ref_gen_Rp_B1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[17], ref_Buried.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[18] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_open_bracket( context[9] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[13], context[14] );
    refalrts::link_brackets( context[9], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[14], context[18] );
    res = refalrts::splice_evar( res, context[7], context[8] );
    res = refalrts::splice_evar( res, context[12], context[13] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[9], context[9] );
    res = refalrts::splice_evar( res, context[10], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( refalrts::open_evar_advance( context[5], context[6], context[2], context[3] ) );
  return refalrts::cRecognitionImpossible;
}

static refalrts::NativeReference nat_ref_Rp("Rp", 0U, 0U, func_Rp);

static refalrts::FnResult func_gen_Sub_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Sub$2=1/4 (/7 e.First#2/5 )/8 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#2 as range 5
  // closed e.Second#2 as range 2
  //DEBUG: e.First#2: 5
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sub-Normed/4 AsIs: (/7 AsIs: e.First#2/5 AsIs: )/8 AsIs: e.Second#2/2 AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Subm_Normed.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Sub_S2A1("Sub$2=1", 4190823648U, 3252578238U, func_gen_Sub_S2A1);

static refalrts::FnResult func_Sub(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & Sub/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // s.idx s.idx
    // </0 & Sub/4 s.First#1/7 s.Second#1/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.First#1: 7
    //DEBUG: s.Second#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sub-Digits/4 AsIs: s.First#1/7 AsIs: s.Second#1/8 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Subm_Digits.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & Sub/4 e.ArithmArg#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.ArithmArg#1 as range 5
  //DEBUG: e.ArithmArg#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </7 & Sub$2=1/8 Tile{ AsIs: </0 Reuse: & NormArithmArg/4 AsIs: e.ArithmArg#1/5 AsIs: >/1 } >/9 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_gen_Sub_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormArithmArg.ref.function );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Sub("Sub", 0U, 0U, func_Sub);

static refalrts::FnResult func_Subm_Digits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1169 "Library.sref"
  ARITHM_PRELUDE

  if (first >= second) {
    refalrts::reinit_number(arg_begin, first - second);
    refalrts::splice_to_freelist(pFunc, arg_end);
  } else {
    refalrts::reinit_char(arg_begin, '-');
    refalrts::reinit_number(pFunc, second - first);
    refalrts::splice_to_freelist(pFirst, arg_end);
  }

  return refalrts::cSuccess;
#line 7854 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Subm_Digits("Sub-Digits", 4190823648U, 3252578238U, func_Subm_Digits);

static refalrts::FnResult func_Subm_Normed(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) s.$ e.$
  // </0 & Sub-Normed/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 e.idxTV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTV#0 as range 2
  do {
    // ( '+' e.idx ) '+' e.idx
    // </0 & Sub-Normed/4 (/7 '+'/14 e.First#1/10 )/8 '+'/9 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '+', context[9] ) )
      continue;
    context[14] = refalrts::char_left( '+', context[10], context[11] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 10
    // closed e.Second#1 as range 12
    //DEBUG: e.First#1: 10
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} '+'/14 {REMOVED TILE} )/8 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sub-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/10 } Tile{ HalfReuse: )/9 AsIs: e.Second#1/12 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Subm_Nat.ref.function );
    refalrts::reinit_close_bracket( context[9] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[9];
    res = refalrts::splice_evar( res, context[10], context[11] );
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '+' e.idx ) '-' e.idx
    // </0 & Sub-Normed/4 (/7 '+'/14 e.First#1/10 )/8 '-'/9 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '-', context[9] ) )
      continue;
    context[14] = refalrts::char_left( '+', context[10], context[11] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 10
    // closed e.Second#1 as range 12
    //DEBUG: e.First#1: 10
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} '+'/14 {REMOVED TILE} )/8 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Add-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/10 } Tile{ HalfReuse: )/9 AsIs: e.Second#1/12 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Addm_Nat.ref.function );
    refalrts::reinit_close_bracket( context[9] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[9];
    res = refalrts::splice_evar( res, context[10], context[11] );
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '+' e.idx ) 0
    // </0 & Sub-Normed/4 (/7 '+'/14 e.First#1/10 )/8 0/9 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::number_term( 0UL, context[9] ) )
      continue;
    context[14] = refalrts::char_left( '+', context[10], context[11] );
    if( ! context[14] )
      continue;
    if( ! refalrts::empty_seq( context[12], context[13] ) )
      continue;
    // closed e.First#1 as range 10
    //DEBUG: e.First#1: 10

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Sub-Normed/4 (/7 '+'/14 {REMOVED TILE} )/8 0/9 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: e.First#1/10 } Tile{ ]] }
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[10], context[11] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '-' e.idx ) '+' e.idx
    // </0 & Sub-Normed/4 (/7 '-'/14 e.First#1/10 )/8 '+'/9 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '+', context[9] ) )
      continue;
    context[14] = refalrts::char_left( '-', context[10], context[11] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 10
    // closed e.Second#1 as range 12
    //DEBUG: e.First#1: 10
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} '+'/9 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: '-'/0 HalfReuse: </4 HalfReuse: & Add-Nat/7 HalfReuse: (/14 AsIs: e.First#1/10 AsIs: )/8 } Tile{ AsIs: e.Second#1/12 } Tile{ AsIs: >/1 ]] }
    refalrts::reinit_char( context[0], '-' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], ref_Addm_Nat.ref.function );
    refalrts::reinit_open_bracket( context[14] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[14], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[12], context[13] );
    refalrts::splice_to_freelist_open( context[8], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '-' e.idx ) '-' e.idx
    // </0 & Sub-Normed/4 (/7 '-'/14 e.First#1/10 )/8 '-'/9 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '-', context[9] ) )
      continue;
    context[14] = refalrts::char_left( '-', context[10], context[11] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 10
    // closed e.Second#1 as range 12
    //DEBUG: e.First#1: 10
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Neg/4 HalfReuse: </7 HalfReuse: & Sub-Nat/14 } Tile{ HalfReuse: (/8 } Tile{ AsIs: e.First#1/10 } Tile{ HalfReuse: )/9 AsIs: e.Second#1/12 AsIs: >/1 } >/15 Tile{ ]] }
    if( ! refalrts::alloc_close_call( context[15] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Neg.ref.function );
    refalrts::reinit_open_call( context[7] );
    refalrts::reinit_name( context[14], ref_Subm_Nat.ref.function );
    refalrts::reinit_open_bracket( context[8] );
    refalrts::reinit_close_bracket( context[9] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[7] );
    refalrts::link_brackets( context[8], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[9], context[1] );
    res = refalrts::splice_evar( res, context[10], context[11] );
    res = refalrts::splice_evar( res, context[8], context[8] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '-' e.idx ) 0
    // </0 & Sub-Normed/4 (/7 '-'/14 e.First#1/10 )/8 0/9 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::number_term( 0UL, context[9] ) )
      continue;
    context[14] = refalrts::char_left( '-', context[10], context[11] );
    if( ! context[14] )
      continue;
    if( ! refalrts::empty_seq( context[12], context[13] ) )
      continue;
    // closed e.First#1 as range 10
    //DEBUG: e.First#1: 10

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} & Sub-Normed/4 (/7 '-'/14 {REMOVED TILE} )/8 0/9 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: '-'/0 } Tile{ AsIs: e.First#1/10 } Tile{ ]] }
    refalrts::reinit_char( context[0], '-' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[10], context[11] );
    refalrts::splice_to_freelist_open( context[0], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( 0 ) '+' e.idx
    // </0 & Sub-Normed/4 (/7 0/14 )/8 '+'/9 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '+', context[9] ) )
      continue;
    context[14] = refalrts::number_left( 0UL, context[10], context[11] );
    if( ! context[14] )
      continue;
    if( ! refalrts::empty_seq( context[10], context[11] ) )
      continue;
    // closed e.Second#1 as range 12
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} & Sub-Normed/4 (/7 0/14 )/8 '+'/9 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: '-'/0 } Tile{ AsIs: e.Second#1/12 } Tile{ ]] }
    refalrts::reinit_char( context[0], '-' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[12], context[13] );
    refalrts::splice_to_freelist_open( context[0], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( 0 ) '-' e.idx
    // </0 & Sub-Normed/4 (/7 0/14 )/8 '-'/9 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '-', context[9] ) )
      continue;
    context[14] = refalrts::number_left( 0UL, context[10], context[11] );
    if( ! context[14] )
      continue;
    if( ! refalrts::empty_seq( context[10], context[11] ) )
      continue;
    // closed e.Second#1 as range 12
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Sub-Normed/4 (/7 0/14 )/8 '-'/9 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: e.Second#1/12 } Tile{ ]] }
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[12], context[13] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( 0 ) 0
  // </0 & Sub-Normed/4 (/7 0/14 )/8 0/9 >/1
  context[10] = context[5];
  context[11] = context[6];
  context[12] = context[2];
  context[13] = context[3];
  if( ! refalrts::number_term( 0UL, context[9] ) )
    return refalrts::cRecognitionImpossible;
  context[14] = refalrts::number_left( 0UL, context[10], context[11] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[10], context[11] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[12], context[13] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Sub-Normed/4 (/7 0/14 )/8 0/9 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
  refalrts::reinit_number( context[1], 0UL );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Subm_Normed("Sub-Normed", 4190823648U, 3252578238U, func_Subm_Normed);

static refalrts::FnResult func_Neg(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & Neg/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // 0
    // </0 & Neg/4 0/7 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::number_left( 0UL, context[5], context[6] );
    if( ! context[7] )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Neg/4 0/7 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
    refalrts::reinit_number( context[1], 0UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // '-' e.idx
    // </0 & Neg/4 '-'/7 e.Digits#1/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::char_left( '-', context[5], context[6] );
    if( ! context[7] )
      continue;
    // closed e.Digits#1 as range 5
    //DEBUG: e.Digits#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Neg/4 '-'/7 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: e.Digits#1/5 } Tile{ ]] }
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[5], context[6] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & Neg/4 e.Digits#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.Digits#1 as range 5
  //DEBUG: e.Digits#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & Neg/4 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: '-'/0 } Tile{ AsIs: e.Digits#1/5 } Tile{ ]] }
  refalrts::reinit_char( context[0], '-' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Neg("Neg", 4190823648U, 3252578238U, func_Neg);

static refalrts::FnResult func_gen_Subm_Nat_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 18 elems
  refalrts::Iter context[18];
  refalrts::zeros( context, 18 );
  //FAST GEN: ( e.$ ) ( e.$ ) s.$
  //GLOBAL GEN: ( e.$ ) ( e.$ ) s.$
  // </0 & Sub-Nat:1/4 (/7 e.idxB#0/5 )/8 (/11 e.idxTB#0/9 )/12 s.idxTT#0/13 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.idxB#0 as range 5
  // closed e.idxTB#0 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // ( e.idx ) ( e.idx ) '+'
    // </0 & Sub-Nat:1/4 (/7 e.First#1/14 )/8 (/11 e.Second#1/16 )/12 '+'/13 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::char_term( '+', context[13] ) )
      continue;
    // closed e.First#1 as range 14
    // closed e.Second#1 as range 16
    //DEBUG: e.First#1: 14
    //DEBUG: e.Second#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} (/11 {REMOVED TILE} )/12 '+'/13 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sub-Nat-Nat/4 AsIs: (/7 AsIs: e.First#1/14 AsIs: )/8 } Tile{ AsIs: e.Second#1/16 } Tile{ AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Subm_Natm_Nat.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[16], context[17] );
    refalrts::splice_to_freelist_open( context[8], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) ( e.idx ) '-'
    // </0 & Sub-Nat:1/4 (/7 e.First#1/14 )/8 (/11 e.Second#1/16 )/12 '-'/13 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    if( ! refalrts::char_term( '-', context[13] ) )
      continue;
    // closed e.First#1 as range 14
    // closed e.Second#1 as range 16
    //DEBUG: e.First#1: 14
    //DEBUG: e.Second#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} {REMOVED TILE} '-'/13 {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: '-'/0 HalfReuse: </4 } Tile{ HalfReuse: & Sub-Nat-Nat/8 AsIs: (/11 AsIs: e.Second#1/16 AsIs: )/12 } Tile{ AsIs: e.First#1/14 } Tile{ AsIs: >/1 ]] }
    refalrts::reinit_char( context[0], '-' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[8], ref_Subm_Natm_Nat.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[8], context[12] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) ( e.idx ) '0'
  // </0 & Sub-Nat:1/4 (/7 e.First#1/14 )/8 (/11 e.Second#1/16 )/12 '0'/13 >/1
  context[14] = context[5];
  context[15] = context[6];
  context[16] = context[9];
  context[17] = context[10];
  if( ! refalrts::char_term( '0', context[13] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.First#1 as range 14
  // closed e.Second#1 as range 16
  //DEBUG: e.First#1: 14
  //DEBUG: e.Second#1: 16

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Sub-Nat:1/4 (/7 e.First#1/14 )/8 (/11 e.Second#1/16 )/12 '0'/13 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
  refalrts::reinit_number( context[1], 0UL );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Subm_Nat_B1("Sub-Nat:1", 4190823648U, 3252578238U, func_gen_Subm_Nat_B1);

static refalrts::FnResult func_Subm_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 23 elems
  refalrts::Iter context[23];
  refalrts::zeros( context, 23 );
  // </0 & Sub-Nat/4 (/7 e.First#1/5 )/8 e.Second#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#1 as range 5
  // closed e.Second#1 as range 2
  //DEBUG: e.First#1: 5
  //DEBUG: e.Second#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </9 </10 & @create_closure@/11 & Sub-Nat:1/12 (/13 e.First#1/5/14 )/16 (/17 e.Second#1/2/18 )/20 >/21 Tile{ AsIs: </0 Reuse: & Compare-Nat/4 AsIs: (/7 AsIs: e.First#1/5 AsIs: )/8 AsIs: e.Second#1/2 AsIs: >/1 } >/22 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], refalrts::create_closure ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[12], ref_gen_Subm_Nat_B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[14], context[15], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[17] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[18], context[19], context[2], context[3]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[22] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Comparem_Nat.ref.function );
  refalrts::push_stack( context[22] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[10] );
  refalrts::link_brackets( context[17], context[20] );
  refalrts::link_brackets( context[13], context[16] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[22], context[22] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[9], context[21] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Subm_Nat("Sub-Nat", 4190823648U, 3252578238U, func_Subm_Nat);

static refalrts::FnResult func_Subm_Natm_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & Sub-Nat-Nat/4 (/7 e.First#1/5 )/8 e.Second#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#1 as range 5
  // closed e.Second#1 as range 2
  //DEBUG: e.First#1: 5
  //DEBUG: e.Second#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </9 & LeadingZeros/10 Tile{ AsIs: </0 Reuse: & DoSub-Nat-Nat/4 AsIs: (/7 AsIs: e.First#1/5 AsIs: )/8 AsIs: e.Second#1/2 AsIs: >/1 } >/11 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_LeadingZeros.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_DoSubm_Natm_Nat.ref.function );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Subm_Natm_Nat("Sub-Nat-Nat", 4190823648U, 3252578238U, func_Subm_Natm_Nat);

static refalrts::FnResult func_gen_DoSubm_Natm_Nat_S1B2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 25 elems
  refalrts::Iter context[25];
  refalrts::zeros( context, 25 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) ( e.$ ) s.$ e.$
  // </0 & DoSub-Nat-Nat$1:2/4 (/7 e.idxB#0/5 )/8 (/11 e.idxTB#0/9 )/12 s.idxTT#0/13 e.idxTTV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.idxB#0 as range 5
  // closed e.idxTB#0 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTTV#0 as range 2
  do {
    // ( e.idx ) ( e.idx ) s.idx
    // </0 & DoSub-Nat-Nat$1:2/4 (/7 e.First#1/14 )/8 (/11 e.Second#1/16 )/12 s.LastDigit#2/13 >/1
    context[14] = context[5];
    context[15] = context[6];
    context[16] = context[9];
    context[17] = context[10];
    context[18] = context[2];
    context[19] = context[3];
    if( ! refalrts::empty_seq( context[18], context[19] ) )
      continue;
    // closed e.First#1 as range 14
    // closed e.Second#1 as range 16
    //DEBUG: s.LastDigit#2: 13
    //DEBUG: e.First#1: 14
    //DEBUG: e.Second#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} (/11 {REMOVED TILE} {REMOVED TILE} s.LastDigit#2/13 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & DoSub-Nat-Nat/4 AsIs: (/7 AsIs: e.First#1/14 AsIs: )/8 } Tile{ AsIs: e.Second#1/16 } Tile{ HalfReuse: >/12 } Tile{ HalfReuse: s.LastDigit2 #13/1 ]] }
    refalrts::update_name( context[4], ref_DoSubm_Natm_Nat.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_svar( context[1], context[13] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    refalrts::splice_to_freelist_open( context[8], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) ( e.idx ) '*' s.idx
  // </0 & DoSub-Nat-Nat$1:2/4 (/7 e.First#1/14 )/8 (/11 e.Second#1/16 )/12 '*'/13 s.LastDigit#2/20 >/1
  context[14] = context[5];
  context[15] = context[6];
  context[16] = context[9];
  context[17] = context[10];
  context[18] = context[2];
  context[19] = context[3];
  if( ! refalrts::char_term( '*', context[13] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.First#1 as range 14
  // closed e.Second#1 as range 16
  if( ! refalrts::svar_left( context[20], context[18], context[19] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[18], context[19] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.First#1: 14
  //DEBUG: e.Second#1: 16
  //DEBUG: s.LastDigit#2: 20

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LastDigit#2/20 {REMOVED TILE}
  //RESULT: Tile{ [[ } </21 & DoSub-Nat-Nat/22 (/23 Tile{ AsIs: </0 Reuse: & Sub-Nat-Nat/4 AsIs: (/7 AsIs: e.First#1/14 AsIs: )/8 HalfReuse: 1/11 } Tile{ HalfReuse: >/13 } Tile{ AsIs: )/12 } Tile{ AsIs: e.Second#1/16 } >/24 Tile{ HalfReuse: s.LastDigit2 #20/1 ]] }
  if( ! refalrts::alloc_open_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[22], ref_DoSubm_Natm_Nat.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[23] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[24] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Subm_Natm_Nat.ref.function );
  refalrts::reinit_number( context[11], 1UL );
  refalrts::reinit_close_call( context[13] );
  refalrts::reinit_svar( context[1], context[20] );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[21] );
  refalrts::link_brackets( context[23], context[12] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[24], context[24] );
  res = refalrts::splice_evar( res, context[16], context[17] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[13], context[13] );
  res = refalrts::splice_evar( res, context[0], context[11] );
  res = refalrts::splice_evar( res, context[21], context[23] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_DoSubm_Natm_Nat_S1B2("DoSub-Nat-Nat$1:2", 4190823648U, 3252578238U, func_gen_DoSubm_Natm_Nat_S1B2);

static refalrts::FnResult func_gen_DoSubm_Natm_Nat_S1B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1221 "Library.sref"
        ARITHM_PRELUDE

        refalrts::RefalNumber diff = first - second;

        if (diff <= first) {
          pFirst->number_info = diff;
          refalrts::splice_to_freelist(arg_begin, pFunc);
          refalrts::splice_to_freelist(pSecond, arg_end);
        } else {
          refalrts::reinit_char(pFirst, '*');
          pSecond->number_info = diff;
          refalrts::splice_to_freelist(arg_begin, pFunc);
          refalrts::splice_to_freelist(arg_end, arg_end);
        }

        return refalrts::cSuccess;
#line 8638 "Library.cpp"
}

static refalrts::NativeReference nat_ref_gen_DoSubm_Natm_Nat_S1B1("DoSub-Nat-Nat$1:1", 4190823648U, 3252578238U, func_gen_DoSubm_Natm_Nat_S1B1);

static refalrts::FnResult func_DoSubm_Natm_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 23 elems
  refalrts::Iter context[23];
  refalrts::zeros( context, 23 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) e.$
  // </0 & DoSub-Nat-Nat/4 (/7 e.idxB#0/5 )/8 e.idxT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  // closed e.idxT#0 as range 2
  do {
    // ( e.idx s.idx ) e.idx s.idx
    // </0 & DoSub-Nat-Nat/4 (/7 e.First#1/9 s.FirstLast#1/13 )/8 e.Second#1/11 s.SecondLast#1/14 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    if( ! refalrts::svar_right( context[13], context[9], context[10] ) )
      continue;
    // closed e.First#1 as range 9
    if( ! refalrts::svar_right( context[14], context[11], context[12] ) )
      continue;
    // closed e.Second#1 as range 11
    //DEBUG: s.FirstLast#1: 13
    //DEBUG: e.First#1: 9
    //DEBUG: s.SecondLast#1: 14
    //DEBUG: e.Second#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 HalfReuse: </4 HalfReuse: & @create_closure@/7 } & DoSub-Nat-Nat$1:2/15 (/16 Tile{ AsIs: e.First#1/9 } )/17 (/18 Tile{ AsIs: e.Second#1/11 } Tile{ AsIs: )/8 } >/19 </20 & DoSub-Nat-Nat$1:1/21 Tile{ AsIs: s.FirstLast#1/13 } Tile{ AsIs: s.SecondLast#1/14 AsIs: >/1 } >/22 Tile{ ]] }
    if( ! refalrts::alloc_name( context[15], ref_gen_DoSubm_Natm_Nat_S1B2.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[21], ref_gen_DoSubm_Natm_Nat_S1B1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], refalrts::create_closure );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[18], context[8] );
    refalrts::link_brackets( context[16], context[17] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[22], context[22] );
    res = refalrts::splice_evar( res, context[14], context[1] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[19], context[21] );
    res = refalrts::splice_evar( res, context[8], context[8] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[15], context[16] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx )
  // </0 & DoSub-Nat-Nat/4 (/7 e.First#1/9 )/8 >/1
  context[9] = context[5];
  context[10] = context[6];
  context[11] = context[2];
  context[12] = context[3];
  if( ! refalrts::empty_seq( context[11], context[12] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.First#1 as range 9
  //DEBUG: e.First#1: 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & DoSub-Nat-Nat/4 (/7 {REMOVED TILE} )/8 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.First#1/9 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[9], context[10] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DoSubm_Natm_Nat("DoSub-Nat-Nat", 4190823648U, 3252578238U, func_DoSubm_Natm_Nat);

static refalrts::FnResult func_LeadingZeros(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & LeadingZeros/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // 0
    // </0 & LeadingZeros/4 0/7 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::number_left( 0UL, context[5], context[6] );
    if( ! context[7] )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & LeadingZeros/4 0/7 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
    refalrts::reinit_number( context[1], 0UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // 0 e.idx
    // </0 & LeadingZeros/4 0/7 e.Digits#1/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::number_left( 0UL, context[5], context[6] );
    if( ! context[7] )
      continue;
    // closed e.Digits#1 as range 5
    //DEBUG: e.Digits#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: </4 HalfReuse: & LeadingZeros/7 AsIs: e.Digits#1/5 AsIs: >/1 ]] }
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], ref_LeadingZeros.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[4];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & LeadingZeros/4 e.Digits#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.Digits#1 as range 5
  //DEBUG: e.Digits#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & LeadingZeros/4 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.Digits#1/5 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_LeadingZeros("LeadingZeros", 4190823648U, 3252578238U, func_LeadingZeros);

static refalrts::FnResult func_gen_Symb_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  //FAST GEN: ( e.$ ) s.$ s.$
  //GLOBAL GEN: ( e.$ ) s.$ s.$
  // </0 & Symb:1/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 s.idxTV#0/10 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // ( e.idx ) 0 0
    // </0 & Symb:1/4 (/7 e.NormedNumber#2/11 )/8 0/9 0/10 >/1
    context[11] = context[5];
    context[12] = context[6];
    if( ! refalrts::number_term( 0UL, context[9] ) )
      continue;
    if( ! refalrts::number_term( 0UL, context[10] ) )
      continue;
    // closed e.NormedNumber#2 as range 11
    //DEBUG: e.NormedNumber#2: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Symb:1/4 (/7 e.NormedNumber#2/11 )/8 0/9 0/10 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '0'/1 ]] }
    refalrts::reinit_char( context[1], '0' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) s.idx 0
    // </0 & Symb:1/4 (/7 e.NormedNumber#2/11 )/8 s.Sign#3/9 0/10 >/1
    context[11] = context[5];
    context[12] = context[6];
    if( ! refalrts::number_term( 0UL, context[10] ) )
      continue;
    // closed e.NormedNumber#2 as range 11
    //DEBUG: s.Sign#3: 9
    //DEBUG: e.NormedNumber#2: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Symb:1/4 (/7 e.NormedNumber#2/11 )/8 s.Sign#3/9 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: s.Sign3 #9/10 HalfReuse: '0'/1 ]] }
    refalrts::reinit_svar( context[10], context[9] );
    refalrts::reinit_char( context[1], '0' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[10];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( e.idx ) s.idx s.idx
    // </0 & Symb:1/4 (/7 e.NormedNumber#2/11 )/8 s.Sign#3/9 s.Sign#3/10 >/1
    context[11] = context[5];
    context[12] = context[6];
    if( ! refalrts::repeated_stvar_term( context[10], context[9] ) )
      continue;
    // closed e.NormedNumber#2 as range 11
    //DEBUG: s.Sign#3: 9
    //DEBUG: e.NormedNumber#2: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.Sign#3/9 s.Sign#3/10 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: s.Sign3 #10/0 HalfReuse: </4 HalfReuse: & Symb-Nat/7 AsIs: e.NormedNumber#2/11 HalfReuse: >/8 } Tile{ ]] }
    refalrts::reinit_svar( context[0], context[10] );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], ref_Symbm_Nat.ref.function );
    refalrts::reinit_close_call( context[8] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    refalrts::splice_to_freelist_open( context[8], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( e.idx ) s.idx '+'
  // </0 & Symb:1/4 (/7 e.NormedNumber#2/11 )/8 s.Digit#3/9 '+'/10 >/1
  context[11] = context[5];
  context[12] = context[6];
  if( ! refalrts::char_term( '+', context[10] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.NormedNumber#2 as range 11
  //DEBUG: s.Digit#3: 9
  //DEBUG: e.NormedNumber#2: 11

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 s.Digit#3/9 '+'/10 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Symb-Nat/4 } Tile{ AsIs: e.NormedNumber#2/11 } Tile{ AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Symbm_Nat.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[11], context[12] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Symb_B1("Symb:1", 4190823648U, 3252578238U, func_gen_Symb_B1);

static refalrts::FnResult func_gen_Symb_A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & Symb=1/4 s.First#1/5 s.NormedSign#2/6 e.NormedNumber#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.NormedNumber#2 as range 2
  //DEBUG: s.First#1: 5
  //DEBUG: s.NormedSign#2: 6
  //DEBUG: e.NormedNumber#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </7 </8 & @create_closure@/9 & Symb:1/10 (/11 Tile{ AsIs: e.NormedNumber#2/2 } Tile{ HalfReuse: )/0 HalfReuse: >/4 AsIs: s.First#1/5 AsIs: s.NormedSign#2/6 } Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], refalrts::create_closure ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_gen_Symb_B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[11] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_close_bracket( context[0] );
  refalrts::reinit_close_call( context[4] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[4] );
  refalrts::push_stack( context[8] );
  refalrts::link_brackets( context[11], context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[0], context[6] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[7], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Symb_A1("Symb=1", 4190823648U, 3252578238U, func_gen_Symb_A1);

static refalrts::FnResult func_Symb(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  // </0 & Symb/4 s.First#1/5 e.Tail#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Tail#1 as range 2
  //DEBUG: s.First#1: 5
  //DEBUG: e.Tail#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </6 </7 & @create_closure@/8 & Symb=1/9 s.First#1/5/10 >/11 Tile{ AsIs: </0 Reuse: & NormNumber/4 AsIs: s.First#1/5 AsIs: e.Tail#1/2 AsIs: >/1 } >/12 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], refalrts::create_closure ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], ref_gen_Symb_A1.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[10], context[5]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormNumber.ref.function );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[6], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Symb("Symb", 0U, 0U, func_Symb);

static refalrts::FnResult func_gen_Symbm_Nat_S2A2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  // </0 & Symb-Nat$2=2/4 (/7 e.Div#2/5 )/8 (/11 e.Zeros#3/9 )/12 e.StrDigits#3/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.Div#2 as range 5
  // closed e.Zeros#3 as range 9
  // closed e.StrDigits#3 as range 2
  //DEBUG: e.Div#2: 5
  //DEBUG: e.Zeros#3: 9
  //DEBUG: e.StrDigits#3: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 (/11 e.Zeros#3/9 )/12 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Symb-Nat/4 } Tile{ AsIs: e.Div#2/5 } Tile{ AsIs: >/1 } Tile{ AsIs: e.StrDigits#3/2 } Tile{ ]] }
  refalrts::update_name( context[4], ref_Symbm_Nat.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Symbm_Nat_S2A2("Symb-Nat$2=2", 4190823648U, 3252578238U, func_gen_Symbm_Nat_S2A2);

static refalrts::FnResult func_gen_Symbm_Nat_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 22 elems
  refalrts::Iter context[22];
  refalrts::zeros( context, 22 );
  // </0 & Symb-Nat$2=1/4 (/7 e.Div#2/5 )/8 s.Mod#2/9 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Div#2 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Div#2: 5
  //DEBUG: s.Mod#2: 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </10 </11 Tile{ HalfReuse: & @create_closure@/0 Reuse: & Symb-Nat$2=2/4 AsIs: (/7 AsIs: e.Div#2/5 AsIs: )/8 } >/12 </13 & Last/14 9/15"000000000"/16 </18 & StrFromInt/19 Tile{ AsIs: s.Mod#2/9 AsIs: >/1 } >/20 >/21 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], ref_Last.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[15], 9UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[16], context[17], "000000000", 9 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], ref_StrFromInt.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[21] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[0], refalrts::create_closure );
  refalrts::update_name( context[4], ref_gen_Symbm_Nat_S2A2.ref.function );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[11] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[20], context[21] );
  res = refalrts::splice_evar( res, context[9], context[1] );
  res = refalrts::splice_evar( res, context[12], context[19] );
  res = refalrts::splice_evar( res, context[0], context[8] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Symbm_Nat_S2A1("Symb-Nat$2=1", 4190823648U, 3252578238U, func_gen_Symbm_Nat_S2A1);

static refalrts::FnResult func_Symbm_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & Symb-Nat/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // s.idx
    // </0 & Symb-Nat/4 s.Number#1/7 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.Number#1: 7

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & StrFromInt/4 AsIs: s.Number#1/7 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_StrFromInt.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & Symb-Nat/4 e.Number#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.Number#1 as range 5
  //DEBUG: e.Number#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Symb-Nat$2=1/4 } </7 & Divmod/8 (/9 Tile{ AsIs: e.Number#1/5 } )/10 1000000000/11 >/12 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_Divmod.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[11], 1000000000UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_gen_Symbm_Nat_S2A1.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[7] );
  refalrts::link_brackets( context[9], context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[10], context[12] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[7], context[9] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Symbm_Nat("Symb-Nat", 4190823648U, 3252578238U, func_Symbm_Nat);

static refalrts::FnResult func_Type(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1308 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  char type = '*';
  char subtype = '0';

  if (! refalrts::empty_seq(content_b, content_e)) {
    switch (content_b->tag) {
    case refalrts::cDataChar:
      {
        char ch = content_b->char_info;

        if (isdigit(ch)) {
          type = 'D';
        } else {
          if (isalpha(ch)) {
            type = 'L';
          } else if (isprint(ch)) {
            type = 'P';
          } else {
            type = 'O';
          }

          if (isupper(ch)) {
            subtype = 'u';
          } else {
            subtype = 'l';
          }
        }
      }
      break;

    case refalrts::cDataNumber:
      type = 'N';
      break;

    case refalrts::cDataFunction:
      type = 'F';
      subtype = 'g';
      break;

    case refalrts::cDataIdentifier:
      {
        const char *name = content_b->ident_info->name();

        type = 'W';
        subtype = 'q';
        if (isalpha(*name)) {
          while (
            *name != '\0' && (isalnum(*name) || *name == '_' || *name == '-')
          ) {
            ++name;
          }

          if (*name == '\0') {
            subtype = 'i';
          }
        }
      }
      break;

    case refalrts::cDataOpenADT:
      type = 'B';
      subtype = 'a';
      break;

    case refalrts::cDataOpenBracket:
      type = 'B';
      break;

    case refalrts::cDataFile:
      type = 'H';
      break;

    case refalrts::cDataClosure:
      type = 'F';
      subtype = 'c';
      break;

    default:
      refalrts_switch_default_violation(content_b->tag);
      // break;
    }
  }

  refalrts::reinit_char(arg_begin, type);
  refalrts::reinit_char(pfunc_name, subtype);
  refalrts::splice_to_freelist(arg_end, arg_end);

  return refalrts::cSuccess;
#line 9360 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Type("Type", 0U, 0U, func_Type);

#line 1408 "Library.sref"
namespace {

struct UpperConv {
  bool for_convert(refalrts::Iter item) {
    return refalrts::cDataChar == item->tag;
  }

  void convert(refalrts::Iter item) {
    item->char_info = static_cast<char>(toupper(item->char_info));
  }
};

}  // unnamed namespace
#line 9379 "Library.cpp"
static refalrts::FnResult func_Upper(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1425 "Library.sref"
  return convert(arg_begin, arg_end, UpperConv());
#line 9383 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Upper("Upper", 0U, 0U, func_Upper);

static refalrts::FnResult func_GetEnv(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1436 "Library.sref"
  return refal_getenv(arg_begin, arg_end);
#line 9391 "Library.cpp"
}

static refalrts::NativeReference nat_ref_GetEnv("GetEnv", 0U, 0U, func_GetEnv);

static refalrts::FnResult func_Close(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1447 "Library.sref"
  return close(arg_begin, arg_end, cCloseMode_Silent);
#line 9399 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Close("Close", 0U, 0U, func_Close);

static refalrts::FnResult func_ExistFile(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1458 "Library.sref"
  return exist_file(arg_begin, arg_end);
#line 9407 "Library.cpp"
}

static refalrts::NativeReference nat_ref_ExistFile("ExistFile", 0U, 0U, func_ExistFile);

static refalrts::FnResult func_Implodeu_Ext(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1468 "Library.sref"
  return implode_ext(arg_begin, arg_end);
#line 9415 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Implodeu_Ext("Implode_Ext", 0U, 0U, func_Implodeu_Ext);

static refalrts::FnResult func_Explodeu_Ext(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1478 "Library.sref"
  return explode(arg_begin, arg_end);
#line 9423 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Explodeu_Ext("Explode_Ext", 0U, 0U, func_Explodeu_Ext);

static refalrts::FnResult func_gen_Compare_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Compare$2=1/4 (/7 e.First#2/5 )/8 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#2 as range 5
  // closed e.Second#2 as range 2
  //DEBUG: e.First#2: 5
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Compare-Normed/4 AsIs: (/7 AsIs: e.First#2/5 AsIs: )/8 AsIs: e.Second#2/2 AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Comparem_Normed.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Compare_S2A1("Compare$2=1", 4190823648U, 3252578238U, func_gen_Compare_S2A1);

static refalrts::FnResult func_Compare(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  //FAST GEN: e.$
  //GLOBAL GEN: e.$
  // </0 & Compare/4 e.idx#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.idx#0 as range 2
  do {
    // s.idx s.idx
    // </0 & Compare/4 s.First#1/7 s.Second#1/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.First#1: 7
    //DEBUG: s.Second#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Compare-Digits/4 AsIs: s.First#1/7 AsIs: s.Second#1/8 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Comparem_Digits.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // e.idx
  // </0 & Compare/4 e.ArithmArg#1/5 >/1
  context[5] = context[2];
  context[6] = context[3];
  // closed e.ArithmArg#1 as range 5
  //DEBUG: e.ArithmArg#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </7 & Compare$2=1/8 Tile{ AsIs: </0 Reuse: & NormArithmArg/4 AsIs: e.ArithmArg#1/5 AsIs: >/1 } >/9 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_gen_Compare_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormArithmArg.ref.function );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Compare("Compare", 0U, 0U, func_Compare);

static refalrts::FnResult func_Comparem_Normed(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) s.$ e.$
  // </0 & Compare-Normed/4 (/7 e.idxB#0/5 )/8 s.idxT#0/9 e.idxTV#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.idxB#0 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.idxTV#0 as range 2
  do {
    // ( '+' e.idx ) '+' e.idx
    // </0 & Compare-Normed/4 (/7 '+'/14 e.First#1/10 )/8 '+'/9 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '+', context[9] ) )
      continue;
    context[14] = refalrts::char_left( '+', context[10], context[11] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 10
    // closed e.Second#1 as range 12
    //DEBUG: e.First#1: 10
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} '+'/14 {REMOVED TILE} )/8 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Compare-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/10 } Tile{ HalfReuse: )/9 AsIs: e.Second#1/12 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Comparem_Nat.ref.function );
    refalrts::reinit_close_bracket( context[9] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[9];
    res = refalrts::splice_evar( res, context[10], context[11] );
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '+' e.idx ) '-' e.idx
    // </0 & Compare-Normed/4 (/7 '+'/14 e.First#1/10 )/8 '-'/9 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '-', context[9] ) )
      continue;
    context[14] = refalrts::char_left( '+', context[10], context[11] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 10
    // closed e.Second#1 as range 12
    //DEBUG: e.First#1: 10
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-Normed/4 (/7 '+'/14 e.First#1/10 )/8 '-'/9 e.Second#1/12 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '+'/1 ]] }
    refalrts::reinit_char( context[1], '+' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '+' e.idx ) 0
    // </0 & Compare-Normed/4 (/7 '+'/14 e.First#1/10 )/8 0/9 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::number_term( 0UL, context[9] ) )
      continue;
    context[14] = refalrts::char_left( '+', context[10], context[11] );
    if( ! context[14] )
      continue;
    if( ! refalrts::empty_seq( context[12], context[13] ) )
      continue;
    // closed e.First#1 as range 10
    //DEBUG: e.First#1: 10

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-Normed/4 (/7 '+'/14 e.First#1/10 )/8 0/9 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '+'/1 ]] }
    refalrts::reinit_char( context[1], '+' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '-' e.idx ) '+' e.idx
    // </0 & Compare-Normed/4 (/7 '-'/14 e.First#1/10 )/8 '+'/9 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '+', context[9] ) )
      continue;
    context[14] = refalrts::char_left( '-', context[10], context[11] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 10
    // closed e.Second#1 as range 12
    //DEBUG: e.First#1: 10
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-Normed/4 (/7 '-'/14 e.First#1/10 )/8 '+'/9 e.Second#1/12 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '-'/1 ]] }
    refalrts::reinit_char( context[1], '-' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '-' e.idx ) '-' e.idx
    // </0 & Compare-Normed/4 (/7 '-'/14 e.First#1/10 )/8 '-'/9 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '-', context[9] ) )
      continue;
    context[14] = refalrts::char_left( '-', context[10], context[11] );
    if( ! context[14] )
      continue;
    // closed e.First#1 as range 10
    // closed e.Second#1 as range 12
    //DEBUG: e.First#1: 10
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} '-'/14 {REMOVED TILE} {REMOVED TILE} '-'/9 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Compare-Nat/4 AsIs: (/7 } Tile{ AsIs: e.Second#1/12 } Tile{ AsIs: )/8 } Tile{ AsIs: e.First#1/10 } Tile{ AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Comparem_Nat.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[10], context[11] );
    res = refalrts::splice_evar( res, context[8], context[8] );
    res = refalrts::splice_evar( res, context[12], context[13] );
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( '-' e.idx ) 0
    // </0 & Compare-Normed/4 (/7 '-'/14 e.First#1/10 )/8 0/9 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::number_term( 0UL, context[9] ) )
      continue;
    context[14] = refalrts::char_left( '-', context[10], context[11] );
    if( ! context[14] )
      continue;
    if( ! refalrts::empty_seq( context[12], context[13] ) )
      continue;
    // closed e.First#1 as range 10
    //DEBUG: e.First#1: 10

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-Normed/4 (/7 '-'/14 e.First#1/10 )/8 0/9 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '-'/1 ]] }
    refalrts::reinit_char( context[1], '-' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( 0 ) '+' e.idx
    // </0 & Compare-Normed/4 (/7 0/14 )/8 '+'/9 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '+', context[9] ) )
      continue;
    context[14] = refalrts::number_left( 0UL, context[10], context[11] );
    if( ! context[14] )
      continue;
    if( ! refalrts::empty_seq( context[10], context[11] ) )
      continue;
    // closed e.Second#1 as range 12
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-Normed/4 (/7 0/14 )/8 '+'/9 e.Second#1/12 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '-'/1 ]] }
    refalrts::reinit_char( context[1], '-' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( 0 ) '-' e.idx
    // </0 & Compare-Normed/4 (/7 0/14 )/8 '-'/9 e.Second#1/12 >/1
    context[10] = context[5];
    context[11] = context[6];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '-', context[9] ) )
      continue;
    context[14] = refalrts::number_left( 0UL, context[10], context[11] );
    if( ! context[14] )
      continue;
    if( ! refalrts::empty_seq( context[10], context[11] ) )
      continue;
    // closed e.Second#1 as range 12
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-Normed/4 (/7 0/14 )/8 '-'/9 e.Second#1/12 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '+'/1 ]] }
    refalrts::reinit_char( context[1], '+' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( 0 ) 0
  // </0 & Compare-Normed/4 (/7 0/14 )/8 0/9 >/1
  context[10] = context[5];
  context[11] = context[6];
  context[12] = context[2];
  context[13] = context[3];
  if( ! refalrts::number_term( 0UL, context[9] ) )
    return refalrts::cRecognitionImpossible;
  context[14] = refalrts::number_left( 0UL, context[10], context[11] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[10], context[11] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[12], context[13] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Compare-Normed/4 (/7 0/14 )/8 0/9 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: '0'/1 ]] }
  refalrts::reinit_char( context[1], '0' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Comparem_Normed("Compare-Normed", 4190823648U, 3252578238U, func_Comparem_Normed);

static refalrts::FnResult func_Comparem_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  // </0 & Compare-Nat/4 (/7 e.First#1/5 )/8 e.Second#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#1 as range 5
  // closed e.Second#1 as range 2
  //DEBUG: e.First#1: 5
  //DEBUG: e.Second#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Compare-Align/4 AsIs: (/7 } (/9 )/10 Tile{ AsIs: e.First#1/5 } )/11 (/12 Tile{ AsIs: )/8 AsIs: e.Second#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Comparem_Align.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[12], context[8] );
  refalrts::link_brackets( context[7], context[11] );
  refalrts::link_brackets( context[9], context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[8];
  res = refalrts::splice_evar( res, context[11], context[12] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Comparem_Nat("Compare-Nat", 4190823648U, 3252578238U, func_Comparem_Nat);

static refalrts::FnResult func_Comparem_Align(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 27 elems
  refalrts::Iter context[27];
  refalrts::zeros( context, 27 );
  //FAST GEN: e.$
  //GLOBAL GEN: ( e.$ ) ( e.$ ) e.$
  // </0 & Compare-Align/4 (/7 e.idxB#0/5 )/8 (/11 e.idxTB#0/9 )/12 e.idxTT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.idxB#0 as range 5
  // closed e.idxTB#0 as range 9
  // closed e.idxTT#0 as range 2
  do {
    // ( ( e.idx ) s.idx e.idx ) ( e.idx ) s.idx e.idx
    // </0 & Compare-Align/4 (/7 (/21 e.First-L#1/19 )/22 s.First-Dig#1/23 e.First-R#1/13 )/8 (/11 e.Second-L#1/15 )/12 s.Second-Dig#1/24 e.Second-R#1/17 >/1
    context[13] = context[5];
    context[14] = context[6];
    context[15] = context[9];
    context[16] = context[10];
    context[17] = context[2];
    context[18] = context[3];
    context[19] = 0;
    context[20] = 0;
    context[21] = refalrts::brackets_left( context[19], context[20], context[13], context[14] );
    if( ! context[21] )
      continue;
    refalrts::bracket_pointers(context[21], context[22]);
    // closed e.First-L#1 as range 19
    // closed e.Second-L#1 as range 15
    if( ! refalrts::svar_left( context[23], context[13], context[14] ) )
      continue;
    // closed e.First-R#1 as range 13
    if( ! refalrts::svar_left( context[24], context[17], context[18] ) )
      continue;
    // closed e.Second-R#1 as range 17
    //DEBUG: e.First-L#1: 19
    //DEBUG: e.Second-L#1: 15
    //DEBUG: s.First-Dig#1: 23
    //DEBUG: e.First-R#1: 13
    //DEBUG: s.Second-Dig#1: 24
    //DEBUG: e.Second-R#1: 17

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.First-Dig#1/23 {REMOVED TILE} {REMOVED TILE} s.Second-Dig#1/24 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & Compare-Align/4 AsIs: (/7 AsIs: (/21 AsIs: e.First-L#1/19 HalfReuse: s.First-Dig1 #23/22 } )/25 Tile{ AsIs: e.First-R#1/13 } Tile{ AsIs: )/8 AsIs: (/11 AsIs: e.Second-L#1/15 HalfReuse: s.Second-Dig1 #24/12 } )/26 Tile{ AsIs: e.Second-R#1/17 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_bracket( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[26] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_svar( context[22], context[23] );
    refalrts::reinit_svar( context[12], context[24] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[11], context[26] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::link_brackets( context[21], context[25] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[26], context[26] );
    res = refalrts::splice_evar( res, context[8], context[12] );
    res = refalrts::splice_evar( res, context[13], context[14] );
    res = refalrts::splice_evar( res, context[25], context[25] );
    refalrts::splice_to_freelist_open( context[22], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( ( e.idx ) s.idx e.idx ) ( e.idx )
    // </0 & Compare-Align/4 (/7 (/21 e.First-L#1/19 )/22 s.First-Dig#1/23 e.First-R#1/13 )/8 (/11 e.Second-L#1/15 )/12 >/1
    context[13] = context[5];
    context[14] = context[6];
    context[15] = context[9];
    context[16] = context[10];
    context[17] = context[2];
    context[18] = context[3];
    context[19] = 0;
    context[20] = 0;
    context[21] = refalrts::brackets_left( context[19], context[20], context[13], context[14] );
    if( ! context[21] )
      continue;
    refalrts::bracket_pointers(context[21], context[22]);
    if( ! refalrts::empty_seq( context[17], context[18] ) )
      continue;
    // closed e.First-L#1 as range 19
    // closed e.Second-L#1 as range 15
    if( ! refalrts::svar_left( context[23], context[13], context[14] ) )
      continue;
    // closed e.First-R#1 as range 13
    //DEBUG: e.First-L#1: 19
    //DEBUG: e.Second-L#1: 15
    //DEBUG: s.First-Dig#1: 23
    //DEBUG: e.First-R#1: 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-Align/4 (/7 (/21 e.First-L#1/19 )/22 s.First-Dig#1/23 e.First-R#1/13 )/8 (/11 e.Second-L#1/15 )/12 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '+'/1 ]] }
    refalrts::reinit_char( context[1], '+' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // ( ( e.idx ) ) ( e.idx ) s.idx e.idx
    // </0 & Compare-Align/4 (/7 (/21 e.First-L#1/19 )/22 )/8 (/11 e.Second-L#1/15 )/12 s.Second-Dig#1/23 e.Second-R#1/17 >/1
    context[13] = context[5];
    context[14] = context[6];
    context[15] = context[9];
    context[16] = context[10];
    context[17] = context[2];
    context[18] = context[3];
    context[19] = 0;
    context[20] = 0;
    context[21] = refalrts::brackets_left( context[19], context[20], context[13], context[14] );
    if( ! context[21] )
      continue;
    refalrts::bracket_pointers(context[21], context[22]);
    if( ! refalrts::empty_seq( context[13], context[14] ) )
      continue;
    // closed e.First-L#1 as range 19
    // closed e.Second-L#1 as range 15
    if( ! refalrts::svar_left( context[23], context[17], context[18] ) )
      continue;
    // closed e.Second-R#1 as range 17
    //DEBUG: e.First-L#1: 19
    //DEBUG: e.Second-L#1: 15
    //DEBUG: s.Second-Dig#1: 23
    //DEBUG: e.Second-R#1: 17

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-Align/4 (/7 (/21 e.First-L#1/19 )/22 )/8 (/11 e.Second-L#1/15 )/12 s.Second-Dig#1/23 e.Second-R#1/17 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '-'/1 ]] }
    refalrts::reinit_char( context[1], '-' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // ( ( s.idx e.idx ) ) ( s.idx e.idx )
  // </0 & Compare-Align/4 (/7 (/21 s.First-Dig#1/23 e.First#1/19 )/22 )/8 (/11 s.Second-Dig#1/24 e.Second#1/15 )/12 >/1
  context[13] = context[5];
  context[14] = context[6];
  context[15] = context[9];
  context[16] = context[10];
  context[17] = context[2];
  context[18] = context[3];
  context[19] = 0;
  context[20] = 0;
  context[21] = refalrts::brackets_left( context[19], context[20], context[13], context[14] );
  if( ! context[21] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[21], context[22]);
  if( ! refalrts::empty_seq( context[13], context[14] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[17], context[18] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[23], context[19], context[20] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.First#1 as range 19
  if( ! refalrts::svar_left( context[24], context[15], context[16] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Second#1 as range 15
  //DEBUG: s.First-Dig#1: 23
  //DEBUG: e.First#1: 19
  //DEBUG: s.Second-Dig#1: 24
  //DEBUG: e.Second#1: 15

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.Second-Dig#1/24 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Compare-ByDigits/4 HalfReuse: </7 HalfReuse: & Compare-Digits/21 AsIs: s.First-Dig#1/23 } Tile{ HalfReuse: s.Second-Dig1 #24/22 HalfReuse: >/8 AsIs: (/11 } Tile{ AsIs: e.First#1/19 } Tile{ AsIs: )/12 } Tile{ AsIs: e.Second#1/15 } Tile{ AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Comparem_ByDigits.ref.function );
  refalrts::reinit_open_call( context[7] );
  refalrts::reinit_name( context[21], ref_Comparem_Digits.ref.function );
  refalrts::reinit_svar( context[22], context[24] );
  refalrts::reinit_close_call( context[8] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[15], context[16] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[19], context[20] );
  res = refalrts::splice_evar( res, context[22], context[11] );
  refalrts::splice_to_freelist_open( context[23], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Comparem_Align("Compare-Align", 4190823648U, 3252578238U, func_Comparem_Align);

static refalrts::FnResult func_Comparem_ByDigits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 18 elems
  refalrts::Iter context[18];
  refalrts::zeros( context, 18 );
  //FAST GEN: e.$
  //GLOBAL GEN: s.$ ( e.$ ) e.$
  // </0 & Compare-ByDigits/4 s.idx#0/5 (/8 e.idxVB#0/6 )/9 e.idxVT#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  // closed e.idxVB#0 as range 6
  // closed e.idxVT#0 as range 2
  do {
    // '0' ( s.idx e.idx ) s.idx e.idx
    // </0 & Compare-ByDigits/4 '0'/5 (/8 s.First-Dig#1/14 e.First#1/10 )/9 s.Second-Dig#1/15 e.Second#1/12 >/1
    context[10] = context[6];
    context[11] = context[7];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '0', context[5] ) )
      continue;
    if( ! refalrts::svar_left( context[14], context[10], context[11] ) )
      continue;
    // closed e.First#1 as range 10
    if( ! refalrts::svar_left( context[15], context[12], context[13] ) )
      continue;
    // closed e.Second#1 as range 12
    //DEBUG: s.First-Dig#1: 14
    //DEBUG: e.First#1: 10
    //DEBUG: s.Second-Dig#1: 15
    //DEBUG: e.Second#1: 12

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & Compare-ByDigits/4 HalfReuse: </5 HalfReuse: & Compare-Digits/8 AsIs: s.First-Dig#1/14 } Tile{ AsIs: s.Second-Dig#1/15 } >/16 (/17 Tile{ AsIs: e.First#1/10 } Tile{ AsIs: )/9 } Tile{ AsIs: e.Second#1/12 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[5] );
    refalrts::reinit_name( context[8], ref_Comparem_Digits.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[17], context[9] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[5] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[12], context[13] );
    res = refalrts::splice_evar( res, context[9], context[9] );
    res = refalrts::splice_evar( res, context[10], context[11] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // '0' ( )
    // </0 & Compare-ByDigits/4 '0'/5 (/8 )/9 >/1
    context[10] = context[6];
    context[11] = context[7];
    context[12] = context[2];
    context[13] = context[3];
    if( ! refalrts::char_term( '0', context[5] ) )
      continue;
    if( ! refalrts::empty_seq( context[10], context[11] ) )
      continue;
    if( ! refalrts::empty_seq( context[12], context[13] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-ByDigits/4 '0'/5 (/8 )/9 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '0'/1 ]] }
    refalrts::reinit_char( context[1], '0' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // s.idx ( e.idx ) e.idx
  // </0 & Compare-ByDigits/4 s.Compare-Res#1/5 (/8 e.First#1/10 )/9 e.Second#1/12 >/1
  context[10] = context[6];
  context[11] = context[7];
  context[12] = context[2];
  context[13] = context[3];
  // closed e.First#1 as range 10
  // closed e.Second#1 as range 12
  //DEBUG: s.Compare-Res#1: 5
  //DEBUG: e.First#1: 10
  //DEBUG: e.Second#1: 12

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Compare-ByDigits/4 s.Compare-Res#1/5 (/8 e.First#1/10 )/9 e.Second#1/12 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: s.Compare-Res1 #5/1 ]] }
  refalrts::reinit_svar( context[1], context[5] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Comparem_ByDigits("Compare-ByDigits", 4190823648U, 3252578238U, func_Comparem_ByDigits);

static refalrts::FnResult func_Comparem_Digits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1540 "Library.sref"
  ARITHM_PRELUDE

  char res = first < second ? '-' : first > second ? '+' : '0';

  refalrts::reinit_char(arg_begin, res);
  refalrts::splice_to_freelist(pFunc, arg_end);
  return refalrts::cSuccess;
#line 10227 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Comparem_Digits("Compare-Digits", 4190823648U, 3252578238U, func_Comparem_Digits);

static refalrts::FnResult func_Write(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1556 "Library.sref"
  return fwrite_line(
    arg_begin, arg_end,
    cFlags_Autoopen | cFlags_Write | cFlags_StdErr | cFlags_NoEOL
  );
#line 10238 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Write("Write", 0U, 0U, func_Write);

static refalrts::FnResult func_FClose(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1575 "Library.sref"
  return close(arg_begin, arg_end, cCloseMode_Fail);
#line 10246 "Library.cpp"
}

static refalrts::NativeReference nat_ref_FClose("FClose", 0U, 0U, func_FClose);

static refalrts::FnResult func_gen_FOpen_A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  // </0 & FOpen=1/4 t.Mode#1/5 s.FileNameChar#1/7 (/10 e.FileName#1/8 )/11 s.FreeHandle#2/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[7], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[8] = 0;
  context[9] = 0;
  context[10] = refalrts::brackets_left( context[8], context[9], context[2], context[3] );
  if( ! context[10] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[10], context[11]);
  // closed e.FileName#1 as range 8
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: t.Mode#1: 5
  //DEBUG: s.FileNameChar#1: 7
  //DEBUG: e.FileName#1: 8
  //DEBUG: s.FreeHandle#2: 12

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.FileNameChar#1/7 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Open/4 AsIs: t.Mode#1/5 } Tile{ HalfReuse: s.FreeHandle2 #12/1 } Tile{ HalfReuse: s.FileNameChar1 #7/10 AsIs: e.FileName#1/8 HalfReuse: >/11 AsIs: s.FreeHandle#2/12 } Tile{ ]] }
  refalrts::update_name( context[4], ref_Open.ref.function );
  refalrts::reinit_svar( context[1], context[12] );
  refalrts::reinit_svar( context[10], context[7] );
  refalrts::reinit_close_call( context[11] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[10], context[12] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  refalrts::splice_to_freelist_open( context[6], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_FOpen_A1("FOpen=1", 4190823648U, 3252578238U, func_gen_FOpen_A1);

static refalrts::FnResult func_FOpen(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  // </0 & FOpen/4 t.Mode#1/5 s.FileNameChar#1/7 e.FileName#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[7], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.FileName#1 as range 2
  //DEBUG: t.Mode#1: 5
  //DEBUG: s.FileNameChar#1: 7
  //DEBUG: e.FileName#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </8 </9 Tile{ HalfReuse: & @create_closure@/0 Reuse: & FOpen=1/4 AsIs: t.Mode#1/5 AsIs: s.FileNameChar#1/7 } (/10 Tile{ AsIs: e.FileName#1/2 } )/11 >/12 </13 & GetFreeHandle/14 >/15 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], ref_GetFreeHandle.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[15] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[0], refalrts::create_closure );
  refalrts::update_name( context[4], ref_gen_FOpen_A1.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[9] );
  refalrts::link_brackets( context[10], context[11] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[11], context[15] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[0], context[7] );
  res = refalrts::splice_evar( res, context[8], context[9] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_FOpen("FOpen", 0U, 0U, func_FOpen);

static refalrts::FnResult func_FReadLine(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1597 "Library.sref"
  return fread_line(arg_begin, arg_end, cFlags_ReturnHandle | cFlags_StdIn);
#line 10369 "Library.cpp"
}

static refalrts::NativeReference nat_ref_FReadLine("FReadLine", 0U, 0U, func_FReadLine);

static refalrts::FnResult func_FWriteLine(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1607 "Library.sref"
  return fwrite_line(
    arg_begin, arg_end, cFlags_Write | cFlags_StdErr | cFlags_ReturnHandle
  );
#line 10379 "Library.cpp"
}

static refalrts::NativeReference nat_ref_FWriteLine("FWriteLine", 0U, 0U, func_FWriteLine);

static refalrts::FnResult func_GetFreeHandle(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1620 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber free_file = 0;
  if (! get_free_handle(free_file)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reinit_number(arg_begin, free_file);
  refalrts::splice_to_freelist(pfunc_name, arg_end);
  return refalrts::cSuccess;
#line 10403 "Library.cpp"
}

static refalrts::NativeReference nat_ref_GetFreeHandle("GetFreeHandle", 4190823648U, 3252578238U, func_GetFreeHandle);

static refalrts::FnResult func_ReadLine(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1646 "Library.sref"
  return fread_line(arg_begin, arg_end, cFlags_NoHandle | cFlags_StdIn);
#line 10411 "Library.cpp"
}

static refalrts::NativeReference nat_ref_ReadLine("ReadLine", 0U, 0U, func_ReadLine);

static refalrts::FnResult func_WriteLine(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1658 "Library.sref"
  return fwrite_line(arg_begin, arg_end, cFlags_NoHandle | cFlags_StdOut);
#line 10419 "Library.cpp"
}

static refalrts::NativeReference nat_ref_WriteLine("WriteLine", 0U, 0U, func_WriteLine);

#line 1668 "Library.sref"
#define USE_IDENT(ident_name) (ident_ ## ident_name)
#line 10426 "Library.cpp"
#line 1684 "Library.sref"
namespace {

enum { cMaxFileHandles = 40 };
FILE *g_file_handles[cMaxFileHandles];

bool file_handle_left(
  refalrts::Iter& pfile_handle, refalrts::Iter& first, refalrts::Iter& last
) {
  return refalrts::svar_left(pfile_handle, first, last)
    && (
      refalrts::cDataNumber == pfile_handle->tag
      || (
        refalrts::cDataIdentifier == pfile_handle->tag
        && (
          USE_IDENT(stdin) == pfile_handle->ident_info
          || USE_IDENT(stdout) == pfile_handle->ident_info
          || USE_IDENT(stderr) == pfile_handle->ident_info
          || USE_IDENT(stout) == pfile_handle->ident_info
        )
      )
    );
}

void close_all_files_at_exit(void *) {
  for (size_t i = 0; i < cMaxFileHandles; ++i) {
    if (g_file_handles[i] != 0) {
      fclose(g_file_handles[i]);
      g_file_handles[i] = 0;    // на всякий случай
    }
  }
}

FILE *extract_file_handle(refalrts::Iter pfile_handle, unsigned flags = 0) {
  bool is_stdin = (flags & cFlags_StreamMask) == cFlags_StdIn;
  bool is_stdout = (flags & cFlags_StreamMask) == cFlags_StdOut;
  bool is_stderr = (flags & cFlags_StreamMask) == cFlags_StdErr;

  FILE *default_handle =
    is_stdin ? stdin : is_stdout ? stdout : is_stderr ? stderr : 0;

  if (flags & cFlags_NoHandle) {
    assert(is_stdin + is_stdout + is_stderr == 1);
    return default_handle;
  } else {
    assert(
      refalrts::cDataNumber == pfile_handle->tag
      || refalrts::cDataIdentifier == pfile_handle->tag
    );

    if (refalrts::cDataNumber == pfile_handle->tag) {
      bool autoopen = flags & cFlags_Autoopen;
      refalrts::RefalNumber file_no = pfile_handle->number_info % cMaxFileHandles;

      if (file_no == 0) {
        assert(is_stdin + is_stdout + is_stderr <= 1);
        return default_handle;
      } else if (g_file_handles[file_no] == 0 && autoopen) {
        refalrts::at_exit(close_all_files_at_exit, 0);

        char default_name[sizeof("REFAL4294967296.DAT")];
        sprintf(default_name, "REFAL%d.DAT", file_no);

        bool default_read = (flags & cFlags_Read) != 0;
        bool default_write = (flags & cFlags_Write) != 0;
        assert(default_read + default_write == 1);

        const char *default_mode = default_read ? "r" : default_write ? "w" : 0;
        g_file_handles[file_no] = fopen(default_name, default_mode);
      }

      return g_file_handles[file_no];
    } else if (refalrts::cDataIdentifier == pfile_handle->tag) {
      return
        USE_IDENT(stdin) == pfile_handle->ident_info ? stdin :
        USE_IDENT(stdout) == pfile_handle->ident_info ? stdout :
        USE_IDENT(stderr) == pfile_handle->ident_info ? stderr : stdout;
    } else {
      refalrts_switch_default_violation(pfile_handle->tag);
    }
  }
}

bool get_free_handle(refalrts::RefalNumber& free_file) {
  free_file = 1;
  while (free_file < cMaxFileHandles && g_file_handles[free_file] != 0)
    ++free_file;

  return free_file < cMaxFileHandles;
}

bool release_file_handle(refalrts::Iter pfile_handle) {
  if (refalrts::cDataIdentifier == pfile_handle->tag) {
    return true;
  }

  assert(refalrts::cDataNumber == pfile_handle->tag);

  refalrts::RefalNumber file_no = pfile_handle->number_info % cMaxFileHandles;

  assert(g_file_handles[file_no] != 0);

  bool successful_closed = EOF != fclose(g_file_handles[file_no]);
  g_file_handles[file_no] = 0;
  return successful_closed;
}

bool reopen_handle(
  refalrts::Iter pfile_handle, const char *filename, const char *mode
) {
  if (refalrts::cDataIdentifier == pfile_handle->tag) {
    return false;
  }

  assert(refalrts::cDataNumber == pfile_handle->tag);

  refalrts::RefalNumber file_no = pfile_handle->number_info % cMaxFileHandles;

  if (g_file_handles[file_no] != 0) {
    if (! release_file_handle(pfile_handle)) {
      return false;
    }
  }

  char default_name[sizeof("REFAL4294967296.DAT")];
  if ((filename == 0 || strlen(filename) == 0)) {
    sprintf(default_name, "REFAL%d.DAT", file_no);
    filename = default_name;
  }

  refalrts::at_exit(close_all_files_at_exit, 0);
  return (g_file_handles[file_no] = fopen(filename, mode)) != 0;
}

refalrts::FnResult fwrite_line(
  refalrts::Iter arg_begin, refalrts::Iter arg_end, unsigned flags
) {
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  bool handle_in_arg = (flags & cFlags_NoHandle) == 0;
  refalrts::Iter pfile_handle = 0;

  if (handle_in_arg && ! file_handle_left(pfile_handle, content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = extract_file_handle(pfile_handle, flags);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  if (ferror(handle)) {
    return refalrts::cRecognitionImpossible;
  }

  int printf_res = 0;

  for (
    refalrts::Iter p = content_b, end = content_e;
    printf_res >= 0 && ! refalrts::empty_seq(p, end);
    refalrts::move_left(p, end)
  ) {
    switch(p->tag) {
      case refalrts::cDataChar:
        printf_res = fprintf(handle, "%c", p->char_info);
        break;

      case refalrts::cDataNumber:
        printf_res = fprintf(handle, "%u ", p->number_info);
        break;

      case refalrts::cDataFunction:
        printf_res = fprintf(handle, "%s ", p->function_info->name.name);
        break;

      case refalrts::cDataIdentifier:
        printf_res = fprintf(handle, "%s ", p->ident_info->name());
        break;

      case refalrts::cDataOpenADT:
        printf_res = fprintf(handle, "[");
        break;

      case refalrts::cDataCloseADT:
        printf_res = fprintf(handle, "]");
        break;

      case refalrts::cDataOpenBracket:
        printf_res = fprintf(handle, "(");
        break;

      case refalrts::cDataCloseBracket:
        printf_res = fprintf(handle, ")");
        break;

      case refalrts::cDataFile:
        printf_res = fprintf(handle, "*%p", p->file_info);
        break;

      case refalrts::cDataClosure:
        printf_res = fprintf(handle, "{ ");
        p = refalrts::unwrap_closure(p);
        break;

      case refalrts::cDataClosureHead:
        printf_res = fprintf(handle, "[%u] ", p->number_info);
        break;

      case refalrts::cDataUnwrappedClosure:
        printf_res = fprintf(handle, "} ");
        refalrts::wrap_closure(p);
        break;

      default:
        refalrts_switch_default_violation(p->tag);
    }
  }

  if (printf_res >= 0 && ! (flags & cFlags_NoEOL)) {
    printf_res = fprintf(handle, "\n");
  }

  if (printf_res < 0) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter res = arg_begin;
  if (flags & cFlags_Transparent) {
    res = refalrts::splice_evar(res, content_b, content_e);
  }

  if (flags & cFlags_ReturnHandle) {
    refalrts::splice_stvar(res, pfile_handle);
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
}

refalrts::FnResult fread_line(
  refalrts::Iter arg_begin, refalrts::Iter arg_end, unsigned flags
) {
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  bool handle_in_arg = (flags & cFlags_NoHandle) == 0;
  refalrts::Iter pfile_handle = 0;

  if (
    (handle_in_arg && ! file_handle_left(pfile_handle, content_b, content_e))
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();

  FILE *handle = extract_file_handle(pfile_handle, flags);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter dummy = 0;
  int cur_char;
  while ((cur_char = getc(handle)) != EOF && cur_char != '\n') {
    /*
      Пользуемся тем фактом, что в данной реализации размещёные в свободной
      памяти узлы располагаются в последовательных адресах.
    */
    if (! refalrts::alloc_char(dummy, static_cast<char>(cur_char))) {
      return refalrts::cNoMemory;
    }
  }

  if (cur_char == EOF) {
    if (! refalrts::alloc_number(dummy, 0UL)) {
      return refalrts::cNoMemory;
    }
  }

  refalrts::Iter res = refalrts::splice_from_freelist(arg_begin);
  if (flags & cFlags_ReturnHandle) {
    refalrts::splice_stvar(res, pfile_handle);
  }
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
}

refalrts::FnResult string_from_seq(
  std::vector<char>& string, refalrts::Iter begin, refalrts::Iter end
) {
  std::vector<char> result;

  enum { cBufLen = 100 };
  char buffer[cBufLen + 1] = { 0 };

  unsigned read;
  while ((read = refalrts::read_chars(buffer, cBufLen, begin, end)) != 0) {
    // В текущей версии Open Watcom (и форка Open Watcom V2) есть ошибка
    // в функции vector::insert, которая возникает в случае,
    // если во время вставки вектор увеличивает свою ёмкость (capacity).
    // Для обхода этой ошибки предварительно резервируем место.
    result.reserve(result.size() + read + 1);
    result.insert(result.end(), buffer, buffer + read);
  }

  /*
    Здесь refalrts::empty_seq(begin, end) || (begin->tag != cDataChar).
  */

  if (refalrts::empty_seq(begin, end)) {
    result.push_back('\0');
    string.swap(result);
    return refalrts::cSuccess;
  } else {
    // здесь begin->tag != cDataChar
    return refalrts::cRecognitionImpossible;
  }
}

refalrts::FnResult refal_open(
  refalrts::Iter arg_begin, refalrts::Iter arg_end
) {
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  std::string mode;

  refalrts::Iter mode_b = 0;
  refalrts::Iter mode_e = 0;
  refalrts::Iter pmode = 0;

  if (! refalrts::tvar_left(pmode, content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  if (refalrts::char_term('r', pmode)) {
    mode = "r";
  } else if (refalrts::char_term('w', pmode)) {
    mode = "w";
  } else if (refalrts::char_term('a', pmode)) {
    mode = "a";
  } else if (refalrts::brackets_term(mode_b, mode_e, pmode)) {
    char mode_str[100] = { '\0' };  // должно хватить
    unsigned len =
      refalrts::read_chars(mode_str, sizeof(mode_str) - 1, mode_b, mode_e);

    if (! refalrts::empty_seq(mode_b, mode_e) || len == 0) {
      return refalrts::cRecognitionImpossible;
    }

    mode = mode_str;
  } else if (refalrts::cDataIdentifier == pmode->tag) {
    mode = pmode->ident_info->name();
  } else {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter pfile_handle = 0;
  if (! file_handle_left(pfile_handle, content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  char filename[FILENAME_MAX + 1] = { '\0' };
  refalrts::read_chars(filename, FILENAME_MAX, content_b, content_e);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  if (! reopen_handle(pfile_handle, filename, mode.c_str())) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
}

refalrts::FnResult close(
  refalrts::Iter arg_begin, refalrts::Iter arg_end, CloseMode mode
) {
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;
  if (
    ! file_handle_left(pfile_handle, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = extract_file_handle(pfile_handle);
  switch (mode) {
  case cCloseMode_Silent:
    if (handle) {
      if (! release_file_handle(pfile_handle)) {
        return refalrts::cRecognitionImpossible;
      }
    }
    break;

  case cCloseMode_Fail:
    if (! handle) {
      return refalrts::cRecognitionImpossible;
    }

    if (! release_file_handle(pfile_handle)) {
      return refalrts::cRecognitionImpossible;
    }
    break;

  default:
    refalrts_switch_default_violation(mode);
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
}

refalrts::FnResult arg(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pparam_no = 0;
  if (
    ! refalrts::svar_left(pparam_no, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
    || refalrts::cDataNumber != pparam_no->tag
  ) {
    return refalrts::cRecognitionImpossible;
  }

  unsigned int param_no = static_cast<unsigned int>(pparam_no->number_info);

  refalrts::Iter param_begin = 0;
  refalrts::Iter param_end = 0;
  const char *param = refalrts::arg(param_no);

  if (! refalrts::alloc_string(param_begin, param_end, param)) {
    return refalrts::cNoMemory;
  }

  refalrts::splice_evar(arg_begin, param_begin, param_end);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
}


refalrts::FnResult exist_file(
  refalrts::Iter arg_begin, refalrts::Iter arg_end
) {
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  char filename[FILENAME_MAX + 1] = { '\0' };
  unsigned len =
    refalrts::read_chars(filename, FILENAME_MAX, content_b, content_e);

  if (! refalrts::empty_seq(content_b, content_e) || len == 0) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter ans = arg_begin;
  if (FILE *f = fopen(filename, "r")) {
    // Файл существует
    fclose(f);

    refalrts::reinit_ident(ans, USE_IDENT(True));
  } else {
    // Файл по-видимому не существует
    refalrts::reinit_ident(ans, USE_IDENT(False));
  }

  refalrts::splice_to_freelist(pfunc_name, arg_end);
  return refalrts::cSuccess;
}

}  // unnamed namespace
namespace {

refalrts::FnResult refal_getenv(
  refalrts::Iter arg_begin, refalrts::Iter arg_end
) {
  refalrts::Iter envname_b = 0;
  refalrts::Iter envname_e = 0;
  refalrts::call_left(envname_b, envname_e, arg_begin, arg_end);

  std::vector<char> envname;
  refalrts::FnResult envname_res =
    string_from_seq(envname, envname_b, envname_e);

  if (envname_res != refalrts::cSuccess) {
    return envname_res;
  }

  refalrts::reset_allocator();
  const char *envres = getenv(& envname[0]);

  if (envres != 0) {
    refalrts::Iter env_begin;
    refalrts::Iter env_end;

    if (! refalrts::alloc_string(env_begin, env_end, envres)) {
      return refalrts::cNoMemory;
    }

    refalrts::splice_evar(arg_begin, env_begin, env_end);
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
}

}  // unnamed namespace
#line 10950 "Library.cpp"
static refalrts::FnResult func_Exit(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2213 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pretcode = 0;
  if (
    ! refalrts::svar_left(pretcode, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
    || refalrts::cDataNumber != pretcode->tag
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::set_return_code(pretcode->number_info);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cExit;
#line 10969 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Exit("Exit", 0U, 0U, func_Exit);

static refalrts::FnResult func_System(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2234 "Library.sref"
  refalrts::Iter command_b = 0;
  refalrts::Iter command_e = 0;
  refalrts::call_left(command_b, command_e, arg_begin, arg_end);

  std::vector<char> command;
  refalrts::FnResult command_res =
    string_from_seq(command, command_b, command_e);

  if (command_res != refalrts::cSuccess) {
    return command_res;
  }

  fflush(stdout);
  fflush(stderr);

  // Skip return value
  int ret = system(&command[0]);
  (void) ret;

  refalrts::reset_allocator();
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 10998 "Library.cpp"
}

static refalrts::NativeReference nat_ref_System("System", 0U, 0U, func_System);

static refalrts::FnResult func_gen_IntFromStr_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  // </0 & IntFromStr\1/4 (/7 e.MacroDigits#2/5 s.LastDigit#2/9 )/8 e.Rest#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Rest#2 as range 2
  if( ! refalrts::svar_right( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.MacroDigits#2 as range 5
  //DEBUG: e.Rest#2: 2
  //DEBUG: s.LastDigit#2: 9
  //DEBUG: e.MacroDigits#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} (/7 e.MacroDigits#2/5 s.LastDigit#2/9 )/8 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: # Success/0 HalfReuse: s.LastDigit2 #9/4 } Tile{ AsIs: e.Rest#2/2 } Tile{ ]] }
  refalrts::reinit_ident( context[0], ident_Success );
  refalrts::reinit_svar( context[4], context[9] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_IntFromStr_L1("IntFromStr\\1", 4190823648U, 3252578238U, func_gen_IntFromStr_L1);

static refalrts::FnResult func_gen_IntFromStr_L2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 5 elems
  refalrts::Iter context[5];
  refalrts::zeros( context, 5 );
  // </0 & IntFromStr\2/4 e.Rest#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Rest#2 as range 2
  //DEBUG: e.Rest#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & IntFromStr\2/4 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: # Fails/0 } Tile{ AsIs: e.Rest#2/2 } Tile{ ]] }
  refalrts::reinit_ident( context[0], ident_Fails );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_IntFromStr_L2("IntFromStr\\2", 4190823648U, 3252578238U, func_gen_IntFromStr_L2);

static refalrts::FnResult func_IntFromStr(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & IntFromStr/4 e.String#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.String#1 as range 2
  //DEBUG: e.String#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & DoNumb/6 & IntFromStr\1/7 & IntFromStr\2/8 Tile{ HalfReuse: (/0 HalfReuse: )/4 AsIs: e.String#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_DoNumb.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], ref_gen_IntFromStr_L1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_gen_IntFromStr_L2.ref.function ) )
    return refalrts::cNoMemory;
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[5] );
  refalrts::link_brackets( context[0], context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[0];
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_IntFromStr("IntFromStr", 0U, 0U, func_IntFromStr);

static refalrts::FnResult func_StrFromInt(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2277 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter number = 0;
  if (
    ! refalrts::svar_left(number, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
    || refalrts::cDataNumber != number->tag
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();
  refalrts::Iter begin_splice = arg_begin;

  if (refalrts::RefalNumber num = number->number_info) {
    // Длина десятичного числа = 0,3 * длина двоичного числа,
    // т.к. lg(2) = 0,3. Хрен с ним, что много. Главное, что не мало.
    enum { cMaxNumberLen = 8 * sizeof(refalrts::RefalNumber) * 3 / 10 + 2 };

    char buffer[cMaxNumberLen + 1] = { 0 };
    char *lim_digit = buffer + cMaxNumberLen;
    char *cur_digit = lim_digit;

    while (num != 0) {
      -- cur_digit;
      *cur_digit = static_cast<char>((num % 10) + '0');
      num /= 10;
    }

    refalrts::Iter num_begin;
    refalrts::Iter num_end;
    bool allocated = refalrts::alloc_chars(
      num_begin, num_end, cur_digit, unsigned(lim_digit - cur_digit)
    );

    if (! allocated) {
      return refalrts::cNoMemory;
    }

    refalrts::splice_evar(arg_begin, num_begin, num_end);
  } else {
    refalrts::reinit_char(arg_begin, '0');
    begin_splice = pfunc_name;
  }

  refalrts::splice_to_freelist(begin_splice, arg_end);

  return refalrts::cSuccess;
#line 11164 "Library.cpp"
}

static refalrts::NativeReference nat_ref_StrFromInt("StrFromInt", 0U, 0U, func_StrFromInt);

#line 2332 "Library.sref"
namespace {

template <typename T>
char compare_char(T x, T y) {
  if (x < y) {
    return '<';
  } else if (x == y) {
    return '=';
  } else {
    return '>';
  }
}

char strcmp_char(const char *x, const char *y) {
  int res = strcmp(x, y);
  if (res < 0) {
    return '<';
  } else if (res > 0) {
    return '>';
  } else {
    return '=';
  }
}

bool compare(refalrts::Iter left, refalrts::Iter right) {
  char order;

  switch(left->tag) {
    case refalrts::cDataNumber:
      switch(right->tag) {
        case refalrts::cDataNumber:
          order = compare_char(left->number_info, right->number_info);
          break;

        case refalrts::cDataChar:
          order = '>';
          break;

        case refalrts::cDataFunction:
          order = '>';
          break;

        case refalrts::cDataIdentifier:
          order = '>';
          break;

        case refalrts::cDataFile:
          order = '>';
          break;

        default:
          order = '?';
          break;
      }
      break;

    case refalrts::cDataChar:
      switch(right->tag) {
        case refalrts::cDataNumber:
          order = '<';
          break;

        case refalrts::cDataChar:
          order = compare_char(left->char_info, right->char_info);
          break;

        case refalrts::cDataFunction:
          order = '>';
          break;

        case refalrts::cDataIdentifier:
          order = '>';
          break;

        case refalrts::cDataFile:
          order = '>';
          break;

        default:
          order = '?';
          break;
      }
      break;

    case refalrts::cDataFunction:
      switch(right->tag) {
        case refalrts::cDataNumber:
          order = '<';
          break;

        case refalrts::cDataChar:
          order = '<';
          break;

        case refalrts::cDataFunction:
          {
            refalrts::RefalFunction *fl = left->function_info;
            refalrts::RefalFunction *fr = right->function_info;

            order = strcmp_char(fl->name.name, fr->name.name);
            if (order == '=') {
              order = compare_char(fl->name.cookie1, fr->name.cookie1);
            }
            if (order == '=') {
              order = compare_char(fl->name.cookie2, fr->name.cookie2);
            }
            if (order == '=') {
              order = compare_char(fl->rasl, fr->rasl);
            }
          }
          break;

        case refalrts::cDataIdentifier:
          order = '>';
          break;

        case refalrts::cDataFile:
          order = '>';
          break;

        default:
          order = '?';
          break;
      }
      break;

    case refalrts::cDataIdentifier:
      switch(right->tag) {
        case refalrts::cDataNumber:
          order = '<';
          break;

        case refalrts::cDataChar:
          order = '<';
          break;

        case refalrts::cDataFunction:
          order = '<';
          break;

        case refalrts::cDataIdentifier:
          order =
            strcmp_char(left->ident_info->name(), right->ident_info->name());
          break;

        case refalrts::cDataFile:
          order = '>';
          break;

        default:
          order = '?';
          break;
      }
      break;

    case refalrts::cDataFile:
      switch(right->tag) {
        case refalrts::cDataNumber:
          order = '<';
          break;

        case refalrts::cDataChar:
          order = '<';
          break;

        case refalrts::cDataFunction:
          order = '<';
          break;

        case refalrts::cDataIdentifier:
          order = '<';
          break;

        case refalrts::cDataFile:
          order = compare_char(left->file_info, right->file_info);
          break;

        default:
          order = '?';
          break;
      }
      break;

    default:
      order = '?';
      break;
  }

  if (order != '?') {
    refalrts::reinit_char(left, order);
    return true;
  } else {
    return false;
  }
}

} // unnamed namespace

#define BINARY(binary) \
  refalrts::Iter pX = 0, pY = 0; \
  refalrts::Iter pFunc = refalrts::call_left(pX, pY, arg_begin, arg_end); \
  \
  if (pX->next != pY) { \
    return refalrts::cRecognitionImpossible; \
  } \
  \
  binary \
  \
  refalrts::splice_to_freelist(arg_begin, pFunc); \
  refalrts::splice_to_freelist(pY, arg_end); \
  return refalrts::cSuccess;

#define COMPARE_BINARY \
  if (! compare(pX, pY)) { \
    return refalrts::cRecognitionImpossible; \
  }
#line 11386 "Library.cpp"
static refalrts::FnResult func_SymbCompare(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2552 "Library.sref"
  BINARY(COMPARE_BINARY);
#line 11390 "Library.cpp"
}

static refalrts::NativeReference nat_ref_SymbCompare("SymbCompare", 0U, 0U, func_SymbCompare);

#line 2557 "Library.sref"
namespace {

refalrts::FnResult implode_ext(
  refalrts::Iter arg_begin, refalrts::Iter arg_end
) {
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  std::vector<char> ident_str;
  refalrts::FnResult res = string_from_seq(ident_str, content_b, content_e);

  if (res != refalrts::cSuccess) {
    return res;
  }

  refalrts::RefalIdentifier ident = refalrts::ident_implode(&ident_str[0]);

  if (! ident) {
    return refalrts::cIdentTableLimit;
  }

  refalrts::reinit_ident(arg_begin, ident);
  refalrts::splice_to_freelist(pfunc_name, arg_end);

  return refalrts::cSuccess;
}


refalrts::FnResult explode(
  refalrts::Iter arg_begin, refalrts::Iter arg_end
) {
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pident = 0;
  if (
    ! refalrts::svar_right(pident, content_b, content_e)
    || refalrts::cDataIdentifier != pident->tag
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();
  if (
    ! refalrts::alloc_string(content_b, content_e, pident->ident_info->name())
  ) {
    return refalrts::cNoMemory;
  }

  refalrts::splice_evar(arg_begin, content_b, content_e);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
}

}  // unnamed namespace
#line 11455 "Library.cpp"
static refalrts::FnResult func_FWriteBytes(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2620 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;

  if (! file_handle_left(pfile_handle, content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = extract_file_handle(pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  int fputc_return = 0;

  while (fputc_return != EOF && ! refalrts::empty_seq(content_b, content_e)) {
    switch (content_b->tag) {
      case refalrts::cDataChar:
        fputc_return = fputc(content_b->char_info, handle);
        break;

      case refalrts::cDataNumber:
        fputc_return = fputc(content_b->number_info & 0xFF, handle);
        break;

      default:
        return refalrts::cRecognitionImpossible;
    }

    refalrts::move_left(content_b, content_e);
  }

  if (fputc_return == EOF) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 11498 "Library.cpp"
}

static refalrts::NativeReference nat_ref_FWriteBytes("FWriteBytes", 0U, 0U, func_FWriteBytes);

static refalrts::FnResult func_FReadBytes(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2665 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;
  refalrts::Iter pcount_bytes = 0;

  if (
    ! file_handle_left(pfile_handle, content_b, content_e)
    || ! refalrts::svar_left(pcount_bytes, content_b, content_e)
    || refalrts::cDataNumber != pcount_bytes->tag
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();

  FILE *handle = extract_file_handle(pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber count = pcount_bytes->number_info;

  refalrts::Iter begin = 0;
  refalrts::Iter end = 0;

  clearerr(handle);
  int cur_char = 0;
  while (count > 0 && (cur_char = getc(handle)) != EOF) {
    /*
      Пользуемся тем фактом, что в данной реализации размещёные в свободной
      памяти узлы располагаются в последовательных адресах.
    */
    refalrts::RefalNumber value = cur_char & 0xFFU;
    if (! refalrts::alloc_number(end, value)) {
      return refalrts::cNoMemory;
    }

    if (begin == 0) {
      begin = end;
    }
    --count;
  }

  if (begin == 0) assert (end == 0);
  if (begin != 0) assert (end != 0);

  if (cur_char == EOF && ferror(handle)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_evar(arg_begin, begin, end);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 11561 "Library.cpp"
}

static refalrts::NativeReference nat_ref_FReadBytes("FReadBytes", 0U, 0U, func_FReadBytes);

static refalrts::FnResult func_FTell(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2726 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;

  if (
    ! file_handle_left(pfile_handle, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = extract_file_handle(pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  long int pos = ftell(handle);

  if (pos == -1L) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reinit_number(arg_begin, static_cast<refalrts::RefalNumber>(pos));
  refalrts::splice_to_freelist(pfunc_name, arg_end);
  return refalrts::cSuccess;
#line 11596 "Library.cpp"
}

static refalrts::NativeReference nat_ref_FTell("FTell", 0U, 0U, func_FTell);

static refalrts::FnResult func_FSeek(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2759 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;
  refalrts::Iter porigin = 0;
  refalrts::Iter psign = 0;
  refalrts::Iter poffset = 0;

  if (
    ! file_handle_left(pfile_handle, content_b, content_e)
    || ! refalrts::svar_left(porigin, content_b, content_e)
    || refalrts::cDataIdentifier != porigin->tag
    || ! refalrts::svar_left(psign, content_b, content_e)
    || refalrts::cDataChar != psign->tag
    || ! refalrts::svar_left(poffset, content_b, content_e)
    || refalrts::cDataNumber != poffset->tag
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = extract_file_handle(pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  int origin;
  if (USE_IDENT(BEGIN) == porigin->ident_info) {
    origin = SEEK_SET;
  } else if (USE_IDENT(CURRENT) == porigin->ident_info) {
    origin = SEEK_CUR;
  } else if (USE_IDENT(END) == porigin->ident_info) {
    origin = SEEK_END;
  } else {
    return refalrts::cRecognitionImpossible;
  }

  signed sign;
  if ('+' == psign->char_info) {
    sign = +1;
  } else if ('-' == psign->char_info) {
    sign = -1;
  } else {
    return refalrts::cRecognitionImpossible;
  }

  long int offset = sign * static_cast<long int>(poffset->number_info);

  if (fseek(handle, offset, origin) != 0) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 11658 "Library.cpp"
}

static refalrts::NativeReference nat_ref_FSeek("FSeek", 0U, 0U, func_FSeek);

static refalrts::FnResult func_RenameFile(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2819 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter source_b = 0;
  refalrts::Iter source_e = 0;
  refalrts::Iter target_b = 0;
  refalrts::Iter target_e = 0;

  if (
    ! refalrts::brackets_left(source_b, source_e, content_b, content_e)
    || ! refalrts::brackets_left(target_b, target_e, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  char source[FILENAME_MAX + 1] = { '\0' };
  unsigned source_len = read_chars(source, FILENAME_MAX, source_b, source_e);

  if (! refalrts::empty_seq(source_b, source_e) || source_len == 0) {
    return refalrts::cRecognitionImpossible;
  }

  char target[FILENAME_MAX + 1] = { '\0' };
  unsigned target_len = read_chars(target, FILENAME_MAX, target_b, target_e);

  if (! refalrts::empty_seq(target_b, target_e) || target_len == 0) {
    return refalrts::cRecognitionImpossible;
  }

  int result = rename(source, target);

  refalrts::RefalIdentifier i_result =
    result == 0 ? USE_IDENT(True) : USE_IDENT(False);

  refalrts::reinit_ident(arg_begin, i_result);
  refalrts::splice_to_freelist(pfunc_name, arg_end);
  return refalrts::cSuccess;
#line 11705 "Library.cpp"
}

static refalrts::NativeReference nat_ref_RenameFile("RenameFile", 0U, 0U, func_RenameFile);

static refalrts::FnResult func_RemoveFile(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2864 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  char filename[FILENAME_MAX + 1] = { '\0' };
  unsigned filename_len =
    read_chars(filename, FILENAME_MAX, content_b, content_e);

  if (! refalrts::empty_seq(content_b, content_e) || filename_len == 0) {
    return refalrts::cRecognitionImpossible;
  }

  int result = remove(filename);

  refalrts::RefalIdentifier i_result =
    result == 0 ? USE_IDENT(True) : USE_IDENT(False);

  refalrts::reinit_ident(arg_begin, i_result);
  refalrts::splice_to_freelist(pfunc_name, arg_end);
  return refalrts::cSuccess;
#line 11733 "Library.cpp"
}

static refalrts::NativeReference nat_ref_RemoveFile("RemoveFile", 0U, 0U, func_RemoveFile);


//End of file
