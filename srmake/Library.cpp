// This file automatically generated from 'Library.sref'
// Don't edit! Edit 'Library.sref' and recompile it

#include "refalrts.h"

#define cookie_ns cookie_ns_877573369_332537286
static const refalrts::RefalIdentifier ident_Add = refalrts::ident_from_static("Add");
static const refalrts::RefalIdentifier ident_Arg = refalrts::ident_from_static("Arg");
static const refalrts::RefalIdentifier ident_BEGIN = refalrts::ident_from_static("BEGIN");
static const refalrts::RefalIdentifier ident_Br = refalrts::ident_from_static("Br");
static const refalrts::RefalIdentifier ident_CURRENT = refalrts::ident_from_static("CURRENT");
static const refalrts::RefalIdentifier ident_Card = refalrts::ident_from_static("Card");
static const refalrts::RefalIdentifier ident_Chr = refalrts::ident_from_static("Chr");
static const refalrts::RefalIdentifier ident_Close = refalrts::ident_from_static("Close");
static const refalrts::RefalIdentifier ident_Compare = refalrts::ident_from_static("Compare");
static const refalrts::RefalIdentifier ident_Cp = refalrts::ident_from_static("Cp");
static const refalrts::RefalIdentifier ident_DeSysfun = refalrts::ident_from_static("DeSysfun");
static const refalrts::RefalIdentifier ident_Dg = refalrts::ident_from_static("Dg");
static const refalrts::RefalIdentifier ident_Dgall = refalrts::ident_from_static("Dgall");
static const refalrts::RefalIdentifier ident_Div = refalrts::ident_from_static("Div");
static const refalrts::RefalIdentifier ident_Divmod = refalrts::ident_from_static("Divmod");
static const refalrts::RefalIdentifier ident_Dn = refalrts::ident_from_static("Dn");
static const refalrts::RefalIdentifier ident_END = refalrts::ident_from_static("END");
static const refalrts::RefalIdentifier ident_Escape = refalrts::ident_from_static("Escape");
static const refalrts::RefalIdentifier ident_Escapem_Hex = refalrts::ident_from_static("Escape-Hex");
static const refalrts::RefalIdentifier ident_Evm_met = refalrts::ident_from_static("Ev-met");
static const refalrts::RefalIdentifier ident_ExistFile = refalrts::ident_from_static("ExistFile");
static const refalrts::RefalIdentifier ident_Exit = refalrts::ident_from_static("Exit");
static const refalrts::RefalIdentifier ident_Explode = refalrts::ident_from_static("Explode");
static const refalrts::RefalIdentifier ident_Explodeu_Ext = refalrts::ident_from_static("Explode_Ext");
static const refalrts::RefalIdentifier ident_Fails = refalrts::ident_from_static("Fails");
static const refalrts::RefalIdentifier ident_False = refalrts::ident_from_static("False");
static const refalrts::RefalIdentifier ident_First = refalrts::ident_from_static("First");
static const refalrts::RefalIdentifier ident_Freeze = refalrts::ident_from_static("Freeze");
static const refalrts::RefalIdentifier ident_Freezer = refalrts::ident_from_static("Freezer");
static const refalrts::RefalIdentifier ident_General = refalrts::ident_from_static("General");
static const refalrts::RefalIdentifier ident_Get = refalrts::ident_from_static("Get");
static const refalrts::RefalIdentifier ident_GetCurrentDirectory = refalrts::ident_from_static("GetCurrentDirectory");
static const refalrts::RefalIdentifier ident_GetEnv = refalrts::ident_from_static("GetEnv");
static const refalrts::RefalIdentifier ident_GetPID = refalrts::ident_from_static("GetPID");
static const refalrts::RefalIdentifier ident_GetPPID = refalrts::ident_from_static("GetPPID");
static const refalrts::RefalIdentifier ident_Implode = refalrts::ident_from_static("Implode");
static const refalrts::RefalIdentifier ident_Implodeu_Ext = refalrts::ident_from_static("Implode_Ext");
static const refalrts::RefalIdentifier ident_Last = refalrts::ident_from_static("Last");
static const refalrts::RefalIdentifier ident_Lenw = refalrts::ident_from_static("Lenw");
static const refalrts::RefalIdentifier ident_ListOfBuiltin = refalrts::ident_from_static("ListOfBuiltin");
static const refalrts::RefalIdentifier ident_Lower = refalrts::ident_from_static("Lower");
static const refalrts::RefalIdentifier ident_Mod = refalrts::ident_from_static("Mod");
static const refalrts::RefalIdentifier ident_Mu = refalrts::ident_from_static("Mu");
static const refalrts::RefalIdentifier ident_Mul = refalrts::ident_from_static("Mul");
static const refalrts::RefalIdentifier ident_Numb = refalrts::ident_from_static("Numb");
static const refalrts::RefalIdentifier ident_Number = refalrts::ident_from_static("Number");
static const refalrts::RefalIdentifier ident_Open = refalrts::ident_from_static("Open");
static const refalrts::RefalIdentifier ident_Ord = refalrts::ident_from_static("Ord");
static const refalrts::RefalIdentifier ident_Print = refalrts::ident_from_static("Print");
static const refalrts::RefalIdentifier ident_Prout = refalrts::ident_from_static("Prout");
static const refalrts::RefalIdentifier ident_Put = refalrts::ident_from_static("Put");
static const refalrts::RefalIdentifier ident_Putout = refalrts::ident_from_static("Putout");
static const refalrts::RefalIdentifier ident_Quote = refalrts::ident_from_static("Quote");
static const refalrts::RefalIdentifier ident_Random = refalrts::ident_from_static("Random");
static const refalrts::RefalIdentifier ident_RandomDigit = refalrts::ident_from_static("RandomDigit");
static const refalrts::RefalIdentifier ident_RemoveFile = refalrts::ident_from_static("RemoveFile");
static const refalrts::RefalIdentifier ident_Residue = refalrts::ident_from_static("Residue");
static const refalrts::RefalIdentifier ident_Rp = refalrts::ident_from_static("Rp");
static const refalrts::RefalIdentifier ident_SizeOf = refalrts::ident_from_static("SizeOf");
static const refalrts::RefalIdentifier ident_Step = refalrts::ident_from_static("Step");
static const refalrts::RefalIdentifier ident_Sub = refalrts::ident_from_static("Sub");
static const refalrts::RefalIdentifier ident_Success = refalrts::ident_from_static("Success");
static const refalrts::RefalIdentifier ident_Symb = refalrts::ident_from_static("Symb");
static const refalrts::RefalIdentifier ident_Sysfun = refalrts::ident_from_static("Sysfun");
static const refalrts::RefalIdentifier ident_System = refalrts::ident_from_static("System");
static const refalrts::RefalIdentifier ident_Time = refalrts::ident_from_static("Time");
static const refalrts::RefalIdentifier ident_TimeElapsed = refalrts::ident_from_static("TimeElapsed");
static const refalrts::RefalIdentifier ident_True = refalrts::ident_from_static("True");
static const refalrts::RefalIdentifier ident_Type = refalrts::ident_from_static("Type");
static const refalrts::RefalIdentifier ident_Up = refalrts::ident_from_static("Up");
static const refalrts::RefalIdentifier ident_Upper = refalrts::ident_from_static("Upper");
static const refalrts::RefalIdentifier ident_Word = refalrts::ident_from_static("Word");
static const refalrts::RefalIdentifier ident_Write = refalrts::ident_from_static("Write");
static const refalrts::RefalIdentifier ident_XMLParse = refalrts::ident_from_static("XMLParse");
static const refalrts::RefalIdentifier ident_regular = refalrts::ident_from_static("regular");
static const refalrts::RefalIdentifier ident_special = refalrts::ident_from_static("special");
static const refalrts::RefalIdentifier ident_stderr = refalrts::ident_from_static("stderr");
static const refalrts::RefalIdentifier ident_stdin = refalrts::ident_from_static("stdin");
static const refalrts::RefalIdentifier ident_stdout = refalrts::ident_from_static("stdout");
static const refalrts::RefalIdentifier ident_stout = refalrts::ident_from_static("stout");
static refalrts::ExternalReference ref_Add("Add", 0U, 0U);
static refalrts::ExternalReference ref_gen_Add_S2A1("Add$2=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Addm_Digits("Add-Digits", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Addm_Nat("Add-Nat", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Addm_Nat_S1B1("Add-Nat$1:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Addm_Normed("Add-Normed", 877573369U, 332537286U);
static refalrts::ExternalReference ref_AllDigits("AllDigits", 877573369U, 332537286U);
static refalrts::ExternalReference ref_AllDigitsm_SwFirst("AllDigits-SwFirst", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Arg("Arg", 0U, 0U);
static refalrts::ExternalReference ref_Autoopen("Autoopen", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Br("Br", 0U, 0U);
static refalrts::ExternalReference ref_Buried("Buried", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Card("Card", 0U, 0U);
static refalrts::ExternalReference ref_Chr("Chr", 0U, 0U);
static refalrts::ExternalReference ref_Close("Close", 0U, 0U);
static refalrts::ExternalReference ref_Compare("Compare", 0U, 0U);
static refalrts::ExternalReference ref_gen_Compare_S2A1("Compare$2=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Comparem_Align("Compare-Align", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Comparem_ByDigits("Compare-ByDigits", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Comparem_Digits("Compare-Digits", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Comparem_Nat("Compare-Nat", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Comparem_Normed("Compare-Normed", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Cp("Cp", 0U, 0U);
static refalrts::ExternalReference ref_gen_Cp_B1("Cp:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_DeSysfun("DeSysfun", 0U, 0U);
static refalrts::ExternalReference ref_Dg("Dg", 0U, 0U);
static refalrts::ExternalReference ref_gen_Dg_B1("Dg:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Dgall("Dgall", 0U, 0U);
static refalrts::ExternalReference ref_Div("Div", 0U, 0U);
static refalrts::ExternalReference ref_gen_Div_S1A1("Div$1=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Div_S2A1("Div$2=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Div_S2A2("Div$2=2", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Divmod("Divmod", 0U, 0U);
static refalrts::ExternalReference ref_gen_Divmod_S2A1("Divmod$2=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Divmod_S2A2("Divmod$2=2", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Divmodm_AdjustDigit("Divmod-AdjustDigit", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Divmodm_Align("Divmod-Align", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Divmodm_Align_S2A1("Divmod-Align$2=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Divmodm_CalcDigits("Divmod-CalcDigits", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Divmodm_CalcDigits_B1("Divmod-CalcDigits:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Divmodm_CalcDigits_A1("Divmod-CalcDigits=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Divmodm_Digits("Divmod-Digits", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Divmodm_GetNextDigit("Divmod-GetNextDigit", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Divmodm_GetNextDigit_S2A1("Divmod-GetNextDigit$2=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Divmodm_GuessDigit("Divmod-GuessDigit", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Divmodm_Nat("Divmod-Nat", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Divmodm_Nat_S1A1("Divmod-Nat$1=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Divmodm_Nat_S2A1("Divmod-Nat$2=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Divmodm_Nat_S2A1B1("Divmod-Nat$2=1:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Divmodm_Nat_S2A2("Divmod-Nat$2=2", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Divmodm_Nat_S2A3("Divmod-Nat$2=3", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Divmodm_Nat_S2A4("Divmod-Nat$2=4", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Divmodm_Nat_S2A5("Divmod-Nat$2=5", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Divmodm_Nat_S2A5B1("Divmod-Nat$2=5:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Divmodm_Natm_Normed("Divmod-Nat-Normed", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Divmodm_Normed("Divmod-Normed", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Divmodm_Shl("Divmod-Shl", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Dn("Dn", 0U, 0U);
static refalrts::ExternalReference ref_DoFirst("DoFirst", 877573369U, 332537286U);
static refalrts::ExternalReference ref_DoImplode("DoImplode", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_DoImplode_S4B1("DoImplode$4:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_DoLast("DoLast", 877573369U, 332537286U);
static refalrts::ExternalReference ref_DoLenw("DoLenw", 877573369U, 332537286U);
static refalrts::ExternalReference ref_DoNumb("DoNumb", 877573369U, 332537286U);
static refalrts::ExternalReference ref_DoNumbm_Wrap("DoNumb-Wrap", 877573369U, 332537286U);
static refalrts::ExternalReference ref_DoSubm_Natm_Nat("DoSub-Nat-Nat", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_DoSubm_Natm_Nat_S1B1("DoSub-Nat-Nat$1:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_DoSubm_Natm_Nat_S1B2("DoSub-Nat-Nat$1:2", 877573369U, 332537286U);
static refalrts::ExternalReference ref_ExistFile("ExistFile", 0U, 0U);
static refalrts::ExternalReference ref_Exit("Exit", 0U, 0U);
static refalrts::ExternalReference ref_Explode("Explode", 0U, 0U);
static refalrts::ExternalReference ref_Explodeu_Ext("Explode_Ext", 0U, 0U);
static refalrts::ExternalReference ref_FClose("FClose", 0U, 0U);
static refalrts::ExternalReference ref_FOpen("FOpen", 0U, 0U);
static refalrts::ExternalReference ref_gen_FOpen_A1("FOpen=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_FReadBytes("FReadBytes", 0U, 0U);
static refalrts::ExternalReference ref_FReadLine("FReadLine", 0U, 0U);
static refalrts::ExternalReference ref_FSeek("FSeek", 0U, 0U);
static refalrts::ExternalReference ref_FTell("FTell", 0U, 0U);
static refalrts::ExternalReference ref_FWriteBytes("FWriteBytes", 0U, 0U);
static refalrts::ExternalReference ref_FWriteLine("FWriteLine", 0U, 0U);
static refalrts::ExternalReference ref_First("First", 0U, 0U);
static refalrts::ExternalReference ref_Freeze("Freeze", 0U, 0U);
static refalrts::ExternalReference ref_Freezer("Freezer", 0U, 0U);
static refalrts::ExternalReference ref_Get("Get", 0U, 0U);
static refalrts::ExternalReference ref_Getm_Aux("Get-Aux", 877573369U, 332537286U);
static refalrts::ExternalReference ref_GetCurrentDirectory("GetCurrentDirectory", 0U, 0U);
static refalrts::ExternalReference ref_GetEnv("GetEnv", 0U, 0U);
static refalrts::ExternalReference ref_GetFreeHandle("GetFreeHandle", 877573369U, 332537286U);
static refalrts::ExternalReference ref_GetPID("GetPID", 0U, 0U);
static refalrts::ExternalReference ref_GetPPID("GetPPID", 0U, 0U);
static refalrts::ExternalReference ref_Hex("Hex", 877573369U, 332537286U);
static refalrts::ExternalReference ref_HexDigit("HexDigit", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Implode("Implode", 0U, 0U);
static refalrts::ExternalReference ref_gen_Implode_S1B1("Implode$1:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Implodeu_Ext("Implode_Ext", 0U, 0U);
static refalrts::ExternalReference ref_IntFromStr("IntFromStr", 0U, 0U);
static refalrts::ExternalReference ref_gen_IntFromStr_L1("IntFromStr\\1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_IntFromStr_L2("IntFromStr\\2", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Last("Last", 0U, 0U);
static refalrts::ExternalReference ref_LeadingZeros("LeadingZeros", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Lenw("Lenw", 0U, 0U);
static refalrts::ExternalReference ref_ListOfBuiltin("ListOfBuiltin", 0U, 0U);
static refalrts::ExternalReference ref_Lower("Lower", 0U, 0U);
static refalrts::ExternalReference ref_Mod("Mod", 0U, 0U);
static refalrts::ExternalReference ref_gen_Mod_S1A1("Mod$1=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Mod_S2A1("Mod$2=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Mod_S2A2("Mod$2=2", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Mul("Mul", 0U, 0U);
static refalrts::ExternalReference ref_gen_Mul_S2A1("Mul$2=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Mulm_Digits("Mul-Digits", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Mulm_Nat("Mul-Nat", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Mulm_Natm_Line("Mul-Nat-Line", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Mulm_Natm_Line_S2B1("Mul-Nat-Line$2:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Mulm_Normed("Mul-Normed", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Neg("Neg", 877573369U, 332537286U);
static refalrts::ExternalReference ref_NormArithmArg("NormArithmArg", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_NormArithmArg_S1A1("NormArithmArg$1=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_NormArithmArg_S2A1("NormArithmArg$2=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_NormArithmArg_S2A2("NormArithmArg$2=2", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_NormArithmArg_S3A1("NormArithmArg$3=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_NormArithmArg_S3A2("NormArithmArg$3=2", 877573369U, 332537286U);
static refalrts::ExternalReference ref_NormNumber("NormNumber", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_NormNumber_S7A1("NormNumber$7=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_NormNumber_S8A1("NormNumber$8=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_NormNumber_S9B1("NormNumber$9:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Numb("Numb", 0U, 0U);
static refalrts::ExternalReference ref_Numbm_Aux("Numb-Aux", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Numbm_Fail("Numb-Fail", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Numbm_Ok("Numb-Ok", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Numbm_Wrap("Numb-Wrap", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Open("Open", 0U, 0U);
static refalrts::ExternalReference ref_Ord("Ord", 0U, 0U);
static refalrts::ExternalReference ref_Print("Print", 0U, 0U);
static refalrts::ExternalReference ref_Proud("Proud", 0U, 0U);
static refalrts::ExternalReference ref_Prout("Prout", 0U, 0U);
static refalrts::ExternalReference ref_PtrFromName("PtrFromName", 0U, 0U);
static refalrts::ExternalReference ref_Put("Put", 0U, 0U);
static refalrts::ExternalReference ref_Putm_Aux("Put-Aux", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Putout("Putout", 0U, 0U);
static refalrts::ExternalReference ref_Putoutm_Aux("Putout-Aux", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Quote("Quote", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Random("Random", 0U, 0U);
static refalrts::ExternalReference ref_RandomDigit("RandomDigit", 0U, 0U);
static refalrts::ExternalReference ref_ReadLine("ReadLine", 0U, 0U);
static refalrts::ExternalReference ref_RemoveFile("RemoveFile", 0U, 0U);
static refalrts::ExternalReference ref_RenameFile("RenameFile", 0U, 0U);
static refalrts::ExternalReference ref_Rp("Rp", 0U, 0U);
static refalrts::ExternalReference ref_gen_Rp_B1("Rp:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_SizeOf("SizeOf", 0U, 0U);
static refalrts::ExternalReference ref_Step("Step", 0U, 0U);
static refalrts::ExternalReference ref_StrFromInt("StrFromInt", 0U, 0U);
static refalrts::ExternalReference ref_Sub("Sub", 0U, 0U);
static refalrts::ExternalReference ref_gen_Sub_S2A1("Sub$2=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Subm_Digits("Sub-Digits", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Subm_Nat("Sub-Nat", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Subm_Nat_B1("Sub-Nat:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Subm_Natm_Nat("Sub-Nat-Nat", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Subm_Normed("Sub-Normed", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Symb("Symb", 0U, 0U);
static refalrts::ExternalReference ref_gen_Symb_B1("Symb:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Symb_A1("Symb=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Symbm_Nat("Symb-Nat", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Symbm_Nat_S2A1("Symb-Nat$2=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Symbm_Nat_S2A2("Symb-Nat$2=2", 877573369U, 332537286U);
static refalrts::ExternalReference ref_SymbCompare("SymbCompare", 0U, 0U);
static refalrts::ExternalReference ref_Sysfun("Sysfun", 0U, 0U);
static refalrts::ExternalReference ref_Sysfunm_Xxin("Sysfun-Xxin", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Sysfunm_Xxin_B1("Sysfun-Xxin:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Sysfunm_Xxin_B1S1A1("Sysfun-Xxin:1$1=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Sysfunm_Xxinm_ERROR("Sysfun-Xxin-ERROR", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Sysfunm_Xxout("Sysfun-Xxout", 877573369U, 332537286U);
static refalrts::ExternalReference ref_System("System", 0U, 0U);
static refalrts::ExternalReference ref_Time("Time", 0U, 0U);
static refalrts::ExternalReference ref_TimeElapsed("TimeElapsed", 0U, 0U);
static refalrts::ExternalReference ref_Trout("Trout", 0U, 0U);
static refalrts::ExternalReference ref_Type("Type", 0U, 0U);
static refalrts::ExternalReference ref_Upper("Upper", 0U, 0U);
static refalrts::ExternalReference ref_Write("Write", 0U, 0U);
static refalrts::ExternalReference ref_Writem_Aux("Write-Aux", 877573369U, 332537286U);
static refalrts::ExternalReference ref_WriteLine("WriteLine", 0U, 0U);
static refalrts::ExternalReference ref_XMLParse("XMLParse", 0U, 0U);
static refalrts::ExternalReference ref_Xxinm_Scan("Xxin-Scan", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Xxinm_Scan_S14B1("Xxin-Scan$14:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Xxinm_Scan_S38B1("Xxin-Scan$38:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Xxoutm_Chars("Xxout-Chars", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Xxoutm_Chars_S1B1("Xxout-Chars$1:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Xxoutm_Chars_S1B1S2B1("Xxout-Chars$1:1$2:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Xxoutm_Chars_S1B1S2B1S6A1("Xxout-Chars$1:1$2:1$6=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Xxoutm_Scan("Xxout-Scan", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Xxoutm_Scan_S1A1("Xxout-Scan$1=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Xxoutm_Scan_S2A1("Xxout-Scan$2=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Xxoutm_Scan_S4A1("Xxout-Scan$4=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Xxoutm_Scan_S6A1("Xxout-Scan$6=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Xxoutm_Scan_S7A1("Xxout-Scan$7=1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_Xxoutm_Wrap("Xxout-Wrap", 877573369U, 332537286U);
static refalrts::ExternalReference ref_gen_Xxoutm_Wrap_B1("Xxout-Wrap:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_ZeroHandle("ZeroHandle", 877573369U, 332537286U);
static refalrts::ExternalReference ref_u_u_FindMuPtr("__FindMuPtr", 0U, 0U);
static refalrts::ExternalReference ref_gen_u_u_FindMuPtr_B1("__FindMuPtr:1", 877573369U, 332537286U);
static refalrts::ExternalReference ref_u_u_Stepm_End("__Step-End", 0U, 0U);
static refalrts::ExternalReference ref_u_u_Stepm_Start("__Step-Start", 0U, 0U);
#line 2 "Library.sref"
#include <assert.h>
#include <ctype.h>
#include <errno.h>
#include <float.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <string>
#include <time.h>
#include <vector>

#include "refalrts-platform-specific.h"

//FROM refalrts

#line 306 "Library.cpp"

static refalrts::FnResult func_gen_u_u_FindMuPtr_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  // </0 & __FindMuPtr:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  do {
    // </0 & __FindMuPtr:1/4 s.FnPtr#2/7 e.Rest#2/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    // closed e.Rest#2 as range 5
    //DEBUG: s.FnPtr#2: 7
    //DEBUG: e.Rest#2: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & __FindMuPtr:1/4 s.FnPtr#2/7 e.Rest#2/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: s.FnPtr2 #7/1 ]] }
    refalrts::reinit_svar( context[1], context[7] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & __FindMuPtr:1/4 >/1
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & __FindMuPtr:1/4 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_u_u_FindMuPtr_B1("__FindMuPtr:1", 877573369U, 332537286U, func_gen_u_u_FindMuPtr_B1);


static refalrts::FnResult func_u_u_FindMuPtr(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 17 elems
  refalrts::Iter context[17];
  refalrts::zeros( context, 17 );
  // </0 & __FindMuPtr/4 s.Cookie1#1/5 s.Cookie2#1/6 e.FuncName#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.FuncName#1 as range 2
  //DEBUG: s.Cookie1#1: 5
  //DEBUG: s.Cookie2#1: 6
  //DEBUG: e.FuncName#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </7 & __FindMuPtr:1/8 Tile{ AsIs: </0 Reuse: & PtrFromName/4 AsIs: s.Cookie1#1/5 AsIs: s.Cookie2#1/6 AsIs: e.FuncName#1/2 AsIs: >/1 } </9 & PtrFromName/10 0/11 0/12 e.FuncName#1/2/13 >/15 >/16 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_gen_u_u_FindMuPtr_B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_PtrFromName.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[11], 0UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[12], 0UL ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[13], context[14], context[2], context[3]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[16] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_PtrFromName.ref.function );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[9], context[16] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_u_u_FindMuPtr("__FindMuPtr", 0U, 0U, func_u_u_FindMuPtr);


static refalrts::FnResult func_PtrFromName(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 54 "Library.sref"
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  const char *func_name = 0;

  enum { cMaxFuncName = 2000 };
  char func_name_buffer[cMaxFuncName + 1] = { 0 };
  unsigned read;

  refalrts::Iter pcookie1 = 0, pcookie2 = 0;
  if (
    ! refalrts::svar_left(pcookie1, content_b, content_e)
    || refalrts::cDataNumber != pcookie1->tag
    || ! refalrts::svar_left(pcookie2, content_b, content_e)
    || refalrts::cDataNumber != pcookie2->tag
  ) {
    return refalrts::cRecognitionImpossible;
  }

  if (refalrts::cDataIdentifier == content_b->tag) {
    func_name = content_b->ident_info->name();
    refalrts::move_left(content_b, content_e);
  } else if (
    (
      read = refalrts::read_chars(
        func_name_buffer, cMaxFuncName, content_b, content_e
      )
    ) != 0
    && refalrts::empty_seq(content_b, content_e)
  ) {
    func_name_buffer[read] = '\0';
    func_name = func_name_buffer;
  }

  if (0 == func_name) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalFunction *func_ptr =
    refalrts::RefalFunction::lookup(
      pcookie1->number_info, pcookie2->number_info, func_name
    );

  refalrts::Iter start_garbage = arg_begin;
  if (func_ptr) {
    refalrts::reinit_name(arg_begin, func_ptr);
    start_garbage = pfunc;
  }

  refalrts::splice_to_freelist(start_garbage, arg_end);
  return refalrts::cSuccess;
#line 474 "Library.cpp"
}

static refalrts::NativeReference nat_ref_PtrFromName("PtrFromName", 0U, 0U, func_PtrFromName);


static refalrts::FnResult func_gen_Add_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & Add$2=1/4 (/7 e.First#2/5 )/8 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#2 as range 5
  // closed e.Second#2 as range 2
  //DEBUG: e.First#2: 5
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Add-Normed/4 AsIs: (/7 AsIs: e.First#2/5 AsIs: )/8 AsIs: e.Second#2/2 AsIs: >/1 } </9 & __Step-End/10 >/11 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Addm_Normed.ref.function );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[9], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Add_S2A1("Add$2=1", 877573369U, 332537286U, func_gen_Add_S2A1);


static refalrts::FnResult func_Add(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & Add/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  do {
    // </0 & Add/4 s.First#1/7 s.Second#1/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.First#1: 7
    //DEBUG: s.Second#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </9 & __Step-Start/10 >/11 Tile{ AsIs: </0 Reuse: & Add-Digits/4 AsIs: s.First#1/7 AsIs: s.Second#1/8 AsIs: >/1 } </12 & __Step-End/13 >/14 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], ref_u_u_Stepm_Start.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[13], ref_u_u_Stepm_End.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[14] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Addm_Digits.ref.function );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[12], context[14] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[9], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Add/4 e.ArithmArg#1/2 >/1
  // closed e.ArithmArg#1 as range 2
  //DEBUG: e.ArithmArg#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & Add$2=1/6 </7 & __Step-Start/8 >/9 Tile{ AsIs: </0 Reuse: & NormArithmArg/4 AsIs: e.ArithmArg#1/2 AsIs: >/1 } >/10 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_gen_Add_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_u_u_Stepm_Start.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[10] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormArithmArg.ref.function );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[5], context[9] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Add("Add", 0U, 0U, func_Add);


static refalrts::FnResult func_gen_NormArithmArg_S1A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  // </0 & NormArithmArg$1=1/4 s.SecondSign#2/5 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Second#2 as range 2
  //DEBUG: s.SecondSign#2: 5
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: 0/4 } Tile{ HalfReuse: )/1 } Tile{ AsIs: s.SecondSign#2/5 } Tile{ AsIs: e.Second#2/2 } Tile{ ]] }
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_number( context[4], 0UL );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[0], context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[5], context[5] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormArithmArg_S1A1("NormArithmArg$1=1", 877573369U, 332537286U, func_gen_NormArithmArg_S1A1);


static refalrts::FnResult func_gen_NormArithmArg_S2A2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 7 elems
  refalrts::Iter context[7];
  refalrts::zeros( context, 7 );
  // </0 & NormArithmArg$2=2/4 s.First#2/5 s.SecondSign#3/6 e.Second#3/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Second#3 as range 2
  //DEBUG: s.First#2: 5
  //DEBUG: s.SecondSign#3: 6
  //DEBUG: e.Second#3: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: '+'/4 AsIs: s.First#2/5 } Tile{ HalfReuse: )/1 } Tile{ AsIs: s.SecondSign#3/6 } Tile{ AsIs: e.Second#3/2 } Tile{ ]] }
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_char( context[4], '+' );
  refalrts::reinit_close_bracket( context[1] );
  refalrts::link_brackets( context[0], context[1] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[6], context[6] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormArithmArg_S2A2("NormArithmArg$2=2", 877573369U, 332537286U, func_gen_NormArithmArg_S2A2);


static refalrts::FnResult func_gen_NormArithmArg_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  // </0 & NormArithmArg$2=1/4 (/7 e.Second#1/5 )/8 'N'/9 s.SubType#2/10 s.First#2/11 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = refalrts::char_left( 'N', context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  // closed e.Second#1 as range 5
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Second#1: 5
  //DEBUG: s.SubType#2: 10
  //DEBUG: s.First#2: 11

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.SubType#2/10 {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 HalfReuse: [*]/4 HalfReuse: & NormArithmArg$2=2/7 } Tile{ AsIs: s.First#2/11 } {*}/12 Tile{ HalfReuse: </8 HalfReuse: & NormNumber/9 } Tile{ AsIs: e.Second#1/5 } >/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_unwrapped_closure( context[12], context[4] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[4] );
  refalrts::reinit_name( context[7], ref_gen_NormArithmArg_S2A2.ref.function );
  refalrts::reinit_open_call( context[8] );
  refalrts::reinit_name( context[9], ref_NormNumber.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[13], context[13] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[8], context[9] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  refalrts::splice_to_freelist_open( context[7], res );
  refalrts::wrap_closure( context[12] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormArithmArg_S2A1("NormArithmArg$2=1", 877573369U, 332537286U, func_gen_NormArithmArg_S2A1);


static refalrts::FnResult func_gen_NormArithmArg_S3A2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  // </0 & NormArithmArg$3=2/4 s.FirstSign#2/5 (/8 e.First#2/6 )/9 s.SecondSign#3/10 e.Second#3/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  // closed e.First#2 as range 6
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Second#3 as range 2
  //DEBUG: s.FirstSign#2: 5
  //DEBUG: e.First#2: 6
  //DEBUG: s.SecondSign#3: 10
  //DEBUG: e.Second#3: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & NormArithmArg$3=2/4 s.FirstSign#2/5 {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: (/0 } Tile{ HalfReuse: s.FirstSign2 #5/8 AsIs: e.First#2/6 AsIs: )/9 AsIs: s.SecondSign#3/10 } Tile{ AsIs: e.Second#3/2 } Tile{ ]] }
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_svar( context[8], context[5] );
  refalrts::link_brackets( context[0], context[9] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[8], context[10] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormArithmArg_S3A2("NormArithmArg$3=2", 877573369U, 332537286U, func_gen_NormArithmArg_S3A2);


static refalrts::FnResult func_gen_NormArithmArg_S3A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & NormArithmArg$3=1/4 (/7 e.Second#1/5 )/8 s.FirstSign#2/9 e.First#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Second#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.First#2 as range 2
  //DEBUG: e.Second#1: 5
  //DEBUG: s.FirstSign#2: 9
  //DEBUG: e.First#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 HalfReuse: [*]/4 HalfReuse: & NormArithmArg$3=2/7 } Tile{ AsIs: s.FirstSign#2/9 } (/10 Tile{ AsIs: e.First#2/2 } Tile{ AsIs: )/8 } {*}/11 </12 & NormNumber/13 Tile{ AsIs: e.Second#1/5 } >/14 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[11], context[4] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[13], ref_NormNumber.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[4] );
  refalrts::reinit_name( context[7], ref_gen_NormArithmArg_S3A2.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[12] );
  refalrts::link_brackets( context[10], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[14], context[14] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[11], context[13] );
  res = refalrts::splice_evar( res, context[8], context[8] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  refalrts::use( res );
  refalrts::wrap_closure( context[11] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormArithmArg_S3A1("NormArithmArg$3=1", 877573369U, 332537286U, func_gen_NormArithmArg_S3A1);


static refalrts::FnResult func_NormArithmArg(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  // </0 & NormArithmArg/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  do {
    // </0 & NormArithmArg/4 t.new#1/7 e.new#2/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[8] = refalrts::tvar_left( context[7], context[5], context[6] );
    if( ! context[8] )
      continue;
    // closed e.new#2 as range 5
    do {
      // </0 & NormArithmArg/4 s.new#3/7 e.new#4/5 >/1
      if( ! refalrts::svar_term( context[7], context[7] ) )
        continue;
      // closed e.new#4 as range 5
      do {
        // </0 & NormArithmArg/4 0/7 e.Second#1/5 >/1
        if( ! refalrts::number_term( 0UL, context[7] ) )
          continue;
        // closed e.Second#1 as range 5
        //DEBUG: e.Second#1: 5

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 Reuse: & NormArithmArg$1=1/4 HalfReuse: </7 } & NormNumber/9 Tile{ AsIs: e.Second#1/5 } >/10 Tile{ AsIs: >/1 ]] }
        if( ! refalrts::alloc_name( context[9], ref_NormNumber.ref.function ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_call( context[10] ) )
          return refalrts::cNoMemory;
        refalrts::update_name( context[4], ref_gen_NormArithmArg_S1A1.ref.function );
        refalrts::reinit_open_call( context[7] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[0] );
        refalrts::push_stack( context[10] );
        refalrts::push_stack( context[7] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[1];
        res = refalrts::splice_evar( res, context[10], context[10] );
        res = refalrts::splice_evar( res, context[5], context[6] );
        res = refalrts::splice_evar( res, context[9], context[9] );
        refalrts::use( res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      // </0 & NormArithmArg/4 s.First#1/7 e.Second#1/5 >/1
      // closed e.Second#1 as range 5
      //DEBUG: s.First#1: 7
      //DEBUG: e.Second#1: 5

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </9 [*]/10 & NormArithmArg$2=1/11 (/12 Tile{ AsIs: e.Second#1/5 } )/13 {*}/14 Tile{ AsIs: </0 Reuse: & Type/4 AsIs: s.First#1/7 } >/15 Tile{ AsIs: >/1 ]] }
      if( ! refalrts::alloc_open_call( context[9] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_closure_head( context[10] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_name( context[11], ref_gen_NormArithmArg_S2A1.ref.function ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[12] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[13] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_unwrapped_closure( context[14], context[10] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[15] ) )
        return refalrts::cNoMemory;
      refalrts::update_name( context[4], ref_Type.ref.function );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[9] );
      refalrts::push_stack( context[15] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[12], context[13] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[15], context[15] );
      res = refalrts::splice_evar( res, context[0], context[7] );
      res = refalrts::splice_evar( res, context[13], context[14] );
      res = refalrts::splice_evar( res, context[5], context[6] );
      res = refalrts::splice_evar( res, context[9], context[12] );
      refalrts::use( res );
      refalrts::wrap_closure( context[14] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & NormArithmArg/4 (/7 e.First#1/9 )/8 e.Second#1/5 >/1
    context[9] = 0;
    context[10] = 0;
    if( ! refalrts::brackets_term( context[9], context[10], context[7] ) )
      continue;
    // closed e.First#1 as range 9
    // closed e.Second#1 as range 5
    //DEBUG: e.First#1: 9
    //DEBUG: e.Second#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 HalfReuse: [*]/4 HalfReuse: & NormArithmArg$3=1/7 } (/11 Tile{ AsIs: e.Second#1/5 } Tile{ AsIs: )/8 } {*}/12 </13 & NormNumber/14 Tile{ AsIs: e.First#1/9 } >/15 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_unwrapped_closure( context[12], context[4] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[14], ref_NormNumber.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[15] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_closure_head( context[4] );
    refalrts::reinit_name( context[7], ref_gen_NormArithmArg_S3A1.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[13] );
    refalrts::link_brackets( context[11], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[12], context[14] );
    res = refalrts::splice_evar( res, context[8], context[8] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[11], context[11] );
    refalrts::use( res );
    refalrts::wrap_closure( context[12] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & NormArithmArg/4 e.OtherArg#1/2 >/1
  // closed e.OtherArg#1 as range 2
  //DEBUG: e.OtherArg#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & NormArithmArg/4 e.OtherArg#1/2 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_NormArithmArg("NormArithmArg", 877573369U, 332537286U, func_NormArithmArg);


static refalrts::FnResult func_gen_NormNumber_S7A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  // </0 & NormNumber$7=1/4 (/8 e.Digits#1/6 )/9 # True/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = refalrts::ident_right(  ident_True, context[2], context[3] );
  if( ! context[5] )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Digits#1 as range 6
  //DEBUG: e.Digits#1: 6

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & NormNumber$7=1/4 (/8 {REMOVED TILE} )/9 # True/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: '+'/0 } Tile{ AsIs: e.Digits#1/6 } Tile{ ]] }
  refalrts::reinit_char( context[0], '+' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormNumber_S7A1("NormNumber$7=1", 877573369U, 332537286U, func_gen_NormNumber_S7A1);


static refalrts::FnResult func_gen_NormNumber_S8A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  // </0 & NormNumber$8=1/4 (/8 e.Digits#1/6 )/9 # True/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = refalrts::ident_right(  ident_True, context[2], context[3] );
  if( ! context[5] )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Digits#1 as range 6
  //DEBUG: e.Digits#1: 6

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & NormNumber$8=1/4 (/8 {REMOVED TILE} )/9 # True/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: '-'/0 } Tile{ AsIs: e.Digits#1/6 } Tile{ ]] }
  refalrts::reinit_char( context[0], '-' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[7] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormNumber_S8A1("NormNumber$8=1", 877573369U, 332537286U, func_gen_NormNumber_S8A1);


static refalrts::FnResult func_gen_NormNumber_S9B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 7 elems
  refalrts::Iter context[7];
  refalrts::zeros( context, 7 );
  // </0 & NormNumber$9:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & NormNumber$9:1/4 s.new#1/5 s.new#2/6 e.new#3/2 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#3 as range 2
  do {
    // </0 & NormNumber$9:1/4 'N'/5 s.SubType#2/6 e.Digits#2/2 >/1
    if( ! refalrts::char_term( 'N', context[5] ) )
      continue;
    // closed e.Digits#2 as range 2
    //DEBUG: s.SubType#2: 6
    //DEBUG: e.Digits#2: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.SubType#2/6 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & NormNumber/4 Reuse: '+'/5 } Tile{ AsIs: e.Digits#2/2 } Tile{ AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_NormNumber.ref.function );
    refalrts::update_char( context[5], '+' );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[2], context[3] );
    refalrts::splice_to_freelist_open( context[5], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & NormNumber$9:1/4 s.Type#2/5 s.SubType#2/6 e.NotIsDigits#2/2 >/1
  // closed e.NotIsDigits#2 as range 2
  //DEBUG: s.Type#2: 5
  //DEBUG: s.SubType#2: 6
  //DEBUG: e.NotIsDigits#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & NormNumber$9:1/4 s.Type#2/5 s.SubType#2/6 e.NotIsDigits#2/2 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_NormNumber_S9B1("NormNumber$9:1", 877573369U, 332537286U, func_gen_NormNumber_S9B1);


static refalrts::FnResult func_NormNumber(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  // </0 & NormNumber/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  do {
    // </0 & NormNumber/4 s.new#1/7 e.new#2/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    // closed e.new#2 as range 5
    do {
      // </0 & NormNumber/4 s.new#3/7 0/10 e.new#4/8 >/1
      context[8] = context[5];
      context[9] = context[6];
      context[10] = refalrts::number_left( 0UL, context[8], context[9] );
      if( ! context[10] )
        continue;
      // closed e.new#4 as range 8
      do {
        // </0 & NormNumber/4 '+'/7 0/10 e.new#5/8 >/1
        if( ! refalrts::char_term( '+', context[7] ) )
          continue;
        // closed e.new#5 as range 8
        do {
          // </0 & NormNumber/4 '+'/7 0/10 >/1
          if( ! refalrts::empty_seq( context[8], context[9] ) )
            continue;

          refalrts::reset_allocator();
          //TRASH: {REMOVED TILE} </0 & NormNumber/4 '+'/7 0/10 {REMOVED TILE}
          //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
          refalrts::reinit_number( context[1], 0UL );
          refalrts::Iter trash_prev = arg_begin->prev;
          refalrts::use(trash_prev);
          refalrts::Iter res = context[1];
          refalrts::splice_to_freelist_open( trash_prev, res );
          return refalrts::cSuccess;
        } while ( 0 );
        refalrts::stop_sentence();

        // </0 & NormNumber/4 '+'/7 0/10 e.Digits#1/8 >/1
        // closed e.Digits#1 as range 8
        //DEBUG: e.Digits#1: 8

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} </0 {REMOVED TILE}
        //RESULT: Tile{ [[ } Tile{ HalfReuse: </4 HalfReuse: & NormNumber/7 HalfReuse: '+'/10 AsIs: e.Digits#1/8 AsIs: >/1 ]] }
        refalrts::reinit_open_call( context[4] );
        refalrts::reinit_name( context[7], ref_NormNumber.ref.function );
        refalrts::reinit_char( context[10], '+' );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[4] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[4];
        refalrts::splice_to_freelist_open( trash_prev, res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      // </0 & NormNumber/4 '-'/7 0/10 e.new#5/8 >/1
      if( ! refalrts::char_term( '-', context[7] ) )
        continue;
      // closed e.new#5 as range 8
      do {
        // </0 & NormNumber/4 '-'/7 0/10 >/1
        if( ! refalrts::empty_seq( context[8], context[9] ) )
          continue;

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} </0 & NormNumber/4 '-'/7 0/10 {REMOVED TILE}
        //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
        refalrts::reinit_number( context[1], 0UL );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[1];
        refalrts::splice_to_freelist_open( trash_prev, res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      // </0 & NormNumber/4 '-'/7 0/10 e.Digits#1/8 >/1
      // closed e.Digits#1 as range 8
      //DEBUG: e.Digits#1: 8

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} </0 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: </4 HalfReuse: & NormNumber/7 HalfReuse: '-'/10 AsIs: e.Digits#1/8 AsIs: >/1 ]] }
      refalrts::reinit_open_call( context[4] );
      refalrts::reinit_name( context[7], ref_NormNumber.ref.function );
      refalrts::reinit_char( context[10], '-' );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[4] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[4];
      refalrts::splice_to_freelist_open( trash_prev, res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & NormNumber/4 0/7 e.new#3/5 >/1
      if( ! refalrts::number_term( 0UL, context[7] ) )
        continue;
      // closed e.new#3 as range 5
      do {
        // </0 & NormNumber/4 0/7 >/1
        if( ! refalrts::empty_seq( context[5], context[6] ) )
          continue;

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} </0 & NormNumber/4 0/7 {REMOVED TILE}
        //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
        refalrts::reinit_number( context[1], 0UL );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[1];
        refalrts::splice_to_freelist_open( trash_prev, res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      // </0 & NormNumber/4 0/7 e.Digits#1/5 >/1
      // closed e.Digits#1 as range 5
      //DEBUG: e.Digits#1: 5

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & NormNumber/4 HalfReuse: '+'/7 AsIs: e.Digits#1/5 AsIs: >/1 ]] }
      refalrts::reinit_char( context[7], '+' );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & NormNumber/4 '+'/7 e.Digits#1/5 >/1
      if( ! refalrts::char_term( '+', context[7] ) )
        continue;
      // closed e.Digits#1 as range 5
      //DEBUG: e.Digits#1: 5

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </8 [*]/9 & NormNumber$7=1/10 (/11 e.Digits#1/5/12 )/14 Tile{ HalfReuse: {*}/0 HalfReuse: </4 HalfReuse: & AllDigits/7 AsIs: e.Digits#1/5 AsIs: >/1 } >/15 Tile{ ]] }
      if( ! refalrts::alloc_open_call( context[8] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_closure_head( context[9] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_name( context[10], ref_gen_NormNumber_S7A1.ref.function ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[11] ) )
        return refalrts::cNoMemory;
      if (! refalrts::copy_evar(context[12], context[13], context[5], context[6]))
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[14] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[15] ) )
        return refalrts::cNoMemory;
      refalrts::reinit_unwrapped_closure( context[0], context[9] );
      refalrts::reinit_open_call( context[4] );
      refalrts::reinit_name( context[7], ref_AllDigits.ref.function );
      refalrts::push_stack( context[15] );
      refalrts::push_stack( context[8] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[4] );
      refalrts::link_brackets( context[11], context[14] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = arg_end->next;
      res = refalrts::splice_evar( res, context[15], context[15] );
      res = refalrts::splice_evar( res, context[0], context[1] );
      res = refalrts::splice_evar( res, context[8], context[14] );
      refalrts::use( res );
      refalrts::wrap_closure( context[0] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & NormNumber/4 '-'/7 e.Digits#1/5 >/1
    if( ! refalrts::char_term( '-', context[7] ) )
      continue;
    // closed e.Digits#1 as range 5
    //DEBUG: e.Digits#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </8 [*]/9 & NormNumber$8=1/10 (/11 e.Digits#1/5/12 )/14 Tile{ HalfReuse: {*}/0 HalfReuse: </4 HalfReuse: & AllDigits/7 AsIs: e.Digits#1/5 AsIs: >/1 } >/15 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_closure_head( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], ref_gen_NormNumber_S8A1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[11] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[12], context[13], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[15] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_unwrapped_closure( context[0], context[9] );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], ref_AllDigits.ref.function );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[11], context[14] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[8], context[14] );
    refalrts::use( res );
    refalrts::wrap_closure( context[0] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & NormNumber/4 e.Digits#1/2 >/1
  // closed e.Digits#1 as range 2
  //DEBUG: e.Digits#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & NormNumber$9:1/6 Tile{ AsIs: </0 Reuse: & Type/4 AsIs: e.Digits#1/2 AsIs: >/1 } >/7 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_gen_NormNumber_S9B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[7] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Type.ref.function );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[7], context[7] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_NormNumber("NormNumber", 877573369U, 332537286U, func_NormNumber);


static refalrts::FnResult func_AllDigits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  // </0 & AllDigits/4 e.Items#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Items#1 as range 2
  //DEBUG: e.Items#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & AllDigits-SwFirst/6 Tile{ AsIs: </0 Reuse: & Type/4 AsIs: e.Items#1/2 AsIs: >/1 } >/7 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_AllDigitsm_SwFirst.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[7] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Type.ref.function );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[7], context[7] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_AllDigits("AllDigits", 877573369U, 332537286U, func_AllDigits);


static refalrts::FnResult func_AllDigitsm_SwFirst(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  // </0 & AllDigits-SwFirst/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & AllDigits-SwFirst/4 s.new#1/5 s.new#2/6 e.new#3/2 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#3 as range 2
  do {
    // </0 & AllDigits-SwFirst/4 'N'/5 s.new#4/6 s.new#5/9 e.new#6/7 >/1
    context[7] = context[2];
    context[8] = context[3];
    if( ! refalrts::char_term( 'N', context[5] ) )
      continue;
    if( ! refalrts::svar_left( context[9], context[7], context[8] ) )
      continue;
    // closed e.new#6 as range 7
    do {
      // </0 & AllDigits-SwFirst/4 'N'/5 s.SubType#1/6 s.Digit#1/9 >/1
      if( ! refalrts::empty_seq( context[7], context[8] ) )
        continue;
      //DEBUG: s.SubType#1: 6
      //DEBUG: s.Digit#1: 9

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} </0 & AllDigits-SwFirst/4 'N'/5 s.SubType#1/6 s.Digit#1/9 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: # True/1 ]] }
      refalrts::reinit_ident( context[1], ident_True );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      refalrts::splice_to_freelist_open( trash_prev, res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & AllDigits-SwFirst/4 'N'/5 s.SubType#1/6 s.Digit#1/9 e.Items#1/7 >/1
    // closed e.Items#1 as range 7
    //DEBUG: s.SubType#1: 6
    //DEBUG: s.Digit#1: 9
    //DEBUG: e.Items#1: 7

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} 'N'/5 s.SubType#1/6 s.Digit#1/9 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & AllDigits/4 } Tile{ AsIs: e.Items#1/7 } Tile{ AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_AllDigits.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[7], context[8] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & AllDigits-SwFirst/4 s.Type#1/5 s.SubType#1/6 e.Expr#1/2 >/1
  // closed e.Expr#1 as range 2
  //DEBUG: s.Type#1: 5
  //DEBUG: s.SubType#1: 6
  //DEBUG: e.Expr#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & AllDigits-SwFirst/4 s.Type#1/5 s.SubType#1/6 e.Expr#1/2 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: # False/1 ]] }
  refalrts::reinit_ident( context[1], ident_False );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_AllDigitsm_SwFirst("AllDigits-SwFirst", 877573369U, 332537286U, func_AllDigitsm_SwFirst);


static refalrts::FnResult func_Addm_Normed(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  // </0 & Add-Normed/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Add-Normed/4 (/7 s.new#1/9 e.new#2/5 )/8 e.new#3/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#3 as range 2
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#2 as range 5
  do {
    // </0 & Add-Normed/4 (/7 s.new#4/9 e.new#5/5 )/8 s.new#6/12 e.new#7/10 >/1
    context[10] = context[2];
    context[11] = context[3];
    // closed e.new#5 as range 5
    if( ! refalrts::svar_left( context[12], context[10], context[11] ) )
      continue;
    // closed e.new#7 as range 10
    do {
      // </0 & Add-Normed/4 (/7 '+'/9 e.new#8/5 )/8 s.new#9/12 e.new#10/10 >/1
      if( ! refalrts::char_term( '+', context[9] ) )
        continue;
      // closed e.new#8 as range 5
      // closed e.new#10 as range 10
      do {
        // </0 & Add-Normed/4 (/7 '+'/9 e.First#1/5 )/8 '+'/12 e.Second#1/10 >/1
        if( ! refalrts::char_term( '+', context[12] ) )
          continue;
        // closed e.First#1 as range 5
        // closed e.Second#1 as range 10
        //DEBUG: e.First#1: 5
        //DEBUG: e.Second#1: 10

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} '+'/9 {REMOVED TILE} )/8 {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 Reuse: & Add-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/5 } Tile{ HalfReuse: )/12 AsIs: e.Second#1/10 AsIs: >/1 ]] }
        refalrts::update_name( context[4], ref_Addm_Nat.ref.function );
        refalrts::reinit_close_bracket( context[12] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[0] );
        refalrts::link_brackets( context[7], context[12] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[12];
        res = refalrts::splice_evar( res, context[5], context[6] );
        refalrts::splice_to_freelist_open( context[7], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Add-Normed/4 (/7 '+'/9 e.First#1/5 )/8 '-'/12 e.Second#1/10 >/1
        if( ! refalrts::char_term( '-', context[12] ) )
          continue;
        // closed e.First#1 as range 5
        // closed e.Second#1 as range 10
        //DEBUG: e.First#1: 5
        //DEBUG: e.Second#1: 10

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} '+'/9 {REMOVED TILE} )/8 {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sub-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/5 } Tile{ HalfReuse: )/12 AsIs: e.Second#1/10 AsIs: >/1 ]] }
        refalrts::update_name( context[4], ref_Subm_Nat.ref.function );
        refalrts::reinit_close_bracket( context[12] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[0] );
        refalrts::link_brackets( context[7], context[12] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[12];
        res = refalrts::splice_evar( res, context[5], context[6] );
        refalrts::splice_to_freelist_open( context[7], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      // </0 & Add-Normed/4 (/7 '+'/9 e.First#1/5 )/8 0/12 >/1
      if( ! refalrts::number_term( 0UL, context[12] ) )
        continue;
      if( ! refalrts::empty_seq( context[10], context[11] ) )
        continue;
      // closed e.First#1 as range 5
      //DEBUG: e.First#1: 5

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} </0 & Add-Normed/4 (/7 '+'/9 {REMOVED TILE} )/8 0/12 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: e.First#1/5 } Tile{ ]] }
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = arg_end->next;
      res = refalrts::splice_evar( res, context[5], context[6] );
      refalrts::splice_to_freelist_open( trash_prev, res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & Add-Normed/4 (/7 '-'/9 e.new#8/5 )/8 s.new#9/12 e.new#10/10 >/1
      if( ! refalrts::char_term( '-', context[9] ) )
        continue;
      // closed e.new#8 as range 5
      // closed e.new#10 as range 10
      do {
        // </0 & Add-Normed/4 (/7 '-'/9 e.First#1/5 )/8 '+'/12 e.Second#1/10 >/1
        if( ! refalrts::char_term( '+', context[12] ) )
          continue;
        // closed e.First#1 as range 5
        // closed e.Second#1 as range 10
        //DEBUG: e.First#1: 5
        //DEBUG: e.Second#1: 10

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} '-'/9 {REMOVED TILE} {REMOVED TILE} '+'/12 {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sub-Nat/4 AsIs: (/7 } Tile{ AsIs: e.Second#1/10 } Tile{ AsIs: )/8 } Tile{ AsIs: e.First#1/5 } Tile{ AsIs: >/1 ]] }
        refalrts::update_name( context[4], ref_Subm_Nat.ref.function );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[0] );
        refalrts::link_brackets( context[7], context[8] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[1];
        res = refalrts::splice_evar( res, context[5], context[6] );
        res = refalrts::splice_evar( res, context[8], context[8] );
        res = refalrts::splice_evar( res, context[10], context[11] );
        refalrts::splice_to_freelist_open( context[7], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Add-Normed/4 (/7 '-'/9 e.First#1/5 )/8 '-'/12 e.Second#1/10 >/1
        if( ! refalrts::char_term( '-', context[12] ) )
          continue;
        // closed e.First#1 as range 5
        // closed e.Second#1 as range 10
        //DEBUG: e.First#1: 5
        //DEBUG: e.Second#1: 10

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} '-'/12 {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ HalfReuse: '-'/0 HalfReuse: </4 HalfReuse: & Add-Nat/7 HalfReuse: (/9 AsIs: e.First#1/5 AsIs: )/8 } Tile{ AsIs: e.Second#1/10 } Tile{ AsIs: >/1 ]] }
        refalrts::reinit_char( context[0], '-' );
        refalrts::reinit_open_call( context[4] );
        refalrts::reinit_name( context[7], ref_Addm_Nat.ref.function );
        refalrts::reinit_open_bracket( context[9] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[4] );
        refalrts::link_brackets( context[9], context[8] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[1];
        res = refalrts::splice_evar( res, context[10], context[11] );
        refalrts::splice_to_freelist_open( context[8], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      // </0 & Add-Normed/4 (/7 '-'/9 e.First#1/5 )/8 0/12 >/1
      if( ! refalrts::number_term( 0UL, context[12] ) )
        continue;
      if( ! refalrts::empty_seq( context[10], context[11] ) )
        continue;
      // closed e.First#1 as range 5
      //DEBUG: e.First#1: 5

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} & Add-Normed/4 (/7 '-'/9 {REMOVED TILE} )/8 0/12 >/1 {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: '-'/0 } Tile{ AsIs: e.First#1/5 } Tile{ ]] }
      refalrts::reinit_char( context[0], '-' );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = arg_end->next;
      res = refalrts::splice_evar( res, context[5], context[6] );
      refalrts::splice_to_freelist_open( context[0], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Add-Normed/4 (/7 0/9 )/8 '+'/12 e.Second#1/10 >/1
    if( ! refalrts::char_term( '+', context[12] ) )
      continue;
    if( ! refalrts::number_term( 0UL, context[9] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    // closed e.Second#1 as range 10
    //DEBUG: e.Second#1: 10

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Add-Normed/4 (/7 0/9 )/8 '+'/12 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: e.Second#1/10 } Tile{ ]] }
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[10], context[11] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Add-Normed/4 (/7 0/9 )/8 e.NegOrZero#1/2 >/1
  if( ! refalrts::number_term( 0UL, context[9] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.NegOrZero#1 as range 2
  //DEBUG: e.NegOrZero#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Add-Normed/4 (/7 0/9 )/8 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.NegOrZero#1/2 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Addm_Normed("Add-Normed", 877573369U, 332537286U, func_Addm_Normed);


static refalrts::FnResult func_gen_Addm_Nat_S1B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  // </0 & Add-Nat$1:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Add-Nat$1:1/4 (/7 e.new#1/5 )/8 (/11 e.new#2/9 )/12 e.new#3/2 s.new#4/13 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.new#1 as range 5
  // closed e.new#2 as range 9
  if( ! refalrts::svar_right( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#3 as range 2
  do {
    // </0 & Add-Nat$1:1/4 (/7 e.First#1/5 )/8 (/11 e.Second#1/9 )/12 s.LastSum#2/13 >/1
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    // closed e.First#1 as range 5
    // closed e.Second#1 as range 9
    //DEBUG: s.LastSum#2: 13
    //DEBUG: e.First#1: 5
    //DEBUG: e.Second#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} (/11 {REMOVED TILE} {REMOVED TILE} s.LastSum#2/13 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Add-Nat/4 AsIs: (/7 AsIs: e.First#1/5 AsIs: )/8 } Tile{ AsIs: e.Second#1/9 } Tile{ HalfReuse: >/12 } Tile{ HalfReuse: s.LastSum2 #13/1 ]] }
    refalrts::update_name( context[4], ref_Addm_Nat.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_svar( context[1], context[13] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    refalrts::splice_to_freelist_open( context[8], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Add-Nat$1:1/4 (/7 e.First#1/5 )/8 (/11 e.Second#1/9 )/12 1/14 s.LastSum#2/13 >/1
  context[14] = refalrts::number_left( 1UL, context[2], context[3] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.First#1 as range 5
  // closed e.Second#1 as range 9
  //DEBUG: s.LastSum#2: 13
  //DEBUG: e.First#1: 5
  //DEBUG: e.Second#1: 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LastSum#2/13 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Add-Nat/4 AsIs: (/7 AsIs: e.First#1/5 AsIs: )/8 HalfReuse: </11 } & Add-Nat/15 (/16 Tile{ AsIs: e.Second#1/9 } Tile{ AsIs: )/12 AsIs: 1/14 } >/17 >/18 Tile{ HalfReuse: s.LastSum2 #13/1 ]] }
  if( ! refalrts::alloc_name( context[15], ref_Addm_Nat.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Addm_Nat.ref.function );
  refalrts::reinit_open_call( context[11] );
  refalrts::reinit_svar( context[1], context[13] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[11] );
  refalrts::link_brackets( context[16], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[17], context[18] );
  res = refalrts::splice_evar( res, context[12], context[14] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[15], context[16] );
  refalrts::splice_to_freelist_open( context[11], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Addm_Nat_S1B1("Add-Nat$1:1", 877573369U, 332537286U, func_gen_Addm_Nat_S1B1);


static refalrts::FnResult func_Addm_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 22 elems
  refalrts::Iter context[22];
  refalrts::zeros( context, 22 );
  // </0 & Add-Nat/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Add-Nat/4 (/7 e.new#1/5 )/8 e.new#2/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#1 as range 5
  // closed e.new#2 as range 2
  do {
    // </0 & Add-Nat/4 (/7 e.First#1/9 s.FirstLast#1/13 )/8 e.Second#1/11 s.SecondLast#1/14 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    if( ! refalrts::svar_right( context[13], context[9], context[10] ) )
      continue;
    // closed e.First#1 as range 9
    if( ! refalrts::svar_right( context[14], context[11], context[12] ) )
      continue;
    // closed e.Second#1 as range 11
    //DEBUG: s.FirstLast#1: 13
    //DEBUG: e.First#1: 9
    //DEBUG: s.SecondLast#1: 14
    //DEBUG: e.Second#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 HalfReuse: [*]/4 HalfReuse: & Add-Nat$1:1/7 } (/15 Tile{ AsIs: e.First#1/9 } )/16 (/17 Tile{ AsIs: e.Second#1/11 } Tile{ AsIs: )/8 } {*}/18 </19 & Add-Digits/20 Tile{ AsIs: s.FirstLast#1/13 } Tile{ AsIs: s.SecondLast#1/14 AsIs: >/1 } >/21 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_unwrapped_closure( context[18], context[4] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[20], ref_Addm_Digits.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_closure_head( context[4] );
    refalrts::reinit_name( context[7], ref_gen_Addm_Nat_S1B1.ref.function );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[19] );
    refalrts::link_brackets( context[17], context[8] );
    refalrts::link_brackets( context[15], context[16] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[21], context[21] );
    res = refalrts::splice_evar( res, context[14], context[1] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[18], context[20] );
    res = refalrts::splice_evar( res, context[8], context[8] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    refalrts::use( res );
    refalrts::wrap_closure( context[18] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Add-Nat/4 (/7 e.First#1/5 )/8 e.Second#1/2 >/1
  // closed e.First#1 as range 5
  // closed e.Second#1 as range 2
  //DEBUG: e.First#1: 5
  //DEBUG: e.Second#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Add-Nat/4 (/7 {REMOVED TILE} )/8 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.First#1/5 } Tile{ AsIs: e.Second#1/2 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Addm_Nat("Add-Nat", 877573369U, 332537286U, func_Addm_Nat);

#line 211 "Library.sref"

#define ARITHM_PRELUDE \
  refalrts::Iter pFirst = 0, pSecond = 0; \
  refalrts::Iter pFunc \
    = refalrts::call_left(pFirst, pSecond, arg_begin, arg_end); \
  \
  if (pFirst->next != pSecond) { \
    return refalrts::cRecognitionImpossible; \
  } \
  \
  if ( \
    refalrts::cDataNumber != pFirst->tag \
    || refalrts::cDataNumber != pSecond->tag \
  ) { \
    return refalrts::cRecognitionImpossible; \
  } \
  \
  refalrts::RefalNumber first = pFirst->number_info; \
  refalrts::RefalNumber second = pSecond->number_info;

#line 2028 "Library.cpp"

static refalrts::FnResult func_Addm_Digits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 235 "Library.sref"
  ARITHM_PRELUDE

  refalrts::RefalNumber sum = first + second;

  if (sum >= first) {
    pFirst->number_info = sum;
    refalrts::splice_to_freelist(arg_begin, pFunc);
    refalrts::splice_to_freelist(pSecond, arg_end);
  } else {
    pFirst->number_info = 1;
    pSecond->number_info = sum;
    refalrts::splice_to_freelist(arg_begin, pFunc);
    refalrts::splice_to_freelist(arg_end, arg_end);
  }

  return refalrts::cSuccess;
#line 2048 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Addm_Digits("Add-Digits", 877573369U, 332537286U, func_Addm_Digits);


static refalrts::FnResult func_Arg(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 261 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pparam_no = 0;
  if (
    ! refalrts::svar_left(pparam_no, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
    || refalrts::cDataNumber != pparam_no->tag
  ) {
    return refalrts::cRecognitionImpossible;
  }

  unsigned int param_no = static_cast<unsigned int>(pparam_no->number_info);

  refalrts::Iter param_begin = 0;
  refalrts::Iter param_end = 0;
  const char *param = refalrts::arg(param_no);

  if (! refalrts::alloc_string(param_begin, param_end, param)) {
    return refalrts::cNoMemory;
  }

  refalrts::splice_evar(arg_begin, param_begin, param_end);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 2082 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Arg("Arg", 0U, 0U, func_Arg);


static refalrts::FnResult func_Br(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & Br/4 e.Key#1/5 '='/9 e.Value#1/7 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  refalrts::start_e_loop();
  do {
    context[7] = context[2];
    context[8] = context[3];
    context[9] = refalrts::char_left( '=', context[7], context[8] );
    if( ! context[9] )
      continue;
    // closed e.Value#1 as range 7
    //DEBUG: e.Key#1: 5
    //DEBUG: e.Value#1: 7

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </10 & __Step-Start/11 >/12 </13 Tile{ HalfReuse: & Buried/0 HalfReuse: (/4 AsIs: e.Key#1/5 AsIs: '='/9 AsIs: e.Value#1/7 HalfReuse: )/1 } </14 & Buried/15 >/16 >/17 </18 & __Step-End/19 >/20 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[11], ref_u_u_Stepm_Start.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[15], ref_Buried.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[19], ref_u_u_Stepm_End.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[20] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_name( context[0], ref_Buried.ref.function );
    refalrts::reinit_open_bracket( context[4] );
    refalrts::reinit_close_bracket( context[1] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[17] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[14] );
    refalrts::link_brackets( context[4], context[1] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[14], context[20] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[10], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( refalrts::open_evar_advance( context[5], context[6], context[2], context[3] ) );
  return refalrts::cRecognitionImpossible;
}

static refalrts::NativeReference nat_ref_Br("Br", 0U, 0U, func_Br);


static refalrts::FnResult func_Card(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & Card/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & __Step-Start/4 AsIs: >/1 } </5 & Get-Aux/6 # stdin/7 >/8 </9 & __Step-End/10 >/11 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_Getm_Aux.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[7], ident_stdin ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_u_u_Stepm_Start.ref.function );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Card("Card", 0U, 0U, func_Card);

#line 314 "Library.sref"
namespace {

template <typename Conv>
refalrts::FnResult convert(
  refalrts::Iter arg_begin, refalrts::Iter arg_end, Conv conv
) {
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  while (! refalrts::empty_seq(content_b, content_e)) {
    if (conv.for_convert(content_b)) {
      conv.convert(content_b);
    }

    if (content_b->tag != refalrts::cDataOpenADT) {
      refalrts::move_left(content_b, content_e);
    } else {
      refalrts::Iter dummy;
      refalrts::tvar_left(dummy, content_b, content_e);
    }
  }

  refalrts::splice_to_freelist(arg_begin, pfunc);
  refalrts::splice_to_freelist(arg_end, arg_end);

  return refalrts::cSuccess;
}

struct ChrConv {
  bool for_convert(refalrts::Iter item) {
    return refalrts::cDataNumber == item->tag;
  }

  void convert(refalrts::Iter item) {
    item->tag = refalrts::cDataChar;
    item->char_info = static_cast<char>(item->number_info);
  }
};

}  // unnamed namespace
#line 2254 "Library.cpp"

static refalrts::FnResult func_Chr(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 359 "Library.sref"
  return convert(arg_begin, arg_end, ChrConv());
#line 2259 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Chr("Chr", 0U, 0U, func_Chr);


static refalrts::FnResult func_gen_Cp_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 25 elems
  refalrts::Iter context[25];
  refalrts::zeros( context, 25 );
  // </0 & Cp:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Cp:1/4 (/7 e.new#1/5 )/8 e.new#2/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#1 as range 5
  // closed e.new#2 as range 2
  do {
    // </0 & Cp:1/4 (/7 e.Key#1/5 )/8 e.Values-B#2/11 (/17 e.Key#1/19 '='/21 e.Value#2/15 )/18 e.Values-E#2/13 >/1
    context[9] = context[2];
    context[10] = context[3];
    // closed e.Key#1 as range 5
    context[11] = 0;
    context[12] = 0;
    refalrts::start_e_loop();
    do {
      context[13] = context[9];
      context[14] = context[10];
      context[15] = 0;
      context[16] = 0;
      context[17] = refalrts::brackets_left( context[15], context[16], context[13], context[14] );
      if( ! context[17] )
        continue;
      refalrts::bracket_pointers(context[17], context[18]);
      if( ! refalrts::repeated_evar_left( context[19], context[20], context[5], context[6], context[15], context[16] ) )
        continue;
      context[21] = refalrts::char_left( '=', context[15], context[16] );
      if( ! context[21] )
        continue;
      // closed e.Value#2 as range 15
      // closed e.Values-E#2 as range 13
      //DEBUG: e.Key#1: 5
      //DEBUG: e.Values-B#2: 11
      //DEBUG: e.Value#2: 15
      //DEBUG: e.Values-E#2: 13

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} e.Key#1/5 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } e.Value#2/15/22 </24 Tile{ HalfReuse: & Buried/8 AsIs: e.Values-B#2/11 AsIs: (/17 AsIs: e.Key#1/19 AsIs: '='/21 AsIs: e.Value#2/15 AsIs: )/18 AsIs: e.Values-E#2/13 AsIs: >/1 } Tile{ AsIs: </0 Reuse: & __Step-End/4 HalfReuse: >/7 } Tile{ ]] }
      if (! refalrts::copy_evar(context[22], context[23], context[15], context[16]))
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_call( context[24] ) )
        return refalrts::cNoMemory;
      refalrts::reinit_name( context[8], ref_Buried.ref.function );
      refalrts::update_name( context[4], ref_u_u_Stepm_End.ref.function );
      refalrts::reinit_close_call( context[7] );
      refalrts::push_stack( context[7] );
      refalrts::push_stack( context[0] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[24] );
      refalrts::link_brackets( context[17], context[18] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = arg_end->next;
      res = refalrts::splice_evar( res, context[0], context[7] );
      res = refalrts::splice_evar( res, context[8], context[1] );
      res = refalrts::splice_evar( res, context[24], context[24] );
      res = refalrts::splice_evar( res, context[22], context[23] );
      refalrts::splice_to_freelist_open( trash_prev, res );
      return refalrts::cSuccess;
    } while ( refalrts::open_evar_advance( context[11], context[12], context[9], context[10] ) );
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Cp:1/4 (/7 e.Key#1/5 )/8 e.Values#2/2 >/1
  // closed e.Key#1 as range 5
  // closed e.Values#2 as range 2
  //DEBUG: e.Key#1: 5
  //DEBUG: e.Values#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} e.Key#1/5 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Buried/4 } Tile{ AsIs: e.Values#2/2 } Tile{ HalfReuse: >/7 } Tile{ HalfReuse: </8 } & __Step-End/9 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_name( context[9], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Buried.ref.function );
  refalrts::reinit_close_call( context[7] );
  refalrts::reinit_open_call( context[8] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[8], context[8] );
  res = refalrts::splice_evar( res, context[7], context[7] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Cp_B1("Cp:1", 877573369U, 332537286U, func_gen_Cp_B1);


static refalrts::FnResult func_Cp(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & Cp/4 e.Key#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Key#1 as range 2
  //DEBUG: e.Key#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 HalfReuse: [*]/4 } & Cp:1/5 (/6 Tile{ AsIs: e.Key#1/2 } )/7 {*}/8 </9 & __Step-Start/10 >/11 </12 & Buried/13 >/14 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_name( context[5], ref_gen_Cp_B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[8], context[4] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_u_u_Stepm_Start.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[13], ref_Buried.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[4] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[9] );
  refalrts::link_brackets( context[6], context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[7], context[14] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  refalrts::wrap_closure( context[8] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Cp("Cp", 0U, 0U, func_Cp);


static refalrts::FnResult func_gen_Dg_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 22 elems
  refalrts::Iter context[22];
  refalrts::zeros( context, 22 );
  // </0 & Dg:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Dg:1/4 (/7 e.new#1/5 )/8 e.new#2/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#1 as range 5
  // closed e.new#2 as range 2
  do {
    // </0 & Dg:1/4 (/7 e.Key#1/5 )/8 e.Values-B#2/11 (/17 e.Key#1/19 '='/21 e.Value#2/15 )/18 e.Values-E#2/13 >/1
    context[9] = context[2];
    context[10] = context[3];
    // closed e.Key#1 as range 5
    context[11] = 0;
    context[12] = 0;
    refalrts::start_e_loop();
    do {
      context[13] = context[9];
      context[14] = context[10];
      context[15] = 0;
      context[16] = 0;
      context[17] = refalrts::brackets_left( context[15], context[16], context[13], context[14] );
      if( ! context[17] )
        continue;
      refalrts::bracket_pointers(context[17], context[18]);
      if( ! refalrts::repeated_evar_left( context[19], context[20], context[5], context[6], context[15], context[16] ) )
        continue;
      context[21] = refalrts::char_left( '=', context[15], context[16] );
      if( ! context[21] )
        continue;
      // closed e.Value#2 as range 15
      // closed e.Values-E#2 as range 13
      //DEBUG: e.Key#1: 5
      //DEBUG: e.Values-B#2: 11
      //DEBUG: e.Value#2: 15
      //DEBUG: e.Values-E#2: 13

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} (/7 e.Key#1/5 )/8 {REMOVED TILE} {REMOVED TILE} e.Key#1/19 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ AsIs: e.Value#2/15 } Tile{ AsIs: </0 Reuse: & Buried/4 } Tile{ AsIs: e.Values-B#2/11 } Tile{ AsIs: e.Values-E#2/13 } Tile{ HalfReuse: >/17 } Tile{ HalfReuse: </21 } Tile{ HalfReuse: & __Step-End/18 } Tile{ AsIs: >/1 ]] }
      refalrts::update_name( context[4], ref_Buried.ref.function );
      refalrts::reinit_close_call( context[17] );
      refalrts::reinit_open_call( context[21] );
      refalrts::reinit_name( context[18], ref_u_u_Stepm_End.ref.function );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[21] );
      refalrts::push_stack( context[17] );
      refalrts::push_stack( context[0] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[18], context[18] );
      res = refalrts::splice_evar( res, context[21], context[21] );
      res = refalrts::splice_evar( res, context[17], context[17] );
      res = refalrts::splice_evar( res, context[13], context[14] );
      res = refalrts::splice_evar( res, context[11], context[12] );
      res = refalrts::splice_evar( res, context[0], context[4] );
      res = refalrts::splice_evar( res, context[15], context[16] );
      refalrts::splice_to_freelist_open( trash_prev, res );
      return refalrts::cSuccess;
    } while ( refalrts::open_evar_advance( context[11], context[12], context[9], context[10] ) );
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Dg:1/4 (/7 e.Key#1/5 )/8 e.Values#2/2 >/1
  // closed e.Key#1 as range 5
  // closed e.Values#2 as range 2
  //DEBUG: e.Key#1: 5
  //DEBUG: e.Values#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} e.Key#1/5 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Buried/4 } Tile{ AsIs: e.Values#2/2 } Tile{ HalfReuse: >/7 } Tile{ HalfReuse: </8 } & __Step-End/9 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_name( context[9], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Buried.ref.function );
  refalrts::reinit_close_call( context[7] );
  refalrts::reinit_open_call( context[8] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[8], context[8] );
  res = refalrts::splice_evar( res, context[7], context[7] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Dg_B1("Dg:1", 877573369U, 332537286U, func_gen_Dg_B1);


static refalrts::FnResult func_Dg(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & Dg/4 e.Key#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Key#1 as range 2
  //DEBUG: e.Key#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 HalfReuse: [*]/4 } & Dg:1/5 (/6 Tile{ AsIs: e.Key#1/2 } )/7 {*}/8 </9 & __Step-Start/10 >/11 </12 & Buried/13 >/14 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_name( context[5], ref_gen_Dg_B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[8], context[4] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_u_u_Stepm_Start.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[13], ref_Buried.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[4] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[9] );
  refalrts::link_brackets( context[6], context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[7], context[14] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  refalrts::wrap_closure( context[8] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Dg("Dg", 0U, 0U, func_Dg);


static refalrts::FnResult func_Dgall(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  // </0 & Dgall/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & __Step-Start/4 AsIs: >/1 } </5 & Buried/6 >/7 </8 & __Step-End/9 >/10 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_Buried.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[10] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_u_u_Stepm_Start.ref.function );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[10] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Dgall("Dgall", 0U, 0U, func_Dgall);


static refalrts::FnResult func_gen_Div_S1A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  // </0 & Div$1=1/4 (/7 s.Div#2/9 )/8 s.Rem#2/10 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.Div#2: 9
  //DEBUG: s.Rem#2: 10

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Div#2/9 )/8 s.Rem#2/10 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: s.Div2 #9/0 HalfReuse: </4 HalfReuse: & __Step-End/7 } Tile{ AsIs: >/1 ]] }
  refalrts::reinit_svar( context[0], context[9] );
  refalrts::reinit_open_call( context[4] );
  refalrts::reinit_name( context[7], ref_u_u_Stepm_End.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( context[7], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Div_S1A1("Div$1=1", 877573369U, 332537286U, func_gen_Div_S1A1);


static refalrts::FnResult func_gen_Div_S2A2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Div$2=2/4 (/7 e.Div#3/5 )/8 e.Mod#3/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Div#3 as range 5
  // closed e.Mod#3 as range 2
  //DEBUG: e.Div#3: 5
  //DEBUG: e.Mod#3: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} (/7 {REMOVED TILE} )/8 e.Mod#3/2 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.Div#3/5 } Tile{ AsIs: </0 Reuse: & __Step-End/4 } Tile{ AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_u_u_Stepm_End.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Div_S2A2("Div$2=2", 877573369U, 332537286U, func_gen_Div_S2A2);


static refalrts::FnResult func_gen_Div_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & Div$2=1/4 (/7 e.First#2/5 )/8 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#2 as range 5
  // closed e.Second#2 as range 2
  //DEBUG: e.First#2: 5
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </9 & Div$2=2/10 Tile{ AsIs: </0 Reuse: & Divmod-Normed/4 AsIs: (/7 AsIs: e.First#2/5 AsIs: )/8 AsIs: e.Second#2/2 AsIs: >/1 } >/11 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_gen_Div_S2A2.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Divmodm_Normed.ref.function );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Div_S2A1("Div$2=1", 877573369U, 332537286U, func_gen_Div_S2A1);


static refalrts::FnResult func_Div(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & Div/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  do {
    // </0 & Div/4 s.First#1/7 s.Second#1/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.First#1: 7
    //DEBUG: s.Second#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </9 & Div$1=1/10 </11 & __Step-Start/12 >/13 Tile{ AsIs: </0 Reuse: & Divmod-Digits/4 AsIs: s.First#1/7 AsIs: s.Second#1/8 AsIs: >/1 } >/14 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], ref_gen_Div_S1A1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[12], ref_u_u_Stepm_Start.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[14] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Divmodm_Digits.ref.function );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[11] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[9], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Div/4 e.ArithmArg#1/2 >/1
  // closed e.ArithmArg#1 as range 2
  //DEBUG: e.ArithmArg#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & Div$2=1/6 </7 & __Step-Start/8 >/9 Tile{ AsIs: </0 Reuse: & NormArithmArg/4 AsIs: e.ArithmArg#1/2 AsIs: >/1 } >/10 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_gen_Div_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_u_u_Stepm_Start.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[10] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormArithmArg.ref.function );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[5], context[9] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Div("Div", 0U, 0U, func_Div);


static refalrts::FnResult func_gen_Divmod_S2A2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & Divmod$2=2/4 s.Sign#2/5 (/8 e.First#2/6 )/9 (/12 e.Second#2/10 )/13 e.Signs-B#3/14 s.Sign#2/18 e.Signs-E#3/16 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  context[10] = 0;
  context[11] = 0;
  context[12] = refalrts::brackets_left( context[10], context[11], context[2], context[3] );
  if( ! context[12] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[12], context[13]);
  // closed e.First#2 as range 6
  // closed e.Second#2 as range 10
  context[14] = 0;
  context[15] = 0;
  refalrts::start_e_loop();
  do {
    context[16] = context[2];
    context[17] = context[3];
    if( ! refalrts::repeated_stvar_left( context[18], context[5], context[16], context[17] ) )
      continue;
    // closed e.Signs-E#3 as range 16
    //DEBUG: s.Sign#2: 5
    //DEBUG: e.First#2: 6
    //DEBUG: e.Second#2: 10
    //DEBUG: e.Signs-B#3: 14
    //DEBUG: e.Signs-E#3: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.Sign#2/5 {REMOVED TILE} e.Signs-B#3/14 s.Sign#2/18 e.Signs-E#3/16 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Divmod-Normed/4 } Tile{ AsIs: (/8 AsIs: e.First#2/6 AsIs: )/9 HalfReuse: s.Sign2 #18/12 AsIs: e.Second#2/10 HalfReuse: >/13 } </19 & __Step-End/20 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[20], ref_u_u_Stepm_End.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Divmodm_Normed.ref.function );
    refalrts::reinit_svar( context[12], context[18] );
    refalrts::reinit_close_call( context[13] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[8], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[8], context[13] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( refalrts::open_evar_advance( context[14], context[15], context[2], context[3] ) );
  return refalrts::cRecognitionImpossible;
}

static refalrts::NativeReference nat_ref_gen_Divmod_S2A2("Divmod$2=2", 877573369U, 332537286U, func_gen_Divmod_S2A2);


static refalrts::FnResult func_gen_Divmod_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 17 elems
  refalrts::Iter context[17];
  refalrts::zeros( context, 17 );
  // </0 & Divmod$2=1/4 (/7 e.First#2/5 )/8 s.Sign#2/9 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#2 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Second#2 as range 2
  //DEBUG: e.First#2: 5
  //DEBUG: s.Sign#2: 9
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} s.Sign#2/9 {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </10 [*]/11 Tile{ HalfReuse: & Divmod$2=2/0 HalfReuse: s.Sign2 #9/4 AsIs: (/7 AsIs: e.First#2/5 AsIs: )/8 } (/12 Tile{ AsIs: e.Second#2/2 } )/13 {*}/14"+-"/15 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_closure_head( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[14], context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[15], context[16], "+-", 2 ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[0], ref_gen_Divmod_S2A2.ref.function );
  refalrts::reinit_svar( context[4], context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[10] );
  refalrts::link_brackets( context[12], context[13] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[13], context[16] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[0], context[8] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  refalrts::wrap_closure( context[14] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmod_S2A1("Divmod$2=1", 877573369U, 332537286U, func_gen_Divmod_S2A1);


static refalrts::FnResult func_Divmod(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & Divmod/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  do {
    // </0 & Divmod/4 s.First#1/7 s.Second#1/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.First#1: 7
    //DEBUG: s.Second#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </9 & __Step-Start/10 >/11 Tile{ AsIs: </0 Reuse: & Divmod-Digits/4 AsIs: s.First#1/7 AsIs: s.Second#1/8 AsIs: >/1 } </12 & __Step-End/13 >/14 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], ref_u_u_Stepm_Start.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[13], ref_u_u_Stepm_End.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[14] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Divmodm_Digits.ref.function );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[12], context[14] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[9], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Divmod/4 e.ArithmArg#1/2 >/1
  // closed e.ArithmArg#1 as range 2
  //DEBUG: e.ArithmArg#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & Divmod$2=1/6 </7 & __Step-Start/8 >/9 Tile{ AsIs: </0 Reuse: & NormArithmArg/4 AsIs: e.ArithmArg#1/2 AsIs: >/1 } >/10 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_gen_Divmod_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_u_u_Stepm_Start.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[10] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormArithmArg.ref.function );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[5], context[9] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmod("Divmod", 0U, 0U, func_Divmod);


static refalrts::FnResult func_Divmodm_Digits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 441 "Library.sref"
  ARITHM_PRELUDE

  if (0 == second) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter pleft_bracket = arg_begin;
  refalrts::Iter pdiv = pFunc;
  refalrts::Iter pright_bracket = pFirst;
  refalrts::Iter pmod = pSecond;
  refalrts::link_brackets(pleft_bracket, pright_bracket);

  refalrts::reinit_open_bracket(pleft_bracket);
  refalrts::reinit_number(pdiv, first / second);
  refalrts::reinit_close_bracket(pright_bracket);
  refalrts::update_number(pmod, first % second);
  refalrts::splice_to_freelist(arg_end, arg_end);

  return refalrts::cSuccess;
#line 3133 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Divmodm_Digits("Divmod-Digits", 877573369U, 332537286U, func_Divmodm_Digits);


static refalrts::FnResult func_Divmodm_Normed(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 17 elems
  refalrts::Iter context[17];
  refalrts::zeros( context, 17 );
  // </0 & Divmod-Normed/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Divmod-Normed/4 (/7 s.new#1/9 e.new#2/5 )/8 e.new#3/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#3 as range 2
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#2 as range 5
  do {
    // </0 & Divmod-Normed/4 (/7 s.new#4/9 e.new#5/5 )/8 s.new#6/12 e.new#7/10 >/1
    context[10] = context[2];
    context[11] = context[3];
    // closed e.new#5 as range 5
    if( ! refalrts::svar_left( context[12], context[10], context[11] ) )
      continue;
    // closed e.new#7 as range 10
    do {
      // </0 & Divmod-Normed/4 (/7 '+'/9 e.new#8/5 )/8 s.new#9/12 e.new#10/10 >/1
      if( ! refalrts::char_term( '+', context[9] ) )
        continue;
      // closed e.new#8 as range 5
      // closed e.new#10 as range 10
      do {
        // </0 & Divmod-Normed/4 (/7 '+'/9 e.First#1/5 )/8 '+'/12 e.Second#1/10 >/1
        if( ! refalrts::char_term( '+', context[12] ) )
          continue;
        // closed e.First#1 as range 5
        // closed e.Second#1 as range 10
        //DEBUG: e.First#1: 5
        //DEBUG: e.Second#1: 10

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 Reuse: & Divmod-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/5 } Tile{ HalfReuse: )/9 } Tile{ AsIs: e.Second#1/10 } (/13 Tile{ AsIs: )/8 HalfReuse: (/12 } )/14 Tile{ AsIs: >/1 ]] }
        if( ! refalrts::alloc_open_bracket( context[13] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_bracket( context[14] ) )
          return refalrts::cNoMemory;
        refalrts::update_name( context[4], ref_Divmodm_Nat.ref.function );
        refalrts::reinit_close_bracket( context[9] );
        refalrts::reinit_open_bracket( context[12] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[0] );
        refalrts::link_brackets( context[12], context[14] );
        refalrts::link_brackets( context[13], context[8] );
        refalrts::link_brackets( context[7], context[9] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[1];
        res = refalrts::splice_evar( res, context[14], context[14] );
        res = refalrts::splice_evar( res, context[8], context[12] );
        res = refalrts::splice_evar( res, context[13], context[13] );
        res = refalrts::splice_evar( res, context[10], context[11] );
        res = refalrts::splice_evar( res, context[9], context[9] );
        res = refalrts::splice_evar( res, context[5], context[6] );
        refalrts::use( res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      // </0 & Divmod-Normed/4 (/7 '+'/9 e.First#1/5 )/8 '-'/12 e.Second#1/10 >/1
      if( ! refalrts::char_term( '-', context[12] ) )
        continue;
      // closed e.First#1 as range 5
      // closed e.Second#1 as range 10
      //DEBUG: e.First#1: 5
      //DEBUG: e.Second#1: 10

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Divmod-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/5 } Tile{ HalfReuse: )/9 } Tile{ AsIs: e.Second#1/10 } Tile{ HalfReuse: (/8 AsIs: '-'/12 } )/13 (/14 )/15 Tile{ AsIs: >/1 ]] }
      if( ! refalrts::alloc_close_bracket( context[13] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[14] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[15] ) )
        return refalrts::cNoMemory;
      refalrts::update_name( context[4], ref_Divmodm_Nat.ref.function );
      refalrts::reinit_close_bracket( context[9] );
      refalrts::reinit_open_bracket( context[8] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[14], context[15] );
      refalrts::link_brackets( context[8], context[13] );
      refalrts::link_brackets( context[7], context[9] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[13], context[15] );
      res = refalrts::splice_evar( res, context[8], context[12] );
      res = refalrts::splice_evar( res, context[10], context[11] );
      res = refalrts::splice_evar( res, context[9], context[9] );
      res = refalrts::splice_evar( res, context[5], context[6] );
      refalrts::use( res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Divmod-Normed/4 (/7 '-'/9 e.new#8/5 )/8 s.new#9/12 e.new#10/10 >/1
    if( ! refalrts::char_term( '-', context[9] ) )
      continue;
    // closed e.new#8 as range 5
    // closed e.new#10 as range 10
    do {
      // </0 & Divmod-Normed/4 (/7 '-'/9 e.First#1/5 )/8 '+'/12 e.Second#1/10 >/1
      if( ! refalrts::char_term( '+', context[12] ) )
        continue;
      // closed e.First#1 as range 5
      // closed e.Second#1 as range 10
      //DEBUG: e.First#1: 5
      //DEBUG: e.Second#1: 10

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Divmod-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/5 } )/13 Tile{ AsIs: e.Second#1/10 } (/14 Tile{ AsIs: '-'/9 } Tile{ AsIs: )/8 HalfReuse: (/12 } '-'/15 )/16 Tile{ AsIs: >/1 ]] }
      if( ! refalrts::alloc_close_bracket( context[13] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[14] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_char( context[15], '-' ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[16] ) )
        return refalrts::cNoMemory;
      refalrts::update_name( context[4], ref_Divmodm_Nat.ref.function );
      refalrts::reinit_open_bracket( context[12] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[12], context[16] );
      refalrts::link_brackets( context[14], context[8] );
      refalrts::link_brackets( context[7], context[13] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[15], context[16] );
      res = refalrts::splice_evar( res, context[8], context[12] );
      res = refalrts::splice_evar( res, context[9], context[9] );
      res = refalrts::splice_evar( res, context[14], context[14] );
      res = refalrts::splice_evar( res, context[10], context[11] );
      res = refalrts::splice_evar( res, context[13], context[13] );
      res = refalrts::splice_evar( res, context[5], context[6] );
      refalrts::use( res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Divmod-Normed/4 (/7 '-'/9 e.First#1/5 )/8 '-'/12 e.Second#1/10 >/1
    if( ! refalrts::char_term( '-', context[12] ) )
      continue;
    // closed e.First#1 as range 5
    // closed e.Second#1 as range 10
    //DEBUG: e.First#1: 5
    //DEBUG: e.Second#1: 10

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Divmod-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/5 } )/13 Tile{ AsIs: e.Second#1/10 } (/14 Tile{ AsIs: )/8 HalfReuse: (/12 } Tile{ AsIs: '-'/9 } )/15 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_bracket( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[15] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Divmodm_Nat.ref.function );
    refalrts::reinit_open_bracket( context[12] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[12], context[15] );
    refalrts::link_brackets( context[14], context[8] );
    refalrts::link_brackets( context[7], context[13] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[9], context[9] );
    res = refalrts::splice_evar( res, context[8], context[12] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[10], context[11] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Divmod-Normed/4 (/7 0/9 )/8 e.AnySecond#1/2 >/1
  if( ! refalrts::number_term( 0UL, context[9] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.AnySecond#1 as range 2
  //DEBUG: e.AnySecond#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Divmod-Normed/4 {REMOVED TILE} e.AnySecond#1/2 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: 0/9 AsIs: )/8 } Tile{ HalfReuse: 0/1 ]] }
  refalrts::reinit_number( context[1], 0UL );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmodm_Normed("Divmod-Normed", 877573369U, 332537286U, func_Divmodm_Normed);


static refalrts::FnResult func_gen_Divmodm_Nat_S1A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  // </0 & Divmod-Nat$1=1/4 (/7 e.QuotSign#1/5 )/8 (/11 e.RemSing#1/9 )/12 (/15 s.Quot#2/17 )/16 s.Rem#2/18 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  context[13] = 0;
  context[14] = 0;
  context[15] = refalrts::brackets_left( context[13], context[14], context[2], context[3] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[15], context[16]);
  // closed e.QuotSign#1 as range 5
  // closed e.RemSing#1 as range 9
  if( ! refalrts::svar_left( context[17], context[13], context[14] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[13], context[14] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[18], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.QuotSign#1: 5
  //DEBUG: e.RemSing#1: 9
  //DEBUG: s.Quot#2: 17
  //DEBUG: s.Rem#2: 18

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Divmod-Nat$1=1/4 {REMOVED TILE} (/15 s.Quot#2/17 )/16 s.Rem#2/18 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.QuotSign#1/5 HalfReuse: s.Quot2 #17/8 HalfReuse: )/11 AsIs: e.RemSing#1/9 HalfReuse: s.Rem2 #18/12 } Tile{ ]] }
  refalrts::reinit_svar( context[8], context[17] );
  refalrts::reinit_close_bracket( context[11] );
  refalrts::reinit_svar( context[12], context[18] );
  refalrts::link_brackets( context[7], context[11] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[7], context[12] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Nat_S1A1("Divmod-Nat$1=1", 877573369U, 332537286U, func_gen_Divmodm_Nat_S1A1);


static refalrts::FnResult func_gen_Divmodm_Nat_S2A5(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 17 elems
  refalrts::Iter context[17];
  refalrts::zeros( context, 17 );
  // </0 & Divmod-Nat$2=5/4 (/7 e.QuotSign#1/5 )/8 (/11 e.Quot#5/9 )/12 (/15 e.RemSing#1/13 )/16 e.Rem#6/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  context[13] = 0;
  context[14] = 0;
  context[15] = refalrts::brackets_left( context[13], context[14], context[2], context[3] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[15], context[16]);
  // closed e.QuotSign#1 as range 5
  // closed e.Quot#5 as range 9
  // closed e.RemSing#1 as range 13
  // closed e.Rem#6 as range 2
  //DEBUG: e.QuotSign#1: 5
  //DEBUG: e.Quot#5: 9
  //DEBUG: e.RemSing#1: 13
  //DEBUG: e.Rem#6: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & Divmod-Nat$2=5/4 (/7 {REMOVED TILE} )/8 (/11 {REMOVED TILE} )/12 (/15 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: (/0 } Tile{ AsIs: e.QuotSign#1/5 } Tile{ AsIs: e.Quot#5/9 } Tile{ AsIs: )/16 } Tile{ AsIs: e.RemSing#1/13 } Tile{ AsIs: e.Rem#6/2 } Tile{ ]] }
  refalrts::reinit_open_bracket( context[0] );
  refalrts::link_brackets( context[0], context[16] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[16], context[16] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Nat_S2A5("Divmod-Nat$2=5", 877573369U, 332537286U, func_gen_Divmodm_Nat_S2A5);


static refalrts::FnResult func_gen_Divmodm_Nat_S2A5B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  // </0 & Divmod-Nat$2=5:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Divmod-Nat$2=5:1/4 e.new#1/2 0/5 >/1
  context[5] = refalrts::number_right( 0UL, context[2], context[3] );
  if( ! context[5] )
    return refalrts::cRecognitionImpossible;
  // closed e.new#1 as range 2
  do {
    // </0 & Divmod-Nat$2=5:1/4 0/5 >/1
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Divmod-Nat$2=5:1/4 0/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
    refalrts::reinit_number( context[1], 0UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Divmod-Nat$2=5:1/4 e.Rem#6/2 0/5 >/1
  // closed e.Rem#6 as range 2
  //DEBUG: e.Rem#6: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Divmod-Nat$2=5:1/4 {REMOVED TILE} 0/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.Rem#6/2 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Nat_S2A5B1("Divmod-Nat$2=5:1", 877573369U, 332537286U, func_gen_Divmodm_Nat_S2A5B1);


static refalrts::FnResult func_gen_Divmodm_Nat_S2A4(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 27 elems
  refalrts::Iter context[27];
  refalrts::zeros( context, 27 );
  // </0 & Divmod-Nat$2=4/4 (/7 e.QuotSign#1/5 )/8 (/11 e.RemSing#1/9 )/12 s.RestoreShift#2/13 (/16 e.Quot#5/14 )/17 e.Rem#5/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.QuotSign#1 as range 5
  // closed e.RemSing#1 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[14] = 0;
  context[15] = 0;
  context[16] = refalrts::brackets_left( context[14], context[15], context[2], context[3] );
  if( ! context[16] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[16], context[17]);
  // closed e.Quot#5 as range 14
  // closed e.Rem#5 as range 2
  //DEBUG: e.QuotSign#1: 5
  //DEBUG: e.RemSing#1: 9
  //DEBUG: s.RestoreShift#2: 13
  //DEBUG: e.Quot#5: 14
  //DEBUG: e.Rem#5: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.RestoreShift#2/13 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </18 Tile{ HalfReuse: [*]/0 Reuse: & Divmod-Nat$2=5/4 AsIs: (/7 AsIs: e.QuotSign#1/5 AsIs: )/8 AsIs: (/11 } Tile{ AsIs: e.Quot#5/14 } Tile{ AsIs: )/12 } Tile{ AsIs: (/16 } Tile{ AsIs: e.RemSing#1/9 } )/19 {*}/20 </21 & Divmod-Nat$2=5:1/22 </23 & Divmod-Shl/24 Tile{ HalfReuse: s.RestoreShift2 #13/17 AsIs: e.Rem#5/2 AsIs: >/1 } >/25 >/26 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[20], context[0] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[22], ref_gen_Divmodm_Nat_S2A5B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[23] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[24], ref_Divmodm_Shl.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[25] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[26] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[0] );
  refalrts::update_name( context[4], ref_gen_Divmodm_Nat_S2A5.ref.function );
  refalrts::reinit_svar( context[17], context[13] );
  refalrts::push_stack( context[26] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[25] );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[23] );
  refalrts::link_brackets( context[16], context[19] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[25], context[26] );
  res = refalrts::splice_evar( res, context[17], context[1] );
  res = refalrts::splice_evar( res, context[19], context[24] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[16], context[16] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[0], context[11] );
  res = refalrts::splice_evar( res, context[18], context[18] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  refalrts::wrap_closure( context[20] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Nat_S2A4("Divmod-Nat$2=4", 877573369U, 332537286U, func_gen_Divmodm_Nat_S2A4);


static refalrts::FnResult func_gen_Divmodm_Nat_S2A3(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 23 elems
  refalrts::Iter context[23];
  refalrts::zeros( context, 23 );
  // </0 & Divmod-Nat$2=3/4 (/7 e.QuotSign#1/5 )/8 (/11 e.RemSing#1/9 )/12 s.RestoreShift#2/13 (/16 e.Numerator#3/14 )/17 e.Denominator#4/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.QuotSign#1 as range 5
  // closed e.RemSing#1 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[14] = 0;
  context[15] = 0;
  context[16] = refalrts::brackets_left( context[14], context[15], context[2], context[3] );
  if( ! context[16] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[16], context[17]);
  // closed e.Numerator#3 as range 14
  // closed e.Denominator#4 as range 2
  //DEBUG: e.QuotSign#1: 5
  //DEBUG: e.RemSing#1: 9
  //DEBUG: s.RestoreShift#2: 13
  //DEBUG: e.Numerator#3: 14
  //DEBUG: e.Denominator#4: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </18 Tile{ HalfReuse: [*]/0 Reuse: & Divmod-Nat$2=4/4 AsIs: (/7 AsIs: e.QuotSign#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.RemSing#1/9 AsIs: )/12 AsIs: s.RestoreShift#2/13 HalfReuse: {*}/16 } </19 & Divmod-Nat-Normed/20 (/21 Tile{ AsIs: e.Numerator#3/14 } Tile{ AsIs: )/17 AsIs: e.Denominator#4/2 AsIs: >/1 } >/22 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[20], ref_Divmodm_Natm_Normed.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[22] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[0] );
  refalrts::update_name( context[4], ref_gen_Divmodm_Nat_S2A4.ref.function );
  refalrts::reinit_unwrapped_closure( context[16], context[0] );
  refalrts::push_stack( context[22] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[19] );
  refalrts::link_brackets( context[21], context[17] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[22], context[22] );
  res = refalrts::splice_evar( res, context[17], context[1] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[19], context[21] );
  res = refalrts::splice_evar( res, context[0], context[16] );
  res = refalrts::splice_evar( res, context[18], context[18] );
  refalrts::use( res );
  refalrts::wrap_closure( context[16] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Nat_S2A3("Divmod-Nat$2=3", 877573369U, 332537286U, func_gen_Divmodm_Nat_S2A3);


static refalrts::FnResult func_gen_Divmodm_Nat_S2A2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 25 elems
  refalrts::Iter context[25];
  refalrts::zeros( context, 25 );
  // </0 & Divmod-Nat$2=2/4 (/7 e.QuotSign#1/5 )/8 (/11 e.RemSing#1/9 )/12 s.RestoreShift#2/13 s.NormShift#2/14 s.DenomFirst#1/15 (/18 e.Denominator#1/16 )/19 e.Numerator#3/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.QuotSign#1 as range 5
  // closed e.RemSing#1 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[14], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[15], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[16] = 0;
  context[17] = 0;
  context[18] = refalrts::brackets_left( context[16], context[17], context[2], context[3] );
  if( ! context[18] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[18], context[19]);
  // closed e.Denominator#1 as range 16
  // closed e.Numerator#3 as range 2
  //DEBUG: e.QuotSign#1: 5
  //DEBUG: e.RemSing#1: 9
  //DEBUG: s.RestoreShift#2: 13
  //DEBUG: s.NormShift#2: 14
  //DEBUG: s.DenomFirst#1: 15
  //DEBUG: e.Denominator#1: 16
  //DEBUG: e.Numerator#3: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </20 Tile{ HalfReuse: [*]/0 Reuse: & Divmod-Nat$2=3/4 AsIs: (/7 AsIs: e.QuotSign#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.RemSing#1/9 AsIs: )/12 AsIs: s.RestoreShift#2/13 } Tile{ AsIs: (/18 } Tile{ AsIs: e.Numerator#3/2 } Tile{ AsIs: )/19 } {*}/21 </22 & Divmod-Shl/23 Tile{ AsIs: s.NormShift#2/14 AsIs: s.DenomFirst#1/15 } Tile{ AsIs: e.Denominator#1/16 } >/24 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[21], context[0] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[23], ref_Divmodm_Shl.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[24] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[0] );
  refalrts::update_name( context[4], ref_gen_Divmodm_Nat_S2A3.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[22] );
  refalrts::link_brackets( context[18], context[19] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[24], context[24] );
  res = refalrts::splice_evar( res, context[16], context[17] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[21], context[23] );
  res = refalrts::splice_evar( res, context[19], context[19] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[18], context[18] );
  res = refalrts::splice_evar( res, context[0], context[13] );
  res = refalrts::splice_evar( res, context[20], context[20] );
  refalrts::use( res );
  refalrts::wrap_closure( context[21] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Nat_S2A2("Divmod-Nat$2=2", 877573369U, 332537286U, func_gen_Divmodm_Nat_S2A2);


static refalrts::FnResult func_gen_Divmodm_Nat_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 28 elems
  refalrts::Iter context[28];
  refalrts::zeros( context, 28 );
  // </0 & Divmod-Nat$2=1/4 (/7 e.QuotSign#1/5 )/8 (/11 e.RemSing#1/9 )/12 s.DenomFirst#1/13 (/16 e.Denominator#1/14 )/17 (/20 e.Numerator#1/18 )/21 s.NormShift#2/22 s.RestoreShift#2/23 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.QuotSign#1 as range 5
  // closed e.RemSing#1 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[14] = 0;
  context[15] = 0;
  context[16] = refalrts::brackets_left( context[14], context[15], context[2], context[3] );
  if( ! context[16] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[16], context[17]);
  context[18] = 0;
  context[19] = 0;
  context[20] = refalrts::brackets_left( context[18], context[19], context[2], context[3] );
  if( ! context[20] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[20], context[21]);
  // closed e.Denominator#1 as range 14
  // closed e.Numerator#1 as range 18
  if( ! refalrts::svar_left( context[22], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[23], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.QuotSign#1: 5
  //DEBUG: e.RemSing#1: 9
  //DEBUG: s.DenomFirst#1: 13
  //DEBUG: e.Denominator#1: 14
  //DEBUG: e.Numerator#1: 18
  //DEBUG: s.NormShift#2: 22
  //DEBUG: s.RestoreShift#2: 23

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </24 Tile{ HalfReuse: [*]/0 Reuse: & Divmod-Nat$2=2/4 AsIs: (/7 AsIs: e.QuotSign#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.RemSing#1/9 AsIs: )/12 } Tile{ AsIs: s.RestoreShift#2/23 } s.NormShift#2/22/25 Tile{ AsIs: s.DenomFirst#1/13 AsIs: (/16 AsIs: e.Denominator#1/14 AsIs: )/17 HalfReuse: {*}/20 } </26 Tile{ HalfReuse: & Divmod-Shl/21 AsIs: s.NormShift#2/22 } Tile{ AsIs: e.Numerator#1/18 } >/27 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[24] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[25], context[22]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[26] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[27] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[0] );
  refalrts::update_name( context[4], ref_gen_Divmodm_Nat_S2A2.ref.function );
  refalrts::reinit_unwrapped_closure( context[20], context[0] );
  refalrts::reinit_name( context[21], ref_Divmodm_Shl.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[27] );
  refalrts::push_stack( context[26] );
  refalrts::link_brackets( context[16], context[17] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[27], context[27] );
  res = refalrts::splice_evar( res, context[18], context[19] );
  res = refalrts::splice_evar( res, context[21], context[22] );
  res = refalrts::splice_evar( res, context[26], context[26] );
  res = refalrts::splice_evar( res, context[13], context[20] );
  res = refalrts::splice_evar( res, context[25], context[25] );
  res = refalrts::splice_evar( res, context[23], context[23] );
  res = refalrts::splice_evar( res, context[0], context[12] );
  res = refalrts::splice_evar( res, context[24], context[24] );
  refalrts::use( res );
  refalrts::wrap_closure( context[20] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Nat_S2A1("Divmod-Nat$2=1", 877573369U, 332537286U, func_gen_Divmodm_Nat_S2A1);


static refalrts::FnResult func_gen_Divmodm_Nat_S2A1B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 480 "Library.sref"
        refalrts::Iter pfunc = arg_begin->next;
        assert(refalrts::cDataFunction == pfunc->tag);

        refalrts::Iter pvalue = pfunc->next;
        assert(refalrts::cDataNumber == pvalue->tag);

        refalrts::RefalNumber value = pvalue->number_info;
        assert(value != 0);

        int shift = 0;
        while ((value & (1 << 31)) == 0) {
          ++shift;
          value <<= 1;
        }

        refalrts::reinit_number(arg_begin, shift);
        refalrts::reinit_number(pfunc, 32 - shift);
        refalrts::splice_to_freelist(pvalue, arg_end);
        return refalrts::cSuccess;
#line 3916 "Library.cpp"
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Nat_S2A1B1("Divmod-Nat$2=1:1", 877573369U, 332537286U, func_gen_Divmodm_Nat_S2A1B1);


static refalrts::FnResult func_Divmodm_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 26 elems
  refalrts::Iter context[26];
  refalrts::zeros( context, 26 );
  // </0 & Divmod-Nat/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Divmod-Nat/4 (/7 e.new#1/5 )/8 s.new#2/17 e.new#3/2 (/15 e.new#4/13 )/16 (/11 e.new#5/9 )/12 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_right( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  context[13] = 0;
  context[14] = 0;
  context[15] = refalrts::brackets_right( context[13], context[14], context[2], context[3] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[15], context[16]);
  // closed e.new#1 as range 5
  // closed e.new#4 as range 13
  // closed e.new#5 as range 9
  if( ! refalrts::svar_left( context[17], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#3 as range 2
  do {
    // </0 & Divmod-Nat/4 (/7 s.Numerator#1/20 )/8 s.Denominator#1/17 (/15 e.QuotSign#1/13 )/16 (/11 e.RemSing#1/9 )/12 >/1
    context[18] = context[5];
    context[19] = context[6];
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    // closed e.QuotSign#1 as range 13
    // closed e.RemSing#1 as range 9
    if( ! refalrts::svar_left( context[20], context[18], context[19] ) )
      continue;
    if( ! refalrts::empty_seq( context[18], context[19] ) )
      continue;
    //DEBUG: s.Denominator#1: 17
    //DEBUG: e.QuotSign#1: 13
    //DEBUG: e.RemSing#1: 9
    //DEBUG: s.Numerator#1: 20

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.Numerator#1/20 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 HalfReuse: [*]/4 HalfReuse: & Divmod-Nat$1=1/7 } Tile{ AsIs: (/15 AsIs: e.QuotSign#1/13 AsIs: )/16 AsIs: (/11 AsIs: e.RemSing#1/9 AsIs: )/12 HalfReuse: {*}/1 } </21 & Divmod-Digits/22 Tile{ HalfReuse: s.Numerator1 #20/8 AsIs: s.Denominator#1/17 } >/23 >/24 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[22], ref_Divmodm_Digits.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[24] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_closure_head( context[4] );
    refalrts::reinit_name( context[7], ref_gen_Divmodm_Nat_S1A1.ref.function );
    refalrts::reinit_unwrapped_closure( context[1], context[4] );
    refalrts::reinit_svar( context[8], context[20] );
    refalrts::push_stack( context[24] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[23] );
    refalrts::push_stack( context[21] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::link_brackets( context[15], context[16] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[23], context[24] );
    res = refalrts::splice_evar( res, context[8], context[17] );
    res = refalrts::splice_evar( res, context[21], context[22] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    refalrts::splice_to_freelist_open( context[7], res );
    refalrts::wrap_closure( context[1] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Divmod-Nat/4 (/7 e.Numerator#1/5 )/8 s.DenomFirst#1/17 e.Denominator#1/2 (/15 e.QuotSign#1/13 )/16 (/11 e.RemSing#1/9 )/12 >/1
  // closed e.Numerator#1 as range 5
  // closed e.Denominator#1 as range 2
  // closed e.QuotSign#1 as range 13
  // closed e.RemSing#1 as range 9
  //DEBUG: s.DenomFirst#1: 17
  //DEBUG: e.Numerator#1: 5
  //DEBUG: e.Denominator#1: 2
  //DEBUG: e.QuotSign#1: 13
  //DEBUG: e.RemSing#1: 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 } [*]/18 & Divmod-Nat$2=1/19 Tile{ AsIs: (/15 AsIs: e.QuotSign#1/13 AsIs: )/16 AsIs: (/11 AsIs: e.RemSing#1/9 AsIs: )/12 HalfReuse: s.DenomFirst1 #17/1 } (/20 Tile{ AsIs: e.Denominator#1/2 } Tile{ HalfReuse: )/4 AsIs: (/7 AsIs: e.Numerator#1/5 AsIs: )/8 } {*}/21 </22 & Divmod-Nat$2=1:1/23 Tile{ AsIs: s.DenomFirst#1/17 } >/24 >/25 Tile{ ]] }
  if( ! refalrts::alloc_closure_head( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], ref_gen_Divmodm_Nat_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[21], context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[23], ref_gen_Divmodm_Nat_S2A1B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[24] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[25] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_svar( context[1], context[17] );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::push_stack( context[25] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[22] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::link_brackets( context[20], context[4] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[15], context[16] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[24], context[25] );
  res = refalrts::splice_evar( res, context[17], context[17] );
  res = refalrts::splice_evar( res, context[21], context[23] );
  res = refalrts::splice_evar( res, context[4], context[8] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[20], context[20] );
  res = refalrts::splice_evar( res, context[15], context[1] );
  res = refalrts::splice_evar( res, context[18], context[19] );
  refalrts::use( res );
  refalrts::wrap_closure( context[21] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmodm_Nat("Divmod-Nat", 877573369U, 332537286U, func_Divmodm_Nat);


static refalrts::FnResult func_Divmodm_Shl(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 516 "Library.sref"
  refalrts::Iter digits_b = 0, digits_e = 0;
  refalrts::call_left(digits_b, digits_e, arg_begin, arg_end);

  refalrts::Iter pshift;
  if (
    ! refalrts::svar_left(pshift, digits_b, digits_e)
    && refalrts::cDataNumber != pshift->tag
    && refalrts::empty_seq(digits_b, digits_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber shift = pshift->number_info;
  if (shift > 32) {
    return refalrts::cRecognitionImpossible;
  }

  if (0 == shift) {
    refalrts::splice_to_freelist(arg_begin, pshift);
    refalrts::splice_to_freelist(arg_end, arg_end);
    return refalrts::cSuccess;
  }

  refalrts::Iter garbage_end = pshift;
  refalrts::reinit_number(arg_end, 0);
  if (shift < 32) {
    refalrts::Iter current = digits_e;
    while (current != pshift) {
      current->next->number_info |= current->number_info << shift;
      current->number_info >>= 32 - shift;
      current = current->prev;
    }

    if (0 == digits_b->number_info) {
      garbage_end = digits_b;
    }
  }

  refalrts::splice_to_freelist(arg_begin, garbage_end);
  return refalrts::cSuccess;
#line 4111 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Divmodm_Shl("Divmod-Shl", 877573369U, 332537286U, func_Divmodm_Shl);


static refalrts::FnResult func_Divmodm_Natm_Normed(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  // </0 & Divmod-Nat-Normed/4 (/7 e.Numerator#1/5 )/8 e.Denominator#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Numerator#1 as range 5
  // closed e.Denominator#1 as range 2
  //DEBUG: e.Numerator#1: 5
  //DEBUG: e.Denominator#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Divmod-Align/4 AsIs: (/7 } 0/9 )/10 (/11 Tile{ AsIs: e.Numerator#1/5 } )/12 (/13 Tile{ AsIs: )/8 AsIs: e.Denominator#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_number( context[9], 0UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Divmodm_Align.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[13], context[8] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[8];
  res = refalrts::splice_evar( res, context[12], context[13] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[9], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmodm_Natm_Normed("Divmod-Nat-Normed", 877573369U, 332537286U, func_Divmodm_Natm_Normed);


static refalrts::FnResult func_gen_Divmodm_Align_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Divmod-Align$2=1/4 e.Quot#2/2 (/7 e.Rest#2/5 )/8 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_right( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Quot#2 as range 2
  // closed e.Rest#2 as range 5
  //DEBUG: e.Quot#2: 2
  //DEBUG: e.Rest#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: (/1 } Tile{ AsIs: </0 Reuse: & LeadingZeros/4 AsIs: e.Quot#2/2 HalfReuse: >/7 } Tile{ AsIs: )/8 } Tile{ AsIs: e.Rest#2/5 } Tile{ ]] }
  refalrts::reinit_open_bracket( context[1] );
  refalrts::update_name( context[4], ref_LeadingZeros.ref.function );
  refalrts::reinit_close_call( context[7] );
  refalrts::link_brackets( context[1], context[8] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[8], context[8] );
  res = refalrts::splice_evar( res, context[0], context[7] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_Align_S2A1("Divmod-Align$2=1", 877573369U, 332537286U, func_gen_Divmodm_Align_S2A1);


static refalrts::FnResult func_Divmodm_Align(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 25 elems
  refalrts::Iter context[25];
  refalrts::zeros( context, 25 );
  // </0 & Divmod-Align/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Divmod-Align/4 (/7 e.new#1/5 )/8 (/11 e.new#2/9 )/12 (/15 e.new#3/13 )/16 e.new#4/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  context[13] = 0;
  context[14] = 0;
  context[15] = refalrts::brackets_left( context[13], context[14], context[2], context[3] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[15], context[16]);
  // closed e.new#1 as range 5
  // closed e.new#2 as range 9
  // closed e.new#3 as range 13
  // closed e.new#4 as range 2
  do {
    // </0 & Divmod-Align/4 (/7 e.Numerator#1/5 )/8 (/11 s.N#1/21 e.NumerRest#1/17 )/12 (/15 e.Denominator#1/13 )/16 s.D#1/22 e.DenominRest#1/19 >/1
    context[17] = context[9];
    context[18] = context[10];
    context[19] = context[2];
    context[20] = context[3];
    // closed e.Numerator#1 as range 5
    // closed e.Denominator#1 as range 13
    if( ! refalrts::svar_left( context[21], context[17], context[18] ) )
      continue;
    // closed e.NumerRest#1 as range 17
    if( ! refalrts::svar_left( context[22], context[19], context[20] ) )
      continue;
    // closed e.DenominRest#1 as range 19
    //DEBUG: e.Numerator#1: 5
    //DEBUG: e.Denominator#1: 13
    //DEBUG: s.N#1: 21
    //DEBUG: e.NumerRest#1: 17
    //DEBUG: s.D#1: 22
    //DEBUG: e.DenominRest#1: 19

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.N#1/21 {REMOVED TILE} {REMOVED TILE} s.D#1/22 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & Divmod-Align/4 AsIs: (/7 AsIs: e.Numerator#1/5 HalfReuse: s.N1 #21/8 HalfReuse: )/11 } (/23 Tile{ AsIs: e.NumerRest#1/17 } Tile{ AsIs: )/12 AsIs: (/15 AsIs: e.Denominator#1/13 HalfReuse: s.D1 #22/16 } )/24 Tile{ AsIs: e.DenominRest#1/19 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_bracket( context[23] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[24] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_svar( context[8], context[21] );
    refalrts::reinit_close_bracket( context[11] );
    refalrts::reinit_svar( context[16], context[22] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[15], context[24] );
    refalrts::link_brackets( context[23], context[12] );
    refalrts::link_brackets( context[7], context[11] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[24], context[24] );
    res = refalrts::splice_evar( res, context[12], context[16] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[23], context[23] );
    refalrts::splice_to_freelist_open( context[11], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Divmod-Align/4 (/7 e.Numerator#1/5 )/8 (/11 e.NumerRest#1/9 )/12 (/15 e.Denominator#1/13 )/16 >/1
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    // closed e.Numerator#1 as range 5
    // closed e.NumerRest#1 as range 9
    // closed e.Denominator#1 as range 13
    //DEBUG: e.Numerator#1: 5
    //DEBUG: e.NumerRest#1: 9
    //DEBUG: e.Denominator#1: 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: </15 } & Divmod-Align$2=1/17 Tile{ AsIs: </0 Reuse: & Divmod-CalcDigits/4 AsIs: (/7 AsIs: e.Numerator#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.NumerRest#1/9 AsIs: )/12 } Tile{ AsIs: e.Denominator#1/13 } Tile{ HalfReuse: >/16 AsIs: >/1 ]] }
    if( ! refalrts::alloc_name( context[17], ref_gen_Divmodm_Align_S2A1.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[15] );
    refalrts::update_name( context[4], ref_Divmodm_CalcDigits.ref.function );
    refalrts::reinit_close_call( context[16] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[16];
    res = refalrts::splice_evar( res, context[13], context[14] );
    res = refalrts::splice_evar( res, context[0], context[12] );
    res = refalrts::splice_evar( res, context[17], context[17] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Divmod-Align/4 (/7 0/17 e.Numerator#1/5 )/8 (/11 )/12 (/15 e.Denominator#1/13 )/16 e.DenominRest#1/2 >/1
  context[17] = refalrts::number_left( 0UL, context[5], context[6] );
  if( ! context[17] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[9], context[10] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Numerator#1 as range 5
  // closed e.Denominator#1 as range 13
  // closed e.DenominRest#1 as range 2
  //DEBUG: e.Numerator#1: 5
  //DEBUG: e.Denominator#1: 13
  //DEBUG: e.DenominRest#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Divmod-Align/4 {REMOVED TILE} {REMOVED TILE} )/8 (/11 )/12 (/15 e.Denominator#1/13 {REMOVED TILE} e.DenominRest#1/2 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: 0/17 } Tile{ AsIs: )/16 } Tile{ AsIs: e.Numerator#1/5 } Tile{ ]] }
  refalrts::link_brackets( context[7], context[16] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[16], context[16] );
  res = refalrts::splice_evar( res, context[7], context[17] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmodm_Align("Divmod-Align", 877573369U, 332537286U, func_Divmodm_Align);


static refalrts::FnResult func_gen_Divmodm_CalcDigits_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  // </0 & Divmod-CalcDigits:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Divmod-CalcDigits:1/4 s.new#1/5 (/8 e.new#2/6 )/9 (/12 e.new#3/10 )/13 e.new#4/2 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  context[10] = 0;
  context[11] = 0;
  context[12] = refalrts::brackets_left( context[10], context[11], context[2], context[3] );
  if( ! context[12] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[12], context[13]);
  // closed e.new#2 as range 6
  // closed e.new#3 as range 10
  // closed e.new#4 as range 2
  do {
    // </0 & Divmod-CalcDigits:1/4 s.QuotDigit#2/5 (/8 e.Rem#2/6 )/9 (/12 e.Denominator#1/10 )/13 s.NextDigit#3/16 e.NumerRest#3/14 >/1
    context[14] = context[2];
    context[15] = context[3];
    // closed e.Rem#2 as range 6
    // closed e.Denominator#1 as range 10
    if( ! refalrts::svar_left( context[16], context[14], context[15] ) )
      continue;
    // closed e.NumerRest#3 as range 14
    //DEBUG: s.QuotDigit#2: 5
    //DEBUG: e.Rem#2: 6
    //DEBUG: e.Denominator#1: 10
    //DEBUG: s.NextDigit#3: 16
    //DEBUG: e.NumerRest#3: 14

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.QuotDigit#2/5 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.NextDigit#3/16 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: s.QuotDigit2 #5/0 HalfReuse: </4 } & Divmod-CalcDigits/17 Tile{ AsIs: (/8 AsIs: e.Rem#2/6 HalfReuse: s.NextDigit3 #16/9 HalfReuse: )/12 } (/18 Tile{ AsIs: e.NumerRest#3/14 } Tile{ AsIs: )/13 } Tile{ AsIs: e.Denominator#1/10 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_name( context[17], ref_Divmodm_CalcDigits.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_svar( context[0], context[5] );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_svar( context[9], context[16] );
    refalrts::reinit_close_bracket( context[12] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[18], context[13] );
    refalrts::link_brackets( context[8], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[10], context[11] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[8], context[12] );
    res = refalrts::splice_evar( res, context[17], context[17] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Divmod-CalcDigits:1/4 s.QuotDigit#2/5 (/8 e.Rem#2/6 )/9 (/12 e.Denominator#1/10 )/13 >/1
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Rem#2 as range 6
  // closed e.Denominator#1 as range 10
  //DEBUG: s.QuotDigit#2: 5
  //DEBUG: e.Rem#2: 6
  //DEBUG: e.Denominator#1: 10

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Divmod-CalcDigits:1/4 {REMOVED TILE} (/12 e.Denominator#1/10 )/13 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: s.QuotDigit#2/5 AsIs: (/8 AsIs: e.Rem#2/6 AsIs: )/9 } Tile{ ]] }
  refalrts::link_brackets( context[8], context[9] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[9] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_CalcDigits_B1("Divmod-CalcDigits:1", 877573369U, 332537286U, func_gen_Divmodm_CalcDigits_B1);


static refalrts::FnResult func_gen_Divmodm_CalcDigits_A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  // </0 & Divmod-CalcDigits=1/4 (/7 e.Denominator#1/5 )/8 (/11 e.NumerRest#1/9 )/12 s.QuotDigit#2/13 e.Rem#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.Denominator#1 as range 5
  // closed e.NumerRest#1 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Rem#2 as range 2
  //DEBUG: e.Denominator#1: 5
  //DEBUG: e.NumerRest#1: 9
  //DEBUG: s.QuotDigit#2: 13
  //DEBUG: e.Rem#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 } [*]/14 Tile{ HalfReuse: & Divmod-CalcDigits:1/1 } Tile{ AsIs: s.QuotDigit#2/13 } (/15 Tile{ AsIs: e.Rem#2/2 } Tile{ HalfReuse: )/4 AsIs: (/7 AsIs: e.Denominator#1/5 AsIs: )/8 HalfReuse: {*}/11 AsIs: e.NumerRest#1/9 HalfReuse: >/12 } Tile{ ]] }
  if( ! refalrts::alloc_closure_head( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[15] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[1], ref_gen_Divmodm_CalcDigits_B1.ref.function );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::reinit_unwrapped_closure( context[11], context[14] );
  refalrts::reinit_close_call( context[12] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::link_brackets( context[15], context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[4], context[12] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[15], context[15] );
  res = refalrts::splice_evar( res, context[13], context[13] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[14], context[14] );
  refalrts::use( res );
  refalrts::wrap_closure( context[11] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_CalcDigits_A1("Divmod-CalcDigits=1", 877573369U, 332537286U, func_gen_Divmodm_CalcDigits_A1);


static refalrts::FnResult func_Divmodm_CalcDigits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 22 elems
  refalrts::Iter context[22];
  refalrts::zeros( context, 22 );
  // </0 & Divmod-CalcDigits/4 (/7 e.Numerator#1/5 )/8 (/11 e.NumerRest#1/9 )/12 e.Denominator#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.Numerator#1 as range 5
  // closed e.NumerRest#1 as range 9
  // closed e.Denominator#1 as range 2
  //DEBUG: e.Numerator#1: 5
  //DEBUG: e.NumerRest#1: 9
  //DEBUG: e.Denominator#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </13 [*]/14 & Divmod-CalcDigits=1/15 (/16 e.Denominator#1/2/17 )/19 Tile{ AsIs: (/11 AsIs: e.NumerRest#1/9 AsIs: )/12 } {*}/20 Tile{ AsIs: </0 Reuse: & Divmod-GetNextDigit/4 AsIs: (/7 AsIs: e.Numerator#1/5 AsIs: )/8 } Tile{ AsIs: e.Denominator#1/2 } >/21 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_closure_head( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[15], ref_gen_Divmodm_CalcDigits_A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[17], context[18], context[2], context[3]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[20], context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[21] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Divmodm_GetNextDigit.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[16], context[19] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[21], context[21] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[0], context[8] );
  res = refalrts::splice_evar( res, context[20], context[20] );
  res = refalrts::splice_evar( res, context[11], context[12] );
  res = refalrts::splice_evar( res, context[13], context[19] );
  refalrts::use( res );
  refalrts::wrap_closure( context[20] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmodm_CalcDigits("Divmod-CalcDigits", 877573369U, 332537286U, func_Divmodm_CalcDigits);


static refalrts::FnResult func_gen_Divmodm_GetNextDigit_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 33 elems
  refalrts::Iter context[33];
  refalrts::zeros( context, 33 );
  // </0 & Divmod-GetNextDigit$2=1/4 s.N1#1/5 s.N2#1/6 (/9 e.Numerator#1/7 )/10 s.D#1/11 (/14 e.Denominator#1/12 )/15 s.QuotDigit#2/16 s.RemDigit#2/17 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[7] = 0;
  context[8] = 0;
  context[9] = refalrts::brackets_left( context[7], context[8], context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[9], context[10]);
  // closed e.Numerator#1 as range 7
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[12] = 0;
  context[13] = 0;
  context[14] = refalrts::brackets_left( context[12], context[13], context[2], context[3] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[14], context[15]);
  // closed e.Denominator#1 as range 12
  if( ! refalrts::svar_left( context[16], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[17], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.N1#1: 5
  //DEBUG: s.N2#1: 6
  //DEBUG: e.Numerator#1: 7
  //DEBUG: s.D#1: 11
  //DEBUG: e.Denominator#1: 12
  //DEBUG: s.QuotDigit#2: 16
  //DEBUG: s.RemDigit#2: 17

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.RemDigit#2/17 {REMOVED TILE}
  //RESULT: Tile{ [[ } </18 & Divmod-AdjustDigit/19 s.QuotDigit#2/16/20 </21 & Sub-Normed/22 Tile{ AsIs: (/9 } '+'/23 Tile{ AsIs: </0 Reuse: & LeadingZeros/4 AsIs: s.N1#1/5 AsIs: s.N2#1/6 } Tile{ AsIs: e.Numerator#1/7 } >/24 )/25 '+'/26 </27 Tile{ HalfReuse: & Mul-Nat-Line/10 AsIs: s.D#1/11 } e.Denominator#1/12/28 Tile{ AsIs: s.QuotDigit#2/16 } >/30 >/31 (/32 Tile{ HalfReuse: s.D1 #11/14 AsIs: e.Denominator#1/12 AsIs: )/15 } Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], ref_Divmodm_AdjustDigit.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[20], context[16]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[22], ref_Subm_Normed.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[23], '+' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[24] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[25] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[26], '+' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[27] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[28], context[29], context[12], context[13]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[30] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[31] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[32] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_LeadingZeros.ref.function );
  refalrts::reinit_name( context[10], ref_Mulm_Natm_Line.ref.function );
  refalrts::reinit_svar( context[14], context[11] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[18] );
  refalrts::link_brackets( context[32], context[15] );
  refalrts::push_stack( context[31] );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[30] );
  refalrts::push_stack( context[27] );
  refalrts::link_brackets( context[9], context[25] );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[30], context[32] );
  res = refalrts::splice_evar( res, context[16], context[16] );
  res = refalrts::splice_evar( res, context[28], context[29] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  res = refalrts::splice_evar( res, context[24], context[27] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  res = refalrts::splice_evar( res, context[0], context[6] );
  res = refalrts::splice_evar( res, context[23], context[23] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[18], context[22] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Divmodm_GetNextDigit_S2A1("Divmod-GetNextDigit$2=1", 877573369U, 332537286U, func_gen_Divmodm_GetNextDigit_S2A1);


static refalrts::FnResult func_Divmodm_GetNextDigit(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 22 elems
  refalrts::Iter context[22];
  refalrts::zeros( context, 22 );
  // </0 & Divmod-GetNextDigit/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Divmod-GetNextDigit/4 (/7 s.new#1/9 s.new#2/10 e.new#3/5 )/8 s.new#4/11 e.new#5/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#3 as range 5
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#5 as range 2
  do {
    // </0 & Divmod-GetNextDigit/4 (/7 s.N1#1/9 s.N2#1/10 )/8 s.D#1/11 >/1
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    //DEBUG: s.N1#1: 9
    //DEBUG: s.N2#1: 10
    //DEBUG: s.D#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.N1#1/9 s.N2#1/10 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Divmod-GuessDigit/4 HalfReuse: s.N11 #9/7 } Tile{ HalfReuse: s.N21 #10/8 AsIs: s.D#1/11 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Divmodm_GuessDigit.ref.function );
    refalrts::reinit_svar( context[7], context[9] );
    refalrts::reinit_svar( context[8], context[10] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[8];
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Divmod-GetNextDigit/4 (/7 s.N1#1/9 s.N2#1/10 e.Numerator#1/5 )/8 s.D#1/11 e.Denominator#1/2 >/1
  // closed e.Numerator#1 as range 5
  // closed e.Denominator#1 as range 2
  //DEBUG: s.N1#1: 9
  //DEBUG: s.N2#1: 10
  //DEBUG: s.D#1: 11
  //DEBUG: e.Numerator#1: 5
  //DEBUG: e.Denominator#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 HalfReuse: [*]/4 HalfReuse: & Divmod-GetNextDigit$2=1/7 AsIs: s.N1#1/9 AsIs: s.N2#1/10 } (/12 Tile{ AsIs: e.Numerator#1/5 } Tile{ AsIs: )/8 AsIs: s.D#1/11 } (/13 Tile{ AsIs: e.Denominator#1/2 } )/14 {*}/15 </16 & Divmod-GuessDigit/17 s.N1#1/9/18 s.N2#1/10/19 s.D#1/11/20 >/21 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[15], context[4] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[17], ref_Divmodm_GuessDigit.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[18], context[9]))
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[19], context[10]))
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[20], context[11]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[21] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[4] );
  refalrts::reinit_name( context[7], ref_gen_Divmodm_GetNextDigit_S2A1.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[16] );
  refalrts::link_brackets( context[13], context[14] );
  refalrts::link_brackets( context[12], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[14], context[21] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[13], context[13] );
  res = refalrts::splice_evar( res, context[8], context[11] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  refalrts::use( res );
  refalrts::wrap_closure( context[15] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmodm_GetNextDigit("Divmod-GetNextDigit", 877573369U, 332537286U, func_Divmodm_GetNextDigit);


static refalrts::FnResult func_Divmodm_AdjustDigit(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 23 elems
  refalrts::Iter context[23];
  refalrts::zeros( context, 23 );
  // </0 & Divmod-AdjustDigit/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Divmod-AdjustDigit/4 s.new#1/9 e.new#2/2 (/7 e.new#3/5 )/8 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_right( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#3 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#2 as range 2
  do {
    // </0 & Divmod-AdjustDigit/4 s.QuotDigit#1/9 '-'/12 e.Rem#1/10 (/7 e.Denominator#1/5 )/8 >/1
    context[10] = context[2];
    context[11] = context[3];
    context[12] = refalrts::char_left( '-', context[10], context[11] );
    if( ! context[12] )
      continue;
    // closed e.Rem#1 as range 10
    // closed e.Denominator#1 as range 5
    //DEBUG: s.QuotDigit#1: 9
    //DEBUG: e.Rem#1: 10
    //DEBUG: e.Denominator#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </13 & Divmod-AdjustDigit/14 Tile{ AsIs: </0 Reuse: & Sub-Digits/4 AsIs: s.QuotDigit#1/9 HalfReuse: 1/12 } >/15 </16 & Sub-Nat/17 (/18 e.Denominator#1/5/19 )/21 Tile{ AsIs: e.Rem#1/10 } >/22 Tile{ AsIs: (/7 AsIs: e.Denominator#1/5 AsIs: )/8 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[14], ref_Divmodm_AdjustDigit.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[17], ref_Subm_Nat.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_evar(context[19], context[20], context[5], context[6]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[21] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[22] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Subm_Digits.ref.function );
    refalrts::reinit_number( context[12], 1UL );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[13] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::push_stack( context[22] );
    refalrts::push_stack( context[16] );
    refalrts::link_brackets( context[18], context[21] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[7];
    res = refalrts::splice_evar( res, context[22], context[22] );
    res = refalrts::splice_evar( res, context[10], context[11] );
    res = refalrts::splice_evar( res, context[15], context[21] );
    res = refalrts::splice_evar( res, context[0], context[12] );
    res = refalrts::splice_evar( res, context[13], context[14] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Divmod-AdjustDigit/4 s.QuotDigit#1/9 e.Rem#1/2 (/7 e.Denominator#1/5 )/8 >/1
  // closed e.Rem#1 as range 2
  // closed e.Denominator#1 as range 5
  //DEBUG: s.QuotDigit#1: 9
  //DEBUG: e.Rem#1: 2
  //DEBUG: e.Denominator#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & Divmod-AdjustDigit/4 s.QuotDigit#1/9 {REMOVED TILE} (/7 e.Denominator#1/5 )/8 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: s.QuotDigit1 #9/0 } Tile{ AsIs: e.Rem#1/2 } Tile{ ]] }
  refalrts::reinit_svar( context[0], context[9] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Divmodm_AdjustDigit("Divmod-AdjustDigit", 877573369U, 332537286U, func_Divmodm_AdjustDigit);

#line 619 "Library.sref"
namespace cookie_ns {

void long_mul(
  refalrts::UInt32& res_high, refalrts::UInt32& res_low,
  refalrts::UInt32 first, refalrts::UInt32 second
);

}  // namespace cookie_ns
#line 4934 "Library.cpp"

static refalrts::FnResult func_Divmodm_GuessDigit(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 631 "Library.sref"
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pN1 = 0, pN2 = 0, pD = 0;
  if (
    ! refalrts::svar_left(pN1, content_b, content_e)
    || refalrts::cDataNumber != pN1->tag
    || ! refalrts::svar_left(pN2, content_b, content_e)
    || refalrts::cDataNumber != pN2->tag
    || ! refalrts::svar_left(pD, content_b, content_e)
    || refalrts::cDataNumber != pD->tag
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }


  using refalrts::UInt32;
  UInt32 num_hi = pN1->number_info;
  UInt32 num_lo = pN2->number_info;
  UInt32 denom = pD->number_info;

  if (num_hi >= denom) {
    refalrts::reinit_number(arg_begin, 4294967295U);
    refalrts::reinit_char(pfunc, '*');
    refalrts::splice_to_freelist(pN1, arg_end);
    return refalrts::cSuccess;
  }

  if (num_hi >= denom || (denom & (1 << 31)) == 0) {
    return refalrts::cRecognitionImpossible;
  }

  UInt32 denom_half_hi = denom >> 16;
  UInt32 quot_hi = num_hi / denom_half_hi;
  if (quot_hi >= 65536) {
    quot_hi = 65535;
  }

  UInt32 subst_hi, subst_lo;
  while (true) {
    cookie_ns::long_mul(subst_hi, subst_lo, quot_hi << 16, denom);

    if (subst_hi < num_hi || (subst_hi == num_hi && subst_lo <= num_lo)) {
      break;
    }
    --quot_hi;
  }

  if (subst_lo > num_lo) {
    --num_hi;
  }
  num_lo -= subst_lo;
  num_hi -= subst_hi;

  assert(num_hi < 65536);

  UInt32 num_major = (num_hi << 16) | (num_lo >> 16);
  assert(num_major < denom);
  UInt32 quot_lo = (num_major) / denom_half_hi;

  while (true) {
    cookie_ns::long_mul(subst_hi, subst_lo, quot_lo, denom);

    if (subst_hi < num_hi || (subst_hi == num_hi && subst_lo <= num_lo)) {
      break;
    }
    --quot_lo;
  }

  if (subst_lo > num_lo) {
    --num_hi;
  }
  num_lo -= subst_lo;
  num_hi -= subst_hi;

  assert(num_hi == 0);

  UInt32 quot = (quot_hi << 16) + quot_lo;
  UInt32 rem = num_lo;

  refalrts::reinit_number(arg_begin, quot);
  refalrts::reinit_number(pfunc, rem);
  refalrts::splice_to_freelist(pN1, arg_end);

  return refalrts::cSuccess;
#line 5025 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Divmodm_GuessDigit("Divmod-GuessDigit", 877573369U, 332537286U, func_Divmodm_GuessDigit);


static refalrts::FnResult func_Explode(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 728 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pident = 0;
  if (
    ! refalrts::svar_right(pident, content_b, content_e)
    || refalrts::cDataIdentifier != pident->tag
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();
  if (
    ! refalrts::alloc_string(content_b, content_e, pident->ident_info->name())
  ) {
    return refalrts::cNoMemory;
  }

  refalrts::splice_evar(arg_begin, content_b, content_e);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 5056 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Explode("Explode", 0U, 0U, func_Explode);


static refalrts::FnResult func_First(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  // </0 & First/4 s.N#1/5 e.Expr#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Expr#1 as range 2
  //DEBUG: s.N#1: 5
  //DEBUG: e.Expr#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & __Step-Start/4 } >/6 </7 & DoFirst/8 Tile{ AsIs: s.N#1/5 } (/9 )/10 Tile{ AsIs: e.Expr#1/2 } >/11 </12 & __Step-End/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_DoFirst.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[13], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_u_u_Stepm_Start.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[7] );
  refalrts::link_brackets( context[9], context[10] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[11], context[13] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[5], context[5] );
  res = refalrts::splice_evar( res, context[6], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_First("First", 0U, 0U, func_First);


static refalrts::FnResult func_DoFirst(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  // </0 & DoFirst/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & DoFirst/4 s.new#1/5 (/8 e.new#2/6 )/9 e.new#3/2 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  // closed e.new#2 as range 6
  // closed e.new#3 as range 2
  do {
    // </0 & DoFirst/4 0/5 (/8 e.Prefix#1/6 )/9 e.Suffix#1/2 >/1
    if( ! refalrts::number_term( 0UL, context[5] ) )
      continue;
    // closed e.Prefix#1 as range 6
    // closed e.Suffix#1 as range 2
    //DEBUG: e.Prefix#1: 6
    //DEBUG: e.Suffix#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & DoFirst/4 0/5 {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/8 AsIs: e.Prefix#1/6 AsIs: )/9 } Tile{ AsIs: e.Suffix#1/2 } Tile{ ]] }
    refalrts::link_brackets( context[8], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[8], context[9] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & DoFirst/4 s.N#1/5 (/8 e.Prefix#1/6 )/9 >/1
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    // closed e.Prefix#1 as range 6
    //DEBUG: s.N#1: 5
    //DEBUG: e.Prefix#1: 6

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & DoFirst/4 s.N#1/5 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/8 AsIs: e.Prefix#1/6 AsIs: )/9 } Tile{ ]] }
    refalrts::link_brackets( context[8], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[8], context[9] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & DoFirst/4 s.N#1/5 (/8 e.Prefix#1/6 )/9 t.Next#1/10 e.Suffix#1/2 >/1
  // closed e.Prefix#1 as range 6
  context[11] = refalrts::tvar_left( context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  // closed e.Suffix#1 as range 2
  //DEBUG: s.N#1: 5
  //DEBUG: e.Prefix#1: 6
  //DEBUG: t.Next#1: 10
  //DEBUG: e.Suffix#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoFirst/4 } </12 & Sub-Digits/13 Tile{ AsIs: s.N#1/5 HalfReuse: 1/8 } >/14 (/15 Tile{ AsIs: e.Prefix#1/6 } Tile{ AsIs: t.Next#1/10 } Tile{ AsIs: )/9 } Tile{ AsIs: e.Suffix#1/2 } Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[13], ref_Subm_Digits.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[15] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_number( context[8], 1UL );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[15], context[9] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[12] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  res = refalrts::splice_evar( res, context[6], context[7] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[5], context[8] );
  res = refalrts::splice_evar( res, context[12], context[13] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DoFirst("DoFirst", 877573369U, 332537286U, func_DoFirst);


static refalrts::FnResult func_Get(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & Get/4 s.FileNo#1/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.FileNo#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </6 & __Step-Start/7 >/8 </9 & Autoopen/10 'r'/11 s.FileNo#1/5/12 >/13 </14 & Get-Aux/15 Tile{ AsIs: </0 Reuse: & ZeroHandle/4 AsIs: s.FileNo#1/5 HalfReuse: # stdin/1 } >/16 >/17 </18 & __Step-End/19 >/20 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], ref_u_u_Stepm_Start.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_Autoopen.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[11], 'r' ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[12], context[5]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[15], ref_Getm_Aux.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_ZeroHandle.ref.function );
  refalrts::reinit_ident( context[1], ident_stdin );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[6] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[16], context[20] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[6], context[15] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Get("Get", 0U, 0U, func_Get);


static refalrts::FnResult func_ZeroHandle(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 7 elems
  refalrts::Iter context[7];
  refalrts::zeros( context, 7 );
  // </0 & ZeroHandle/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & ZeroHandle/4 s.new#1/5 s.new#2/6 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // </0 & ZeroHandle/4 0/5 s.Default#1/6 >/1
    if( ! refalrts::number_term( 0UL, context[5] ) )
      continue;
    //DEBUG: s.Default#1: 6

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & ZeroHandle/4 0/5 s.Default#1/6 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: s.Default1 #6/1 ]] }
    refalrts::reinit_svar( context[1], context[6] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & ZeroHandle/4 s.FileNo#1/5 s.Default#1/6 >/1
  //DEBUG: s.FileNo#1: 5
  //DEBUG: s.Default#1: 6

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & ZeroHandle/4 s.FileNo#1/5 s.Default#1/6 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: s.FileNo1 #5/1 ]] }
  refalrts::reinit_svar( context[1], context[5] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_ZeroHandle("ZeroHandle", 877573369U, 332537286U, func_ZeroHandle);

#line 792 "Library.sref"
namespace {

#define USE_IDENT(ident_name) (ident_ ## ident_name)

enum { cMaxFileHandles = 40 };
FILE *g_file_handles[cMaxFileHandles];

bool file_handle_left(
  refalrts::Iter& pfile_handle, refalrts::Iter& first, refalrts::Iter& last
) {
  return refalrts::svar_left(pfile_handle, first, last)
    && (
      refalrts::cDataNumber == pfile_handle->tag
      || (
        refalrts::cDataIdentifier == pfile_handle->tag
        && (
          USE_IDENT(stdin) == pfile_handle->ident_info
          || USE_IDENT(stdout) == pfile_handle->ident_info
          || USE_IDENT(stderr) == pfile_handle->ident_info
          || USE_IDENT(stout) == pfile_handle->ident_info
        )
      )
    );
}

void close_all_files_at_exit(void *) {
  for (size_t i = 0; i < cMaxFileHandles; ++i) {
    if (g_file_handles[i] != 0) {
      fclose(g_file_handles[i]);
      g_file_handles[i] = 0;    // на всякий случай
    }
  }
}

FILE *extract_file_handle(refalrts::Iter pfile_handle) {
  assert(
    refalrts::cDataNumber == pfile_handle->tag
    || refalrts::cDataIdentifier == pfile_handle->tag
  );

  if (refalrts::cDataNumber == pfile_handle->tag) {
    refalrts::RefalNumber file_no = pfile_handle->number_info % cMaxFileHandles;

    if (file_no == 0) {
      return 0;
    }

    return g_file_handles[file_no];
  } else if (refalrts::cDataIdentifier == pfile_handle->tag) {
    return
      USE_IDENT(stdin) == pfile_handle->ident_info ? stdin :
      USE_IDENT(stdout) == pfile_handle->ident_info ? stdout :
      USE_IDENT(stderr) == pfile_handle->ident_info ? stderr : stdout;
  } else {
    refalrts_switch_default_violation(pfile_handle->tag);
  }
}

bool release_file_handle(refalrts::Iter pfile_handle) {
  if (refalrts::cDataIdentifier == pfile_handle->tag) {
    return true;
  }

  assert(refalrts::cDataNumber == pfile_handle->tag);

  refalrts::RefalNumber file_no = pfile_handle->number_info % cMaxFileHandles;

  assert(g_file_handles[file_no] != 0);

  bool successful_closed = EOF != fclose(g_file_handles[file_no]);
  g_file_handles[file_no] = 0;
  return successful_closed;
}

bool open_handle(
  refalrts::RefalNumber file_no, const char *filename, const char *mode
) {
  if (0 != g_file_handles[file_no]) {
    return false;
  }

  char default_name[sizeof("REFAL4294967296.DAT")];
  if ((filename == 0 || strlen(filename) == 0)) {
    sprintf(default_name, "REFAL%d.DAT", file_no);
    filename = default_name;
  }

  refalrts::at_exit(close_all_files_at_exit, 0);
  return (g_file_handles[file_no] = fopen(filename, mode)) != 0;
}

bool reopen_handle(
  refalrts::Iter pfile_handle, const char *filename, const char *mode
) {
  assert(refalrts::cDataNumber == pfile_handle->tag);

  refalrts::RefalNumber file_no = pfile_handle->number_info % cMaxFileHandles;

  if (g_file_handles[file_no] != 0) {
    if (! release_file_handle(pfile_handle)) {
      return false;
    }
  }

  return open_handle(file_no, filename, mode);
}

}  // unnamed namespace
#line 5471 "Library.cpp"

static refalrts::FnResult func_Autoopen(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 904 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pmode = 0;
  refalrts::Iter pfile_handle = 0;
  if (
    ! refalrts::svar_left(pmode, content_b, content_e)
    || refalrts::cDataChar != pmode->tag
    || ('r' != pmode->char_info && 'w' != pmode->char_info)
    || ! file_handle_left(pfile_handle, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  bool success = true;
  if (refalrts::cDataNumber == pfile_handle->tag) {
    refalrts::RefalNumber file_no = pfile_handle->number_info % cMaxFileHandles;

    if (0 != file_no && 0 == g_file_handles[file_no]) {
      char default_mode[] = { pmode->char_info, '\0' };
      success = open_handle(file_no, 0, default_mode);
    }
  }

  if (! success) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 5507 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Autoopen("Autoopen", 877573369U, 332537286U, func_Autoopen);


static refalrts::FnResult func_Getm_Aux(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 941 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;

  if (
    ! file_handle_left(pfile_handle, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();

  FILE *handle = extract_file_handle(pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter dummy = 0;
  int cur_char;
  while ((cur_char = getc(handle)) != EOF && cur_char != '\n') {
    /*
      Пользуемся тем фактом, что в данной реализации размещёные в свободной
      памяти узлы располагаются в последовательных адресах.
    */
    if (! refalrts::alloc_char(dummy, static_cast<char>(cur_char))) {
      return refalrts::cNoMemory;
    }
  }

  if (cur_char == EOF) {
    if (! refalrts::alloc_number(dummy, 0UL)) {
      return refalrts::cNoMemory;
    }
  }

  refalrts::splice_from_freelist(arg_begin);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 5556 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Getm_Aux("Get-Aux", 877573369U, 332537286U, func_Getm_Aux);


static refalrts::FnResult func_gen_Implode_S1B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  // </0 & Implode$1:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Implode$1:1/4 (/7 e.new#1/5 )/8 s.new#2/9 s.new#3/10 s.new#4/11 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // </0 & Implode$1:1/4 (/7 e.Tail#1/5 )/8 'L'/9 s.SubType#2/10 s.Init#2/11 >/1
    if( ! refalrts::char_term( 'L', context[9] ) )
      continue;
    // closed e.Tail#1 as range 5
    //DEBUG: s.SubType#2: 10
    //DEBUG: s.Init#2: 11
    //DEBUG: e.Tail#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.SubType#2/10 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & DoImplode/4 AsIs: (/7 } Tile{ AsIs: s.Init#2/11 } Tile{ AsIs: )/8 } Tile{ AsIs: e.Tail#1/5 } Tile{ HalfReuse: >/9 } </12 & __Step-End/13 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[13], ref_u_u_Stepm_End.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_DoImplode.ref.function );
    refalrts::reinit_close_call( context[9] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[12], context[13] );
    res = refalrts::splice_evar( res, context[9], context[9] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[8], context[8] );
    res = refalrts::splice_evar( res, context[11], context[11] );
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Implode$1:1/4 (/7 e.Tail#1/5 )/8 s.Type#2/9 s.SubType#2/10 s.Init#2/11 >/1
  // closed e.Tail#1 as range 5
  //DEBUG: s.Type#2: 9
  //DEBUG: s.SubType#2: 10
  //DEBUG: s.Init#2: 11
  //DEBUG: e.Tail#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.Type#2/9 s.SubType#2/10 s.Init#2/11 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/4 HalfReuse: s.Init2 #11/7 AsIs: e.Tail#1/5 HalfReuse: </8 } Tile{ HalfReuse: & __Step-End/0 } Tile{ AsIs: >/1 ]] }
  refalrts::reinit_number( context[4], 0UL );
  refalrts::reinit_svar( context[7], context[11] );
  refalrts::reinit_open_call( context[8] );
  refalrts::reinit_name( context[0], ref_u_u_Stepm_End.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[0], context[0] );
  res = refalrts::splice_evar( res, context[4], context[8] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Implode_S1B1("Implode$1:1", 877573369U, 332537286U, func_gen_Implode_S1B1);


static refalrts::FnResult func_Implode(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 18 elems
  refalrts::Iter context[18];
  refalrts::zeros( context, 18 );
  // </0 & Implode/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  do {
    // </0 & Implode/4 s.Init#1/7 e.Tail#1/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    // closed e.Tail#1 as range 5
    //DEBUG: s.Init#1: 7
    //DEBUG: e.Tail#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </8 [*]/9 & Implode$1:1/10 (/11 Tile{ AsIs: e.Tail#1/5 } )/12 {*}/13 </14 & __Step-Start/15 >/16 Tile{ AsIs: </0 Reuse: & Type/4 AsIs: s.Init#1/7 } >/17 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_closure_head( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], ref_gen_Implode_S1B1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_unwrapped_closure( context[13], context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[15], ref_u_u_Stepm_Start.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[17] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Type.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[17] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[14] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[17], context[17] );
    res = refalrts::splice_evar( res, context[0], context[7] );
    res = refalrts::splice_evar( res, context[12], context[16] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[8], context[11] );
    refalrts::use( res );
    refalrts::wrap_closure( context[13] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Implode/4 e.InvalidExpr#1/2 >/1
  // closed e.InvalidExpr#1 as range 2
  //DEBUG: e.InvalidExpr#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & Implode/4 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: 0/0 } Tile{ AsIs: e.InvalidExpr#1/2 } Tile{ ]] }
  refalrts::reinit_number( context[0], 0UL );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Implode("Implode", 0U, 0U, func_Implode);


static refalrts::FnResult func_gen_DoImplode_S4B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  // </0 & DoImplode$4:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & DoImplode$4:1/4 (/7 e.new#1/5 )/8 (/11 e.new#2/9 )/12 s.new#3/13 s.new#4/14 s.new#5/15 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.new#1 as range 5
  // closed e.new#2 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[14], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[15], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // </0 & DoImplode$4:1/4 (/7 e.Scanned#1/5 )/8 (/11 e.Tail#1/9 )/12 'L'/13 s.SubType#2/14 s.Lettern#2/15 >/1
    if( ! refalrts::char_term( 'L', context[13] ) )
      continue;
    // closed e.Scanned#1 as range 5
    // closed e.Tail#1 as range 9
    //DEBUG: s.SubType#2: 14
    //DEBUG: s.Lettern#2: 15
    //DEBUG: e.Scanned#1: 5
    //DEBUG: e.Tail#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} 'L'/13 s.SubType#2/14 s.Lettern#2/15 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & DoImplode/4 AsIs: (/7 AsIs: e.Scanned#1/5 HalfReuse: s.Lettern2 #15/8 HalfReuse: )/11 AsIs: e.Tail#1/9 HalfReuse: >/12 } Tile{ ]] }
    refalrts::update_name( context[4], ref_DoImplode.ref.function );
    refalrts::reinit_svar( context[8], context[15] );
    refalrts::reinit_close_bracket( context[11] );
    refalrts::reinit_close_call( context[12] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[11] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    refalrts::splice_to_freelist_open( context[12], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & DoImplode$4:1/4 (/7 e.Scanned#1/5 )/8 (/11 e.Tail#1/9 )/12 'D'/13 s.SubType#2/14 s.Digit#2/15 >/1
    if( ! refalrts::char_term( 'D', context[13] ) )
      continue;
    // closed e.Scanned#1 as range 5
    // closed e.Tail#1 as range 9
    //DEBUG: s.SubType#2: 14
    //DEBUG: s.Digit#2: 15
    //DEBUG: e.Scanned#1: 5
    //DEBUG: e.Tail#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} 'D'/13 s.SubType#2/14 s.Digit#2/15 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & DoImplode/4 AsIs: (/7 AsIs: e.Scanned#1/5 HalfReuse: s.Digit2 #15/8 HalfReuse: )/11 AsIs: e.Tail#1/9 HalfReuse: >/12 } Tile{ ]] }
    refalrts::update_name( context[4], ref_DoImplode.ref.function );
    refalrts::reinit_svar( context[8], context[15] );
    refalrts::reinit_close_bracket( context[11] );
    refalrts::reinit_close_call( context[12] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[11] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    refalrts::splice_to_freelist_open( context[12], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & DoImplode$4:1/4 (/7 e.Scanned#1/5 )/8 (/11 e.Tail#1/9 )/12 s.Type#2/13 s.SubType#2/14 s.Other#2/15 >/1
  // closed e.Scanned#1 as range 5
  // closed e.Tail#1 as range 9
  //DEBUG: s.Type#2: 13
  //DEBUG: s.SubType#2: 14
  //DEBUG: s.Other#2: 15
  //DEBUG: e.Scanned#1: 5
  //DEBUG: e.Tail#1: 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 (/11 {REMOVED TILE} )/12 s.Type#2/13 s.SubType#2/14 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Implode_Ext/4 } Tile{ AsIs: e.Scanned#1/5 } Tile{ AsIs: >/1 } Tile{ AsIs: s.Other#2/15 } Tile{ AsIs: e.Tail#1/9 } Tile{ ]] }
  refalrts::update_name( context[4], ref_Implodeu_Ext.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[15], context[15] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_DoImplode_S4B1("DoImplode$4:1", 877573369U, 332537286U, func_gen_DoImplode_S4B1);


static refalrts::FnResult func_DoImplode(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  // </0 & DoImplode/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & DoImplode/4 (/7 e.new#1/5 )/8 e.new#2/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#1 as range 5
  // closed e.new#2 as range 2
  do {
    // </0 & DoImplode/4 (/7 e.new#3/5 )/8 s.new#4/11 e.new#5/9 >/1
    context[9] = context[2];
    context[10] = context[3];
    // closed e.new#3 as range 5
    if( ! refalrts::svar_left( context[11], context[9], context[10] ) )
      continue;
    // closed e.new#5 as range 9
    do {
      // </0 & DoImplode/4 (/7 e.Scanned#1/5 )/8 '-'/11 e.Tail#1/9 >/1
      if( ! refalrts::char_term( '-', context[11] ) )
        continue;
      // closed e.Scanned#1 as range 5
      // closed e.Tail#1 as range 9
      //DEBUG: e.Scanned#1: 5
      //DEBUG: e.Tail#1: 9

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoImplode/4 AsIs: (/7 AsIs: e.Scanned#1/5 HalfReuse: '-'/8 HalfReuse: )/11 AsIs: e.Tail#1/9 AsIs: >/1 ]] }
      refalrts::reinit_char( context[8], '-' );
      refalrts::reinit_close_bracket( context[11] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[7], context[11] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & DoImplode/4 (/7 e.Scanned#1/5 )/8 '_'/11 e.Tail#1/9 >/1
      if( ! refalrts::char_term( '_', context[11] ) )
        continue;
      // closed e.Scanned#1 as range 5
      // closed e.Tail#1 as range 9
      //DEBUG: e.Scanned#1: 5
      //DEBUG: e.Tail#1: 9

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoImplode/4 AsIs: (/7 AsIs: e.Scanned#1/5 HalfReuse: '_'/8 HalfReuse: )/11 AsIs: e.Tail#1/9 AsIs: >/1 ]] }
      refalrts::reinit_char( context[8], '_' );
      refalrts::reinit_close_bracket( context[11] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[7], context[11] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & DoImplode/4 (/7 e.Scanned#1/5 )/8 '$'/11 e.Tail#1/9 >/1
      if( ! refalrts::char_term( '$', context[11] ) )
        continue;
      // closed e.Scanned#1 as range 5
      // closed e.Tail#1 as range 9
      //DEBUG: e.Scanned#1: 5
      //DEBUG: e.Tail#1: 9

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoImplode/4 AsIs: (/7 AsIs: e.Scanned#1/5 HalfReuse: '$'/8 HalfReuse: )/11 AsIs: e.Tail#1/9 AsIs: >/1 ]] }
      refalrts::reinit_char( context[8], '$' );
      refalrts::reinit_close_bracket( context[11] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[7], context[11] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & DoImplode/4 (/7 e.Scanned#1/5 )/8 s.Next#1/11 e.Tail#1/9 >/1
    // closed e.Scanned#1 as range 5
    // closed e.Tail#1 as range 9
    //DEBUG: s.Next#1: 11
    //DEBUG: e.Scanned#1: 5
    //DEBUG: e.Tail#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </12 Tile{ HalfReuse: [*]/0 Reuse: & DoImplode$4:1/4 AsIs: (/7 AsIs: e.Scanned#1/5 AsIs: )/8 } (/13 Tile{ AsIs: e.Tail#1/9 } )/14 {*}/15 </16 & Type/17 Tile{ AsIs: s.Next#1/11 } >/18 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_unwrapped_closure( context[15], context[0] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[17], ref_Type.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[18] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_closure_head( context[0] );
    refalrts::update_name( context[4], ref_gen_DoImplode_S4B1.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[16] );
    refalrts::link_brackets( context[13], context[14] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[11], context[11] );
    res = refalrts::splice_evar( res, context[14], context[17] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[0], context[8] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    refalrts::use( res );
    refalrts::wrap_closure( context[15] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & DoImplode/4 (/7 e.Scanned#1/5 )/8 e.Other#1/2 >/1
  // closed e.Scanned#1 as range 5
  // closed e.Other#1 as range 2
  //DEBUG: e.Scanned#1: 5
  //DEBUG: e.Other#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Implode_Ext/4 } Tile{ AsIs: e.Scanned#1/5 } Tile{ AsIs: >/1 } Tile{ AsIs: e.Other#1/2 } Tile{ ]] }
  refalrts::update_name( context[4], ref_Implodeu_Ext.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DoImplode("DoImplode", 877573369U, 332537286U, func_DoImplode);


static refalrts::FnResult func_Last(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  // </0 & Last/4 s.N#1/5 e.Expr#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Expr#1 as range 2
  //DEBUG: s.N#1: 5
  //DEBUG: e.Expr#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & __Step-Start/4 } >/6 </7 & DoLast/8 Tile{ AsIs: s.N#1/5 } (/9 Tile{ AsIs: e.Expr#1/2 } )/10 >/11 </12 & __Step-End/13 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_DoLast.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[13], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_u_u_Stepm_Start.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[7] );
  refalrts::link_brackets( context[9], context[10] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[10], context[13] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[5], context[5] );
  res = refalrts::splice_evar( res, context[6], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Last("Last", 0U, 0U, func_Last);


static refalrts::FnResult func_DoLast(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  // </0 & DoLast/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & DoLast/4 s.new#1/5 (/8 e.new#2/6 )/9 e.new#3/2 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  // closed e.new#2 as range 6
  // closed e.new#3 as range 2
  do {
    // </0 & DoLast/4 0/5 (/8 e.Prefix#1/6 )/9 e.Suffix#1/2 >/1
    if( ! refalrts::number_term( 0UL, context[5] ) )
      continue;
    // closed e.Prefix#1 as range 6
    // closed e.Suffix#1 as range 2
    //DEBUG: e.Prefix#1: 6
    //DEBUG: e.Suffix#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & DoLast/4 0/5 {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/8 AsIs: e.Prefix#1/6 AsIs: )/9 } Tile{ AsIs: e.Suffix#1/2 } Tile{ ]] }
    refalrts::link_brackets( context[8], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[8], context[9] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & DoLast/4 s.N#1/5 (/8 )/9 e.Suffix#1/2 >/1
    if( ! refalrts::empty_seq( context[6], context[7] ) )
      continue;
    // closed e.Suffix#1 as range 2
    //DEBUG: s.N#1: 5
    //DEBUG: e.Suffix#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & DoLast/4 s.N#1/5 {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/8 AsIs: )/9 } Tile{ AsIs: e.Suffix#1/2 } Tile{ ]] }
    refalrts::link_brackets( context[8], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[8], context[9] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & DoLast/4 s.N#1/5 (/8 e.Prefix#1/6 t.Next#1/10 )/9 e.Suffix#1/2 >/1
  // closed e.Suffix#1 as range 2
  context[11] = refalrts::tvar_right( context[10], context[6], context[7] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  // closed e.Prefix#1 as range 6
  //DEBUG: s.N#1: 5
  //DEBUG: e.Suffix#1: 2
  //DEBUG: t.Next#1: 10
  //DEBUG: e.Prefix#1: 6

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoLast/4 } </12 & Sub-Digits/13 Tile{ AsIs: s.N#1/5 HalfReuse: 1/8 } >/14 (/15 Tile{ AsIs: e.Prefix#1/6 } Tile{ AsIs: )/9 } Tile{ AsIs: t.Next#1/10 } Tile{ AsIs: e.Suffix#1/2 } Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[13], ref_Subm_Digits.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[15] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_number( context[8], 1UL );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[15], context[9] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[12] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[10], context[11] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[6], context[7] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[5], context[8] );
  res = refalrts::splice_evar( res, context[12], context[13] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DoLast("DoLast", 877573369U, 332537286U, func_DoLast);


static refalrts::FnResult func_Lenw(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & Lenw/4 e.Expr#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Expr#1 as range 2
  //DEBUG: e.Expr#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & __Step-Start/4 } >/5 </6 & DoLenw/7 0/8 Tile{ AsIs: e.Expr#1/2 } >/9 </10 & __Step-End/11 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_close_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], ref_DoLenw.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[8], 0UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_u_u_Stepm_Start.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[9], context[11] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Lenw("Lenw", 0U, 0U, func_Lenw);


static refalrts::FnResult func_DoLenw(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & DoLenw/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & DoLenw/4 s.new#1/5 e.new#2/2 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#2 as range 2
  do {
    // </0 & DoLenw/4 s.Len#1/5 >/1
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    //DEBUG: s.Len#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & DoLenw/4 s.Len#1/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: s.Len1 #5/1 ]] }
    refalrts::reinit_svar( context[1], context[5] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & DoLenw/4 s.Len#1/5 e.Expr#1/2 t.Term#1/6 >/1
  context[7] = refalrts::tvar_right( context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  // closed e.Expr#1 as range 2
  //DEBUG: s.Len#1: 5
  //DEBUG: t.Term#1: 6
  //DEBUG: e.Expr#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoLenw/4 } </8 & Add-Digits/9 Tile{ AsIs: s.Len#1/5 } 1/10 Tile{ AsIs: >/1 } Tile{ AsIs: e.Expr#1/2 } >/11 Tile{ AsIs: t.Term#1/6 } Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], ref_Addm_Digits.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[10], 1UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[7] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[5], context[5] );
  res = refalrts::splice_evar( res, context[8], context[9] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DoLenw("DoLenw", 877573369U, 332537286U, func_DoLenw);

#line 1057 "Library.sref"
namespace {

struct LowerConv {
  bool for_convert(refalrts::Iter item) {
    return refalrts::cDataChar == item->tag;
  }

  void convert(refalrts::Iter item) {
    item->char_info = static_cast<char>(tolower(item->char_info));
  }
};

}  // unnamed namespace
#line 6338 "Library.cpp"

static refalrts::FnResult func_Lower(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1074 "Library.sref"
  return convert(arg_begin, arg_end, LowerConv());
#line 6343 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Lower("Lower", 0U, 0U, func_Lower);


static refalrts::FnResult func_gen_Mod_S1A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  // </0 & Mod$1=1/4 (/7 s.Div#2/9 )/8 s.Mod#2/10 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.Div#2: 9
  //DEBUG: s.Mod#2: 10

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Div#2/9 )/8 s.Mod#2/10 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: s.Mod2 #10/0 HalfReuse: </4 HalfReuse: & __Step-End/7 } Tile{ AsIs: >/1 ]] }
  refalrts::reinit_svar( context[0], context[10] );
  refalrts::reinit_open_call( context[4] );
  refalrts::reinit_name( context[7], ref_u_u_Stepm_End.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( context[7], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Mod_S1A1("Mod$1=1", 877573369U, 332537286U, func_gen_Mod_S1A1);


static refalrts::FnResult func_gen_Mod_S2A2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Mod$2=2/4 (/7 e.Div#3/5 )/8 e.Mod#3/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Div#3 as range 5
  // closed e.Mod#3 as range 2
  //DEBUG: e.Div#3: 5
  //DEBUG: e.Mod#3: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} (/7 e.Div#3/5 )/8 {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.Mod#3/2 } Tile{ AsIs: </0 Reuse: & __Step-End/4 } Tile{ AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_u_u_Stepm_End.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[0], context[4] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Mod_S2A2("Mod$2=2", 877573369U, 332537286U, func_gen_Mod_S2A2);


static refalrts::FnResult func_gen_Mod_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & Mod$2=1/4 (/7 e.First#2/5 )/8 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#2 as range 5
  // closed e.Second#2 as range 2
  //DEBUG: e.First#2: 5
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </9 & Mod$2=2/10 Tile{ AsIs: </0 Reuse: & Divmod-Normed/4 AsIs: (/7 AsIs: e.First#2/5 AsIs: )/8 AsIs: e.Second#2/2 AsIs: >/1 } >/11 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_gen_Mod_S2A2.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Divmodm_Normed.ref.function );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Mod_S2A1("Mod$2=1", 877573369U, 332537286U, func_gen_Mod_S2A1);


static refalrts::FnResult func_Mod(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & Mod/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  do {
    // </0 & Mod/4 s.First#1/7 s.Second#1/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.First#1: 7
    //DEBUG: s.Second#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </9 & Mod$1=1/10 </11 & __Step-Start/12 >/13 Tile{ AsIs: </0 Reuse: & Divmod-Digits/4 AsIs: s.First#1/7 AsIs: s.Second#1/8 AsIs: >/1 } >/14 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], ref_gen_Mod_S1A1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[12], ref_u_u_Stepm_Start.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[14] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Divmodm_Digits.ref.function );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[13] );
    refalrts::push_stack( context[11] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[9], context[13] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Mod/4 e.ArithmArg#1/2 >/1
  // closed e.ArithmArg#1 as range 2
  //DEBUG: e.ArithmArg#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & Mod$2=1/6 </7 & __Step-Start/8 >/9 Tile{ AsIs: </0 Reuse: & NormArithmArg/4 AsIs: e.ArithmArg#1/2 AsIs: >/1 } >/10 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_gen_Mod_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_u_u_Stepm_Start.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[10] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormArithmArg.ref.function );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[5], context[9] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Mod("Mod", 0U, 0U, func_Mod);


static refalrts::FnResult func_gen_Mul_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & Mul$2=1/4 (/7 e.First#2/5 )/8 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#2 as range 5
  // closed e.Second#2 as range 2
  //DEBUG: e.First#2: 5
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Mul-Normed/4 AsIs: (/7 AsIs: e.First#2/5 AsIs: )/8 AsIs: e.Second#2/2 AsIs: >/1 } </9 & __Step-End/10 >/11 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Mulm_Normed.ref.function );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[9], context[11] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Mul_S2A1("Mul$2=1", 877573369U, 332537286U, func_gen_Mul_S2A1);


static refalrts::FnResult func_Mul(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & Mul/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  do {
    // </0 & Mul/4 s.First#1/7 s.Second#1/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.First#1: 7
    //DEBUG: s.Second#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } </9 & __Step-Start/10 >/11 Tile{ AsIs: </0 Reuse: & Mul-Digits/4 AsIs: s.First#1/7 AsIs: s.Second#1/8 AsIs: >/1 } </12 & __Step-End/13 >/14 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], ref_u_u_Stepm_Start.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[13], ref_u_u_Stepm_End.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[14] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Mulm_Digits.ref.function );
    refalrts::push_stack( context[14] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[12], context[14] );
    res = refalrts::splice_evar( res, context[0], context[1] );
    res = refalrts::splice_evar( res, context[9], context[11] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Mul/4 e.ArithmArg#1/2 >/1
  // closed e.ArithmArg#1 as range 2
  //DEBUG: e.ArithmArg#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & Mul$2=1/6 </7 & __Step-Start/8 >/9 Tile{ AsIs: </0 Reuse: & NormArithmArg/4 AsIs: e.ArithmArg#1/2 AsIs: >/1 } >/10 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_gen_Mul_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_u_u_Stepm_Start.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[10] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormArithmArg.ref.function );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[5], context[9] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Mul("Mul", 0U, 0U, func_Mul);

#line 1111 "Library.sref"
void cookie_ns::long_mul(
  refalrts::UInt32& res_high, refalrts::UInt32& res_low,
  refalrts::UInt32 first, refalrts::UInt32 second
) {
  /*
    Double-word multiplication scheme:

    (x,y,z,t) = (F,i)*(S,e)     -- first * second

       S   e        (A,a) = F * S
     ---------      (B,b) = i * S
     |\ b|\ d|      (C,c) = F * e
    i| \ | \ |t     (D,d) = i * e
     |B \|D \|
     ---------      t = d
     |\ a|\ c|      (Z,z) = b + D + c
    F| \ | \ |z     (Y,y) = B + a + C + Z
     |A \|C \|      x = A + Y
     ---------
       x   y        (x,y) = (A, a) + B + C + Z
  */

  using refalrts::UInt32;

  UInt32 F = first >> 16;
  UInt32 i = first & 0xFFFFU;
  UInt32 S = second >> 16;
  UInt32 e = second & 0xFFFFU;

  UInt32 Aa = F * S;
  UInt32 Bb = i * S;
  UInt32 Cc = F * e;
  UInt32 Dd = i * e;

  UInt32 Zz = (Bb & 0xFFFFU) + (Dd >> 16) + (Cc & 0xFFFFU);
  res_low = (Zz << 16) + (Dd & 0xFFFFU);
  res_high = Aa + (Bb >> 16) + (Cc >> 16) + (Zz >> 16);
}
#line 6765 "Library.cpp"

static refalrts::FnResult func_Mulm_Digits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1153 "Library.sref"
  ARITHM_PRELUDE

  refalrts::UInt32 res_high, res_low;
  cookie_ns::long_mul(res_high, res_low, first, second);

  if (res_high > 0) {
    refalrts::reinit_number(arg_begin, res_high);
    refalrts::reinit_number(pFunc, res_low);
    refalrts::splice_to_freelist(pFirst, arg_end);
  } else {
    refalrts::reinit_number(arg_begin, res_low);
    refalrts::splice_to_freelist(pFunc, arg_end);
  }

  return refalrts::cSuccess;
#line 6784 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Mulm_Digits("Mul-Digits", 877573369U, 332537286U, func_Mulm_Digits);


static refalrts::FnResult func_Mulm_Normed(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  // </0 & Mul-Normed/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Mul-Normed/4 (/7 s.new#1/9 e.new#2/5 )/8 e.new#3/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#3 as range 2
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#2 as range 5
  do {
    // </0 & Mul-Normed/4 (/7 s.new#4/9 e.new#5/5 )/8 s.new#6/12 e.new#7/10 >/1
    context[10] = context[2];
    context[11] = context[3];
    // closed e.new#5 as range 5
    if( ! refalrts::svar_left( context[12], context[10], context[11] ) )
      continue;
    // closed e.new#7 as range 10
    do {
      // </0 & Mul-Normed/4 (/7 '+'/9 e.new#8/5 )/8 s.new#9/12 e.new#10/10 >/1
      if( ! refalrts::char_term( '+', context[9] ) )
        continue;
      // closed e.new#8 as range 5
      // closed e.new#10 as range 10
      do {
        // </0 & Mul-Normed/4 (/7 '+'/9 e.First#1/5 )/8 '+'/12 e.Second#1/10 >/1
        if( ! refalrts::char_term( '+', context[12] ) )
          continue;
        // closed e.First#1 as range 5
        // closed e.Second#1 as range 10
        //DEBUG: e.First#1: 5
        //DEBUG: e.Second#1: 10

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} '+'/9 {REMOVED TILE} )/8 {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 Reuse: & Mul-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/5 } Tile{ HalfReuse: )/12 AsIs: e.Second#1/10 AsIs: >/1 ]] }
        refalrts::update_name( context[4], ref_Mulm_Nat.ref.function );
        refalrts::reinit_close_bracket( context[12] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[0] );
        refalrts::link_brackets( context[7], context[12] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[12];
        res = refalrts::splice_evar( res, context[5], context[6] );
        refalrts::splice_to_freelist_open( context[7], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Mul-Normed/4 (/7 '+'/9 e.First#1/5 )/8 '-'/12 e.Second#1/10 >/1
        if( ! refalrts::char_term( '-', context[12] ) )
          continue;
        // closed e.First#1 as range 5
        // closed e.Second#1 as range 10
        //DEBUG: e.First#1: 5
        //DEBUG: e.Second#1: 10

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} '-'/12 {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ HalfReuse: '-'/0 HalfReuse: </4 HalfReuse: & Mul-Nat/7 HalfReuse: (/9 AsIs: e.First#1/5 AsIs: )/8 } Tile{ AsIs: e.Second#1/10 } Tile{ AsIs: >/1 ]] }
        refalrts::reinit_char( context[0], '-' );
        refalrts::reinit_open_call( context[4] );
        refalrts::reinit_name( context[7], ref_Mulm_Nat.ref.function );
        refalrts::reinit_open_bracket( context[9] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[4] );
        refalrts::link_brackets( context[9], context[8] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[1];
        res = refalrts::splice_evar( res, context[10], context[11] );
        refalrts::splice_to_freelist_open( context[8], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      // </0 & Mul-Normed/4 (/7 '+'/9 e.First#1/5 )/8 0/12 >/1
      if( ! refalrts::number_term( 0UL, context[12] ) )
        continue;
      if( ! refalrts::empty_seq( context[10], context[11] ) )
        continue;
      // closed e.First#1 as range 5
      //DEBUG: e.First#1: 5

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} </0 & Mul-Normed/4 (/7 '+'/9 e.First#1/5 )/8 0/12 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
      refalrts::reinit_number( context[1], 0UL );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      refalrts::splice_to_freelist_open( trash_prev, res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Mul-Normed/4 (/7 '-'/9 e.new#8/5 )/8 s.new#9/12 e.new#10/10 >/1
    if( ! refalrts::char_term( '-', context[9] ) )
      continue;
    // closed e.new#8 as range 5
    // closed e.new#10 as range 10
    do {
      // </0 & Mul-Normed/4 (/7 '-'/9 e.First#1/5 )/8 '+'/12 e.Second#1/10 >/1
      if( ! refalrts::char_term( '+', context[12] ) )
        continue;
      // closed e.First#1 as range 5
      // closed e.Second#1 as range 10
      //DEBUG: e.First#1: 5
      //DEBUG: e.Second#1: 10

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} '+'/12 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: '-'/0 HalfReuse: </4 HalfReuse: & Mul-Nat/7 HalfReuse: (/9 AsIs: e.First#1/5 AsIs: )/8 } Tile{ AsIs: e.Second#1/10 } Tile{ AsIs: >/1 ]] }
      refalrts::reinit_char( context[0], '-' );
      refalrts::reinit_open_call( context[4] );
      refalrts::reinit_name( context[7], ref_Mulm_Nat.ref.function );
      refalrts::reinit_open_bracket( context[9] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[4] );
      refalrts::link_brackets( context[9], context[8] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[10], context[11] );
      refalrts::splice_to_freelist_open( context[8], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & Mul-Normed/4 (/7 '-'/9 e.First#1/5 )/8 '-'/12 e.Second#1/10 >/1
      if( ! refalrts::char_term( '-', context[12] ) )
        continue;
      // closed e.First#1 as range 5
      // closed e.Second#1 as range 10
      //DEBUG: e.First#1: 5
      //DEBUG: e.Second#1: 10

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} '-'/9 {REMOVED TILE} )/8 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Mul-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/5 } Tile{ HalfReuse: )/12 AsIs: e.Second#1/10 AsIs: >/1 ]] }
      refalrts::update_name( context[4], ref_Mulm_Nat.ref.function );
      refalrts::reinit_close_bracket( context[12] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[7], context[12] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[12];
      res = refalrts::splice_evar( res, context[5], context[6] );
      refalrts::splice_to_freelist_open( context[7], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Mul-Normed/4 (/7 '-'/9 e.First#1/5 )/8 0/12 >/1
    if( ! refalrts::number_term( 0UL, context[12] ) )
      continue;
    if( ! refalrts::empty_seq( context[10], context[11] ) )
      continue;
    // closed e.First#1 as range 5
    //DEBUG: e.First#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Mul-Normed/4 (/7 '-'/9 e.First#1/5 )/8 0/12 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
    refalrts::reinit_number( context[1], 0UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Mul-Normed/4 (/7 0/9 )/8 e.AnySecond#1/2 >/1
  if( ! refalrts::number_term( 0UL, context[9] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.AnySecond#1 as range 2
  //DEBUG: e.AnySecond#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Mul-Normed/4 (/7 0/9 )/8 e.AnySecond#1/2 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
  refalrts::reinit_number( context[1], 0UL );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Mulm_Normed("Mul-Normed", 877573369U, 332537286U, func_Mulm_Normed);


static refalrts::FnResult func_Mulm_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & Mul-Nat/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Mul-Nat/4 (/7 e.new#1/5 )/8 e.new#2/2 s.new#3/9 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#1 as range 5
  if( ! refalrts::svar_right( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#2 as range 2
  do {
    // </0 & Mul-Nat/4 (/7 e.First#1/5 )/8 s.SecondLast#1/9 >/1
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    // closed e.First#1 as range 5
    //DEBUG: s.SecondLast#1: 9
    //DEBUG: e.First#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Mul-Nat-Line/4 } Tile{ AsIs: e.First#1/5 } Tile{ AsIs: s.SecondLast#1/9 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Mulm_Natm_Line.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[9];
    res = refalrts::splice_evar( res, context[5], context[6] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Mul-Nat/4 (/7 e.First#1/5 )/8 e.Second#1/2 s.SecondLast#1/9 >/1
  // closed e.First#1 as range 5
  // closed e.Second#1 as range 2
  //DEBUG: s.SecondLast#1: 9
  //DEBUG: e.First#1: 5
  //DEBUG: e.Second#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </10 & Add-Nat/11 (/12 Tile{ AsIs: </0 AsIs: & Mul-Nat/4 AsIs: (/7 AsIs: e.First#1/5 AsIs: )/8 } Tile{ AsIs: e.Second#1/2 } >/13 0/14 )/15 </16 & Mul-Nat-Line/17 e.First#1/5/18 Tile{ AsIs: s.SecondLast#1/9 AsIs: >/1 } >/20 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], ref_Addm_Nat.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[14], 0UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[17], ref_Mulm_Natm_Line.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[18], context[19], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[20] ) )
    return refalrts::cNoMemory;
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[16] );
  refalrts::link_brackets( context[12], context[15] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[20], context[20] );
  res = refalrts::splice_evar( res, context[9], context[1] );
  res = refalrts::splice_evar( res, context[18], context[19] );
  res = refalrts::splice_evar( res, context[13], context[17] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[0], context[8] );
  res = refalrts::splice_evar( res, context[10], context[12] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Mulm_Nat("Mul-Nat", 877573369U, 332537286U, func_Mulm_Nat);


static refalrts::FnResult func_gen_Mulm_Natm_Line_S2B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 18 elems
  refalrts::Iter context[18];
  refalrts::zeros( context, 18 );
  // </0 & Mul-Nat-Line$2:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Mul-Nat-Line$2:1/4 (/7 e.new#1/5 )/8 e.new#2/2 s.new#3/10 s.new#4/9 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#1 as range 5
  if( ! refalrts::svar_right( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_right( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#2 as range 2
  do {
    // </0 & Mul-Nat-Line$2:1/4 (/7 e.First#1/5 )/8 s.Second#1/13 s.MulHigh#2/10 s.MulLow#2/9 >/1
    context[11] = context[2];
    context[12] = context[3];
    // closed e.First#1 as range 5
    if( ! refalrts::svar_left( context[13], context[11], context[12] ) )
      continue;
    if( ! refalrts::empty_seq( context[11], context[12] ) )
      continue;
    //DEBUG: s.MulHigh#2: 10
    //DEBUG: s.MulLow#2: 9
    //DEBUG: e.First#1: 5
    //DEBUG: s.Second#1: 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.MulLow#2/9 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Add-Nat/4 AsIs: (/7 } </14 & Mul-Nat-Line/15 Tile{ AsIs: e.First#1/5 } Tile{ AsIs: s.Second#1/13 } >/16 Tile{ AsIs: )/8 } Tile{ AsIs: s.MulHigh#2/10 } >/17 Tile{ HalfReuse: s.MulLow2 #9/1 ]] }
    if( ! refalrts::alloc_open_call( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[15], ref_Mulm_Natm_Line.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[17] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Addm_Nat.ref.function );
    refalrts::reinit_svar( context[1], context[9] );
    refalrts::push_stack( context[17] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[14] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[17], context[17] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[8], context[8] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[14], context[15] );
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Mul-Nat-Line$2:1/4 (/7 e.First#1/5 )/8 s.Second#1/10 s.MulLow#2/9 >/1
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.First#1 as range 5
  //DEBUG: s.Second#1: 10
  //DEBUG: s.MulLow#2: 9
  //DEBUG: e.First#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.MulLow#2/9 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Mul-Nat-Line/4 } Tile{ AsIs: e.First#1/5 } Tile{ AsIs: s.Second#1/10 } Tile{ HalfReuse: >/8 } Tile{ HalfReuse: s.MulLow2 #9/1 ]] }
  refalrts::update_name( context[4], ref_Mulm_Natm_Line.ref.function );
  refalrts::reinit_close_call( context[8] );
  refalrts::reinit_svar( context[1], context[9] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[8], context[8] );
  res = refalrts::splice_evar( res, context[10], context[10] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Mulm_Natm_Line_S2B1("Mul-Nat-Line$2:1", 877573369U, 332537286U, func_gen_Mulm_Natm_Line_S2B1);


static refalrts::FnResult func_Mulm_Natm_Line(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & Mul-Nat-Line/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Mul-Nat-Line/4 e.new#1/2 s.new#2/6 s.new#3/5 >/1
  if( ! refalrts::svar_right( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_right( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#1 as range 2
  do {
    // </0 & Mul-Nat-Line/4 s.FirstLast#1/6 s.Second#1/5 >/1
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    //DEBUG: s.FirstLast#1: 6
    //DEBUG: s.Second#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Mul-Digits/4 AsIs: s.FirstLast#1/6 AsIs: s.Second#1/5 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Mulm_Digits.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Mul-Nat-Line/4 e.First#1/2 s.FirstLast#1/6 s.Second#1/5 >/1
  // closed e.First#1 as range 2
  //DEBUG: s.FirstLast#1: 6
  //DEBUG: s.Second#1: 5
  //DEBUG: e.First#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 HalfReuse: [*]/4 } & Mul-Nat-Line$2:1/7 (/8 Tile{ AsIs: e.First#1/2 } )/9 s.Second#1/5/10 {*}/11 </12 & Mul-Digits/13 Tile{ AsIs: s.FirstLast#1/6 AsIs: s.Second#1/5 AsIs: >/1 } >/14 Tile{ ]] }
  if( ! refalrts::alloc_name( context[7], ref_gen_Mulm_Natm_Line_S2B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[9] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[10], context[5]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[11], context[4] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[13], ref_Mulm_Digits.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[4] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[12] );
  refalrts::link_brackets( context[8], context[9] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[14], context[14] );
  res = refalrts::splice_evar( res, context[6], context[1] );
  res = refalrts::splice_evar( res, context[9], context[13] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::use( res );
  refalrts::wrap_closure( context[11] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Mulm_Natm_Line("Mul-Nat-Line", 877573369U, 332537286U, func_Mulm_Natm_Line);


static refalrts::FnResult func_Numb(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  // </0 & Numb/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  do {
    // </0 & Numb/4 s.new#1/7 e.new#2/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    // closed e.new#2 as range 5
    do {
      // </0 & Numb/4 '-'/7 e.String#1/5 >/1
      if( ! refalrts::char_term( '-', context[7] ) )
        continue;
      // closed e.String#1 as range 5
      //DEBUG: e.String#1: 5

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & __Step-Start/4 HalfReuse: >/7 } </8 & Neg/9 </10 & Numb-Aux/11 Tile{ AsIs: e.String#1/5 } >/12 >/13 </14 & __Step-End/15 Tile{ AsIs: >/1 ]] }
      if( ! refalrts::alloc_open_call( context[8] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_name( context[9], ref_Neg.ref.function ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_call( context[10] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_name( context[11], ref_Numbm_Aux.ref.function ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[12] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[13] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_call( context[14] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_name( context[15], ref_u_u_Stepm_End.ref.function ) )
        return refalrts::cNoMemory;
      refalrts::update_name( context[4], ref_u_u_Stepm_Start.ref.function );
      refalrts::reinit_close_call( context[7] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[14] );
      refalrts::push_stack( context[13] );
      refalrts::push_stack( context[8] );
      refalrts::push_stack( context[12] );
      refalrts::push_stack( context[10] );
      refalrts::push_stack( context[7] );
      refalrts::push_stack( context[0] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[12], context[15] );
      res = refalrts::splice_evar( res, context[5], context[6] );
      res = refalrts::splice_evar( res, context[8], context[11] );
      refalrts::use( res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Numb/4 '+'/7 e.String#1/5 >/1
    if( ! refalrts::char_term( '+', context[7] ) )
      continue;
    // closed e.String#1 as range 5
    //DEBUG: e.String#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & __Step-Start/4 HalfReuse: >/7 } </8 & Numb-Aux/9 Tile{ AsIs: e.String#1/5 } >/10 </11 & __Step-End/12 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[9], ref_Numbm_Aux.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[10] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[12], ref_u_u_Stepm_End.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_u_u_Stepm_Start.ref.function );
    refalrts::reinit_close_call( context[7] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[10] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[7] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[10], context[12] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[8], context[9] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Numb/4 e.String#1/2 >/1
  // closed e.String#1 as range 2
  //DEBUG: e.String#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & __Step-Start/6 >/7 Tile{ AsIs: </0 Reuse: & Numb-Aux/4 AsIs: e.String#1/2 AsIs: >/1 } </8 & __Step-End/9 >/10 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_u_u_Stepm_Start.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[10] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Numbm_Aux.ref.function );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[5] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[8], context[10] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[5], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Numb("Numb", 0U, 0U, func_Numb);


static refalrts::FnResult func_Numbm_Aux(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Numb-Aux/4 e.String#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.String#1 as range 2
  //DEBUG: e.String#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & DoNumb/6 & Numb-Ok/7 & Numb-Fail/8 Tile{ HalfReuse: (/0 HalfReuse: )/4 AsIs: e.String#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_DoNumb.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], ref_Numbm_Ok.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_Numbm_Fail.ref.function ) )
    return refalrts::cNoMemory;
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[5] );
  refalrts::link_brackets( context[0], context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[0];
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Numbm_Aux("Numb-Aux", 877573369U, 332537286U, func_Numbm_Aux);


static refalrts::FnResult func_DoNumb(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  // </0 & DoNumb/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & DoNumb/4 s.new#1/5 s.new#2/6 (/9 e.new#3/7 )/10 e.new#4/2 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[7] = 0;
  context[8] = 0;
  context[9] = refalrts::brackets_left( context[7], context[8], context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[9], context[10]);
  // closed e.new#3 as range 7
  // closed e.new#4 as range 2
  do {
    // </0 & DoNumb/4 s.new#5/5 s.new#6/6 (/9 e.new#7/7 )/10 s.new#8/13 e.new#9/11 >/1
    context[11] = context[2];
    context[12] = context[3];
    // closed e.new#7 as range 7
    if( ! refalrts::svar_left( context[13], context[11], context[12] ) )
      continue;
    // closed e.new#9 as range 11
    do {
      // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/7 )/10 '0'/13 e.Rest#1/11 >/1
      if( ! refalrts::char_term( '0', context[13] ) )
        continue;
      // closed e.Digits#1 as range 7
      // closed e.Rest#1 as range 11
      //DEBUG: s.Ok#1: 5
      //DEBUG: s.Fail#1: 6
      //DEBUG: e.Digits#1: 7
      //DEBUG: e.Rest#1: 11

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/7 HalfReuse: 0/10 HalfReuse: )/13 AsIs: e.Rest#1/11 AsIs: >/1 ]] }
      refalrts::reinit_number( context[10], 0UL );
      refalrts::reinit_close_bracket( context[13] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[9], context[13] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/7 )/10 '1'/13 e.Rest#1/11 >/1
      if( ! refalrts::char_term( '1', context[13] ) )
        continue;
      // closed e.Digits#1 as range 7
      // closed e.Rest#1 as range 11
      //DEBUG: s.Ok#1: 5
      //DEBUG: s.Fail#1: 6
      //DEBUG: e.Digits#1: 7
      //DEBUG: e.Rest#1: 11

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/7 HalfReuse: 1/10 HalfReuse: )/13 AsIs: e.Rest#1/11 AsIs: >/1 ]] }
      refalrts::reinit_number( context[10], 1UL );
      refalrts::reinit_close_bracket( context[13] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[9], context[13] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/7 )/10 '2'/13 e.Rest#1/11 >/1
      if( ! refalrts::char_term( '2', context[13] ) )
        continue;
      // closed e.Digits#1 as range 7
      // closed e.Rest#1 as range 11
      //DEBUG: s.Ok#1: 5
      //DEBUG: s.Fail#1: 6
      //DEBUG: e.Digits#1: 7
      //DEBUG: e.Rest#1: 11

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/7 HalfReuse: 2/10 HalfReuse: )/13 AsIs: e.Rest#1/11 AsIs: >/1 ]] }
      refalrts::reinit_number( context[10], 2UL );
      refalrts::reinit_close_bracket( context[13] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[9], context[13] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/7 )/10 '3'/13 e.Rest#1/11 >/1
      if( ! refalrts::char_term( '3', context[13] ) )
        continue;
      // closed e.Digits#1 as range 7
      // closed e.Rest#1 as range 11
      //DEBUG: s.Ok#1: 5
      //DEBUG: s.Fail#1: 6
      //DEBUG: e.Digits#1: 7
      //DEBUG: e.Rest#1: 11

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/7 HalfReuse: 3/10 HalfReuse: )/13 AsIs: e.Rest#1/11 AsIs: >/1 ]] }
      refalrts::reinit_number( context[10], 3UL );
      refalrts::reinit_close_bracket( context[13] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[9], context[13] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/7 )/10 '4'/13 e.Rest#1/11 >/1
      if( ! refalrts::char_term( '4', context[13] ) )
        continue;
      // closed e.Digits#1 as range 7
      // closed e.Rest#1 as range 11
      //DEBUG: s.Ok#1: 5
      //DEBUG: s.Fail#1: 6
      //DEBUG: e.Digits#1: 7
      //DEBUG: e.Rest#1: 11

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/7 HalfReuse: 4/10 HalfReuse: )/13 AsIs: e.Rest#1/11 AsIs: >/1 ]] }
      refalrts::reinit_number( context[10], 4UL );
      refalrts::reinit_close_bracket( context[13] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[9], context[13] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/7 )/10 '5'/13 e.Rest#1/11 >/1
      if( ! refalrts::char_term( '5', context[13] ) )
        continue;
      // closed e.Digits#1 as range 7
      // closed e.Rest#1 as range 11
      //DEBUG: s.Ok#1: 5
      //DEBUG: s.Fail#1: 6
      //DEBUG: e.Digits#1: 7
      //DEBUG: e.Rest#1: 11

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/7 HalfReuse: 5/10 HalfReuse: )/13 AsIs: e.Rest#1/11 AsIs: >/1 ]] }
      refalrts::reinit_number( context[10], 5UL );
      refalrts::reinit_close_bracket( context[13] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[9], context[13] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/7 )/10 '6'/13 e.Rest#1/11 >/1
      if( ! refalrts::char_term( '6', context[13] ) )
        continue;
      // closed e.Digits#1 as range 7
      // closed e.Rest#1 as range 11
      //DEBUG: s.Ok#1: 5
      //DEBUG: s.Fail#1: 6
      //DEBUG: e.Digits#1: 7
      //DEBUG: e.Rest#1: 11

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/7 HalfReuse: 6/10 HalfReuse: )/13 AsIs: e.Rest#1/11 AsIs: >/1 ]] }
      refalrts::reinit_number( context[10], 6UL );
      refalrts::reinit_close_bracket( context[13] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[9], context[13] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/7 )/10 '7'/13 e.Rest#1/11 >/1
      if( ! refalrts::char_term( '7', context[13] ) )
        continue;
      // closed e.Digits#1 as range 7
      // closed e.Rest#1 as range 11
      //DEBUG: s.Ok#1: 5
      //DEBUG: s.Fail#1: 6
      //DEBUG: e.Digits#1: 7
      //DEBUG: e.Rest#1: 11

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/7 HalfReuse: 7/10 HalfReuse: )/13 AsIs: e.Rest#1/11 AsIs: >/1 ]] }
      refalrts::reinit_number( context[10], 7UL );
      refalrts::reinit_close_bracket( context[13] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[9], context[13] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/7 )/10 '8'/13 e.Rest#1/11 >/1
      if( ! refalrts::char_term( '8', context[13] ) )
        continue;
      // closed e.Digits#1 as range 7
      // closed e.Rest#1 as range 11
      //DEBUG: s.Ok#1: 5
      //DEBUG: s.Fail#1: 6
      //DEBUG: e.Digits#1: 7
      //DEBUG: e.Rest#1: 11

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/7 HalfReuse: 8/10 HalfReuse: )/13 AsIs: e.Rest#1/11 AsIs: >/1 ]] }
      refalrts::reinit_number( context[10], 8UL );
      refalrts::reinit_close_bracket( context[13] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[9], context[13] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/7 )/10 '9'/13 e.Rest#1/11 >/1
    if( ! refalrts::char_term( '9', context[13] ) )
      continue;
    // closed e.Digits#1 as range 7
    // closed e.Rest#1 as range 11
    //DEBUG: s.Ok#1: 5
    //DEBUG: s.Fail#1: 6
    //DEBUG: e.Digits#1: 7
    //DEBUG: e.Rest#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb/4 AsIs: s.Ok#1/5 AsIs: s.Fail#1/6 AsIs: (/9 AsIs: e.Digits#1/7 HalfReuse: 9/10 HalfReuse: )/13 AsIs: e.Rest#1/11 AsIs: >/1 ]] }
    refalrts::reinit_number( context[10], 9UL );
    refalrts::reinit_close_bracket( context[13] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[9], context[13] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 )/10 e.Rest#1/2 >/1
    if( ! refalrts::empty_seq( context[7], context[8] ) )
      continue;
    // closed e.Rest#1 as range 2
    //DEBUG: s.Ok#1: 5
    //DEBUG: s.Fail#1: 6
    //DEBUG: e.Rest#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: </9 HalfReuse: s.Fail1 #6/10 AsIs: e.Rest#1/2 AsIs: >/1 ]] }
    refalrts::reinit_open_call( context[9] );
    refalrts::reinit_svar( context[10], context[6] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[9];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & DoNumb/4 s.Ok#1/5 s.Fail#1/6 (/9 e.Digits#1/7 )/10 e.Rest#1/2 >/1
  // closed e.Digits#1 as range 7
  // closed e.Rest#1 as range 2
  //DEBUG: s.Ok#1: 5
  //DEBUG: s.Fail#1: 6
  //DEBUG: e.Digits#1: 7
  //DEBUG: e.Rest#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Ok#1/5 s.Fail#1/6 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 HalfReuse: s.Ok1 #5/4 } Tile{ AsIs: (/9 } </11 & Numb-Wrap/12 Tile{ AsIs: e.Digits#1/7 } >/13 Tile{ AsIs: )/10 AsIs: e.Rest#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[12], ref_Numbm_Wrap.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_svar( context[4], context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[9], context[10] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[11] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[10];
  res = refalrts::splice_evar( res, context[13], context[13] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  res = refalrts::splice_evar( res, context[11], context[12] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DoNumb("DoNumb", 877573369U, 332537286U, func_DoNumb);


static refalrts::FnResult func_Numbm_Ok(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Numb-Ok/4 (/7 e.Number#1/5 )/8 e.Rest#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Number#1 as range 5
  // closed e.Rest#1 as range 2
  //DEBUG: e.Number#1: 5
  //DEBUG: e.Rest#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Numb-Ok/4 (/7 {REMOVED TILE} )/8 e.Rest#1/2 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.Number#1/5 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Numbm_Ok("Numb-Ok", 877573369U, 332537286U, func_Numbm_Ok);


static refalrts::FnResult func_Numbm_Fail(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 5 elems
  refalrts::Iter context[5];
  refalrts::zeros( context, 5 );
  // </0 & Numb-Fail/4 e.Rest#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Rest#1 as range 2
  //DEBUG: e.Rest#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Numb-Fail/4 e.Rest#1/2 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
  refalrts::reinit_number( context[1], 0UL );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Numbm_Fail("Numb-Fail", 877573369U, 332537286U, func_Numbm_Fail);


static refalrts::FnResult func_Numbm_Wrap(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  // </0 & Numb-Wrap/4 e.Digits#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Digits#1 as range 2
  //DEBUG: e.Digits#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & DoNumb-Wrap/6 (/7 Tile{ HalfReuse: 0/0 HalfReuse: )/4 AsIs: e.Digits#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_DoNumbm_Wrap.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[7] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_number( context[0], 0UL );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[5] );
  refalrts::link_brackets( context[7], context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[0];
  res = refalrts::splice_evar( res, context[5], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Numbm_Wrap("Numb-Wrap", 877573369U, 332537286U, func_Numbm_Wrap);


static refalrts::FnResult func_DoNumbm_Wrap(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & DoNumb-Wrap/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & DoNumb-Wrap/4 (/7 e.new#1/5 )/8 e.new#2/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#1 as range 5
  // closed e.new#2 as range 2
  do {
    // </0 & DoNumb-Wrap/4 (/7 e.Result#1/5 )/8 s.NextDigit#1/11 e.Digits#1/9 >/1
    context[9] = context[2];
    context[10] = context[3];
    // closed e.Result#1 as range 5
    if( ! refalrts::svar_left( context[11], context[9], context[10] ) )
      continue;
    // closed e.Digits#1 as range 9
    //DEBUG: e.Result#1: 5
    //DEBUG: s.NextDigit#1: 11
    //DEBUG: e.Digits#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & DoNumb-Wrap/4 AsIs: (/7 } </12 & Add-Nat/13 (/14 </15 & Mul-Nat-Line/16 Tile{ AsIs: e.Result#1/5 } 10/17 >/18 Tile{ AsIs: )/8 AsIs: s.NextDigit#1/11 } >/19 )/20 Tile{ AsIs: e.Digits#1/9 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[13], ref_Addm_Nat.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[14] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[16], ref_Mulm_Natm_Line.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_number( context[17], 10UL ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[20] ) )
      return refalrts::cNoMemory;
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[20] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[12] );
    refalrts::link_brackets( context[14], context[8] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[15] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[8], context[11] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[12], context[16] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & DoNumb-Wrap/4 (/7 e.Result#1/5 )/8 >/1
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Result#1 as range 5
  //DEBUG: e.Result#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & DoNumb-Wrap/4 (/7 {REMOVED TILE} )/8 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.Result#1/5 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DoNumbm_Wrap("DoNumb-Wrap", 877573369U, 332537286U, func_DoNumbm_Wrap);


static refalrts::FnResult func_Open(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1266 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  std::string mode;

  refalrts::Iter mode_b = 0;
  refalrts::Iter mode_e = 0;
  refalrts::Iter pmode = 0;

  if (! refalrts::tvar_left(pmode, content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  if (refalrts::char_term('r', pmode) || refalrts::char_term('R', pmode)) {
    mode = "r";
  } else if (
    refalrts::char_term('w', pmode) || refalrts::char_term('W', pmode)
  ) {
    mode = "w";
  } else if (
    refalrts::char_term('a', pmode) || refalrts::char_term('A', pmode)
  ) {
    mode = "a";
  } else if (refalrts::brackets_term(mode_b, mode_e, pmode)) {
    char mode_str[100] = { '\0' };  // должно хватить
    unsigned len =
      refalrts::read_chars(mode_str, sizeof(mode_str) - 1, mode_b, mode_e);

    if (! refalrts::empty_seq(mode_b, mode_e) || len == 0) {
      return refalrts::cRecognitionImpossible;
    }

    mode = mode_str;
  } else if (refalrts::cDataIdentifier == pmode->tag) {
    mode = pmode->ident_info->name();
  } else {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter pfile_handle = 0;
  if (
    ! file_handle_left(pfile_handle, content_b, content_e)
    || refalrts::cDataNumber != pfile_handle->tag
  ) {
    return refalrts::cRecognitionImpossible;
  }

  char filename[FILENAME_MAX + 1] = { '\0' };
  refalrts::read_chars(filename, FILENAME_MAX, content_b, content_e);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  if (! reopen_handle(pfile_handle, filename, mode.c_str())) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 8055 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Open("Open", 0U, 0U, func_Open);

#line 1335 "Library.sref"
namespace {

struct OrdConv {
  bool for_convert(refalrts::Iter item) {
    return refalrts::cDataChar == item->tag;
  }

  void convert(refalrts::Iter item) {
    item->tag = refalrts::cDataNumber;
    item->number_info = static_cast<unsigned char>(item->char_info);
  }
};

}  // unnamed namespace
#line 8075 "Library.cpp"

static refalrts::FnResult func_Ord(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1353 "Library.sref"
  return convert(arg_begin, arg_end, OrdConv());
#line 8080 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Ord("Ord", 0U, 0U, func_Ord);


static refalrts::FnResult func_Print(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & Print/4 e.AnyExpression#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.AnyExpression#1 as range 2
  //DEBUG: e.AnyExpression#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & __Step-Start/4 } >/5 </6 & Put-Aux/7 # stdout/8 Tile{ AsIs: e.AnyExpression#1/2 } >/9 </10 & __Step-End/11 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_close_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], ref_Putm_Aux.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[8], ident_stdout ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_u_u_Stepm_Start.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[9], context[11] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Print("Print", 0U, 0U, func_Print);


static refalrts::FnResult func_Prout(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & Prout/4 e.AnyExpression#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.AnyExpression#1 as range 2
  //DEBUG: e.AnyExpression#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & __Step-Start/4 } >/5 </6 & Putout-Aux/7 # stdout/8 Tile{ AsIs: e.AnyExpression#1/2 } >/9 </10 & __Step-End/11 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_close_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], ref_Putoutm_Aux.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[8], ident_stdout ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_u_u_Stepm_Start.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[9], context[11] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Prout("Prout", 0U, 0U, func_Prout);


static refalrts::FnResult func_Proud(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 5 elems
  refalrts::Iter context[5];
  refalrts::zeros( context, 5 );
  // </0 & Proud/4 e.AnyExpression#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.AnyExpression#1 as range 2
  //DEBUG: e.AnyExpression#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Prout/4 AsIs: e.AnyExpression#1/2 AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Prout.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Proud("Proud", 0U, 0U, func_Proud);


static refalrts::FnResult func_Trout(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 5 elems
  refalrts::Iter context[5];
  refalrts::zeros( context, 5 );
  // </0 & Trout/4 e.AnyExpression#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.AnyExpression#1 as range 2
  //DEBUG: e.AnyExpression#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Prout/4 AsIs: e.AnyExpression#1/2 AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Prout.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Trout("Trout", 0U, 0U, func_Trout);


static refalrts::FnResult func_Put(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & Put/4 s.FileNo#1/5 e.AnyExpression#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.AnyExpression#1 as range 2
  //DEBUG: s.FileNo#1: 5
  //DEBUG: e.AnyExpression#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & __Step-Start/4 } >/6 </7 & Autoopen/8 'w'/9 Tile{ AsIs: s.FileNo#1/5 } >/10 </11 & Put-Aux/12 </13 & ZeroHandle/14 s.FileNo#1/5/15 # stderr/16 >/17 Tile{ AsIs: e.AnyExpression#1/2 } >/18 </19 & __Step-End/20 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_Autoopen.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[9], 'w' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[12], ref_Putm_Aux.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], ref_ZeroHandle.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[15], context[5]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[16], ident_stderr ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[20], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_u_u_Stepm_Start.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[19] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[18], context[20] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[10], context[17] );
  res = refalrts::splice_evar( res, context[5], context[5] );
  res = refalrts::splice_evar( res, context[6], context[9] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Put("Put", 0U, 0U, func_Put);

#line 1394 "Library.sref"
namespace cookie_ns {

enum {
  cFlags_ReturnHandle   = 1 << 3,
  cFlags_Transparent    = 1 << 5,
  cFlags_NoEOL          = 1 << 8,
};

extern refalrts::FnResult fwrite_line(
  refalrts::Iter arg_begin, refalrts::Iter arg_end, unsigned flags
);

}  // namespace cookie_ns
#line 8329 "Library.cpp"

static refalrts::FnResult func_Putm_Aux(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1411 "Library.sref"
  return cookie_ns::fwrite_line(
    arg_begin, arg_end, cookie_ns::cFlags_Transparent
  );
#line 8336 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Putm_Aux("Put-Aux", 877573369U, 332537286U, func_Putm_Aux);

#line 1418 "Library.sref"
refalrts::FnResult cookie_ns::fwrite_line(
  refalrts::Iter arg_begin, refalrts::Iter arg_end, unsigned flags
) {
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;

  if (! file_handle_left(pfile_handle, content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = extract_file_handle(pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  if (ferror(handle)) {
    return refalrts::cRecognitionImpossible;
  }

  int printf_res = 0;

  for (
    refalrts::Iter p = content_b, end = content_e;
    printf_res >= 0 && ! refalrts::empty_seq(p, end);
    refalrts::move_left(p, end)
  ) {
    switch(p->tag) {
      case refalrts::cDataChar:
        printf_res = fprintf(handle, "%c", p->char_info);
        break;

      case refalrts::cDataNumber:
        printf_res = fprintf(handle, "%u ", p->number_info);
        break;

      case refalrts::cDataFunction:
        printf_res = fprintf(handle, "%s ", p->function_info->name.name);
        break;

      case refalrts::cDataIdentifier:
        printf_res = fprintf(handle, "%s ", p->ident_info->name());
        break;

      case refalrts::cDataOpenADT:
        printf_res = fprintf(handle, "[");
        break;

      case refalrts::cDataCloseADT:
        printf_res = fprintf(handle, "]");
        break;

      case refalrts::cDataOpenBracket:
        printf_res = fprintf(handle, "(");
        break;

      case refalrts::cDataCloseBracket:
        printf_res = fprintf(handle, ")");
        break;

      case refalrts::cDataFile:
        printf_res = fprintf(handle, "*%p", p->file_info);
        break;

      case refalrts::cDataClosure:
        printf_res = fprintf(handle, "{ ");
        p = refalrts::unwrap_closure(p);
        break;

      case refalrts::cDataClosureHead:
        printf_res = fprintf(handle, "[%u] ", p->number_info);
        break;

      case refalrts::cDataUnwrappedClosure:
        printf_res = fprintf(handle, "} ");
        refalrts::wrap_closure(p);
        break;

      default:
        refalrts_switch_default_violation(p->tag);
    }
  }

  if (printf_res >= 0 && ! (flags & cFlags_NoEOL)) {
    printf_res = fprintf(handle, "\n");
  }

  if (printf_res < 0) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter res = arg_begin;
  if (flags & cFlags_Transparent) {
    res = refalrts::splice_evar(res, content_b, content_e);
  }

  if (flags & cFlags_ReturnHandle) {
    refalrts::splice_stvar(res, pfile_handle);
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
}
#line 8447 "Library.cpp"

static refalrts::FnResult func_Putout(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & Putout/4 s.FileNo#1/5 e.AnyExpression#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.AnyExpression#1 as range 2
  //DEBUG: s.FileNo#1: 5
  //DEBUG: e.AnyExpression#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & __Step-Start/4 } >/6 </7 & Autoopen/8 'w'/9 Tile{ AsIs: s.FileNo#1/5 } >/10 </11 & Putout-Aux/12 </13 & ZeroHandle/14 s.FileNo#1/5/15 # stderr/16 >/17 Tile{ AsIs: e.AnyExpression#1/2 } >/18 </19 & __Step-End/20 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_Autoopen.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[9], 'w' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[12], ref_Putoutm_Aux.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], ref_ZeroHandle.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[15], context[5]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[16], ident_stderr ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[20], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_u_u_Stepm_Start.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[19] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[18], context[20] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[10], context[17] );
  res = refalrts::splice_evar( res, context[5], context[5] );
  res = refalrts::splice_evar( res, context[6], context[9] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Putout("Putout", 0U, 0U, func_Putout);


static refalrts::FnResult func_Putoutm_Aux(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1539 "Library.sref"
  return cookie_ns::fwrite_line(arg_begin, arg_end, 0);
#line 8528 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Putoutm_Aux("Putout-Aux", 877573369U, 332537286U, func_Putoutm_Aux);


static refalrts::FnResult func_gen_Rp_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 26 elems
  refalrts::Iter context[26];
  refalrts::zeros( context, 26 );
  // </0 & Rp:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Rp:1/4 (/7 e.new#1/5 )/8 (/11 e.new#2/9 )/12 e.new#3/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.new#1 as range 5
  // closed e.new#2 as range 9
  // closed e.new#3 as range 2
  do {
    // </0 & Rp:1/4 (/7 e.Key#1/5 )/8 (/11 e.NewValue#1/9 )/12 e.Values-B#2/15 (/21 e.Key#1/23 '='/25 e.OldValue#2/19 )/22 e.Values-E#2/17 >/1
    context[13] = context[2];
    context[14] = context[3];
    // closed e.Key#1 as range 5
    // closed e.NewValue#1 as range 9
    context[15] = 0;
    context[16] = 0;
    refalrts::start_e_loop();
    do {
      context[17] = context[13];
      context[18] = context[14];
      context[19] = 0;
      context[20] = 0;
      context[21] = refalrts::brackets_left( context[19], context[20], context[17], context[18] );
      if( ! context[21] )
        continue;
      refalrts::bracket_pointers(context[21], context[22]);
      if( ! refalrts::repeated_evar_left( context[23], context[24], context[5], context[6], context[19], context[20] ) )
        continue;
      context[25] = refalrts::char_left( '=', context[19], context[20] );
      if( ! context[25] )
        continue;
      // closed e.OldValue#2 as range 19
      // closed e.Values-E#2 as range 17
      //DEBUG: e.Key#1: 5
      //DEBUG: e.NewValue#1: 9
      //DEBUG: e.Values-B#2: 15
      //DEBUG: e.OldValue#2: 19
      //DEBUG: e.Values-E#2: 17

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} e.Key#1/5 )/8 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} e.OldValue#2/19 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 } Tile{ HalfReuse: & Buried/12 AsIs: e.Values-B#2/15 AsIs: (/21 AsIs: e.Key#1/23 AsIs: '='/25 } Tile{ AsIs: e.NewValue#1/9 } Tile{ AsIs: )/22 AsIs: e.Values-E#2/17 AsIs: >/1 } Tile{ HalfReuse: </11 } Tile{ Reuse: & __Step-End/4 HalfReuse: >/7 } Tile{ ]] }
      refalrts::reinit_name( context[12], ref_Buried.ref.function );
      refalrts::reinit_open_call( context[11] );
      refalrts::update_name( context[4], ref_u_u_Stepm_End.ref.function );
      refalrts::reinit_close_call( context[7] );
      refalrts::push_stack( context[7] );
      refalrts::push_stack( context[11] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[21], context[22] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = arg_end->next;
      res = refalrts::splice_evar( res, context[4], context[7] );
      res = refalrts::splice_evar( res, context[11], context[11] );
      res = refalrts::splice_evar( res, context[22], context[1] );
      res = refalrts::splice_evar( res, context[9], context[10] );
      res = refalrts::splice_evar( res, context[12], context[25] );
      refalrts::splice_to_freelist_open( context[0], res );
      return refalrts::cSuccess;
    } while ( refalrts::open_evar_advance( context[15], context[16], context[13], context[14] ) );
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Rp:1/4 (/7 e.Key#1/5 )/8 (/11 e.NewValue#1/9 )/12 e.Values#2/2 >/1
  // closed e.Key#1 as range 5
  // closed e.NewValue#1 as range 9
  // closed e.Values#2 as range 2
  //DEBUG: e.Key#1: 5
  //DEBUG: e.NewValue#1: 9
  //DEBUG: e.Values#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Buried/4 AsIs: (/7 AsIs: e.Key#1/5 HalfReuse: '='/8 } Tile{ AsIs: e.NewValue#1/9 } Tile{ AsIs: )/12 AsIs: e.Values#2/2 AsIs: >/1 } Tile{ HalfReuse: </11 } & __Step-End/13 >/14 Tile{ ]] }
  if( ! refalrts::alloc_name( context[13], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Buried.ref.function );
  refalrts::reinit_char( context[8], '=' );
  refalrts::reinit_open_call( context[11] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[12] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[12], context[1] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Rp_B1("Rp:1", 877573369U, 332537286U, func_gen_Rp_B1);


static refalrts::FnResult func_Rp(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & Rp/4 e.Key#1/5 '='/9 e.NewValue#1/7 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  refalrts::start_e_loop();
  do {
    context[7] = context[2];
    context[8] = context[3];
    context[9] = refalrts::char_left( '=', context[7], context[8] );
    if( ! context[9] )
      continue;
    // closed e.NewValue#1 as range 7
    //DEBUG: e.Key#1: 5
    //DEBUG: e.NewValue#1: 7

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 HalfReuse: [*]/4 } & Rp:1/10 (/11 Tile{ AsIs: e.Key#1/5 } Tile{ HalfReuse: )/9 } (/12 Tile{ AsIs: e.NewValue#1/7 } )/13 {*}/14 </15 & __Step-Start/16 >/17 </18 & Buried/19 >/20 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_name( context[10], ref_gen_Rp_B1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[12] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[13] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_unwrapped_closure( context[14], context[4] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[16], ref_u_u_Stepm_Start.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[19], ref_Buried.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[20] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_closure_head( context[4] );
    refalrts::reinit_close_bracket( context[9] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[17] );
    refalrts::push_stack( context[15] );
    refalrts::link_brackets( context[12], context[13] );
    refalrts::link_brackets( context[11], context[9] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[13], context[20] );
    res = refalrts::splice_evar( res, context[7], context[8] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[9], context[9] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[10], context[11] );
    refalrts::use( res );
    refalrts::wrap_closure( context[14] );
    return refalrts::cSuccess;
  } while ( refalrts::open_evar_advance( context[5], context[6], context[2], context[3] ) );
  return refalrts::cRecognitionImpossible;
}

static refalrts::NativeReference nat_ref_Rp("Rp", 0U, 0U, func_Rp);

#line 1565 "Library.sref"
namespace cookie_ns {

extern unsigned long raw_step();

extern unsigned long g_correction;

}  // namespace cookie_ns
#line 8741 "Library.cpp"

static refalrts::FnResult func_Step(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1576 "Library.sref"
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber step =
    static_cast<refalrts::RefalNumber>(
      cookie_ns::raw_step() - cookie_ns::g_correction
    );

  refalrts::reinit_number(arg_begin, step);
  refalrts::splice_to_freelist(pfunc, arg_end);

  return refalrts::cSuccess;
#line 8762 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Step("Step", 0U, 0U, func_Step);

#line 1597 "Library.sref"
unsigned long cookie_ns::raw_step() {
  unsigned long perfomance_counters[
    refalrts::cPerformanceCounter_COUNTERS_NUMBER
  ];

  refalrts::read_performance_counters(perfomance_counters);
  return perfomance_counters[refalrts::cPerformanceCounter_TotalSteps];
}

namespace cookie_ns {

unsigned long g_correction = 1;  // call of Go is not countered

unsigned long g_start_step = 0;

}  // namespace cookie_ns
#line 8784 "Library.cpp"

static refalrts::FnResult func_u_u_Stepm_Start(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1621 "Library.sref"
  if (0 != cookie_ns::g_start_step) {
    return refalrts::cRecognitionImpossible;
  }
  cookie_ns::g_start_step = cookie_ns::raw_step();

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 8795 "Library.cpp"
}

static refalrts::NativeReference nat_ref_u_u_Stepm_Start("__Step-Start", 0U, 0U, func_u_u_Stepm_Start);


static refalrts::FnResult func_u_u_Stepm_End(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1633 "Library.sref"
  if (0 == cookie_ns::g_start_step) {
    return refalrts::cRecognitionImpossible;
  }
  cookie_ns::g_correction +=
    (cookie_ns::raw_step() - cookie_ns::g_start_step) + 1;
  cookie_ns::g_start_step = 0;

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 8812 "Library.cpp"
}

static refalrts::NativeReference nat_ref_u_u_Stepm_End("__Step-End", 0U, 0U, func_u_u_Stepm_End);


static refalrts::FnResult func_gen_Sub_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Sub$2=1/4 (/7 e.First#2/5 )/8 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#2 as range 5
  // closed e.Second#2 as range 2
  //DEBUG: e.First#2: 5
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sub-Normed/4 AsIs: (/7 AsIs: e.First#2/5 AsIs: )/8 AsIs: e.Second#2/2 AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Subm_Normed.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Sub_S2A1("Sub$2=1", 877573369U, 332537286U, func_gen_Sub_S2A1);


static refalrts::FnResult func_Sub(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Sub/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  do {
    // </0 & Sub/4 s.First#1/7 s.Second#1/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.First#1: 7
    //DEBUG: s.Second#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sub-Digits/4 AsIs: s.First#1/7 AsIs: s.Second#1/8 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Subm_Digits.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Sub/4 e.ArithmArg#1/2 >/1
  // closed e.ArithmArg#1 as range 2
  //DEBUG: e.ArithmArg#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & Sub$2=1/6 Tile{ AsIs: </0 Reuse: & NormArithmArg/4 AsIs: e.ArithmArg#1/2 AsIs: >/1 } >/7 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_gen_Sub_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[7] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormArithmArg.ref.function );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[7], context[7] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Sub("Sub", 0U, 0U, func_Sub);


static refalrts::FnResult func_Subm_Digits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1661 "Library.sref"
  ARITHM_PRELUDE

  if (first >= second) {
    refalrts::reinit_number(arg_begin, first - second);
    refalrts::splice_to_freelist(pFunc, arg_end);
  } else {
    refalrts::reinit_char(arg_begin, '-');
    refalrts::reinit_number(pFunc, second - first);
    refalrts::splice_to_freelist(pFirst, arg_end);
  }

  return refalrts::cSuccess;
#line 8933 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Subm_Digits("Sub-Digits", 877573369U, 332537286U, func_Subm_Digits);


static refalrts::FnResult func_Subm_Normed(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & Sub-Normed/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Sub-Normed/4 (/7 s.new#1/9 e.new#2/5 )/8 s.new#3/10 e.new#4/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#2 as range 5
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#4 as range 2
  do {
    // </0 & Sub-Normed/4 (/7 '+'/9 e.new#5/5 )/8 s.new#6/10 e.new#7/2 >/1
    if( ! refalrts::char_term( '+', context[9] ) )
      continue;
    // closed e.new#5 as range 5
    // closed e.new#7 as range 2
    do {
      // </0 & Sub-Normed/4 (/7 '+'/9 e.First#1/5 )/8 '+'/10 e.Second#1/2 >/1
      if( ! refalrts::char_term( '+', context[10] ) )
        continue;
      // closed e.First#1 as range 5
      // closed e.Second#1 as range 2
      //DEBUG: e.First#1: 5
      //DEBUG: e.Second#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} '+'/9 {REMOVED TILE} )/8 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sub-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/5 } Tile{ HalfReuse: )/10 AsIs: e.Second#1/2 AsIs: >/1 ]] }
      refalrts::update_name( context[4], ref_Subm_Nat.ref.function );
      refalrts::reinit_close_bracket( context[10] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[7], context[10] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[10];
      res = refalrts::splice_evar( res, context[5], context[6] );
      refalrts::splice_to_freelist_open( context[7], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & Sub-Normed/4 (/7 '+'/9 e.First#1/5 )/8 '-'/10 e.Second#1/2 >/1
      if( ! refalrts::char_term( '-', context[10] ) )
        continue;
      // closed e.First#1 as range 5
      // closed e.Second#1 as range 2
      //DEBUG: e.First#1: 5
      //DEBUG: e.Second#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} '+'/9 {REMOVED TILE} )/8 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Add-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/5 } Tile{ HalfReuse: )/10 AsIs: e.Second#1/2 AsIs: >/1 ]] }
      refalrts::update_name( context[4], ref_Addm_Nat.ref.function );
      refalrts::reinit_close_bracket( context[10] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[7], context[10] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[10];
      res = refalrts::splice_evar( res, context[5], context[6] );
      refalrts::splice_to_freelist_open( context[7], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Sub-Normed/4 (/7 '+'/9 e.First#1/5 )/8 0/10 >/1
    if( ! refalrts::number_term( 0UL, context[10] ) )
      continue;
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    // closed e.First#1 as range 5
    //DEBUG: e.First#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Sub-Normed/4 (/7 '+'/9 {REMOVED TILE} )/8 0/10 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: e.First#1/5 } Tile{ ]] }
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[5], context[6] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Sub-Normed/4 (/7 '-'/9 e.new#5/5 )/8 s.new#6/10 e.new#7/2 >/1
    if( ! refalrts::char_term( '-', context[9] ) )
      continue;
    // closed e.new#5 as range 5
    // closed e.new#7 as range 2
    do {
      // </0 & Sub-Normed/4 (/7 '-'/9 e.First#1/5 )/8 '+'/10 e.Second#1/2 >/1
      if( ! refalrts::char_term( '+', context[10] ) )
        continue;
      // closed e.First#1 as range 5
      // closed e.Second#1 as range 2
      //DEBUG: e.First#1: 5
      //DEBUG: e.Second#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} '+'/10 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ HalfReuse: '-'/0 HalfReuse: </4 HalfReuse: & Add-Nat/7 HalfReuse: (/9 AsIs: e.First#1/5 AsIs: )/8 } Tile{ AsIs: e.Second#1/2 } Tile{ AsIs: >/1 ]] }
      refalrts::reinit_char( context[0], '-' );
      refalrts::reinit_open_call( context[4] );
      refalrts::reinit_name( context[7], ref_Addm_Nat.ref.function );
      refalrts::reinit_open_bracket( context[9] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[4] );
      refalrts::link_brackets( context[9], context[8] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[2], context[3] );
      refalrts::splice_to_freelist_open( context[8], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & Sub-Normed/4 (/7 '-'/9 e.First#1/5 )/8 '-'/10 e.Second#1/2 >/1
      if( ! refalrts::char_term( '-', context[10] ) )
        continue;
      // closed e.First#1 as range 5
      // closed e.Second#1 as range 2
      //DEBUG: e.First#1: 5
      //DEBUG: e.Second#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Neg/4 HalfReuse: </7 HalfReuse: & Sub-Nat/9 } Tile{ HalfReuse: (/8 } Tile{ AsIs: e.First#1/5 } Tile{ HalfReuse: )/10 AsIs: e.Second#1/2 AsIs: >/1 } >/11 Tile{ ]] }
      if( ! refalrts::alloc_close_call( context[11] ) )
        return refalrts::cNoMemory;
      refalrts::update_name( context[4], ref_Neg.ref.function );
      refalrts::reinit_open_call( context[7] );
      refalrts::reinit_name( context[9], ref_Subm_Nat.ref.function );
      refalrts::reinit_open_bracket( context[8] );
      refalrts::reinit_close_bracket( context[10] );
      refalrts::push_stack( context[11] );
      refalrts::push_stack( context[0] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[7] );
      refalrts::link_brackets( context[8], context[10] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = arg_end->next;
      res = refalrts::splice_evar( res, context[11], context[11] );
      res = refalrts::splice_evar( res, context[10], context[1] );
      res = refalrts::splice_evar( res, context[5], context[6] );
      res = refalrts::splice_evar( res, context[8], context[8] );
      refalrts::use( res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Sub-Normed/4 (/7 '-'/9 e.First#1/5 )/8 0/10 >/1
    if( ! refalrts::number_term( 0UL, context[10] ) )
      continue;
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    // closed e.First#1 as range 5
    //DEBUG: e.First#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} & Sub-Normed/4 (/7 '-'/9 {REMOVED TILE} )/8 0/10 >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: '-'/0 } Tile{ AsIs: e.First#1/5 } Tile{ ]] }
    refalrts::reinit_char( context[0], '-' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[5], context[6] );
    refalrts::splice_to_freelist_open( context[0], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Sub-Normed/4 (/7 0/9 )/8 s.new#5/10 e.new#6/2 >/1
  if( ! refalrts::number_term( 0UL, context[9] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#6 as range 2
  do {
    // </0 & Sub-Normed/4 (/7 0/9 )/8 '+'/10 e.Second#1/2 >/1
    if( ! refalrts::char_term( '+', context[10] ) )
      continue;
    // closed e.Second#1 as range 2
    //DEBUG: e.Second#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} & Sub-Normed/4 (/7 0/9 )/8 '+'/10 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: '-'/0 } Tile{ AsIs: e.Second#1/2 } Tile{ ]] }
    refalrts::reinit_char( context[0], '-' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[2], context[3] );
    refalrts::splice_to_freelist_open( context[0], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Sub-Normed/4 (/7 0/9 )/8 '-'/10 e.Second#1/2 >/1
    if( ! refalrts::char_term( '-', context[10] ) )
      continue;
    // closed e.Second#1 as range 2
    //DEBUG: e.Second#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Sub-Normed/4 (/7 0/9 )/8 '-'/10 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: e.Second#1/2 } Tile{ ]] }
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[2], context[3] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Sub-Normed/4 (/7 0/9 )/8 0/10 >/1
  if( ! refalrts::number_term( 0UL, context[10] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Sub-Normed/4 (/7 0/9 )/8 0/10 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
  refalrts::reinit_number( context[1], 0UL );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Subm_Normed("Sub-Normed", 877573369U, 332537286U, func_Subm_Normed);


static refalrts::FnResult func_Neg(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  // </0 & Neg/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  do {
    // </0 & Neg/4 s.new#1/7 e.new#2/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    // closed e.new#2 as range 5
    do {
      // </0 & Neg/4 0/7 >/1
      if( ! refalrts::number_term( 0UL, context[7] ) )
        continue;
      if( ! refalrts::empty_seq( context[5], context[6] ) )
        continue;

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} </0 & Neg/4 0/7 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
      refalrts::reinit_number( context[1], 0UL );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      refalrts::splice_to_freelist_open( trash_prev, res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Neg/4 '-'/7 e.Digits#1/5 >/1
    if( ! refalrts::char_term( '-', context[7] ) )
      continue;
    // closed e.Digits#1 as range 5
    //DEBUG: e.Digits#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Neg/4 '-'/7 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: e.Digits#1/5 } Tile{ ]] }
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[5], context[6] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Neg/4 e.Digits#1/2 >/1
  // closed e.Digits#1 as range 2
  //DEBUG: e.Digits#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & Neg/4 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: '-'/0 } Tile{ AsIs: e.Digits#1/2 } Tile{ ]] }
  refalrts::reinit_char( context[0], '-' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Neg("Neg", 877573369U, 332537286U, func_Neg);


static refalrts::FnResult func_gen_Subm_Nat_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  // </0 & Sub-Nat:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Sub-Nat:1/4 (/7 e.new#1/5 )/8 (/11 e.new#2/9 )/12 s.new#3/13 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.new#1 as range 5
  // closed e.new#2 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // </0 & Sub-Nat:1/4 (/7 e.First#1/5 )/8 (/11 e.Second#1/9 )/12 '+'/13 >/1
    if( ! refalrts::char_term( '+', context[13] ) )
      continue;
    // closed e.First#1 as range 5
    // closed e.Second#1 as range 9
    //DEBUG: e.First#1: 5
    //DEBUG: e.Second#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} (/11 {REMOVED TILE} )/12 '+'/13 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sub-Nat-Nat/4 AsIs: (/7 AsIs: e.First#1/5 AsIs: )/8 } Tile{ AsIs: e.Second#1/9 } Tile{ AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Subm_Natm_Nat.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[9], context[10] );
    refalrts::splice_to_freelist_open( context[8], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Sub-Nat:1/4 (/7 e.First#1/5 )/8 (/11 e.Second#1/9 )/12 '-'/13 >/1
    if( ! refalrts::char_term( '-', context[13] ) )
      continue;
    // closed e.First#1 as range 5
    // closed e.Second#1 as range 9
    //DEBUG: e.First#1: 5
    //DEBUG: e.Second#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} {REMOVED TILE} '-'/13 {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: '-'/0 HalfReuse: </4 } Tile{ HalfReuse: & Sub-Nat-Nat/8 AsIs: (/11 AsIs: e.Second#1/9 AsIs: )/12 } Tile{ AsIs: e.First#1/5 } Tile{ AsIs: >/1 ]] }
    refalrts::reinit_char( context[0], '-' );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[8], ref_Subm_Natm_Nat.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::link_brackets( context[11], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[5], context[6] );
    res = refalrts::splice_evar( res, context[8], context[12] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Sub-Nat:1/4 (/7 e.First#1/5 )/8 (/11 e.Second#1/9 )/12 '0'/13 >/1
  if( ! refalrts::char_term( '0', context[13] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.First#1 as range 5
  // closed e.Second#1 as range 9
  //DEBUG: e.First#1: 5
  //DEBUG: e.Second#1: 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Sub-Nat:1/4 (/7 e.First#1/5 )/8 (/11 e.Second#1/9 )/12 '0'/13 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
  refalrts::reinit_number( context[1], 0UL );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Subm_Nat_B1("Sub-Nat:1", 877573369U, 332537286U, func_gen_Subm_Nat_B1);


static refalrts::FnResult func_Subm_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 22 elems
  refalrts::Iter context[22];
  refalrts::zeros( context, 22 );
  // </0 & Sub-Nat/4 (/7 e.First#1/5 )/8 e.Second#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#1 as range 5
  // closed e.Second#1 as range 2
  //DEBUG: e.First#1: 5
  //DEBUG: e.Second#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </9 [*]/10 & Sub-Nat:1/11 (/12 e.First#1/5/13 )/15 (/16 e.Second#1/2/17 )/19 {*}/20 Tile{ AsIs: </0 Reuse: & Compare-Nat/4 AsIs: (/7 AsIs: e.First#1/5 AsIs: )/8 AsIs: e.Second#1/2 AsIs: >/1 } >/21 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_closure_head( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], ref_gen_Subm_Nat_B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[13], context[14], context[5], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[17], context[18], context[2], context[3]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[20], context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[21] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Comparem_Nat.ref.function );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::link_brackets( context[16], context[19] );
  refalrts::link_brackets( context[12], context[15] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[21], context[21] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[9], context[20] );
  refalrts::use( res );
  refalrts::wrap_closure( context[20] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Subm_Nat("Sub-Nat", 877573369U, 332537286U, func_Subm_Nat);


static refalrts::FnResult func_Subm_Natm_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & Sub-Nat-Nat/4 (/7 e.First#1/5 )/8 e.Second#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#1 as range 5
  // closed e.Second#1 as range 2
  //DEBUG: e.First#1: 5
  //DEBUG: e.Second#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </9 & LeadingZeros/10 Tile{ AsIs: </0 Reuse: & DoSub-Nat-Nat/4 AsIs: (/7 AsIs: e.First#1/5 AsIs: )/8 AsIs: e.Second#1/2 AsIs: >/1 } >/11 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_LeadingZeros.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_DoSubm_Natm_Nat.ref.function );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Subm_Natm_Nat("Sub-Nat-Nat", 877573369U, 332537286U, func_Subm_Natm_Nat);


static refalrts::FnResult func_gen_DoSubm_Natm_Nat_S1B2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 19 elems
  refalrts::Iter context[19];
  refalrts::zeros( context, 19 );
  // </0 & DoSub-Nat-Nat$1:2/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & DoSub-Nat-Nat$1:2/4 (/7 e.new#1/5 )/8 (/11 e.new#2/9 )/12 e.new#3/2 s.new#4/13 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.new#1 as range 5
  // closed e.new#2 as range 9
  if( ! refalrts::svar_right( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#3 as range 2
  do {
    // </0 & DoSub-Nat-Nat$1:2/4 (/7 e.First#1/5 )/8 (/11 e.Second#1/9 )/12 s.LastDigit#2/13 >/1
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    // closed e.First#1 as range 5
    // closed e.Second#1 as range 9
    //DEBUG: s.LastDigit#2: 13
    //DEBUG: e.First#1: 5
    //DEBUG: e.Second#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} (/11 {REMOVED TILE} {REMOVED TILE} s.LastDigit#2/13 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & DoSub-Nat-Nat/4 AsIs: (/7 AsIs: e.First#1/5 AsIs: )/8 } Tile{ AsIs: e.Second#1/9 } Tile{ HalfReuse: >/12 } Tile{ HalfReuse: s.LastDigit2 #13/1 ]] }
    refalrts::update_name( context[4], ref_DoSubm_Natm_Nat.ref.function );
    refalrts::reinit_close_call( context[12] );
    refalrts::reinit_svar( context[1], context[13] );
    refalrts::push_stack( context[12] );
    refalrts::push_stack( context[0] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    refalrts::splice_to_freelist_open( context[8], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & DoSub-Nat-Nat$1:2/4 (/7 e.First#1/5 )/8 (/11 e.Second#1/9 )/12 '*'/14 s.LastDigit#2/13 >/1
  context[14] = refalrts::char_left( '*', context[2], context[3] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.First#1 as range 5
  // closed e.Second#1 as range 9
  //DEBUG: s.LastDigit#2: 13
  //DEBUG: e.First#1: 5
  //DEBUG: e.Second#1: 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.LastDigit#2/13 {REMOVED TILE}
  //RESULT: Tile{ [[ } </15 & DoSub-Nat-Nat/16 (/17 Tile{ AsIs: </0 Reuse: & Sub-Nat-Nat/4 AsIs: (/7 AsIs: e.First#1/5 AsIs: )/8 HalfReuse: 1/11 } Tile{ HalfReuse: >/14 } Tile{ AsIs: )/12 } Tile{ AsIs: e.Second#1/9 } >/18 Tile{ HalfReuse: s.LastDigit2 #13/1 ]] }
  if( ! refalrts::alloc_open_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[16], ref_DoSubm_Natm_Nat.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Subm_Natm_Nat.ref.function );
  refalrts::reinit_number( context[11], 1UL );
  refalrts::reinit_close_call( context[14] );
  refalrts::reinit_svar( context[1], context[13] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[15] );
  refalrts::link_brackets( context[17], context[12] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[18], context[18] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[14], context[14] );
  res = refalrts::splice_evar( res, context[0], context[11] );
  res = refalrts::splice_evar( res, context[15], context[17] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_DoSubm_Natm_Nat_S1B2("DoSub-Nat-Nat$1:2", 877573369U, 332537286U, func_gen_DoSubm_Natm_Nat_S1B2);


static refalrts::FnResult func_gen_DoSubm_Natm_Nat_S1B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1713 "Library.sref"
        ARITHM_PRELUDE

        refalrts::RefalNumber diff = first - second;

        if (diff <= first) {
          pFirst->number_info = diff;
          refalrts::splice_to_freelist(arg_begin, pFunc);
          refalrts::splice_to_freelist(pSecond, arg_end);
        } else {
          refalrts::reinit_char(pFirst, '*');
          pSecond->number_info = diff;
          refalrts::splice_to_freelist(arg_begin, pFunc);
          refalrts::splice_to_freelist(arg_end, arg_end);
        }

        return refalrts::cSuccess;
#line 9624 "Library.cpp"
}

static refalrts::NativeReference nat_ref_gen_DoSubm_Natm_Nat_S1B1("DoSub-Nat-Nat$1:1", 877573369U, 332537286U, func_gen_DoSubm_Natm_Nat_S1B1);


static refalrts::FnResult func_DoSubm_Natm_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 22 elems
  refalrts::Iter context[22];
  refalrts::zeros( context, 22 );
  // </0 & DoSub-Nat-Nat/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & DoSub-Nat-Nat/4 (/7 e.new#1/5 )/8 e.new#2/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#1 as range 5
  // closed e.new#2 as range 2
  do {
    // </0 & DoSub-Nat-Nat/4 (/7 e.First#1/9 s.FirstLast#1/13 )/8 e.Second#1/11 s.SecondLast#1/14 >/1
    context[9] = context[5];
    context[10] = context[6];
    context[11] = context[2];
    context[12] = context[3];
    if( ! refalrts::svar_right( context[13], context[9], context[10] ) )
      continue;
    // closed e.First#1 as range 9
    if( ! refalrts::svar_right( context[14], context[11], context[12] ) )
      continue;
    // closed e.Second#1 as range 11
    //DEBUG: s.FirstLast#1: 13
    //DEBUG: e.First#1: 9
    //DEBUG: s.SecondLast#1: 14
    //DEBUG: e.Second#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 HalfReuse: [*]/4 HalfReuse: & DoSub-Nat-Nat$1:2/7 } (/15 Tile{ AsIs: e.First#1/9 } )/16 (/17 Tile{ AsIs: e.Second#1/11 } Tile{ AsIs: )/8 } {*}/18 </19 & DoSub-Nat-Nat$1:1/20 Tile{ AsIs: s.FirstLast#1/13 } Tile{ AsIs: s.SecondLast#1/14 AsIs: >/1 } >/21 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_unwrapped_closure( context[18], context[4] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[20], ref_gen_DoSubm_Natm_Nat_S1B1.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_closure_head( context[4] );
    refalrts::reinit_name( context[7], ref_gen_DoSubm_Natm_Nat_S1B2.ref.function );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[19] );
    refalrts::link_brackets( context[17], context[8] );
    refalrts::link_brackets( context[15], context[16] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[21], context[21] );
    res = refalrts::splice_evar( res, context[14], context[1] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    res = refalrts::splice_evar( res, context[18], context[20] );
    res = refalrts::splice_evar( res, context[8], context[8] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    refalrts::use( res );
    refalrts::wrap_closure( context[18] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & DoSub-Nat-Nat/4 (/7 e.First#1/5 )/8 >/1
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.First#1 as range 5
  //DEBUG: e.First#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & DoSub-Nat-Nat/4 (/7 {REMOVED TILE} )/8 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.First#1/5 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DoSubm_Natm_Nat("DoSub-Nat-Nat", 877573369U, 332537286U, func_DoSubm_Natm_Nat);


static refalrts::FnResult func_LeadingZeros(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 8 elems
  refalrts::Iter context[8];
  refalrts::zeros( context, 8 );
  // </0 & LeadingZeros/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  do {
    // </0 & LeadingZeros/4 0/7 e.new#1/5 >/1
    context[5] = context[2];
    context[6] = context[3];
    context[7] = refalrts::number_left( 0UL, context[5], context[6] );
    if( ! context[7] )
      continue;
    // closed e.new#1 as range 5
    do {
      // </0 & LeadingZeros/4 0/7 >/1
      if( ! refalrts::empty_seq( context[5], context[6] ) )
        continue;

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} </0 & LeadingZeros/4 0/7 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
      refalrts::reinit_number( context[1], 0UL );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      refalrts::splice_to_freelist_open( trash_prev, res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & LeadingZeros/4 0/7 e.Digits#1/5 >/1
    // closed e.Digits#1 as range 5
    //DEBUG: e.Digits#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: </4 HalfReuse: & LeadingZeros/7 AsIs: e.Digits#1/5 AsIs: >/1 ]] }
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], ref_LeadingZeros.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[4];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & LeadingZeros/4 e.Digits#1/2 >/1
  // closed e.Digits#1 as range 2
  //DEBUG: e.Digits#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & LeadingZeros/4 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: e.Digits#1/2 } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_LeadingZeros("LeadingZeros", 877573369U, 332537286U, func_LeadingZeros);


static refalrts::FnResult func_gen_Symb_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  // </0 & Symb:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Symb:1/4 (/7 e.new#1/5 )/8 s.new#2/9 s.new#3/10 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // </0 & Symb:1/4 (/7 e.new#4/5 )/8 s.new#5/9 0/10 >/1
    if( ! refalrts::number_term( 0UL, context[10] ) )
      continue;
    // closed e.new#4 as range 5
    do {
      // </0 & Symb:1/4 (/7 e.NormedNumber#2/5 )/8 0/9 0/10 >/1
      if( ! refalrts::number_term( 0UL, context[9] ) )
        continue;
      // closed e.NormedNumber#2 as range 5
      //DEBUG: e.NormedNumber#2: 5

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} </0 & Symb:1/4 (/7 e.NormedNumber#2/5 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: '0'/8 HalfReuse: </9 HalfReuse: & __Step-End/10 AsIs: >/1 ]] }
      refalrts::reinit_char( context[8], '0' );
      refalrts::reinit_open_call( context[9] );
      refalrts::reinit_name( context[10], ref_u_u_Stepm_End.ref.function );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[9] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[8];
      refalrts::splice_to_freelist_open( trash_prev, res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Symb:1/4 (/7 e.NormedNumber#2/5 )/8 s.Sign#3/9 0/10 >/1
    // closed e.NormedNumber#2 as range 5
    //DEBUG: s.Sign#3: 9
    //DEBUG: e.NormedNumber#2: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} e.NormedNumber#2/5 )/8 s.Sign#3/9 {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: s.Sign3 #9/0 HalfReuse: '0'/4 HalfReuse: </7 } Tile{ HalfReuse: & __Step-End/10 AsIs: >/1 ]] }
    refalrts::reinit_svar( context[0], context[9] );
    refalrts::reinit_char( context[4], '0' );
    refalrts::reinit_open_call( context[7] );
    refalrts::reinit_name( context[10], ref_u_u_Stepm_End.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[7] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[10];
    refalrts::splice_to_freelist_open( context[7], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Symb:1/4 (/7 e.NormedNumber#2/5 )/8 s.Sign#3/9 s.Sign#3/10 >/1
    if( ! refalrts::repeated_stvar_term( context[10], context[9] ) )
      continue;
    // closed e.NormedNumber#2 as range 5
    //DEBUG: s.Sign#3: 9
    //DEBUG: e.NormedNumber#2: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.Sign#3/9 s.Sign#3/10 {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: s.Sign3 #10/0 HalfReuse: </4 HalfReuse: & Symb-Nat/7 AsIs: e.NormedNumber#2/5 HalfReuse: >/8 } </11 & __Step-End/12 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[12], ref_u_u_Stepm_End.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::reinit_svar( context[0], context[10] );
    refalrts::reinit_open_call( context[4] );
    refalrts::reinit_name( context[7], ref_Symbm_Nat.ref.function );
    refalrts::reinit_close_call( context[8] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[4] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[11], context[12] );
    refalrts::splice_to_freelist_open( context[8], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Symb:1/4 (/7 e.NormedNumber#2/5 )/8 s.Digit#3/9 '+'/10 >/1
  if( ! refalrts::char_term( '+', context[10] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.NormedNumber#2 as range 5
  //DEBUG: s.Digit#3: 9
  //DEBUG: e.NormedNumber#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.Digit#3/9 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Symb-Nat/4 } Tile{ AsIs: e.NormedNumber#2/5 } Tile{ HalfReuse: >/8 } Tile{ HalfReuse: </7 } Tile{ HalfReuse: & __Step-End/10 AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Symbm_Nat.ref.function );
  refalrts::reinit_close_call( context[8] );
  refalrts::reinit_open_call( context[7] );
  refalrts::reinit_name( context[10], ref_u_u_Stepm_End.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[10];
  res = refalrts::splice_evar( res, context[7], context[7] );
  res = refalrts::splice_evar( res, context[8], context[8] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Symb_B1("Symb:1", 877573369U, 332537286U, func_gen_Symb_B1);


static refalrts::FnResult func_gen_Symb_A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  // </0 & Symb=1/4 s.First#1/5 s.NormedSign#2/6 e.NormedNumber#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.NormedNumber#2 as range 2
  //DEBUG: s.First#1: 5
  //DEBUG: s.NormedSign#2: 6
  //DEBUG: e.NormedNumber#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </7 [*]/8 & Symb:1/9 (/10 Tile{ AsIs: e.NormedNumber#2/2 } Tile{ HalfReuse: )/0 HalfReuse: {*}/4 AsIs: s.First#1/5 AsIs: s.NormedSign#2/6 } Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_closure_head( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[9], ref_gen_Symb_B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[10] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_close_bracket( context[0] );
  refalrts::reinit_unwrapped_closure( context[4], context[8] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[7] );
  refalrts::link_brackets( context[10], context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[0], context[6] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[7], context[10] );
  refalrts::use( res );
  refalrts::wrap_closure( context[4] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Symb_A1("Symb=1", 877573369U, 332537286U, func_gen_Symb_A1);


static refalrts::FnResult func_Symb(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & Symb/4 s.First#1/5 e.Tail#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Tail#1 as range 2
  //DEBUG: s.First#1: 5
  //DEBUG: e.Tail#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </6 [*]/7 & Symb=1/8 s.First#1/5/9 {*}/10 </11 & __Step-Start/12 >/13 Tile{ AsIs: </0 Reuse: & NormNumber/4 AsIs: s.First#1/5 AsIs: e.Tail#1/2 AsIs: >/1 } >/14 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_closure_head( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_gen_Symb_A1.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[9], context[5]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[10], context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[12], ref_u_u_Stepm_Start.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormNumber.ref.function );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[11] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[14], context[14] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[6], context[13] );
  refalrts::use( res );
  refalrts::wrap_closure( context[10] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Symb("Symb", 0U, 0U, func_Symb);


static refalrts::FnResult func_gen_Symbm_Nat_S2A2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  // </0 & Symb-Nat$2=2/4 (/7 e.Div#2/5 )/8 (/11 e.Zeros#3/9 )/12 e.StrDigits#3/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.Div#2 as range 5
  // closed e.Zeros#3 as range 9
  // closed e.StrDigits#3 as range 2
  //DEBUG: e.Div#2: 5
  //DEBUG: e.Zeros#3: 9
  //DEBUG: e.StrDigits#3: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} (/7 {REMOVED TILE} )/8 (/11 e.Zeros#3/9 )/12 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Symb-Nat/4 } Tile{ AsIs: e.Div#2/5 } Tile{ AsIs: >/1 } Tile{ AsIs: e.StrDigits#3/2 } Tile{ ]] }
  refalrts::update_name( context[4], ref_Symbm_Nat.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Symbm_Nat_S2A2("Symb-Nat$2=2", 877573369U, 332537286U, func_gen_Symbm_Nat_S2A2);


static refalrts::FnResult func_gen_Symbm_Nat_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 23 elems
  refalrts::Iter context[23];
  refalrts::zeros( context, 23 );
  // </0 & Symb-Nat$2=1/4 (/7 e.Div#2/5 )/8 s.Mod#2/9 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Div#2 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Div#2: 5
  //DEBUG: s.Mod#2: 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </10 Tile{ HalfReuse: [*]/0 Reuse: & Symb-Nat$2=2/4 AsIs: (/7 AsIs: e.Div#2/5 AsIs: )/8 } {*}/11 </12 & DoLast/13 9/14 (/15"000000000"/16 </18 & StrFromInt/19 Tile{ AsIs: s.Mod#2/9 AsIs: >/1 } )/20 >/21 >/22 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[11], context[0] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[13], ref_DoLast.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[14], 9UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_chars( context[16], context[17], "000000000", 9 ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[19], ref_StrFromInt.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[22] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[0] );
  refalrts::update_name( context[4], ref_gen_Symbm_Nat_S2A2.ref.function );
  refalrts::push_stack( context[22] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[21] );
  refalrts::push_stack( context[12] );
  refalrts::link_brackets( context[15], context[20] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[18] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[20], context[22] );
  res = refalrts::splice_evar( res, context[9], context[1] );
  res = refalrts::splice_evar( res, context[11], context[19] );
  res = refalrts::splice_evar( res, context[0], context[8] );
  res = refalrts::splice_evar( res, context[10], context[10] );
  refalrts::use( res );
  refalrts::wrap_closure( context[11] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Symbm_Nat_S2A1("Symb-Nat$2=1", 877573369U, 332537286U, func_gen_Symbm_Nat_S2A1);


static refalrts::FnResult func_Symbm_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & Symb-Nat/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  do {
    // </0 & Symb-Nat/4 s.Number#1/7 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.Number#1: 7

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & StrFromInt/4 AsIs: s.Number#1/7 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_StrFromInt.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Symb-Nat/4 e.Number#1/2 >/1
  // closed e.Number#1 as range 2
  //DEBUG: e.Number#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Symb-Nat$2=1/4 } </5 & Divmod-Nat/6 (/7 Tile{ AsIs: e.Number#1/2 } )/8 1000000000/9 (/10 )/11 (/12 )/13 >/14 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_Divmodm_Nat.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[9], 1000000000UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_gen_Symbm_Nat_S2A1.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[5] );
  refalrts::link_brackets( context[12], context[13] );
  refalrts::link_brackets( context[10], context[11] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[8], context[14] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[5], context[7] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Symbm_Nat("Symb-Nat", 877573369U, 332537286U, func_Symbm_Nat);


static refalrts::FnResult func_Time(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1780 "Library.sref"
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();

  time_t timer;
  time(&timer);
  char *str_time = ctime(&timer);

  char *newline = strchr(str_time, '\n');
  if (newline) {
    *newline = '\0';
  }

  if (! refalrts::alloc_string(content_b, content_e, str_time)) {
    return refalrts::cNoMemory;
  }

  refalrts::splice_evar(arg_begin, content_b, content_e);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 10287 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Time("Time", 0U, 0U, func_Time);


static refalrts::FnResult func_Type(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1836 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  char type = '*';
  char subtype = '0';

  if (! refalrts::empty_seq(content_b, content_e)) {
    switch (content_b->tag) {
    case refalrts::cDataChar:
      {
        char ch = content_b->char_info;

        if (isdigit(ch)) {
          type = 'D';
        } else {
          if (isalpha(ch)) {
            type = 'L';
          } else if (isprint(ch)) {
            type = 'P';
          } else {
            type = 'O';
          }

          if (isupper(ch)) {
            subtype = 'u';
          } else {
            subtype = 'l';
          }
        }
      }
      break;

    case refalrts::cDataNumber:
      type = 'N';
      break;

    case refalrts::cDataFunction:
      type = 'F';
      subtype = 'g';
      break;

    case refalrts::cDataIdentifier:
      {
        const char *name = content_b->ident_info->name();

        type = 'W';
        subtype = 'q';
        if (isalpha(*name)) {
          while (
            *name != '\0' && (isalnum(*name) || *name == '_' || *name == '-')
          ) {
            ++name;
          }

          if (*name == '\0') {
            subtype = 'i';
          }
        }
      }
      break;

    case refalrts::cDataOpenADT:
      type = 'B';
      subtype = 'a';
      break;

    case refalrts::cDataOpenBracket:
      type = 'B';
      break;

    case refalrts::cDataFile:
      type = 'H';
      break;

    case refalrts::cDataClosure:
      type = 'F';
      subtype = 'c';
      break;

    default:
      refalrts_switch_default_violation(content_b->tag);
      // break;
    }
  }

  refalrts::reinit_char(arg_begin, type);
  refalrts::reinit_char(pfunc_name, subtype);
  refalrts::splice_to_freelist(arg_end, arg_end);

  return refalrts::cSuccess;
#line 10387 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Type("Type", 0U, 0U, func_Type);

#line 1936 "Library.sref"
namespace {

struct UpperConv {
  bool for_convert(refalrts::Iter item) {
    return refalrts::cDataChar == item->tag;
  }

  void convert(refalrts::Iter item) {
    item->char_info = static_cast<char>(toupper(item->char_info));
  }
};

}  // unnamed namespace
#line 10406 "Library.cpp"

static refalrts::FnResult func_Upper(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 1953 "Library.sref"
  return convert(arg_begin, arg_end, UpperConv());
#line 10411 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Upper("Upper", 0U, 0U, func_Upper);


static refalrts::FnResult func_Sysfun(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  // </0 & Sysfun/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Sysfun/4 s.new#1/5 e.new#2/2 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#2 as range 2
  do {
    // </0 & Sysfun/4 1/5 e.FileName#1/2 >/1
    if( ! refalrts::number_term( 1UL, context[5] ) )
      continue;
    // closed e.FileName#1 as range 2
    //DEBUG: e.FileName#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & __Step-Start/4 HalfReuse: >/5 } </6 & Sysfun-Xxin/7 Tile{ AsIs: e.FileName#1/2 } >/8 </9 & __Step-End/10 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[6] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[7], ref_Sysfunm_Xxin.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[8] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[9] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[10], ref_u_u_Stepm_End.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_u_u_Stepm_Start.ref.function );
    refalrts::reinit_close_call( context[5] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[6] );
    refalrts::push_stack( context[5] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[8], context[10] );
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[6], context[7] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Sysfun/4 2/5 e.FileName#1/2 (/8 s.Width#1/10 e.ObjectExpression#1/6 )/9 >/1
  if( ! refalrts::number_term( 2UL, context[5] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_right( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  // closed e.FileName#1 as range 2
  if( ! refalrts::svar_left( context[10], context[6], context[7] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.ObjectExpression#1 as range 6
  //DEBUG: e.FileName#1: 2
  //DEBUG: s.Width#1: 10
  //DEBUG: e.ObjectExpression#1: 6

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </11 & __Step-Start/12 Tile{ HalfReuse: >/0 HalfReuse: </4 HalfReuse: & Sysfun-Xxout/5 AsIs: e.FileName#1/2 AsIs: (/8 AsIs: s.Width#1/10 AsIs: e.ObjectExpression#1/6 AsIs: )/9 AsIs: >/1 } </13 & __Step-End/14 >/15 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[12], ref_u_u_Stepm_Start.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[15] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_close_call( context[0] );
  refalrts::reinit_open_call( context[4] );
  refalrts::reinit_name( context[5], ref_Sysfunm_Xxout.ref.function );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[4] );
  refalrts::link_brackets( context[8], context[9] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[11] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[13], context[15] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[11], context[12] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Sysfun("Sysfun", 0U, 0U, func_Sysfun);


static refalrts::FnResult func_gen_Sysfunm_Xxin_B1S1A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 17 elems
  refalrts::Iter context[17];
  refalrts::zeros( context, 17 );
  // </0 & Sysfun-Xxin:1$1=1/4 s.FileNo#3/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.FileNo#3: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Xxin-Scan/4 AsIs: s.FileNo#3/5 HalfReuse: # General/1 } (/6 '^'/7 )/8 </9 & Type/10 </11 & Get-Aux/12 s.FileNo#3/5/13 >/14 >/15 >/16 Tile{ ]] }
  if( ! refalrts::alloc_open_bracket( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[7], '^' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_Type.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[12], ref_Getm_Aux.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[13], context[5]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[16] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Xxinm_Scan.ref.function );
  refalrts::reinit_ident( context[1], ident_General );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[11] );
  refalrts::link_brackets( context[6], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[6], context[16] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Sysfunm_Xxin_B1S1A1("Sysfun-Xxin:1$1=1", 877573369U, 332537286U, func_gen_Sysfunm_Xxin_B1S1A1);


static refalrts::FnResult func_gen_Sysfunm_Xxin_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  // </0 & Sysfun-Xxin:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Sysfun-Xxin:1/4 (/7 e.new#1/5 )/8 s.new#2/9 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // </0 & Sysfun-Xxin:1/4 (/7 e.FileName#1/5 )/8 # True/9 >/1
    if( ! refalrts::ident_term(  ident_True, context[9] ) )
      continue;
    // closed e.FileName#1 as range 5
    //DEBUG: e.FileName#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: </1 } & Sysfun-Xxin:1$1=1/10 Tile{ AsIs: </0 Reuse: & FOpen/4 HalfReuse: 'r'/7 AsIs: e.FileName#1/5 HalfReuse: >/8 HalfReuse: >/9 } Tile{ ]] }
    if( ! refalrts::alloc_name( context[10], ref_gen_Sysfunm_Xxin_B1S1A1.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[1] );
    refalrts::update_name( context[4], ref_FOpen.ref.function );
    refalrts::reinit_char( context[7], 'r' );
    refalrts::reinit_close_call( context[8] );
    refalrts::reinit_close_call( context[9] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[8] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[0], context[9] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[1], context[1] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Sysfun-Xxin:1/4 (/7 e.FileName#1/5 )/8 # False/9 >/1
  if( ! refalrts::ident_term(  ident_False, context[9] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.FileName#1 as range 5
  //DEBUG: e.FileName#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Sysfun-Xxin:1/4 (/7 e.FileName#1/5 )/8 # False/9 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Sysfunm_Xxin_B1("Sysfun-Xxin:1", 877573369U, 332537286U, func_gen_Sysfunm_Xxin_B1);


static refalrts::FnResult func_Sysfunm_Xxin(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  // </0 & Sysfun-Xxin/4 e.FileName#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.FileName#1 as range 2
  //DEBUG: e.FileName#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 [*]/6 & Sysfun-Xxin:1/7 (/8 e.FileName#1/2/9 )/11 {*}/12 Tile{ AsIs: </0 Reuse: & ExistFile/4 AsIs: e.FileName#1/2 AsIs: >/1 } >/13 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_closure_head( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], ref_gen_Sysfunm_Xxin_B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[8] ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_evar(context[9], context[10], context[2], context[3]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[12], context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[13] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_ExistFile.ref.function );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[8], context[11] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[13], context[13] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[5], context[12] );
  refalrts::use( res );
  refalrts::wrap_closure( context[12] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Sysfunm_Xxin("Sysfun-Xxin", 877573369U, 332537286U, func_Sysfunm_Xxin);


static refalrts::FnResult func_gen_Xxinm_Scan_S14B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 28 elems
  refalrts::Iter context[28];
  refalrts::zeros( context, 28 );
  // </0 & Xxin-Scan$14:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Xxin-Scan$14:1/4 s.new#1/5 s.new#2/6 t.new#3/7 (/11 e.new#4/9 )/12 (/15 e.new#5/13 )/16 (/19 e.new#6/17 )/20 e.new#7/2 s.new#8/21 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[8] = refalrts::tvar_left( context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  context[13] = 0;
  context[14] = 0;
  context[15] = refalrts::brackets_left( context[13], context[14], context[2], context[3] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[15], context[16]);
  context[17] = 0;
  context[18] = 0;
  context[19] = refalrts::brackets_left( context[17], context[18], context[2], context[3] );
  if( ! context[19] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[19], context[20]);
  // closed e.new#4 as range 9
  // closed e.new#5 as range 13
  // closed e.new#6 as range 17
  if( ! refalrts::svar_right( context[21], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#7 as range 2
  do {
    // </0 & Xxin-Scan$14:1/4 s.FileNo#1/5 s.State#1/6 t.Stack#1/7 (/11 e.Scanned#1/9 )/12 (/15 e.Digits#1/13 )/16 (/19 e.Tail#1/17 )/20 s.Char#1/24 s.Digit#2/21 >/1
    context[22] = context[2];
    context[23] = context[3];
    // closed e.Scanned#1 as range 9
    // closed e.Digits#1 as range 13
    // closed e.Tail#1 as range 17
    if( ! refalrts::svar_left( context[24], context[22], context[23] ) )
      continue;
    if( ! refalrts::empty_seq( context[22], context[23] ) )
      continue;
    //DEBUG: t.Stack#1: 7
    //DEBUG: s.FileNo#1: 5
    //DEBUG: s.State#1: 6
    //DEBUG: s.Digit#2: 21
    //DEBUG: e.Scanned#1: 9
    //DEBUG: e.Digits#1: 13
    //DEBUG: e.Tail#1: 17
    //DEBUG: s.Char#1: 24

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.Char#1/24 s.Digit#2/21 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Xxin-Scan/4 AsIs: s.FileNo#1/5 } Tile{ HalfReuse: # Escape-Hex/20 } Tile{ AsIs: (/11 } Tile{ HalfReuse: (/12 } Tile{ AsIs: s.State#1/6 AsIs: t.Stack#1/7 } Tile{ AsIs: e.Scanned#1/9 } Tile{ HalfReuse: )/15 AsIs: e.Digits#1/13 HalfReuse: s.Digit2 #21/16 HalfReuse: )/19 } </25 & Type/26 Tile{ AsIs: e.Tail#1/17 } >/27 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[25] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[26], ref_Type.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[27] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Xxinm_Scan.ref.function );
    refalrts::reinit_ident( context[20], ident_Escapem_Hex );
    refalrts::reinit_open_bracket( context[12] );
    refalrts::reinit_close_bracket( context[15] );
    refalrts::reinit_svar( context[16], context[21] );
    refalrts::reinit_close_bracket( context[19] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[27] );
    refalrts::push_stack( context[25] );
    refalrts::link_brackets( context[11], context[19] );
    refalrts::link_brackets( context[12], context[15] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[27], context[27] );
    res = refalrts::splice_evar( res, context[17], context[18] );
    res = refalrts::splice_evar( res, context[25], context[26] );
    res = refalrts::splice_evar( res, context[15], context[19] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[6], context[8] );
    res = refalrts::splice_evar( res, context[12], context[12] );
    res = refalrts::splice_evar( res, context[11], context[11] );
    res = refalrts::splice_evar( res, context[20], context[20] );
    refalrts::splice_to_freelist_open( context[5], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Xxin-Scan$14:1/4 s.FileNo#1/5 s.State#1/6 t.Stack#1/7 (/11 e.Scanned#1/9 )/12 (/15 e.Digits#1/13 )/16 (/19 e.Tail#1/17 )/20 s.Char#1/21 >/1
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Scanned#1 as range 9
  // closed e.Digits#1 as range 13
  // closed e.Tail#1 as range 17
  //DEBUG: t.Stack#1: 7
  //DEBUG: s.FileNo#1: 5
  //DEBUG: s.State#1: 6
  //DEBUG: s.Char#1: 21
  //DEBUG: e.Scanned#1: 9
  //DEBUG: e.Digits#1: 13
  //DEBUG: e.Tail#1: 17

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.FileNo#1/5 s.State#1/6 t.Stack#1/7 {REMOVED TILE} e.Scanned#1/9 {REMOVED TILE} e.Digits#1/13 {REMOVED TILE} e.Tail#1/17 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sysfun-Xxin-ERROR/4 } Tile{ HalfReuse: 'U'/16 HalfReuse: 'n'/19 } Tile{ HalfReuse: 'k'/12 HalfReuse: 'n'/15 } Tile{ HalfReuse: 'o'/11 }"wn escape sequence \\"/22 Tile{ HalfReuse: 'x'/20 AsIs: s.Char#1/21 AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[22], context[23], "wn escape sequence \\", 20 ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Sysfunm_Xxinm_ERROR.ref.function );
  refalrts::reinit_char( context[16], 'U' );
  refalrts::reinit_char( context[19], 'n' );
  refalrts::reinit_char( context[12], 'k' );
  refalrts::reinit_char( context[15], 'n' );
  refalrts::reinit_char( context[11], 'o' );
  refalrts::reinit_char( context[20], 'x' );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[20];
  res = refalrts::splice_evar( res, context[22], context[23] );
  res = refalrts::splice_evar( res, context[11], context[11] );
  res = refalrts::splice_evar( res, context[12], context[15] );
  res = refalrts::splice_evar( res, context[16], context[19] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Xxinm_Scan_S14B1("Xxin-Scan$14:1", 877573369U, 332537286U, func_gen_Xxinm_Scan_S14B1);


static refalrts::FnResult func_gen_Xxinm_Scan_S38B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & Xxin-Scan$38:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Xxin-Scan$38:1/4 s.new#1/5 t.new#2/6 (/10 e.new#3/8 )/11 (/14 e.new#4/12 )/15 e.new#5/2 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[7] = refalrts::tvar_left( context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  context[8] = 0;
  context[9] = 0;
  context[10] = refalrts::brackets_left( context[8], context[9], context[2], context[3] );
  if( ! context[10] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[10], context[11]);
  context[12] = 0;
  context[13] = 0;
  context[14] = refalrts::brackets_left( context[12], context[13], context[2], context[3] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[14], context[15]);
  // closed e.new#3 as range 8
  // closed e.new#4 as range 12
  // closed e.new#5 as range 2
  do {
    // </0 & Xxin-Scan$38:1/4 s.FileNo#1/5 t.Stack#1/6 (/10 e.Scanned#1/8 )/11 (/14 e.Tail#1/12 )/15 s.OneMacroDigit#2/18 >/1
    context[16] = context[2];
    context[17] = context[3];
    // closed e.Scanned#1 as range 8
    // closed e.Tail#1 as range 12
    if( ! refalrts::svar_left( context[18], context[16], context[17] ) )
      continue;
    if( ! refalrts::empty_seq( context[16], context[17] ) )
      continue;
    //DEBUG: t.Stack#1: 6
    //DEBUG: s.FileNo#1: 5
    //DEBUG: e.Scanned#1: 8
    //DEBUG: e.Tail#1: 12
    //DEBUG: s.OneMacroDigit#2: 18

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Xxin-Scan/4 AsIs: s.FileNo#1/5 } # General/19 Tile{ AsIs: (/10 } Tile{ AsIs: t.Stack#1/6 } Tile{ AsIs: e.Scanned#1/8 } Tile{ AsIs: s.OneMacroDigit#2/18 } )/20 Tile{ HalfReuse: </11 HalfReuse: & Type/14 AsIs: e.Tail#1/12 HalfReuse: >/15 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_ident( context[19], ident_General ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[20] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Xxinm_Scan.ref.function );
    refalrts::reinit_open_call( context[11] );
    refalrts::reinit_name( context[14], ref_Type.ref.function );
    refalrts::reinit_close_call( context[15] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[11] );
    refalrts::link_brackets( context[10], context[20] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[11], context[15] );
    res = refalrts::splice_evar( res, context[20], context[20] );
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[8], context[9] );
    res = refalrts::splice_evar( res, context[6], context[7] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[19], context[19] );
    refalrts::use( res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Xxin-Scan$38:1/4 s.FileNo#1/5 t.Stack#1/6 (/10 e.Scanned#1/8 )/11 (/14 e.Tail#1/12 )/15 e.SeveralMacrodigits#2/2 >/1
  // closed e.Scanned#1 as range 8
  // closed e.Tail#1 as range 12
  // closed e.SeveralMacrodigits#2 as range 2
  //DEBUG: t.Stack#1: 6
  //DEBUG: s.FileNo#1: 5
  //DEBUG: e.Scanned#1: 8
  //DEBUG: e.Tail#1: 12
  //DEBUG: e.SeveralMacrodigits#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.FileNo#1/5 t.Stack#1/6 {REMOVED TILE} e.Scanned#1/8 {REMOVED TILE} e.Tail#1/12 {REMOVED TILE} e.SeveralMacrodigits#2/2 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sysfun-Xxin-ERROR/4 } Tile{ HalfReuse: 'V'/10 } Tile{ HalfReuse: 'e'/11 HalfReuse: 'r'/14 } Tile{ HalfReuse: 'y'/15 }" long macrodigit is read"/16 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_chars( context[16], context[17], " long macrodigit is read", 24 ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Sysfunm_Xxinm_ERROR.ref.function );
  refalrts::reinit_char( context[10], 'V' );
  refalrts::reinit_char( context[11], 'e' );
  refalrts::reinit_char( context[14], 'r' );
  refalrts::reinit_char( context[15], 'y' );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[16], context[17] );
  res = refalrts::splice_evar( res, context[15], context[15] );
  res = refalrts::splice_evar( res, context[11], context[14] );
  res = refalrts::splice_evar( res, context[10], context[10] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Xxinm_Scan_S38B1("Xxin-Scan$38:1", 877573369U, 332537286U, func_gen_Xxinm_Scan_S38B1);


static refalrts::FnResult func_Xxinm_Scan(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 32 elems
  refalrts::Iter context[32];
  refalrts::zeros( context, 32 );
  // </0 & Xxin-Scan/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Xxin-Scan/4 s.new#1/5 s.new#2/6 (/9 t.new#3/13 e.new#4/7 )/10 s.new#5/11 s.new#6/12 e.new#7/2 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[7] = 0;
  context[8] = 0;
  context[9] = refalrts::brackets_left( context[7], context[8], context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[9], context[10]);
  if( ! refalrts::svar_left( context[11], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#7 as range 2
  context[14] = refalrts::tvar_left( context[13], context[7], context[8] );
  if( ! context[14] )
    return refalrts::cRecognitionImpossible;
  // closed e.new#4 as range 7
  do {
    // </0 & Xxin-Scan/4 s.FileNo#1/5 s.State#1/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 '*'/11 s.0#1/12 >/1
    if( ! refalrts::char_term( '*', context[11] ) )
      continue;
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    // closed e.Scanned#1 as range 7
    //DEBUG: t.Stack#1: 13
    //DEBUG: s.FileNo#1: 5
    //DEBUG: s.State#1: 6
    //DEBUG: s.0#1: 12
    //DEBUG: e.Scanned#1: 7

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.0#1/12 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 AsIs: s.State#1/6 AsIs: (/9 AsIs: t.Stack#1/13 AsIs: e.Scanned#1/7 AsIs: )/10 HalfReuse: </11 } & Type/15 </16 & Get-Aux/17 s.FileNo#1/5/18 >/19 >/20 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_name( context[15], ref_Type.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[17], ref_Getm_Aux.ref.function ) )
      return refalrts::cNoMemory;
    if (! refalrts::copy_stvar(context[18], context[5]))
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[20] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[11] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[16] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[15], context[20] );
    refalrts::splice_to_freelist_open( context[11], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Xxin-Scan/4 s.new#8/5 s.new#9/6 (/9 (/13 s.new#10/17 t.new#11/18 e.new#12/15 )/14 e.new#13/7 )/10 s.new#14/11 s.new#15/12 e.new#16/2 >/1
    context[15] = 0;
    context[16] = 0;
    if( ! refalrts::brackets_term( context[15], context[16], context[13] ) )
      continue;
    // closed e.new#13 as range 7
    // closed e.new#16 as range 2
    if( ! refalrts::svar_left( context[17], context[15], context[16] ) )
      continue;
    context[19] = refalrts::tvar_left( context[18], context[15], context[16] );
    if( ! context[19] )
      continue;
    // closed e.new#12 as range 15
    do {
      // </0 & Xxin-Scan/4 s.new#17/5 # Escape/6 (/9 (/13 s.new#18/17 t.new#19/18 e.new#20/15 )/14 )/10 s.new#21/11 s.new#22/12 s.new#23/22 e.new#24/20 >/1
      context[20] = context[2];
      context[21] = context[3];
      if( ! refalrts::ident_term(  ident_Escape, context[6] ) )
        continue;
      if( ! refalrts::empty_seq( context[7], context[8] ) )
        continue;
      // closed e.new#20 as range 15
      if( ! refalrts::svar_left( context[22], context[20], context[21] ) )
        continue;
      // closed e.new#24 as range 20
      do {
        // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 )/10 s.T#1/11 s.S#1/12 '\\'/22 e.Tail#1/20 >/1
        if( ! refalrts::char_term( '\\', context[22] ) )
          continue;
        // closed e.Scanned#1 as range 15
        // closed e.Tail#1 as range 20
        //DEBUG: t.Stack#1: 18
        //DEBUG: s.FileNo#1: 5
        //DEBUG: s.State#1: 17
        //DEBUG: s.T#1: 11
        //DEBUG: s.S#1: 12
        //DEBUG: e.Scanned#1: 15
        //DEBUG: e.Tail#1: 20

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} s.State#1/17 {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 HalfReuse: s.State1 #17/6 AsIs: (/9 } Tile{ AsIs: t.Stack#1/18 AsIs: e.Scanned#1/15 HalfReuse: '\\'/14 AsIs: )/10 } Tile{ HalfReuse: </13 } Tile{ HalfReuse: & Type/22 AsIs: e.Tail#1/20 AsIs: >/1 } >/23 Tile{ ]] }
        if( ! refalrts::alloc_close_call( context[23] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_svar( context[6], context[17] );
        refalrts::reinit_char( context[14], '\\' );
        refalrts::reinit_open_call( context[13] );
        refalrts::reinit_name( context[22], ref_Type.ref.function );
        refalrts::push_stack( context[23] );
        refalrts::push_stack( context[0] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[13] );
        refalrts::link_brackets( context[9], context[10] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = arg_end->next;
        res = refalrts::splice_evar( res, context[23], context[23] );
        res = refalrts::splice_evar( res, context[22], context[1] );
        res = refalrts::splice_evar( res, context[13], context[13] );
        res = refalrts::splice_evar( res, context[18], context[10] );
        refalrts::splice_to_freelist_open( context[9], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 )/10 s.T#1/11 s.S#1/12 '\''/22 e.Tail#1/20 >/1
        if( ! refalrts::char_term( '\'', context[22] ) )
          continue;
        // closed e.Scanned#1 as range 15
        // closed e.Tail#1 as range 20
        //DEBUG: t.Stack#1: 18
        //DEBUG: s.FileNo#1: 5
        //DEBUG: s.State#1: 17
        //DEBUG: s.T#1: 11
        //DEBUG: s.S#1: 12
        //DEBUG: e.Scanned#1: 15
        //DEBUG: e.Tail#1: 20

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} s.State#1/17 {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 HalfReuse: s.State1 #17/6 AsIs: (/9 } Tile{ AsIs: t.Stack#1/18 AsIs: e.Scanned#1/15 HalfReuse: '\''/14 AsIs: )/10 } Tile{ HalfReuse: </13 } Tile{ HalfReuse: & Type/22 AsIs: e.Tail#1/20 AsIs: >/1 } >/23 Tile{ ]] }
        if( ! refalrts::alloc_close_call( context[23] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_svar( context[6], context[17] );
        refalrts::reinit_char( context[14], '\'' );
        refalrts::reinit_open_call( context[13] );
        refalrts::reinit_name( context[22], ref_Type.ref.function );
        refalrts::push_stack( context[23] );
        refalrts::push_stack( context[0] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[13] );
        refalrts::link_brackets( context[9], context[10] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = arg_end->next;
        res = refalrts::splice_evar( res, context[23], context[23] );
        res = refalrts::splice_evar( res, context[22], context[1] );
        res = refalrts::splice_evar( res, context[13], context[13] );
        res = refalrts::splice_evar( res, context[18], context[10] );
        refalrts::splice_to_freelist_open( context[9], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 )/10 s.T#1/11 s.S#1/12 '\"'/22 e.Tail#1/20 >/1
        if( ! refalrts::char_term( '\"', context[22] ) )
          continue;
        // closed e.Scanned#1 as range 15
        // closed e.Tail#1 as range 20
        //DEBUG: t.Stack#1: 18
        //DEBUG: s.FileNo#1: 5
        //DEBUG: s.State#1: 17
        //DEBUG: s.T#1: 11
        //DEBUG: s.S#1: 12
        //DEBUG: e.Scanned#1: 15
        //DEBUG: e.Tail#1: 20

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} s.State#1/17 {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 HalfReuse: s.State1 #17/6 AsIs: (/9 } Tile{ AsIs: t.Stack#1/18 AsIs: e.Scanned#1/15 HalfReuse: '\"'/14 AsIs: )/10 } Tile{ HalfReuse: </13 } Tile{ HalfReuse: & Type/22 AsIs: e.Tail#1/20 AsIs: >/1 } >/23 Tile{ ]] }
        if( ! refalrts::alloc_close_call( context[23] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_svar( context[6], context[17] );
        refalrts::reinit_char( context[14], '\"' );
        refalrts::reinit_open_call( context[13] );
        refalrts::reinit_name( context[22], ref_Type.ref.function );
        refalrts::push_stack( context[23] );
        refalrts::push_stack( context[0] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[13] );
        refalrts::link_brackets( context[9], context[10] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = arg_end->next;
        res = refalrts::splice_evar( res, context[23], context[23] );
        res = refalrts::splice_evar( res, context[22], context[1] );
        res = refalrts::splice_evar( res, context[13], context[13] );
        res = refalrts::splice_evar( res, context[18], context[10] );
        refalrts::splice_to_freelist_open( context[9], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 )/10 s.T#1/11 s.S#1/12 '('/22 e.Tail#1/20 >/1
        if( ! refalrts::char_term( '(', context[22] ) )
          continue;
        // closed e.Scanned#1 as range 15
        // closed e.Tail#1 as range 20
        //DEBUG: t.Stack#1: 18
        //DEBUG: s.FileNo#1: 5
        //DEBUG: s.State#1: 17
        //DEBUG: s.T#1: 11
        //DEBUG: s.S#1: 12
        //DEBUG: e.Scanned#1: 15
        //DEBUG: e.Tail#1: 20

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} s.State#1/17 {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 HalfReuse: s.State1 #17/6 AsIs: (/9 } Tile{ AsIs: t.Stack#1/18 AsIs: e.Scanned#1/15 HalfReuse: '('/14 AsIs: )/10 } Tile{ HalfReuse: </13 } Tile{ HalfReuse: & Type/22 AsIs: e.Tail#1/20 AsIs: >/1 } >/23 Tile{ ]] }
        if( ! refalrts::alloc_close_call( context[23] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_svar( context[6], context[17] );
        refalrts::reinit_char( context[14], '(' );
        refalrts::reinit_open_call( context[13] );
        refalrts::reinit_name( context[22], ref_Type.ref.function );
        refalrts::push_stack( context[23] );
        refalrts::push_stack( context[0] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[13] );
        refalrts::link_brackets( context[9], context[10] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = arg_end->next;
        res = refalrts::splice_evar( res, context[23], context[23] );
        res = refalrts::splice_evar( res, context[22], context[1] );
        res = refalrts::splice_evar( res, context[13], context[13] );
        res = refalrts::splice_evar( res, context[18], context[10] );
        refalrts::splice_to_freelist_open( context[9], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 )/10 s.T#1/11 s.S#1/12 ')'/22 e.Tail#1/20 >/1
        if( ! refalrts::char_term( ')', context[22] ) )
          continue;
        // closed e.Scanned#1 as range 15
        // closed e.Tail#1 as range 20
        //DEBUG: t.Stack#1: 18
        //DEBUG: s.FileNo#1: 5
        //DEBUG: s.State#1: 17
        //DEBUG: s.T#1: 11
        //DEBUG: s.S#1: 12
        //DEBUG: e.Scanned#1: 15
        //DEBUG: e.Tail#1: 20

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} s.State#1/17 {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 HalfReuse: s.State1 #17/6 AsIs: (/9 } Tile{ AsIs: t.Stack#1/18 AsIs: e.Scanned#1/15 HalfReuse: ')'/14 AsIs: )/10 } Tile{ HalfReuse: </13 } Tile{ HalfReuse: & Type/22 AsIs: e.Tail#1/20 AsIs: >/1 } >/23 Tile{ ]] }
        if( ! refalrts::alloc_close_call( context[23] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_svar( context[6], context[17] );
        refalrts::reinit_char( context[14], ')' );
        refalrts::reinit_open_call( context[13] );
        refalrts::reinit_name( context[22], ref_Type.ref.function );
        refalrts::push_stack( context[23] );
        refalrts::push_stack( context[0] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[13] );
        refalrts::link_brackets( context[9], context[10] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = arg_end->next;
        res = refalrts::splice_evar( res, context[23], context[23] );
        res = refalrts::splice_evar( res, context[22], context[1] );
        res = refalrts::splice_evar( res, context[13], context[13] );
        res = refalrts::splice_evar( res, context[18], context[10] );
        refalrts::splice_to_freelist_open( context[9], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 )/10 s.T#1/11 s.S#1/12 '<'/22 e.Tail#1/20 >/1
        if( ! refalrts::char_term( '<', context[22] ) )
          continue;
        // closed e.Scanned#1 as range 15
        // closed e.Tail#1 as range 20
        //DEBUG: t.Stack#1: 18
        //DEBUG: s.FileNo#1: 5
        //DEBUG: s.State#1: 17
        //DEBUG: s.T#1: 11
        //DEBUG: s.S#1: 12
        //DEBUG: e.Scanned#1: 15
        //DEBUG: e.Tail#1: 20

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} s.State#1/17 {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 HalfReuse: s.State1 #17/6 AsIs: (/9 } Tile{ AsIs: t.Stack#1/18 AsIs: e.Scanned#1/15 HalfReuse: '<'/14 AsIs: )/10 } Tile{ HalfReuse: </13 } Tile{ HalfReuse: & Type/22 AsIs: e.Tail#1/20 AsIs: >/1 } >/23 Tile{ ]] }
        if( ! refalrts::alloc_close_call( context[23] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_svar( context[6], context[17] );
        refalrts::reinit_char( context[14], '<' );
        refalrts::reinit_open_call( context[13] );
        refalrts::reinit_name( context[22], ref_Type.ref.function );
        refalrts::push_stack( context[23] );
        refalrts::push_stack( context[0] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[13] );
        refalrts::link_brackets( context[9], context[10] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = arg_end->next;
        res = refalrts::splice_evar( res, context[23], context[23] );
        res = refalrts::splice_evar( res, context[22], context[1] );
        res = refalrts::splice_evar( res, context[13], context[13] );
        res = refalrts::splice_evar( res, context[18], context[10] );
        refalrts::splice_to_freelist_open( context[9], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 )/10 s.T#1/11 s.S#1/12 '>'/22 e.Tail#1/20 >/1
        if( ! refalrts::char_term( '>', context[22] ) )
          continue;
        // closed e.Scanned#1 as range 15
        // closed e.Tail#1 as range 20
        //DEBUG: t.Stack#1: 18
        //DEBUG: s.FileNo#1: 5
        //DEBUG: s.State#1: 17
        //DEBUG: s.T#1: 11
        //DEBUG: s.S#1: 12
        //DEBUG: e.Scanned#1: 15
        //DEBUG: e.Tail#1: 20

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} s.State#1/17 {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 HalfReuse: s.State1 #17/6 AsIs: (/9 } Tile{ AsIs: t.Stack#1/18 AsIs: e.Scanned#1/15 HalfReuse: '>'/14 AsIs: )/10 } Tile{ HalfReuse: </13 } Tile{ HalfReuse: & Type/22 AsIs: e.Tail#1/20 AsIs: >/1 } >/23 Tile{ ]] }
        if( ! refalrts::alloc_close_call( context[23] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_svar( context[6], context[17] );
        refalrts::reinit_char( context[14], '>' );
        refalrts::reinit_open_call( context[13] );
        refalrts::reinit_name( context[22], ref_Type.ref.function );
        refalrts::push_stack( context[23] );
        refalrts::push_stack( context[0] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[13] );
        refalrts::link_brackets( context[9], context[10] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = arg_end->next;
        res = refalrts::splice_evar( res, context[23], context[23] );
        res = refalrts::splice_evar( res, context[22], context[1] );
        res = refalrts::splice_evar( res, context[13], context[13] );
        res = refalrts::splice_evar( res, context[18], context[10] );
        refalrts::splice_to_freelist_open( context[9], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 )/10 s.T#1/11 s.S#1/12 'n'/22 e.Tail#1/20 >/1
        if( ! refalrts::char_term( 'n', context[22] ) )
          continue;
        // closed e.Scanned#1 as range 15
        // closed e.Tail#1 as range 20
        //DEBUG: t.Stack#1: 18
        //DEBUG: s.FileNo#1: 5
        //DEBUG: s.State#1: 17
        //DEBUG: s.T#1: 11
        //DEBUG: s.S#1: 12
        //DEBUG: e.Scanned#1: 15
        //DEBUG: e.Tail#1: 20

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} s.State#1/17 {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 HalfReuse: s.State1 #17/6 AsIs: (/9 } Tile{ AsIs: t.Stack#1/18 AsIs: e.Scanned#1/15 HalfReuse: '\n'/14 AsIs: )/10 } Tile{ HalfReuse: </13 } Tile{ HalfReuse: & Type/22 AsIs: e.Tail#1/20 AsIs: >/1 } >/23 Tile{ ]] }
        if( ! refalrts::alloc_close_call( context[23] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_svar( context[6], context[17] );
        refalrts::reinit_char( context[14], '\n' );
        refalrts::reinit_open_call( context[13] );
        refalrts::reinit_name( context[22], ref_Type.ref.function );
        refalrts::push_stack( context[23] );
        refalrts::push_stack( context[0] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[13] );
        refalrts::link_brackets( context[9], context[10] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = arg_end->next;
        res = refalrts::splice_evar( res, context[23], context[23] );
        res = refalrts::splice_evar( res, context[22], context[1] );
        res = refalrts::splice_evar( res, context[13], context[13] );
        res = refalrts::splice_evar( res, context[18], context[10] );
        refalrts::splice_to_freelist_open( context[9], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 )/10 s.T#1/11 s.S#1/12 't'/22 e.Tail#1/20 >/1
        if( ! refalrts::char_term( 't', context[22] ) )
          continue;
        // closed e.Scanned#1 as range 15
        // closed e.Tail#1 as range 20
        //DEBUG: t.Stack#1: 18
        //DEBUG: s.FileNo#1: 5
        //DEBUG: s.State#1: 17
        //DEBUG: s.T#1: 11
        //DEBUG: s.S#1: 12
        //DEBUG: e.Scanned#1: 15
        //DEBUG: e.Tail#1: 20

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} s.State#1/17 {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 HalfReuse: s.State1 #17/6 AsIs: (/9 } Tile{ AsIs: t.Stack#1/18 AsIs: e.Scanned#1/15 HalfReuse: '\t'/14 AsIs: )/10 } Tile{ HalfReuse: </13 } Tile{ HalfReuse: & Type/22 AsIs: e.Tail#1/20 AsIs: >/1 } >/23 Tile{ ]] }
        if( ! refalrts::alloc_close_call( context[23] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_svar( context[6], context[17] );
        refalrts::reinit_char( context[14], '\t' );
        refalrts::reinit_open_call( context[13] );
        refalrts::reinit_name( context[22], ref_Type.ref.function );
        refalrts::push_stack( context[23] );
        refalrts::push_stack( context[0] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[13] );
        refalrts::link_brackets( context[9], context[10] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = arg_end->next;
        res = refalrts::splice_evar( res, context[23], context[23] );
        res = refalrts::splice_evar( res, context[22], context[1] );
        res = refalrts::splice_evar( res, context[13], context[13] );
        res = refalrts::splice_evar( res, context[18], context[10] );
        refalrts::splice_to_freelist_open( context[9], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 )/10 s.T#1/11 s.S#1/12 'r'/22 e.Tail#1/20 >/1
        if( ! refalrts::char_term( 'r', context[22] ) )
          continue;
        // closed e.Scanned#1 as range 15
        // closed e.Tail#1 as range 20
        //DEBUG: t.Stack#1: 18
        //DEBUG: s.FileNo#1: 5
        //DEBUG: s.State#1: 17
        //DEBUG: s.T#1: 11
        //DEBUG: s.S#1: 12
        //DEBUG: e.Scanned#1: 15
        //DEBUG: e.Tail#1: 20

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} s.State#1/17 {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 HalfReuse: s.State1 #17/6 AsIs: (/9 } Tile{ AsIs: t.Stack#1/18 AsIs: e.Scanned#1/15 HalfReuse: '\r'/14 AsIs: )/10 } Tile{ HalfReuse: </13 } Tile{ HalfReuse: & Type/22 AsIs: e.Tail#1/20 AsIs: >/1 } >/23 Tile{ ]] }
        if( ! refalrts::alloc_close_call( context[23] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_svar( context[6], context[17] );
        refalrts::reinit_char( context[14], '\r' );
        refalrts::reinit_open_call( context[13] );
        refalrts::reinit_name( context[22], ref_Type.ref.function );
        refalrts::push_stack( context[23] );
        refalrts::push_stack( context[0] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[13] );
        refalrts::link_brackets( context[9], context[10] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = arg_end->next;
        res = refalrts::splice_evar( res, context[23], context[23] );
        res = refalrts::splice_evar( res, context[22], context[1] );
        res = refalrts::splice_evar( res, context[13], context[13] );
        res = refalrts::splice_evar( res, context[18], context[10] );
        refalrts::splice_to_freelist_open( context[9], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 )/10 s.T#1/11 s.S#1/12 'x'/22 e.Tail#1/20 >/1
      if( ! refalrts::char_term( 'x', context[22] ) )
        continue;
      // closed e.Scanned#1 as range 15
      // closed e.Tail#1 as range 20
      //DEBUG: t.Stack#1: 18
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.State#1: 17
      //DEBUG: s.T#1: 11
      //DEBUG: s.S#1: 12
      //DEBUG: e.Scanned#1: 15
      //DEBUG: e.Tail#1: 20

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 Reuse: # Escape-Hex/6 AsIs: (/9 AsIs: (/13 AsIs: s.State#1/17 AsIs: t.Stack#1/18 AsIs: e.Scanned#1/15 AsIs: )/14 AsIs: )/10 } </23 Tile{ HalfReuse: & Type/22 AsIs: e.Tail#1/20 AsIs: >/1 } >/24 Tile{ ]] }
      if( ! refalrts::alloc_open_call( context[23] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[24] ) )
        return refalrts::cNoMemory;
      refalrts::update_ident( context[6], ident_Escapem_Hex );
      refalrts::reinit_name( context[22], ref_Type.ref.function );
      refalrts::push_stack( context[24] );
      refalrts::push_stack( context[0] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[23] );
      refalrts::link_brackets( context[9], context[10] );
      refalrts::link_brackets( context[13], context[14] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = arg_end->next;
      res = refalrts::splice_evar( res, context[24], context[24] );
      res = refalrts::splice_evar( res, context[22], context[1] );
      res = refalrts::splice_evar( res, context[23], context[23] );
      refalrts::splice_to_freelist_open( context[10], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & Xxin-Scan/4 s.new#17/5 # Escape-Hex/6 (/9 (/13 s.new#18/17 t.new#19/18 e.new#20/15 )/14 e.new#21/7 )/10 s.new#22/11 s.new#23/12 e.new#24/2 >/1
      if( ! refalrts::ident_term(  ident_Escapem_Hex, context[6] ) )
        continue;
      // closed e.new#20 as range 15
      // closed e.new#21 as range 7
      // closed e.new#24 as range 2
      do {
        // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape-Hex/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 s.D1#1/22 s.D2#1/23 )/10 s.T#1/11 s.S#1/12 e.Tail#1/2 >/1
        context[20] = context[7];
        context[21] = context[8];
        // closed e.Scanned#1 as range 15
        // closed e.Tail#1 as range 2
        if( ! refalrts::svar_left( context[22], context[20], context[21] ) )
          continue;
        if( ! refalrts::svar_left( context[23], context[20], context[21] ) )
          continue;
        if( ! refalrts::empty_seq( context[20], context[21] ) )
          continue;
        //DEBUG: t.Stack#1: 18
        //DEBUG: s.FileNo#1: 5
        //DEBUG: s.State#1: 17
        //DEBUG: s.T#1: 11
        //DEBUG: s.S#1: 12
        //DEBUG: e.Scanned#1: 15
        //DEBUG: e.Tail#1: 2
        //DEBUG: s.D1#1: 22
        //DEBUG: s.D2#1: 23

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} s.State#1/17 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 HalfReuse: s.State1 #17/6 AsIs: (/9 } Tile{ AsIs: t.Stack#1/18 AsIs: e.Scanned#1/15 HalfReuse: </14 } & Chr/24 </25 Tile{ HalfReuse: & Add-Digits/13 } </26 & Mul-Digits/27 Tile{ AsIs: s.D1#1/22 } 16/28 >/29 Tile{ AsIs: s.D2#1/23 } >/30 >/31 Tile{ AsIs: )/10 AsIs: s.T#1/11 AsIs: s.S#1/12 AsIs: e.Tail#1/2 AsIs: >/1 ]] }
        if( ! refalrts::alloc_name( context[24], ref_Chr.ref.function ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_open_call( context[25] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_open_call( context[26] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_name( context[27], ref_Mulm_Digits.ref.function ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_number( context[28], 16UL ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_call( context[29] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_call( context[30] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_call( context[31] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_svar( context[6], context[17] );
        refalrts::reinit_open_call( context[14] );
        refalrts::reinit_name( context[13], ref_Addm_Digits.ref.function );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[0] );
        refalrts::link_brackets( context[9], context[10] );
        refalrts::push_stack( context[31] );
        refalrts::push_stack( context[14] );
        refalrts::push_stack( context[30] );
        refalrts::push_stack( context[25] );
        refalrts::push_stack( context[29] );
        refalrts::push_stack( context[26] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[10];
        res = refalrts::splice_evar( res, context[30], context[31] );
        res = refalrts::splice_evar( res, context[23], context[23] );
        res = refalrts::splice_evar( res, context[28], context[29] );
        res = refalrts::splice_evar( res, context[22], context[22] );
        res = refalrts::splice_evar( res, context[26], context[27] );
        res = refalrts::splice_evar( res, context[13], context[13] );
        res = refalrts::splice_evar( res, context[24], context[25] );
        res = refalrts::splice_evar( res, context[18], context[14] );
        refalrts::splice_to_freelist_open( context[9], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      // </0 & Xxin-Scan/4 s.new#25/5 # Escape-Hex/6 (/9 (/13 s.new#26/17 t.new#27/18 e.new#28/15 )/14 e.new#29/7 )/10 s.new#30/11 s.new#31/12 s.new#32/22 e.new#33/20 >/1
      context[20] = context[2];
      context[21] = context[3];
      // closed e.new#28 as range 15
      // closed e.new#29 as range 7
      if( ! refalrts::svar_left( context[22], context[20], context[21] ) )
        continue;
      // closed e.new#33 as range 20
      do {
        // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape-Hex/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 e.Digits#1/7 )/10 s.T#1/11 s.S#1/12 s.Char#1/22 e.Tail#1/20 >/1
        // closed e.Scanned#1 as range 15
        // closed e.Digits#1 as range 7
        // closed e.Tail#1 as range 20
        //DEBUG: t.Stack#1: 18
        //DEBUG: s.FileNo#1: 5
        //DEBUG: s.State#1: 17
        //DEBUG: s.T#1: 11
        //DEBUG: s.S#1: 12
        //DEBUG: s.Char#1: 22
        //DEBUG: e.Scanned#1: 15
        //DEBUG: e.Digits#1: 7
        //DEBUG: e.Tail#1: 20

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} s.FileNo#1/5 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 } Tile{ HalfReuse: [*]/6 HalfReuse: & Xxin-Scan$14:1/9 HalfReuse: s.FileNo1 #5/13 AsIs: s.State#1/17 AsIs: t.Stack#1/18 } (/23 Tile{ AsIs: e.Scanned#1/15 } )/24 Tile{ HalfReuse: (/14 AsIs: e.Digits#1/7 AsIs: )/10 } (/25 Tile{ AsIs: e.Tail#1/20 } )/26 Tile{ AsIs: s.Char#1/22 } {*}/27 </28 Tile{ Reuse: & HexDigit/4 } s.Char#1/22/29 >/30 Tile{ AsIs: >/1 ]] }
        if( ! refalrts::alloc_open_bracket( context[23] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_bracket( context[24] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_open_bracket( context[25] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_bracket( context[26] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_unwrapped_closure( context[27], context[6] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_open_call( context[28] ) )
          return refalrts::cNoMemory;
        if (! refalrts::copy_stvar(context[29], context[22]))
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_call( context[30] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_closure_head( context[6] );
        refalrts::reinit_name( context[9], ref_gen_Xxinm_Scan_S14B1.ref.function );
        refalrts::reinit_svar( context[13], context[5] );
        refalrts::reinit_open_bracket( context[14] );
        refalrts::update_name( context[4], ref_HexDigit.ref.function );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[0] );
        refalrts::push_stack( context[30] );
        refalrts::push_stack( context[28] );
        refalrts::link_brackets( context[25], context[26] );
        refalrts::link_brackets( context[14], context[10] );
        refalrts::link_brackets( context[23], context[24] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[1];
        res = refalrts::splice_evar( res, context[29], context[30] );
        res = refalrts::splice_evar( res, context[4], context[4] );
        res = refalrts::splice_evar( res, context[27], context[28] );
        res = refalrts::splice_evar( res, context[22], context[22] );
        res = refalrts::splice_evar( res, context[26], context[26] );
        res = refalrts::splice_evar( res, context[20], context[21] );
        res = refalrts::splice_evar( res, context[25], context[25] );
        res = refalrts::splice_evar( res, context[14], context[10] );
        res = refalrts::splice_evar( res, context[24], context[24] );
        res = refalrts::splice_evar( res, context[15], context[16] );
        res = refalrts::splice_evar( res, context[23], context[23] );
        res = refalrts::splice_evar( res, context[6], context[19] );
        refalrts::splice_to_freelist_open( context[0], res );
        refalrts::wrap_closure( context[27] );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape-Hex/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 e.Digits#1/7 )/10 'N'/11 s.0#1/12 0/22 >/1
      if( ! refalrts::char_term( 'N', context[11] ) )
        continue;
      if( ! refalrts::number_term( 0UL, context[22] ) )
        continue;
      if( ! refalrts::empty_seq( context[20], context[21] ) )
        continue;
      // closed e.Scanned#1 as range 15
      // closed e.Digits#1 as range 7
      //DEBUG: t.Stack#1: 18
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.State#1: 17
      //DEBUG: s.0#1: 12
      //DEBUG: e.Scanned#1: 15
      //DEBUG: e.Digits#1: 7

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} s.FileNo#1/5 {REMOVED TILE} s.State#1/17 t.Stack#1/18 e.Scanned#1/15 {REMOVED TILE} e.Digits#1/7 {REMOVED TILE} s.0#1/12 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sysfun-Xxin-ERROR/4 } 'U'/23 Tile{ HalfReuse: 'n'/10 Reuse: 'e'/11 } Tile{ HalfReuse: 'x'/6 HalfReuse: 'p'/9 HalfReuse: 'e'/13 } Tile{ HalfReuse: 'c'/14 }"ted EOF in \\x.."/24 Tile{ HalfReuse: '.'/22 AsIs: >/1 ]] }
      if( ! refalrts::alloc_char( context[23], 'U' ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_chars( context[24], context[25], "ted EOF in \\x..", 15 ) )
        return refalrts::cNoMemory;
      refalrts::update_name( context[4], ref_Sysfunm_Xxinm_ERROR.ref.function );
      refalrts::reinit_char( context[10], 'n' );
      refalrts::update_char( context[11], 'e' );
      refalrts::reinit_char( context[6], 'x' );
      refalrts::reinit_char( context[9], 'p' );
      refalrts::reinit_char( context[13], 'e' );
      refalrts::reinit_char( context[14], 'c' );
      refalrts::reinit_char( context[22], '.' );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[22];
      res = refalrts::splice_evar( res, context[24], context[25] );
      res = refalrts::splice_evar( res, context[14], context[14] );
      res = refalrts::splice_evar( res, context[6], context[13] );
      res = refalrts::splice_evar( res, context[10], context[11] );
      res = refalrts::splice_evar( res, context[23], context[23] );
      refalrts::splice_to_freelist_open( context[4], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Xxin-Scan/4 s.new#17/5 # Escape/6 (/9 (/13 s.new#18/17 t.new#19/18 e.new#20/15 )/14 )/10 s.new#21/11 s.new#22/12 s.new#23/22 e.new#24/20 >/1
    context[20] = context[2];
    context[21] = context[3];
    if( ! refalrts::ident_term(  ident_Escape, context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[7], context[8] ) )
      continue;
    // closed e.new#20 as range 15
    if( ! refalrts::svar_left( context[22], context[20], context[21] ) )
      continue;
    // closed e.new#24 as range 20
    do {
      // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 )/10 'N'/11 s.0#1/12 0/22 >/1
      if( ! refalrts::char_term( 'N', context[11] ) )
        continue;
      if( ! refalrts::number_term( 0UL, context[22] ) )
        continue;
      if( ! refalrts::empty_seq( context[20], context[21] ) )
        continue;
      // closed e.Scanned#1 as range 15
      //DEBUG: t.Stack#1: 18
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.State#1: 17
      //DEBUG: s.0#1: 12
      //DEBUG: e.Scanned#1: 15

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} s.FileNo#1/5 {REMOVED TILE} s.State#1/17 t.Stack#1/18 e.Scanned#1/15 {REMOVED TILE} s.0#1/12 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sysfun-Xxin-ERROR/4 } 'U'/23 Tile{ HalfReuse: 'n'/14 HalfReuse: 'e'/10 Reuse: 'x'/11 } Tile{ HalfReuse: 'p'/6 HalfReuse: 'e'/9 HalfReuse: 'c'/13 }"ted EOF in escape sequenc"/24 Tile{ HalfReuse: 'e'/22 AsIs: >/1 ]] }
      if( ! refalrts::alloc_char( context[23], 'U' ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_chars( context[24], context[25], "ted EOF in escape sequenc", 25 ) )
        return refalrts::cNoMemory;
      refalrts::update_name( context[4], ref_Sysfunm_Xxinm_ERROR.ref.function );
      refalrts::reinit_char( context[14], 'n' );
      refalrts::reinit_char( context[10], 'e' );
      refalrts::update_char( context[11], 'x' );
      refalrts::reinit_char( context[6], 'p' );
      refalrts::reinit_char( context[9], 'e' );
      refalrts::reinit_char( context[13], 'c' );
      refalrts::reinit_char( context[22], 'e' );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[22];
      res = refalrts::splice_evar( res, context[24], context[25] );
      res = refalrts::splice_evar( res, context[6], context[13] );
      res = refalrts::splice_evar( res, context[14], context[11] );
      res = refalrts::splice_evar( res, context[23], context[23] );
      refalrts::splice_to_freelist_open( context[4], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Xxin-Scan/4 s.FileNo#1/5 # Escape/6 (/9 (/13 s.State#1/17 t.Stack#1/18 e.Scanned#1/15 )/14 )/10 s.T#1/11 s.S#1/12 s.Next#1/22 e.Tail#1/20 >/1
    // closed e.Scanned#1 as range 15
    // closed e.Tail#1 as range 20
    //DEBUG: t.Stack#1: 18
    //DEBUG: s.FileNo#1: 5
    //DEBUG: s.State#1: 17
    //DEBUG: s.T#1: 11
    //DEBUG: s.S#1: 12
    //DEBUG: s.Next#1: 22
    //DEBUG: e.Scanned#1: 15
    //DEBUG: e.Tail#1: 20

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.FileNo#1/5 {REMOVED TILE} s.State#1/17 t.Stack#1/18 e.Scanned#1/15 {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} e.Tail#1/20 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sysfun-Xxin-ERROR/4 } 'B'/23 Tile{ HalfReuse: 'a'/6 HalfReuse: 'd'/9 HalfReuse: ' '/13 } 'e'/24 Tile{ HalfReuse: 's'/14 HalfReuse: 'c'/10 }"ape sequence \\"/25 Tile{ AsIs: s.Next#1/22 } Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_char( context[23], 'B' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[24], 'e' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[25], context[26], "ape sequence \\", 14 ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Sysfunm_Xxinm_ERROR.ref.function );
    refalrts::reinit_char( context[6], 'a' );
    refalrts::reinit_char( context[9], 'd' );
    refalrts::reinit_char( context[13], ' ' );
    refalrts::reinit_char( context[14], 's' );
    refalrts::reinit_char( context[10], 'c' );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[22], context[22] );
    res = refalrts::splice_evar( res, context[25], context[26] );
    res = refalrts::splice_evar( res, context[14], context[10] );
    res = refalrts::splice_evar( res, context[24], context[24] );
    res = refalrts::splice_evar( res, context[6], context[13] );
    res = refalrts::splice_evar( res, context[23], context[23] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Xxin-Scan/4 s.new#8/5 s.new#9/6 (/9 t.new#10/13 e.new#11/7 )/10 s.new#12/11 s.new#13/12 s.new#14/15 e.new#15/2 >/1
  // closed e.new#11 as range 7
  if( ! refalrts::svar_left( context[15], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#15 as range 2
  do {
    // </0 & Xxin-Scan/4 s.FileNo#1/5 s.State#1/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 s.T#1/11 s.S#1/12 '\\'/15 e.Tail#1/2 >/1
    if( ! refalrts::char_term( '\\', context[15] ) )
      continue;
    // closed e.Scanned#1 as range 7
    // closed e.Tail#1 as range 2
    //DEBUG: t.Stack#1: 13
    //DEBUG: s.FileNo#1: 5
    //DEBUG: s.State#1: 6
    //DEBUG: s.T#1: 11
    //DEBUG: s.S#1: 12
    //DEBUG: e.Scanned#1: 7
    //DEBUG: e.Tail#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.State#1/6 {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 } # Escape/16 (/17 (/18 Tile{ HalfReuse: s.State1 #6/9 AsIs: t.Stack#1/13 AsIs: e.Scanned#1/7 AsIs: )/10 } )/19 </20 Tile{ HalfReuse: & Type/15 AsIs: e.Tail#1/2 AsIs: >/1 } >/21 Tile{ ]] }
    if( ! refalrts::alloc_ident( context[16], ident_Escape ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_bracket( context[18] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_svar( context[9], context[6] );
    refalrts::reinit_name( context[15], ref_Type.ref.function );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[20] );
    refalrts::link_brackets( context[17], context[19] );
    refalrts::link_brackets( context[18], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[21], context[21] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[19], context[20] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[16], context[18] );
    refalrts::splice_to_freelist_open( context[5], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Xxin-Scan/4 s.new#16/5 # General/6 (/9 t.new#17/13 e.new#18/7 )/10 s.new#19/11 s.new#20/12 s.new#21/15 e.new#22/2 >/1
    if( ! refalrts::ident_term(  ident_General, context[6] ) )
      continue;
    // closed e.new#18 as range 7
    // closed e.new#22 as range 2
    do {
      // </0 & Xxin-Scan/4 s.FileNo#1/5 # General/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 s.T#1/11 s.S#1/12 '('/15 e.Tail#1/2 >/1
      if( ! refalrts::char_term( '(', context[15] ) )
        continue;
      // closed e.Scanned#1 as range 7
      // closed e.Tail#1 as range 2
      //DEBUG: t.Stack#1: 13
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.T#1: 11
      //DEBUG: s.S#1: 12
      //DEBUG: e.Scanned#1: 7
      //DEBUG: e.Tail#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 AsIs: # General/6 AsIs: (/9 } (/16 # General/17 Tile{ AsIs: t.Stack#1/13 AsIs: e.Scanned#1/7 AsIs: )/10 } )/18 </19 Tile{ HalfReuse: & Type/15 AsIs: e.Tail#1/2 AsIs: >/1 } >/20 Tile{ ]] }
      if( ! refalrts::alloc_open_bracket( context[16] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_ident( context[17], ident_General ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[18] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_call( context[19] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[20] ) )
        return refalrts::cNoMemory;
      refalrts::reinit_name( context[15], ref_Type.ref.function );
      refalrts::push_stack( context[20] );
      refalrts::push_stack( context[0] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[19] );
      refalrts::link_brackets( context[9], context[18] );
      refalrts::link_brackets( context[16], context[10] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = arg_end->next;
      res = refalrts::splice_evar( res, context[20], context[20] );
      res = refalrts::splice_evar( res, context[15], context[1] );
      res = refalrts::splice_evar( res, context[18], context[19] );
      res = refalrts::splice_evar( res, context[13], context[10] );
      res = refalrts::splice_evar( res, context[16], context[17] );
      refalrts::splice_to_freelist_open( context[9], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & Xxin-Scan/4 s.new#23/5 # General/6 (/9 t.new#24/13 e.new#25/7 )/10 s.new#26/11 s.new#27/12 ')'/15 e.new#28/2 >/1
      if( ! refalrts::char_term( ')', context[15] ) )
        continue;
      // closed e.new#25 as range 7
      // closed e.new#28 as range 2
      do {
        // </0 & Xxin-Scan/4 s.FileNo#1/5 # General/6 (/9 (/13 # General/18 t.Stack#1/19 e.Scanned#1/16 )/14 e.Inner#1/7 )/10 s.T#1/11 s.S#1/12 ')'/15 e.Tail#1/2 >/1
        context[16] = 0;
        context[17] = 0;
        if( ! refalrts::brackets_term( context[16], context[17], context[13] ) )
          continue;
        context[18] = refalrts::ident_left(  ident_General, context[16], context[17] );
        if( ! context[18] )
          continue;
        // closed e.Inner#1 as range 7
        // closed e.Tail#1 as range 2
        context[20] = refalrts::tvar_left( context[19], context[16], context[17] );
        if( ! context[20] )
          continue;
        // closed e.Scanned#1 as range 16
        //DEBUG: s.FileNo#1: 5
        //DEBUG: s.T#1: 11
        //DEBUG: s.S#1: 12
        //DEBUG: e.Inner#1: 7
        //DEBUG: e.Tail#1: 2
        //DEBUG: t.Stack#1: 19
        //DEBUG: e.Scanned#1: 16

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 AsIs: # General/6 AsIs: (/9 } Tile{ AsIs: t.Stack#1/19 AsIs: e.Scanned#1/16 HalfReuse: (/14 AsIs: e.Inner#1/7 AsIs: )/10 } Tile{ HalfReuse: )/13 HalfReuse: </18 } Tile{ HalfReuse: & Type/15 AsIs: e.Tail#1/2 AsIs: >/1 } >/21 Tile{ ]] }
        if( ! refalrts::alloc_close_call( context[21] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_open_bracket( context[14] );
        refalrts::reinit_close_bracket( context[13] );
        refalrts::reinit_open_call( context[18] );
        refalrts::reinit_name( context[15], ref_Type.ref.function );
        refalrts::push_stack( context[21] );
        refalrts::push_stack( context[0] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[18] );
        refalrts::link_brackets( context[9], context[13] );
        refalrts::link_brackets( context[14], context[10] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = arg_end->next;
        res = refalrts::splice_evar( res, context[21], context[21] );
        res = refalrts::splice_evar( res, context[15], context[1] );
        res = refalrts::splice_evar( res, context[13], context[18] );
        res = refalrts::splice_evar( res, context[19], context[10] );
        refalrts::splice_to_freelist_open( context[9], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      // </0 & Xxin-Scan/4 s.FileNo#1/5 # General/6 (/9 '^'/13 e.Scanned#1/7 )/10 s.T#1/11 s.S#1/12 ')'/15 e.Tail#1/2 >/1
      if( ! refalrts::char_term( '^', context[13] ) )
        continue;
      // closed e.Scanned#1 as range 7
      // closed e.Tail#1 as range 2
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.T#1: 11
      //DEBUG: s.S#1: 12
      //DEBUG: e.Scanned#1: 7
      //DEBUG: e.Tail#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} s.FileNo#1/5 {REMOVED TILE} e.Scanned#1/7 {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} e.Tail#1/2 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sysfun-Xxin-ERROR/4 } Tile{ HalfReuse: 'U'/10 } Tile{ HalfReuse: 'n'/6 HalfReuse: 'b'/9 Reuse: 'a'/13 }"lanced "/16 Tile{ AsIs: ')'/15 } Tile{ AsIs: >/1 ]] }
      if( ! refalrts::alloc_chars( context[16], context[17], "lanced ", 7 ) )
        return refalrts::cNoMemory;
      refalrts::update_name( context[4], ref_Sysfunm_Xxinm_ERROR.ref.function );
      refalrts::reinit_char( context[10], 'U' );
      refalrts::reinit_char( context[6], 'n' );
      refalrts::reinit_char( context[9], 'b' );
      refalrts::update_char( context[13], 'a' );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[15], context[15] );
      res = refalrts::splice_evar( res, context[16], context[17] );
      res = refalrts::splice_evar( res, context[6], context[13] );
      res = refalrts::splice_evar( res, context[10], context[10] );
      refalrts::splice_to_freelist_open( context[4], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & Xxin-Scan/4 s.new#23/5 # General/6 (/9 t.new#24/13 e.new#25/7 )/10 'N'/11 s.new#26/12 0/15 >/1
      if( ! refalrts::char_term( 'N', context[11] ) )
        continue;
      if( ! refalrts::number_term( 0UL, context[15] ) )
        continue;
      if( ! refalrts::empty_seq( context[2], context[3] ) )
        continue;
      // closed e.new#25 as range 7
      do {
        // </0 & Xxin-Scan/4 s.FileNo#1/5 # General/6 (/9 '^'/13 e.Scanned#1/7 )/10 'N'/11 s.0#1/12 0/15 >/1
        if( ! refalrts::char_term( '^', context[13] ) )
          continue;
        // closed e.Scanned#1 as range 7
        //DEBUG: s.FileNo#1: 5
        //DEBUG: s.0#1: 12
        //DEBUG: e.Scanned#1: 7

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} (/9 '^'/13 {REMOVED TILE} )/10 'N'/11 s.0#1/12 0/15 >/1 {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 Reuse: & FClose/4 AsIs: s.FileNo#1/5 HalfReuse: >/6 } Tile{ AsIs: e.Scanned#1/7 } Tile{ ]] }
        refalrts::update_name( context[4], ref_FClose.ref.function );
        refalrts::reinit_close_call( context[6] );
        refalrts::push_stack( context[6] );
        refalrts::push_stack( context[0] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = arg_end->next;
        res = refalrts::splice_evar( res, context[7], context[8] );
        refalrts::splice_to_freelist_open( context[6], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      // </0 & Xxin-Scan/4 s.FileNo#1/5 # General/6 (/9 (/13 # General/18 t.Stack#1/19 e.Scanned#1/16 )/14 e.Inner#1/7 )/10 'N'/11 s.0#1/12 0/15 >/1
      context[16] = 0;
      context[17] = 0;
      if( ! refalrts::brackets_term( context[16], context[17], context[13] ) )
        continue;
      context[18] = refalrts::ident_left(  ident_General, context[16], context[17] );
      if( ! context[18] )
        continue;
      // closed e.Inner#1 as range 7
      context[20] = refalrts::tvar_left( context[19], context[16], context[17] );
      if( ! context[20] )
        continue;
      // closed e.Scanned#1 as range 16
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.0#1: 12
      //DEBUG: e.Inner#1: 7
      //DEBUG: t.Stack#1: 19
      //DEBUG: e.Scanned#1: 16

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} s.FileNo#1/5 {REMOVED TILE} t.Stack#1/19 e.Scanned#1/16 {REMOVED TILE} e.Inner#1/7 {REMOVED TILE} s.0#1/12 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sysfun-Xxin-ERROR/4 } Tile{ HalfReuse: 'U'/6 HalfReuse: 'n'/9 HalfReuse: 'b'/13 HalfReuse: 'a'/18 } Tile{ HalfReuse: 'l'/10 Reuse: 'a'/11 } Tile{ HalfReuse: 'n'/14 }"ced "/21 Tile{ HalfReuse: '('/15 AsIs: >/1 ]] }
      if( ! refalrts::alloc_chars( context[21], context[22], "ced ", 4 ) )
        return refalrts::cNoMemory;
      refalrts::update_name( context[4], ref_Sysfunm_Xxinm_ERROR.ref.function );
      refalrts::reinit_char( context[6], 'U' );
      refalrts::reinit_char( context[9], 'n' );
      refalrts::reinit_char( context[13], 'b' );
      refalrts::reinit_char( context[18], 'a' );
      refalrts::reinit_char( context[10], 'l' );
      refalrts::update_char( context[11], 'a' );
      refalrts::reinit_char( context[14], 'n' );
      refalrts::reinit_char( context[15], '(' );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[15];
      res = refalrts::splice_evar( res, context[21], context[22] );
      res = refalrts::splice_evar( res, context[14], context[14] );
      res = refalrts::splice_evar( res, context[10], context[11] );
      res = refalrts::splice_evar( res, context[6], context[18] );
      refalrts::splice_to_freelist_open( context[4], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & Xxin-Scan/4 s.FileNo#1/5 # General/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 s.S#1/11 s.T#1/12 '\''/15 e.Tail#1/2 >/1
      if( ! refalrts::char_term( '\'', context[15] ) )
        continue;
      // closed e.Scanned#1 as range 7
      // closed e.Tail#1 as range 2
      //DEBUG: t.Stack#1: 13
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.S#1: 11
      //DEBUG: s.T#1: 12
      //DEBUG: e.Scanned#1: 7
      //DEBUG: e.Tail#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} s.S#1/11 s.T#1/12 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 Reuse: # Quote/6 AsIs: (/9 } (/16 # General/17 Tile{ AsIs: t.Stack#1/13 AsIs: e.Scanned#1/7 AsIs: )/10 } '\''/18 )/19 </20 Tile{ HalfReuse: & Type/15 AsIs: e.Tail#1/2 AsIs: >/1 } >/21 Tile{ ]] }
      if( ! refalrts::alloc_open_bracket( context[16] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_ident( context[17], ident_General ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_char( context[18], '\'' ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[19] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_call( context[20] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[21] ) )
        return refalrts::cNoMemory;
      refalrts::update_ident( context[6], ident_Quote );
      refalrts::reinit_name( context[15], ref_Type.ref.function );
      refalrts::push_stack( context[21] );
      refalrts::push_stack( context[0] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[20] );
      refalrts::link_brackets( context[9], context[19] );
      refalrts::link_brackets( context[16], context[10] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = arg_end->next;
      res = refalrts::splice_evar( res, context[21], context[21] );
      res = refalrts::splice_evar( res, context[15], context[1] );
      res = refalrts::splice_evar( res, context[18], context[20] );
      res = refalrts::splice_evar( res, context[13], context[10] );
      res = refalrts::splice_evar( res, context[16], context[17] );
      refalrts::splice_to_freelist_open( context[9], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Xxin-Scan/4 s.FileNo#1/5 # General/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 s.S#1/11 s.T#1/12 '\"'/15 e.Tail#1/2 >/1
    if( ! refalrts::char_term( '\"', context[15] ) )
      continue;
    // closed e.Scanned#1 as range 7
    // closed e.Tail#1 as range 2
    //DEBUG: t.Stack#1: 13
    //DEBUG: s.FileNo#1: 5
    //DEBUG: s.S#1: 11
    //DEBUG: s.T#1: 12
    //DEBUG: e.Scanned#1: 7
    //DEBUG: e.Tail#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.S#1/11 s.T#1/12 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 Reuse: # Quote/6 AsIs: (/9 } (/16 # General/17 Tile{ AsIs: t.Stack#1/13 AsIs: e.Scanned#1/7 AsIs: )/10 } '\"'/18 )/19 </20 Tile{ HalfReuse: & Type/15 AsIs: e.Tail#1/2 AsIs: >/1 } >/21 Tile{ ]] }
    if( ! refalrts::alloc_open_bracket( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_ident( context[17], ident_General ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[18], '\"' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_bracket( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[20] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[21] ) )
      return refalrts::cNoMemory;
    refalrts::update_ident( context[6], ident_Quote );
    refalrts::reinit_name( context[15], ref_Type.ref.function );
    refalrts::push_stack( context[21] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[20] );
    refalrts::link_brackets( context[9], context[19] );
    refalrts::link_brackets( context[16], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[21], context[21] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[18], context[20] );
    res = refalrts::splice_evar( res, context[13], context[10] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    refalrts::splice_to_freelist_open( context[9], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Xxin-Scan/4 s.new#16/5 # Quote/6 (/9 (/13 # General/20 t.new#17/22 e.new#18/18 )/14 s.new#19/21 e.new#20/16 )/10 s.new#21/11 s.new#22/12 s.new#23/15 e.new#24/2 >/1
    context[16] = context[7];
    context[17] = context[8];
    context[18] = 0;
    context[19] = 0;
    if( ! refalrts::brackets_term( context[18], context[19], context[13] ) )
      continue;
    if( ! refalrts::ident_term(  ident_Quote, context[6] ) )
      continue;
    context[20] = refalrts::ident_left(  ident_General, context[18], context[19] );
    if( ! context[20] )
      continue;
    // closed e.new#24 as range 2
    if( ! refalrts::svar_left( context[21], context[16], context[17] ) )
      continue;
    // closed e.new#20 as range 16
    context[23] = refalrts::tvar_left( context[22], context[18], context[19] );
    if( ! context[23] )
      continue;
    // closed e.new#18 as range 18
    do {
      // </0 & Xxin-Scan/4 s.FileNo#1/5 # Quote/6 (/9 (/13 # General/20 t.Stack#1/22 e.Scanned#1/18 )/14 s.Quote#1/21 e.Quotten#1/16 )/10 s.S#1/11 s.T#1/12 s.Quote#1/15 e.Tail#1/2 >/1
      if( ! refalrts::repeated_stvar_term( context[15], context[21] ) )
        continue;
      // closed e.Scanned#1 as range 18
      // closed e.Quotten#1 as range 16
      // closed e.Tail#1 as range 2
      //DEBUG: t.Stack#1: 22
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.Quote#1: 21
      //DEBUG: s.S#1: 11
      //DEBUG: s.T#1: 12
      //DEBUG: e.Scanned#1: 18
      //DEBUG: e.Quotten#1: 16
      //DEBUG: e.Tail#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.S#1/11 s.T#1/12 s.Quote#1/15 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 Reuse: # General/6 AsIs: (/9 } Tile{ AsIs: t.Stack#1/22 } Tile{ AsIs: e.Scanned#1/18 } </24 Tile{ HalfReuse: & Quote/14 AsIs: s.Quote#1/21 AsIs: e.Quotten#1/16 HalfReuse: >/10 } Tile{ HalfReuse: )/13 HalfReuse: </20 } & Type/25 Tile{ AsIs: e.Tail#1/2 } >/26 Tile{ AsIs: >/1 ]] }
      if( ! refalrts::alloc_open_call( context[24] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_name( context[25], ref_Type.ref.function ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[26] ) )
        return refalrts::cNoMemory;
      refalrts::update_ident( context[6], ident_General );
      refalrts::reinit_name( context[14], ref_Quote.ref.function );
      refalrts::reinit_close_call( context[10] );
      refalrts::reinit_close_bracket( context[13] );
      refalrts::reinit_open_call( context[20] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::push_stack( context[26] );
      refalrts::push_stack( context[20] );
      refalrts::link_brackets( context[9], context[13] );
      refalrts::push_stack( context[10] );
      refalrts::push_stack( context[24] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[26], context[26] );
      res = refalrts::splice_evar( res, context[2], context[3] );
      res = refalrts::splice_evar( res, context[25], context[25] );
      res = refalrts::splice_evar( res, context[13], context[20] );
      res = refalrts::splice_evar( res, context[14], context[10] );
      res = refalrts::splice_evar( res, context[24], context[24] );
      res = refalrts::splice_evar( res, context[18], context[19] );
      res = refalrts::splice_evar( res, context[22], context[23] );
      refalrts::splice_to_freelist_open( context[9], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Xxin-Scan/4 s.FileNo#1/5 # Quote/6 (/9 (/13 # General/20 t.Stack#1/22 e.Scanned#1/18 )/14 s.Quote#1/21 e.Quotten#1/16 )/10 'N'/11 s.0#1/12 0/15 >/1
    if( ! refalrts::char_term( 'N', context[11] ) )
      continue;
    if( ! refalrts::number_term( 0UL, context[15] ) )
      continue;
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    // closed e.Scanned#1 as range 18
    // closed e.Quotten#1 as range 16
    //DEBUG: t.Stack#1: 22
    //DEBUG: s.FileNo#1: 5
    //DEBUG: s.Quote#1: 21
    //DEBUG: s.0#1: 12
    //DEBUG: e.Scanned#1: 18
    //DEBUG: e.Quotten#1: 16

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.FileNo#1/5 {REMOVED TILE} t.Stack#1/22 e.Scanned#1/18 {REMOVED TILE} e.Quotten#1/16 {REMOVED TILE} s.0#1/12 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sysfun-Xxin-ERROR/4 } 'U'/24 Tile{ HalfReuse: 'n'/6 HalfReuse: 'e'/9 HalfReuse: 'x'/13 HalfReuse: 'p'/20 } 'e'/25 Tile{ HalfReuse: 'c'/10 Reuse: 't'/11 }"ed EOF in"/26 Tile{ HalfReuse: ' '/14 AsIs: s.Quote#1/21 }".."/28 Tile{ HalfReuse: '.'/15 AsIs: >/1 ]] }
    if( ! refalrts::alloc_char( context[24], 'U' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[25], 'e' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[26], context[27], "ed EOF in", 9 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[28], context[29], "..", 2 ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Sysfunm_Xxinm_ERROR.ref.function );
    refalrts::reinit_char( context[6], 'n' );
    refalrts::reinit_char( context[9], 'e' );
    refalrts::reinit_char( context[13], 'x' );
    refalrts::reinit_char( context[20], 'p' );
    refalrts::reinit_char( context[10], 'c' );
    refalrts::update_char( context[11], 't' );
    refalrts::reinit_char( context[14], ' ' );
    refalrts::reinit_char( context[15], '.' );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[15];
    res = refalrts::splice_evar( res, context[28], context[29] );
    res = refalrts::splice_evar( res, context[14], context[21] );
    res = refalrts::splice_evar( res, context[26], context[27] );
    res = refalrts::splice_evar( res, context[10], context[11] );
    res = refalrts::splice_evar( res, context[25], context[25] );
    res = refalrts::splice_evar( res, context[6], context[20] );
    res = refalrts::splice_evar( res, context[24], context[24] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Xxin-Scan/4 s.new#16/5 s.new#17/6 (/9 t.new#18/13 e.new#19/7 )/10 'L'/11 s.new#20/12 s.new#21/15 e.new#22/2 >/1
    if( ! refalrts::char_term( 'L', context[11] ) )
      continue;
    // closed e.new#19 as range 7
    // closed e.new#22 as range 2
    do {
      // </0 & Xxin-Scan/4 s.FileNo#1/5 # General/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 'L'/11 s.S#1/12 s.Letter#1/15 e.Tail#1/2 >/1
      if( ! refalrts::ident_term(  ident_General, context[6] ) )
        continue;
      // closed e.Scanned#1 as range 7
      // closed e.Tail#1 as range 2
      //DEBUG: t.Stack#1: 13
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.S#1: 12
      //DEBUG: s.Letter#1: 15
      //DEBUG: e.Scanned#1: 7
      //DEBUG: e.Tail#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} s.S#1/12 s.Letter#1/15 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 Reuse: # Word/6 AsIs: (/9 } (/16 # General/17 Tile{ AsIs: t.Stack#1/13 AsIs: e.Scanned#1/7 AsIs: )/10 HalfReuse: s.Letter1 #15/11 } )/18 </19 & Type/20 Tile{ AsIs: e.Tail#1/2 } >/21 Tile{ AsIs: >/1 ]] }
      if( ! refalrts::alloc_open_bracket( context[16] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_ident( context[17], ident_General ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[18] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_call( context[19] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_name( context[20], ref_Type.ref.function ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[21] ) )
        return refalrts::cNoMemory;
      refalrts::update_ident( context[6], ident_Word );
      refalrts::reinit_svar( context[11], context[15] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::push_stack( context[21] );
      refalrts::push_stack( context[19] );
      refalrts::link_brackets( context[9], context[18] );
      refalrts::link_brackets( context[16], context[10] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[21], context[21] );
      res = refalrts::splice_evar( res, context[2], context[3] );
      res = refalrts::splice_evar( res, context[18], context[20] );
      res = refalrts::splice_evar( res, context[13], context[11] );
      res = refalrts::splice_evar( res, context[16], context[17] );
      refalrts::splice_to_freelist_open( context[9], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Xxin-Scan/4 s.FileNo#1/5 # Word/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 'L'/11 s.S#1/12 s.Letter#1/15 e.Tail#1/2 >/1
    if( ! refalrts::ident_term(  ident_Word, context[6] ) )
      continue;
    // closed e.Scanned#1 as range 7
    // closed e.Tail#1 as range 2
    //DEBUG: t.Stack#1: 13
    //DEBUG: s.FileNo#1: 5
    //DEBUG: s.S#1: 12
    //DEBUG: s.Letter#1: 15
    //DEBUG: e.Scanned#1: 7
    //DEBUG: e.Tail#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.S#1/12 s.Letter#1/15 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 AsIs: # Word/6 AsIs: (/9 AsIs: t.Stack#1/13 AsIs: e.Scanned#1/7 HalfReuse: s.Letter1 #15/10 HalfReuse: )/11 } </16 & Type/17 Tile{ AsIs: e.Tail#1/2 } >/18 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[17], ref_Type.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[18] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_svar( context[10], context[15] );
    refalrts::reinit_close_bracket( context[11] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[16] );
    refalrts::link_brackets( context[9], context[11] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    refalrts::splice_to_freelist_open( context[11], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Xxin-Scan/4 s.new#16/5 # Word/6 (/9 t.new#17/13 e.new#18/7 )/10 s.new#19/11 s.new#20/12 s.new#21/15 e.new#22/2 >/1
    if( ! refalrts::ident_term(  ident_Word, context[6] ) )
      continue;
    // closed e.new#18 as range 7
    // closed e.new#22 as range 2
    do {
      // </0 & Xxin-Scan/4 s.FileNo#1/5 # Word/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 'D'/11 s.0#1/12 s.Digit#1/15 e.Tail#1/2 >/1
      if( ! refalrts::char_term( 'D', context[11] ) )
        continue;
      // closed e.Scanned#1 as range 7
      // closed e.Tail#1 as range 2
      //DEBUG: t.Stack#1: 13
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.0#1: 12
      //DEBUG: s.Digit#1: 15
      //DEBUG: e.Scanned#1: 7
      //DEBUG: e.Tail#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} s.0#1/12 s.Digit#1/15 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 AsIs: # Word/6 AsIs: (/9 AsIs: t.Stack#1/13 AsIs: e.Scanned#1/7 HalfReuse: s.Digit1 #15/10 HalfReuse: )/11 } </16 & Type/17 Tile{ AsIs: e.Tail#1/2 } >/18 Tile{ AsIs: >/1 ]] }
      if( ! refalrts::alloc_open_call( context[16] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_name( context[17], ref_Type.ref.function ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[18] ) )
        return refalrts::cNoMemory;
      refalrts::reinit_svar( context[10], context[15] );
      refalrts::reinit_close_bracket( context[11] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::push_stack( context[18] );
      refalrts::push_stack( context[16] );
      refalrts::link_brackets( context[9], context[11] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[18], context[18] );
      res = refalrts::splice_evar( res, context[2], context[3] );
      res = refalrts::splice_evar( res, context[16], context[17] );
      refalrts::splice_to_freelist_open( context[11], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & Xxin-Scan/4 s.FileNo#1/5 # Word/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 s.T#1/11 s.S#1/12 '-'/15 e.Tail#1/2 >/1
      if( ! refalrts::char_term( '-', context[15] ) )
        continue;
      // closed e.Scanned#1 as range 7
      // closed e.Tail#1 as range 2
      //DEBUG: t.Stack#1: 13
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.T#1: 11
      //DEBUG: s.S#1: 12
      //DEBUG: e.Scanned#1: 7
      //DEBUG: e.Tail#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 AsIs: # Word/6 AsIs: (/9 AsIs: t.Stack#1/13 AsIs: e.Scanned#1/7 HalfReuse: '-'/10 } )/16 </17 Tile{ HalfReuse: & Type/15 AsIs: e.Tail#1/2 AsIs: >/1 } >/18 Tile{ ]] }
      if( ! refalrts::alloc_close_bracket( context[16] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_call( context[17] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[18] ) )
        return refalrts::cNoMemory;
      refalrts::reinit_char( context[10], '-' );
      refalrts::reinit_name( context[15], ref_Type.ref.function );
      refalrts::push_stack( context[18] );
      refalrts::push_stack( context[0] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[17] );
      refalrts::link_brackets( context[9], context[16] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = arg_end->next;
      res = refalrts::splice_evar( res, context[18], context[18] );
      res = refalrts::splice_evar( res, context[15], context[1] );
      res = refalrts::splice_evar( res, context[16], context[17] );
      refalrts::splice_to_freelist_open( context[10], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & Xxin-Scan/4 s.FileNo#1/5 # Word/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 s.T#1/11 s.S#1/12 '_'/15 e.Tail#1/2 >/1
      if( ! refalrts::char_term( '_', context[15] ) )
        continue;
      // closed e.Scanned#1 as range 7
      // closed e.Tail#1 as range 2
      //DEBUG: t.Stack#1: 13
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.T#1: 11
      //DEBUG: s.S#1: 12
      //DEBUG: e.Scanned#1: 7
      //DEBUG: e.Tail#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 AsIs: # Word/6 AsIs: (/9 AsIs: t.Stack#1/13 AsIs: e.Scanned#1/7 HalfReuse: '_'/10 } )/16 </17 Tile{ HalfReuse: & Type/15 AsIs: e.Tail#1/2 AsIs: >/1 } >/18 Tile{ ]] }
      if( ! refalrts::alloc_close_bracket( context[16] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_call( context[17] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[18] ) )
        return refalrts::cNoMemory;
      refalrts::reinit_char( context[10], '_' );
      refalrts::reinit_name( context[15], ref_Type.ref.function );
      refalrts::push_stack( context[18] );
      refalrts::push_stack( context[0] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[17] );
      refalrts::link_brackets( context[9], context[16] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = arg_end->next;
      res = refalrts::splice_evar( res, context[18], context[18] );
      res = refalrts::splice_evar( res, context[15], context[1] );
      res = refalrts::splice_evar( res, context[16], context[17] );
      refalrts::splice_to_freelist_open( context[10], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & Xxin-Scan/4 s.FileNo#1/5 # Word/6 (/9 (/13 # General/18 t.Stack#1/19 e.Scanned#1/16 )/14 e.Word#1/7 )/10 s.T#1/11 s.S#1/12 ' '/15 e.Tail#1/2 >/1
      context[16] = 0;
      context[17] = 0;
      if( ! refalrts::brackets_term( context[16], context[17], context[13] ) )
        continue;
      if( ! refalrts::char_term( ' ', context[15] ) )
        continue;
      context[18] = refalrts::ident_left(  ident_General, context[16], context[17] );
      if( ! context[18] )
        continue;
      // closed e.Word#1 as range 7
      // closed e.Tail#1 as range 2
      context[20] = refalrts::tvar_left( context[19], context[16], context[17] );
      if( ! context[20] )
        continue;
      // closed e.Scanned#1 as range 16
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.T#1: 11
      //DEBUG: s.S#1: 12
      //DEBUG: e.Word#1: 7
      //DEBUG: e.Tail#1: 2
      //DEBUG: t.Stack#1: 19
      //DEBUG: e.Scanned#1: 16

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 Reuse: # General/6 AsIs: (/9 } Tile{ AsIs: t.Stack#1/19 AsIs: e.Scanned#1/16 HalfReuse: </14 } Tile{ HalfReuse: & Implode_Ext/18 } Tile{ AsIs: e.Word#1/7 } Tile{ HalfReuse: >/13 } Tile{ AsIs: )/10 } </21 Tile{ HalfReuse: & Type/15 AsIs: e.Tail#1/2 AsIs: >/1 } >/22 Tile{ ]] }
      if( ! refalrts::alloc_open_call( context[21] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[22] ) )
        return refalrts::cNoMemory;
      refalrts::update_ident( context[6], ident_General );
      refalrts::reinit_open_call( context[14] );
      refalrts::reinit_name( context[18], ref_Implodeu_Ext.ref.function );
      refalrts::reinit_close_call( context[13] );
      refalrts::reinit_name( context[15], ref_Type.ref.function );
      refalrts::push_stack( context[22] );
      refalrts::push_stack( context[0] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[21] );
      refalrts::link_brackets( context[9], context[10] );
      refalrts::push_stack( context[13] );
      refalrts::push_stack( context[14] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = arg_end->next;
      res = refalrts::splice_evar( res, context[22], context[22] );
      res = refalrts::splice_evar( res, context[15], context[1] );
      res = refalrts::splice_evar( res, context[21], context[21] );
      res = refalrts::splice_evar( res, context[10], context[10] );
      res = refalrts::splice_evar( res, context[13], context[13] );
      res = refalrts::splice_evar( res, context[7], context[8] );
      res = refalrts::splice_evar( res, context[18], context[18] );
      res = refalrts::splice_evar( res, context[19], context[14] );
      refalrts::splice_to_freelist_open( context[9], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & Xxin-Scan/4 s.FileNo#1/5 # Word/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 'N'/11 s.0#1/12 0/15 >/1
      if( ! refalrts::char_term( 'N', context[11] ) )
        continue;
      if( ! refalrts::number_term( 0UL, context[15] ) )
        continue;
      if( ! refalrts::empty_seq( context[2], context[3] ) )
        continue;
      // closed e.Scanned#1 as range 7
      //DEBUG: t.Stack#1: 13
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.0#1: 12
      //DEBUG: e.Scanned#1: 7

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} s.FileNo#1/5 {REMOVED TILE} t.Stack#1/13 e.Scanned#1/7 {REMOVED TILE} s.0#1/12 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sysfun-Xxin-ERROR/4 } 'U'/16 Tile{ HalfReuse: 'n'/10 Reuse: 'e'/11 } Tile{ HalfReuse: 'x'/6 HalfReuse: 'p'/9 }"ected EOF while reading wor"/17 Tile{ HalfReuse: 'd'/15 AsIs: >/1 ]] }
      if( ! refalrts::alloc_char( context[16], 'U' ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_chars( context[17], context[18], "ected EOF while reading wor", 27 ) )
        return refalrts::cNoMemory;
      refalrts::update_name( context[4], ref_Sysfunm_Xxinm_ERROR.ref.function );
      refalrts::reinit_char( context[10], 'n' );
      refalrts::update_char( context[11], 'e' );
      refalrts::reinit_char( context[6], 'x' );
      refalrts::reinit_char( context[9], 'p' );
      refalrts::reinit_char( context[15], 'd' );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[15];
      res = refalrts::splice_evar( res, context[17], context[18] );
      res = refalrts::splice_evar( res, context[6], context[9] );
      res = refalrts::splice_evar( res, context[10], context[11] );
      res = refalrts::splice_evar( res, context[16], context[16] );
      refalrts::splice_to_freelist_open( context[4], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Xxin-Scan/4 s.FileNo#1/5 # Word/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 s.T#1/11 s.S#1/12 s.Other#1/15 e.Tail#1/2 >/1
    // closed e.Scanned#1 as range 7
    // closed e.Tail#1 as range 2
    //DEBUG: t.Stack#1: 13
    //DEBUG: s.FileNo#1: 5
    //DEBUG: s.T#1: 11
    //DEBUG: s.S#1: 12
    //DEBUG: s.Other#1: 15
    //DEBUG: e.Scanned#1: 7
    //DEBUG: e.Tail#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.FileNo#1/5 {REMOVED TILE} t.Stack#1/13 e.Scanned#1/7 {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} e.Tail#1/2 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sysfun-Xxin-ERROR/4 }"Un"/16 Tile{ HalfReuse: 'e'/6 HalfReuse: 'x'/9 } Tile{ HalfReuse: 'p'/10 }"ected \""/18 Tile{ AsIs: s.Other#1/15 }"\" while reading word"/20 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_chars( context[16], context[17], "Un", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "ected \"", 7 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "\" while reading word", 20 ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Sysfunm_Xxinm_ERROR.ref.function );
    refalrts::reinit_char( context[6], 'e' );
    refalrts::reinit_char( context[9], 'x' );
    refalrts::reinit_char( context[10], 'p' );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[6], context[9] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Xxin-Scan/4 s.new#16/5 s.new#17/6 (/9 t.new#18/13 e.new#19/7 )/10 'D'/11 s.new#20/12 s.new#21/15 e.new#22/2 >/1
    if( ! refalrts::char_term( 'D', context[11] ) )
      continue;
    // closed e.new#19 as range 7
    // closed e.new#22 as range 2
    do {
      // </0 & Xxin-Scan/4 s.FileNo#1/5 # General/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 'D'/11 s.0#1/12 s.Digit#1/15 e.Tail#1/2 >/1
      if( ! refalrts::ident_term(  ident_General, context[6] ) )
        continue;
      // closed e.Scanned#1 as range 7
      // closed e.Tail#1 as range 2
      //DEBUG: t.Stack#1: 13
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.0#1: 12
      //DEBUG: s.Digit#1: 15
      //DEBUG: e.Scanned#1: 7
      //DEBUG: e.Tail#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} s.0#1/12 s.Digit#1/15 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 Reuse: # Number/6 AsIs: (/9 } (/16 # General/17 Tile{ AsIs: t.Stack#1/13 AsIs: e.Scanned#1/7 AsIs: )/10 HalfReuse: s.Digit1 #15/11 } )/18 </19 & Type/20 Tile{ AsIs: e.Tail#1/2 } >/21 Tile{ AsIs: >/1 ]] }
      if( ! refalrts::alloc_open_bracket( context[16] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_ident( context[17], ident_General ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[18] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_call( context[19] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_name( context[20], ref_Type.ref.function ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[21] ) )
        return refalrts::cNoMemory;
      refalrts::update_ident( context[6], ident_Number );
      refalrts::reinit_svar( context[11], context[15] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::push_stack( context[21] );
      refalrts::push_stack( context[19] );
      refalrts::link_brackets( context[9], context[18] );
      refalrts::link_brackets( context[16], context[10] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[21], context[21] );
      res = refalrts::splice_evar( res, context[2], context[3] );
      res = refalrts::splice_evar( res, context[18], context[20] );
      res = refalrts::splice_evar( res, context[13], context[11] );
      res = refalrts::splice_evar( res, context[16], context[17] );
      refalrts::splice_to_freelist_open( context[9], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Xxin-Scan/4 s.FileNo#1/5 # Number/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 'D'/11 s.0#1/12 s.Digit#1/15 e.Tail#1/2 >/1
    if( ! refalrts::ident_term(  ident_Number, context[6] ) )
      continue;
    // closed e.Scanned#1 as range 7
    // closed e.Tail#1 as range 2
    //DEBUG: t.Stack#1: 13
    //DEBUG: s.FileNo#1: 5
    //DEBUG: s.0#1: 12
    //DEBUG: s.Digit#1: 15
    //DEBUG: e.Scanned#1: 7
    //DEBUG: e.Tail#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.0#1/12 s.Digit#1/15 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 AsIs: # Number/6 AsIs: (/9 AsIs: t.Stack#1/13 AsIs: e.Scanned#1/7 HalfReuse: s.Digit1 #15/10 HalfReuse: )/11 } </16 & Type/17 Tile{ AsIs: e.Tail#1/2 } >/18 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[17], ref_Type.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[18] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_svar( context[10], context[15] );
    refalrts::reinit_close_bracket( context[11] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[18] );
    refalrts::push_stack( context[16] );
    refalrts::link_brackets( context[9], context[11] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[18], context[18] );
    res = refalrts::splice_evar( res, context[2], context[3] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    refalrts::splice_to_freelist_open( context[11], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Xxin-Scan/4 s.new#16/5 # Number/6 (/9 t.new#17/13 e.new#18/7 )/10 s.new#19/11 s.new#20/12 s.new#21/15 e.new#22/2 >/1
    if( ! refalrts::ident_term(  ident_Number, context[6] ) )
      continue;
    // closed e.new#18 as range 7
    // closed e.new#22 as range 2
    do {
      // </0 & Xxin-Scan/4 s.FileNo#1/5 # Number/6 (/9 (/13 # General/18 t.Stack#1/19 e.Scanned#1/16 )/14 e.Number#1/7 )/10 s.T#1/11 s.S#1/12 ' '/15 e.Tail#1/2 >/1
      context[16] = 0;
      context[17] = 0;
      if( ! refalrts::brackets_term( context[16], context[17], context[13] ) )
        continue;
      if( ! refalrts::char_term( ' ', context[15] ) )
        continue;
      context[18] = refalrts::ident_left(  ident_General, context[16], context[17] );
      if( ! context[18] )
        continue;
      // closed e.Number#1 as range 7
      // closed e.Tail#1 as range 2
      context[20] = refalrts::tvar_left( context[19], context[16], context[17] );
      if( ! context[20] )
        continue;
      // closed e.Scanned#1 as range 16
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.T#1: 11
      //DEBUG: s.S#1: 12
      //DEBUG: e.Number#1: 7
      //DEBUG: e.Tail#1: 2
      //DEBUG: t.Stack#1: 19
      //DEBUG: e.Scanned#1: 16

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.FileNo#1/5 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: </6 HalfReuse: [*]/9 HalfReuse: & Xxin-Scan$38:1/13 HalfReuse: s.FileNo1 #5/18 AsIs: t.Stack#1/19 } Tile{ HalfReuse: (/4 } Tile{ AsIs: e.Scanned#1/16 } Tile{ HalfReuse: )/15 } (/21 Tile{ AsIs: e.Tail#1/2 } )/22 {*}/23 Tile{ AsIs: </0 } Tile{ HalfReuse: & Numb-Aux/14 AsIs: e.Number#1/7 HalfReuse: >/10 } Tile{ AsIs: >/1 ]] }
      if( ! refalrts::alloc_open_bracket( context[21] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[22] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_unwrapped_closure( context[23], context[9] ) )
        return refalrts::cNoMemory;
      refalrts::reinit_open_call( context[6] );
      refalrts::reinit_closure_head( context[9] );
      refalrts::reinit_name( context[13], ref_gen_Xxinm_Scan_S38B1.ref.function );
      refalrts::reinit_svar( context[18], context[5] );
      refalrts::reinit_open_bracket( context[4] );
      refalrts::reinit_close_bracket( context[15] );
      refalrts::reinit_name( context[14], ref_Numbm_Aux.ref.function );
      refalrts::reinit_close_call( context[10] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[6] );
      refalrts::push_stack( context[10] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[21], context[22] );
      refalrts::link_brackets( context[4], context[15] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[14], context[10] );
      res = refalrts::splice_evar( res, context[0], context[0] );
      res = refalrts::splice_evar( res, context[22], context[23] );
      res = refalrts::splice_evar( res, context[2], context[3] );
      res = refalrts::splice_evar( res, context[21], context[21] );
      res = refalrts::splice_evar( res, context[15], context[15] );
      res = refalrts::splice_evar( res, context[16], context[17] );
      res = refalrts::splice_evar( res, context[4], context[4] );
      res = refalrts::splice_evar( res, context[6], context[20] );
      refalrts::splice_to_freelist_open( trash_prev, res );
      refalrts::wrap_closure( context[23] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & Xxin-Scan/4 s.FileNo#1/5 # Number/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 'N'/11 s.0#1/12 0/15 >/1
      if( ! refalrts::char_term( 'N', context[11] ) )
        continue;
      if( ! refalrts::number_term( 0UL, context[15] ) )
        continue;
      if( ! refalrts::empty_seq( context[2], context[3] ) )
        continue;
      // closed e.Scanned#1 as range 7
      //DEBUG: t.Stack#1: 13
      //DEBUG: s.FileNo#1: 5
      //DEBUG: s.0#1: 12
      //DEBUG: e.Scanned#1: 7

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} s.FileNo#1/5 {REMOVED TILE} t.Stack#1/13 e.Scanned#1/7 {REMOVED TILE} s.0#1/12 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sysfun-Xxin-ERROR/4 } 'U'/16 Tile{ HalfReuse: 'n'/10 Reuse: 'e'/11 } Tile{ HalfReuse: 'x'/6 HalfReuse: 'p'/9 }"ected EOF while reading macrodigi"/17 Tile{ HalfReuse: 't'/15 AsIs: >/1 ]] }
      if( ! refalrts::alloc_char( context[16], 'U' ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_chars( context[17], context[18], "ected EOF while reading macrodigi", 33 ) )
        return refalrts::cNoMemory;
      refalrts::update_name( context[4], ref_Sysfunm_Xxinm_ERROR.ref.function );
      refalrts::reinit_char( context[10], 'n' );
      refalrts::update_char( context[11], 'e' );
      refalrts::reinit_char( context[6], 'x' );
      refalrts::reinit_char( context[9], 'p' );
      refalrts::reinit_char( context[15], 't' );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[15];
      res = refalrts::splice_evar( res, context[17], context[18] );
      res = refalrts::splice_evar( res, context[6], context[9] );
      res = refalrts::splice_evar( res, context[10], context[11] );
      res = refalrts::splice_evar( res, context[16], context[16] );
      refalrts::splice_to_freelist_open( context[4], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Xxin-Scan/4 s.FileNo#1/5 # Number/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 s.T#1/11 s.S#1/12 s.Other#1/15 e.Tail#1/2 >/1
    // closed e.Scanned#1 as range 7
    // closed e.Tail#1 as range 2
    //DEBUG: t.Stack#1: 13
    //DEBUG: s.FileNo#1: 5
    //DEBUG: s.T#1: 11
    //DEBUG: s.S#1: 12
    //DEBUG: s.Other#1: 15
    //DEBUG: e.Scanned#1: 7
    //DEBUG: e.Tail#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.FileNo#1/5 {REMOVED TILE} t.Stack#1/13 e.Scanned#1/7 {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} e.Tail#1/2 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Sysfun-Xxin-ERROR/4 }"Un"/16 Tile{ HalfReuse: 'e'/6 HalfReuse: 'x'/9 } Tile{ HalfReuse: 'p'/10 }"ected \""/18 Tile{ AsIs: s.Other#1/15 }"\" while reading macrodigit"/20 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_chars( context[16], context[17], "Un", 2 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[18], context[19], "ected \"", 7 ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_chars( context[20], context[21], "\" while reading macrodigit", 26 ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Sysfunm_Xxinm_ERROR.ref.function );
    refalrts::reinit_char( context[6], 'e' );
    refalrts::reinit_char( context[9], 'x' );
    refalrts::reinit_char( context[10], 'p' );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[20], context[21] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[18], context[19] );
    res = refalrts::splice_evar( res, context[10], context[10] );
    res = refalrts::splice_evar( res, context[6], context[9] );
    res = refalrts::splice_evar( res, context[16], context[17] );
    refalrts::splice_to_freelist_open( context[4], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Xxin-Scan/4 s.FileNo#1/5 # General/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 s.T#1/11 s.S#1/12 ' '/15 e.Tail#1/2 >/1
    if( ! refalrts::char_term( ' ', context[15] ) )
      continue;
    if( ! refalrts::ident_term(  ident_General, context[6] ) )
      continue;
    // closed e.Scanned#1 as range 7
    // closed e.Tail#1 as range 2
    //DEBUG: t.Stack#1: 13
    //DEBUG: s.FileNo#1: 5
    //DEBUG: s.T#1: 11
    //DEBUG: s.S#1: 12
    //DEBUG: e.Scanned#1: 7
    //DEBUG: e.Tail#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.T#1/11 s.S#1/12 {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 AsIs: # General/6 AsIs: (/9 AsIs: t.Stack#1/13 AsIs: e.Scanned#1/7 AsIs: )/10 } </16 Tile{ HalfReuse: & Type/15 AsIs: e.Tail#1/2 AsIs: >/1 } >/17 Tile{ ]] }
    if( ! refalrts::alloc_open_call( context[16] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[17] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_name( context[15], ref_Type.ref.function );
    refalrts::push_stack( context[17] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[16] );
    refalrts::link_brackets( context[9], context[10] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[17], context[17] );
    res = refalrts::splice_evar( res, context[15], context[1] );
    res = refalrts::splice_evar( res, context[16], context[16] );
    refalrts::splice_to_freelist_open( context[10], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Xxin-Scan/4 s.FileNo#1/5 s.State#1/6 (/9 t.Stack#1/13 e.Scanned#1/7 )/10 s.T#1/11 s.S#1/12 s.Other#1/15 e.Tail#1/2 >/1
  // closed e.Scanned#1 as range 7
  // closed e.Tail#1 as range 2
  //DEBUG: t.Stack#1: 13
  //DEBUG: s.FileNo#1: 5
  //DEBUG: s.State#1: 6
  //DEBUG: s.T#1: 11
  //DEBUG: s.S#1: 12
  //DEBUG: s.Other#1: 15
  //DEBUG: e.Scanned#1: 7
  //DEBUG: e.Tail#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.T#1/11 s.S#1/12 s.Other#1/15 {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 AsIs: & Xxin-Scan/4 AsIs: s.FileNo#1/5 AsIs: s.State#1/6 AsIs: (/9 AsIs: t.Stack#1/13 AsIs: e.Scanned#1/7 HalfReuse: s.Other1 #15/10 } )/16 </17 & Type/18 Tile{ AsIs: e.Tail#1/2 } >/19 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_close_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[18], ref_Type.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[19] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_svar( context[10], context[15] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[19] );
  refalrts::push_stack( context[17] );
  refalrts::link_brackets( context[9], context[16] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[19], context[19] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[16], context[18] );
  refalrts::splice_to_freelist_open( context[10], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Xxinm_Scan("Xxin-Scan", 877573369U, 332537286U, func_Xxinm_Scan);


static refalrts::FnResult func_HexDigit(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  // </0 & HexDigit/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & HexDigit/4 s.new#1/5 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // </0 & HexDigit/4 '0'/5 >/1
    if( ! refalrts::char_term( '0', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 '0'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 0/1 ]] }
    refalrts::reinit_number( context[1], 0UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 '1'/5 >/1
    if( ! refalrts::char_term( '1', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 '1'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 1/1 ]] }
    refalrts::reinit_number( context[1], 1UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 '2'/5 >/1
    if( ! refalrts::char_term( '2', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 '2'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 2/1 ]] }
    refalrts::reinit_number( context[1], 2UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 '3'/5 >/1
    if( ! refalrts::char_term( '3', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 '3'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 3/1 ]] }
    refalrts::reinit_number( context[1], 3UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 '4'/5 >/1
    if( ! refalrts::char_term( '4', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 '4'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 4/1 ]] }
    refalrts::reinit_number( context[1], 4UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 '5'/5 >/1
    if( ! refalrts::char_term( '5', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 '5'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 5/1 ]] }
    refalrts::reinit_number( context[1], 5UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 '6'/5 >/1
    if( ! refalrts::char_term( '6', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 '6'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 6/1 ]] }
    refalrts::reinit_number( context[1], 6UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 '7'/5 >/1
    if( ! refalrts::char_term( '7', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 '7'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 7/1 ]] }
    refalrts::reinit_number( context[1], 7UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 '8'/5 >/1
    if( ! refalrts::char_term( '8', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 '8'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 8/1 ]] }
    refalrts::reinit_number( context[1], 8UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 '9'/5 >/1
    if( ! refalrts::char_term( '9', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 '9'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 9/1 ]] }
    refalrts::reinit_number( context[1], 9UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 'A'/5 >/1
    if( ! refalrts::char_term( 'A', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 'A'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 10/1 ]] }
    refalrts::reinit_number( context[1], 10UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 'B'/5 >/1
    if( ! refalrts::char_term( 'B', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 'B'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 11/1 ]] }
    refalrts::reinit_number( context[1], 11UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 'C'/5 >/1
    if( ! refalrts::char_term( 'C', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 'C'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 12/1 ]] }
    refalrts::reinit_number( context[1], 12UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 'D'/5 >/1
    if( ! refalrts::char_term( 'D', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 'D'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 13/1 ]] }
    refalrts::reinit_number( context[1], 13UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 'E'/5 >/1
    if( ! refalrts::char_term( 'E', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 'E'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 14/1 ]] }
    refalrts::reinit_number( context[1], 14UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 'F'/5 >/1
    if( ! refalrts::char_term( 'F', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 'F'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 15/1 ]] }
    refalrts::reinit_number( context[1], 15UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 'a'/5 >/1
    if( ! refalrts::char_term( 'a', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 'a'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 10/1 ]] }
    refalrts::reinit_number( context[1], 10UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 'b'/5 >/1
    if( ! refalrts::char_term( 'b', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 'b'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 11/1 ]] }
    refalrts::reinit_number( context[1], 11UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 'c'/5 >/1
    if( ! refalrts::char_term( 'c', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 'c'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 12/1 ]] }
    refalrts::reinit_number( context[1], 12UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 'd'/5 >/1
    if( ! refalrts::char_term( 'd', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 'd'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 13/1 ]] }
    refalrts::reinit_number( context[1], 13UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 'e'/5 >/1
    if( ! refalrts::char_term( 'e', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 'e'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 14/1 ]] }
    refalrts::reinit_number( context[1], 14UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & HexDigit/4 'f'/5 >/1
    if( ! refalrts::char_term( 'f', context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & HexDigit/4 'f'/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 15/1 ]] }
    refalrts::reinit_number( context[1], 15UL );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & HexDigit/4 s.Other#1/5 >/1
  //DEBUG: s.Other#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & HexDigit/4 s.Other#1/5 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_HexDigit("HexDigit", 877573369U, 332537286U, func_HexDigit);


static refalrts::FnResult func_Quote(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  // </0 & Quote/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Quote/4 s.new#1/5 e.new#2/2 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#2 as range 2
  do {
    // </0 & Quote/4 '\''/5 e.Text#1/2 >/1
    if( ! refalrts::char_term( '\'', context[5] ) )
      continue;
    // closed e.Text#1 as range 2
    //DEBUG: e.Text#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Quote/4 '\''/5 {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: e.Text#1/2 } Tile{ ]] }
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[2], context[3] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Quote/4 '\"'/5 e.Text#1/2 >/1
  if( ! refalrts::char_term( '\"', context[5] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Text#1 as range 2
  //DEBUG: e.Text#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: </4 HalfReuse: & Implode_Ext/5 AsIs: e.Text#1/2 AsIs: >/1 ]] }
  refalrts::reinit_open_call( context[4] );
  refalrts::reinit_name( context[5], ref_Implodeu_Ext.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[4];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Quote("Quote", 877573369U, 332537286U, func_Quote);


static refalrts::FnResult func_Sysfunm_Xxout(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 18 elems
  refalrts::Iter context[18];
  refalrts::zeros( context, 18 );
  // </0 & Sysfun-Xxout/4 e.FileName#1/2 (/7 s.Width#1/9 e.Expression#1/5 )/8 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_right( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.FileName#1 as range 2
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Expression#1 as range 5
  //DEBUG: e.FileName#1: 2
  //DEBUG: s.Width#1: 9
  //DEBUG: e.Expression#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </10 & Xxout-Wrap/11 </12 Tile{ HalfReuse: & FOpen/0 HalfReuse: 'w'/4 AsIs: e.FileName#1/2 HalfReuse: >/7 AsIs: s.Width#1/9 } </13 & Xxout-Scan/14 </15 & Type/16 Tile{ AsIs: e.Expression#1/5 } >/17 Tile{ HalfReuse: >/8 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], ref_Xxoutm_Wrap.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], ref_Xxoutm_Scan.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[15] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[16], ref_Type.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[17] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[0], ref_FOpen.ref.function );
  refalrts::reinit_char( context[4], 'w' );
  refalrts::reinit_close_call( context[7] );
  refalrts::reinit_close_call( context[8] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[12] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[8];
  res = refalrts::splice_evar( res, context[17], context[17] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[13], context[16] );
  res = refalrts::splice_evar( res, context[0], context[9] );
  res = refalrts::splice_evar( res, context[10], context[12] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Sysfunm_Xxout("Sysfun-Xxout", 877573369U, 332537286U, func_Sysfunm_Xxout);


static refalrts::FnResult func_gen_Xxoutm_Wrap_B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 14 elems
  refalrts::Iter context[14];
  refalrts::zeros( context, 14 );
  // </0 & Xxout-Wrap:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Xxout-Wrap:1/4 s.new#1/5 s.new#2/6 (/9 e.new#3/7 )/10 e.new#4/2 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[7] = 0;
  context[8] = 0;
  context[9] = refalrts::brackets_left( context[7], context[8], context[2], context[3] );
  if( ! context[9] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[9], context[10]);
  // closed e.new#3 as range 7
  // closed e.new#4 as range 2
  do {
    // </0 & Xxout-Wrap:1/4 s.FileNo#1/5 s.Width#1/6 (/9 e.Line#2/7 )/10 >/1
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    // closed e.Line#2 as range 7
    //DEBUG: s.FileNo#1: 5
    //DEBUG: s.Width#1: 6
    //DEBUG: e.Line#2: 7

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} s.Width#1/6 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Write-Aux/4 AsIs: s.FileNo#1/5 } Tile{ AsIs: e.Line#2/7 } Tile{ HalfReuse: >/9 } </11 & FClose/12 Tile{ HalfReuse: s.FileNo1 #5/10 AsIs: >/1 ]] }
    if( ! refalrts::alloc_open_call( context[11] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[12], ref_FClose.ref.function ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Writem_Aux.ref.function );
    refalrts::reinit_close_call( context[9] );
    refalrts::reinit_svar( context[10], context[5] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[11] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[0] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[10];
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[9], context[9] );
    res = refalrts::splice_evar( res, context[7], context[8] );
    refalrts::splice_to_freelist_open( context[5], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Xxout-Wrap:1/4 s.FileNo#1/5 s.Width#1/6 (/9 e.Line#2/7 )/10 e.Rest#2/2 >/1
  // closed e.Line#2 as range 7
  // closed e.Rest#2 as range 2
  //DEBUG: s.FileNo#1: 5
  //DEBUG: s.Width#1: 6
  //DEBUG: e.Line#2: 7
  //DEBUG: e.Rest#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.Width#1/6 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Putout-Aux/4 AsIs: s.FileNo#1/5 } Tile{ AsIs: e.Line#2/7 } Tile{ HalfReuse: >/9 } </11 & Xxout-Wrap/12 s.FileNo#1/5/13 Tile{ HalfReuse: s.Width1 #6/10 AsIs: e.Rest#2/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[12], ref_Xxoutm_Wrap.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[13], context[5]))
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Putoutm_Aux.ref.function );
  refalrts::reinit_close_call( context[9] );
  refalrts::reinit_svar( context[10], context[6] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[10];
  res = refalrts::splice_evar( res, context[11], context[13] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[7], context[8] );
  refalrts::splice_to_freelist_open( context[5], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Xxoutm_Wrap_B1("Xxout-Wrap:1", 877573369U, 332537286U, func_gen_Xxoutm_Wrap_B1);


static refalrts::FnResult func_Xxoutm_Wrap(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & Xxout-Wrap/4 s.FileNo#1/5 s.Width#1/6 e.Text#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Text#1 as range 2
  //DEBUG: s.FileNo#1: 5
  //DEBUG: s.Width#1: 6
  //DEBUG: e.Text#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </7 Tile{ HalfReuse: [*]/0 Reuse: & Xxout-Wrap:1/4 AsIs: s.FileNo#1/5 AsIs: s.Width#1/6 } {*}/8 </9 & DoFirst/10 s.Width#1/6/11 (/12 )/13 Tile{ AsIs: e.Text#1/2 } >/14 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[8], context[0] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_DoFirst.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[11], context[6]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[0] );
  refalrts::update_name( context[4], ref_gen_Xxoutm_Wrap_B1.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[9] );
  refalrts::link_brackets( context[12], context[13] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[14], context[14] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[8], context[13] );
  res = refalrts::splice_evar( res, context[0], context[6] );
  res = refalrts::splice_evar( res, context[7], context[7] );
  refalrts::use( res );
  refalrts::wrap_closure( context[8] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Xxoutm_Wrap("Xxout-Wrap", 877573369U, 332537286U, func_Xxoutm_Wrap);


static refalrts::FnResult func_gen_Xxoutm_Scan_S1A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  // </0 & Xxout-Scan$1=1/4 (/7 e.Chars#2/5 )/8 s.T#2/9 s.S#2/10 e.Tail#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Chars#2 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Tail#2 as range 2
  //DEBUG: e.Chars#2: 5
  //DEBUG: s.T#2: 9
  //DEBUG: s.S#2: 10
  //DEBUG: e.Tail#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: '\''/0 } Tile{ AsIs: e.Chars#2/5 } Tile{ HalfReuse: '\''/4 HalfReuse: </7 } Tile{ HalfReuse: & Xxout-Scan/8 AsIs: s.T#2/9 AsIs: s.S#2/10 AsIs: e.Tail#2/2 AsIs: >/1 ]] }
  refalrts::reinit_char( context[0], '\'' );
  refalrts::reinit_char( context[4], '\'' );
  refalrts::reinit_open_call( context[7] );
  refalrts::reinit_name( context[8], ref_Xxoutm_Scan.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[8];
  res = refalrts::splice_evar( res, context[4], context[7] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Xxoutm_Scan_S1A1("Xxout-Scan$1=1", 877573369U, 332537286U, func_gen_Xxoutm_Scan_S1A1);


static refalrts::FnResult func_gen_Xxoutm_Scan_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  // </0 & Xxout-Scan$2=1/4 (/7 e.Chars#2/5 )/8 s.T#2/9 s.S#2/10 e.Tail#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Chars#2 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Tail#2 as range 2
  //DEBUG: e.Chars#2: 5
  //DEBUG: s.T#2: 9
  //DEBUG: s.S#2: 10
  //DEBUG: e.Tail#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: '\''/0 } Tile{ AsIs: e.Chars#2/5 } Tile{ HalfReuse: '\''/4 HalfReuse: </7 } Tile{ HalfReuse: & Xxout-Scan/8 AsIs: s.T#2/9 AsIs: s.S#2/10 AsIs: e.Tail#2/2 AsIs: >/1 ]] }
  refalrts::reinit_char( context[0], '\'' );
  refalrts::reinit_char( context[4], '\'' );
  refalrts::reinit_open_call( context[7] );
  refalrts::reinit_name( context[8], ref_Xxoutm_Scan.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[8];
  res = refalrts::splice_evar( res, context[4], context[7] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Xxoutm_Scan_S2A1("Xxout-Scan$2=1", 877573369U, 332537286U, func_gen_Xxoutm_Scan_S2A1);


static refalrts::FnResult func_gen_Xxoutm_Scan_S4A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & Xxout-Scan$4=1/4 (/7 e.Tail#1/5 )/8 (/11 e.Chars#2/9 )/12 '*'/13 s.0#2/14 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  context[13] = refalrts::char_left( '*', context[2], context[3] );
  if( ! context[13] )
    return refalrts::cRecognitionImpossible;
  // closed e.Tail#1 as range 5
  // closed e.Chars#2 as range 9
  if( ! refalrts::svar_left( context[14], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Tail#1: 5
  //DEBUG: e.Chars#2: 9
  //DEBUG: s.0#2: 14

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.0#2/14 {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ Reuse: '\"'/13 } Tile{ AsIs: e.Chars#2/9 } Tile{ HalfReuse: '\"'/1 } Tile{ HalfReuse: </12 } Tile{ HalfReuse: & Xxout-Scan/0 HalfReuse: </4 HalfReuse: & Type/7 AsIs: e.Tail#1/5 HalfReuse: >/8 HalfReuse: >/11 } Tile{ ]] }
  refalrts::update_char( context[13], '\"' );
  refalrts::reinit_char( context[1], '\"' );
  refalrts::reinit_open_call( context[12] );
  refalrts::reinit_name( context[0], ref_Xxoutm_Scan.ref.function );
  refalrts::reinit_open_call( context[4] );
  refalrts::reinit_name( context[7], ref_Type.ref.function );
  refalrts::reinit_close_call( context[8] );
  refalrts::reinit_close_call( context[11] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[0], context[11] );
  res = refalrts::splice_evar( res, context[12], context[12] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[13], context[13] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Xxoutm_Scan_S4A1("Xxout-Scan$4=1", 877573369U, 332537286U, func_gen_Xxoutm_Scan_S4A1);


static refalrts::FnResult func_gen_Xxoutm_Scan_S6A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  // </0 & Xxout-Scan$6=1/4 (/7 e.Chars#2/5 )/8 s.T#2/9 s.S#2/10 e.Tail#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Chars#2 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Tail#2 as range 2
  //DEBUG: e.Chars#2: 5
  //DEBUG: s.T#2: 9
  //DEBUG: s.S#2: 10
  //DEBUG: e.Tail#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: '\''/0 } Tile{ AsIs: e.Chars#2/5 } Tile{ HalfReuse: '\''/4 HalfReuse: </7 } Tile{ HalfReuse: & Xxout-Scan/8 AsIs: s.T#2/9 AsIs: s.S#2/10 AsIs: e.Tail#2/2 AsIs: >/1 ]] }
  refalrts::reinit_char( context[0], '\'' );
  refalrts::reinit_char( context[4], '\'' );
  refalrts::reinit_open_call( context[7] );
  refalrts::reinit_name( context[8], ref_Xxoutm_Scan.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[8];
  res = refalrts::splice_evar( res, context[4], context[7] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Xxoutm_Scan_S6A1("Xxout-Scan$6=1", 877573369U, 332537286U, func_gen_Xxoutm_Scan_S6A1);


static refalrts::FnResult func_gen_Xxoutm_Scan_S7A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  // </0 & Xxout-Scan$7=1/4 (/7 e.Chars#2/5 )/8 s.T#2/9 s.S#2/10 e.Tail#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Chars#2 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Tail#2 as range 2
  //DEBUG: e.Chars#2: 5
  //DEBUG: s.T#2: 9
  //DEBUG: s.S#2: 10
  //DEBUG: e.Tail#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: '\''/0 } Tile{ AsIs: e.Chars#2/5 } Tile{ HalfReuse: '\''/4 HalfReuse: </7 } Tile{ HalfReuse: & Xxout-Scan/8 AsIs: s.T#2/9 AsIs: s.S#2/10 AsIs: e.Tail#2/2 AsIs: >/1 ]] }
  refalrts::reinit_char( context[0], '\'' );
  refalrts::reinit_char( context[4], '\'' );
  refalrts::reinit_open_call( context[7] );
  refalrts::reinit_name( context[8], ref_Xxoutm_Scan.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[8];
  res = refalrts::splice_evar( res, context[4], context[7] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Xxoutm_Scan_S7A1("Xxout-Scan$7=1", 877573369U, 332537286U, func_gen_Xxoutm_Scan_S7A1);


static refalrts::FnResult func_Xxoutm_Scan(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 24 elems
  refalrts::Iter context[24];
  refalrts::zeros( context, 24 );
  // </0 & Xxout-Scan/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Xxout-Scan/4 s.new#1/5 s.new#2/6 e.new#3/2 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[6], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#3 as range 2
  do {
    // </0 & Xxout-Scan/4 s.new#4/5 s.new#5/6 t.new#6/9 e.new#7/7 >/1
    context[7] = context[2];
    context[8] = context[3];
    context[10] = refalrts::tvar_left( context[9], context[7], context[8] );
    if( ! context[10] )
      continue;
    // closed e.new#7 as range 7
    do {
      // </0 & Xxout-Scan/4 s.new#8/5 s.new#9/6 s.new#10/9 e.new#11/7 >/1
      if( ! refalrts::svar_term( context[9], context[9] ) )
        continue;
      // closed e.new#11 as range 7
      do {
        // </0 & Xxout-Scan/4 'L'/5 s.S#1/6 s.Letter#1/9 e.Tail#1/7 >/1
        if( ! refalrts::char_term( 'L', context[5] ) )
          continue;
        // closed e.Tail#1 as range 7
        //DEBUG: s.S#1: 6
        //DEBUG: s.Letter#1: 9
        //DEBUG: e.Tail#1: 7

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ } </11 & Xxout-Scan$1=1/12 </13 & Xxout-Chars/14 Tile{ HalfReuse: (/0 HalfReuse: )/4 AsIs: 'L'/5 AsIs: s.S#1/6 AsIs: s.Letter#1/9 AsIs: e.Tail#1/7 AsIs: >/1 } >/15 Tile{ ]] }
        if( ! refalrts::alloc_open_call( context[11] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_name( context[12], ref_gen_Xxoutm_Scan_S1A1.ref.function ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_open_call( context[13] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_name( context[14], ref_Xxoutm_Chars.ref.function ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_call( context[15] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_open_bracket( context[0] );
        refalrts::reinit_close_bracket( context[4] );
        refalrts::push_stack( context[15] );
        refalrts::push_stack( context[11] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[13] );
        refalrts::link_brackets( context[0], context[4] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = arg_end->next;
        res = refalrts::splice_evar( res, context[15], context[15] );
        res = refalrts::splice_evar( res, context[0], context[1] );
        res = refalrts::splice_evar( res, context[11], context[14] );
        refalrts::use( res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Xxout-Scan/4 'D'/5 s.0#1/6 s.Digit#1/9 e.Tail#1/7 >/1
        if( ! refalrts::char_term( 'D', context[5] ) )
          continue;
        // closed e.Tail#1 as range 7
        //DEBUG: s.0#1: 6
        //DEBUG: s.Digit#1: 9
        //DEBUG: e.Tail#1: 7

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ } </11 & Xxout-Scan$2=1/12 </13 & Xxout-Chars/14 Tile{ HalfReuse: (/0 HalfReuse: )/4 AsIs: 'D'/5 AsIs: s.0#1/6 AsIs: s.Digit#1/9 AsIs: e.Tail#1/7 AsIs: >/1 } >/15 Tile{ ]] }
        if( ! refalrts::alloc_open_call( context[11] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_name( context[12], ref_gen_Xxoutm_Scan_S2A1.ref.function ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_open_call( context[13] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_name( context[14], ref_Xxoutm_Chars.ref.function ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_call( context[15] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_open_bracket( context[0] );
        refalrts::reinit_close_bracket( context[4] );
        refalrts::push_stack( context[15] );
        refalrts::push_stack( context[11] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[13] );
        refalrts::link_brackets( context[0], context[4] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = arg_end->next;
        res = refalrts::splice_evar( res, context[15], context[15] );
        res = refalrts::splice_evar( res, context[0], context[1] );
        res = refalrts::splice_evar( res, context[11], context[14] );
        refalrts::use( res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Xxout-Scan/4 'W'/5 s.new#12/6 s.new#13/9 e.new#14/7 >/1
        if( ! refalrts::char_term( 'W', context[5] ) )
          continue;
        // closed e.new#14 as range 7
        do {
          // </0 & Xxout-Scan/4 'W'/5 'i'/6 s.Word#1/9 e.Tail#1/7 >/1
          if( ! refalrts::char_term( 'i', context[6] ) )
            continue;
          // closed e.Tail#1 as range 7
          //DEBUG: s.Word#1: 9
          //DEBUG: e.Tail#1: 7

          refalrts::reset_allocator();
          //TRASH: {REMOVED TILE} s.Word#1/9 {REMOVED TILE} {REMOVED TILE}
          //RESULT: Tile{ [[ AsIs: </0 Reuse: & Explode/4 HalfReuse: s.Word1 #9/5 HalfReuse: >/6 } ' '/11 </12 & Xxout-Scan/13 </14 & Type/15 Tile{ AsIs: e.Tail#1/7 } >/16 Tile{ AsIs: >/1 ]] }
          if( ! refalrts::alloc_char( context[11], ' ' ) )
            return refalrts::cNoMemory;
          if( ! refalrts::alloc_open_call( context[12] ) )
            return refalrts::cNoMemory;
          if( ! refalrts::alloc_name( context[13], ref_Xxoutm_Scan.ref.function ) )
            return refalrts::cNoMemory;
          if( ! refalrts::alloc_open_call( context[14] ) )
            return refalrts::cNoMemory;
          if( ! refalrts::alloc_name( context[15], ref_Type.ref.function ) )
            return refalrts::cNoMemory;
          if( ! refalrts::alloc_close_call( context[16] ) )
            return refalrts::cNoMemory;
          refalrts::update_name( context[4], ref_Explode.ref.function );
          refalrts::reinit_svar( context[5], context[9] );
          refalrts::reinit_close_call( context[6] );
          refalrts::push_stack( context[1] );
          refalrts::push_stack( context[12] );
          refalrts::push_stack( context[16] );
          refalrts::push_stack( context[14] );
          refalrts::push_stack( context[6] );
          refalrts::push_stack( context[0] );
          refalrts::Iter trash_prev = arg_begin->prev;
          refalrts::use(trash_prev);
          refalrts::Iter res = context[1];
          res = refalrts::splice_evar( res, context[16], context[16] );
          res = refalrts::splice_evar( res, context[7], context[8] );
          res = refalrts::splice_evar( res, context[11], context[15] );
          refalrts::splice_to_freelist_open( context[6], res );
          return refalrts::cSuccess;
        } while ( 0 );
        refalrts::stop_sentence();

        // </0 & Xxout-Scan/4 'W'/5 'q'/6 s.Compound#1/9 e.Tail#1/7 >/1
        if( ! refalrts::char_term( 'q', context[6] ) )
          continue;
        // closed e.Tail#1 as range 7
        //DEBUG: s.Compound#1: 9
        //DEBUG: e.Tail#1: 7

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ } </11 [*]/12 & Xxout-Scan$4=1/13 (/14 Tile{ AsIs: e.Tail#1/7 } )/15 {*}/16 </17 & Xxout-Chars/18 (/19 )/20 Tile{ AsIs: </0 Reuse: & Type/4 HalfReuse: </5 HalfReuse: & Explode/6 AsIs: s.Compound#1/9 } >/21 >/22 >/23 Tile{ AsIs: >/1 ]] }
        if( ! refalrts::alloc_open_call( context[11] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_closure_head( context[12] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_name( context[13], ref_gen_Xxoutm_Scan_S4A1.ref.function ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_open_bracket( context[14] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_bracket( context[15] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_unwrapped_closure( context[16], context[12] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_open_call( context[17] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_name( context[18], ref_Xxoutm_Chars.ref.function ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_open_bracket( context[19] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_bracket( context[20] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_call( context[21] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_call( context[22] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_call( context[23] ) )
          return refalrts::cNoMemory;
        refalrts::update_name( context[4], ref_Type.ref.function );
        refalrts::reinit_open_call( context[5] );
        refalrts::reinit_name( context[6], ref_Explode.ref.function );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[11] );
        refalrts::push_stack( context[23] );
        refalrts::push_stack( context[17] );
        refalrts::push_stack( context[22] );
        refalrts::push_stack( context[0] );
        refalrts::push_stack( context[21] );
        refalrts::push_stack( context[5] );
        refalrts::link_brackets( context[19], context[20] );
        refalrts::link_brackets( context[14], context[15] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[1];
        res = refalrts::splice_evar( res, context[21], context[23] );
        res = refalrts::splice_evar( res, context[0], context[9] );
        res = refalrts::splice_evar( res, context[15], context[20] );
        res = refalrts::splice_evar( res, context[7], context[8] );
        res = refalrts::splice_evar( res, context[11], context[14] );
        refalrts::use( res );
        refalrts::wrap_closure( context[16] );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Xxout-Scan/4 'N'/5 s.0#1/6 s.Number#1/9 e.Tail#1/7 >/1
        if( ! refalrts::char_term( 'N', context[5] ) )
          continue;
        // closed e.Tail#1 as range 7
        //DEBUG: s.0#1: 6
        //DEBUG: s.Number#1: 9
        //DEBUG: e.Tail#1: 7

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} s.0#1/6 s.Number#1/9 {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ AsIs: </0 Reuse: & StrFromInt/4 HalfReuse: s.Number1 #9/5 } >/11 ' '/12 </13 & Xxout-Scan/14 </15 & Type/16 Tile{ AsIs: e.Tail#1/7 } >/17 Tile{ AsIs: >/1 ]] }
        if( ! refalrts::alloc_close_call( context[11] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_char( context[12], ' ' ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_open_call( context[13] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_name( context[14], ref_Xxoutm_Scan.ref.function ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_open_call( context[15] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_name( context[16], ref_Type.ref.function ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_call( context[17] ) )
          return refalrts::cNoMemory;
        refalrts::update_name( context[4], ref_StrFromInt.ref.function );
        refalrts::reinit_svar( context[5], context[9] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[13] );
        refalrts::push_stack( context[17] );
        refalrts::push_stack( context[15] );
        refalrts::push_stack( context[11] );
        refalrts::push_stack( context[0] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = context[1];
        res = refalrts::splice_evar( res, context[17], context[17] );
        res = refalrts::splice_evar( res, context[7], context[8] );
        res = refalrts::splice_evar( res, context[11], context[16] );
        refalrts::splice_to_freelist_open( context[5], res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      do {
        // </0 & Xxout-Scan/4 'P'/5 s.S#1/6 s.Printable#1/9 e.Tail#1/7 >/1
        if( ! refalrts::char_term( 'P', context[5] ) )
          continue;
        // closed e.Tail#1 as range 7
        //DEBUG: s.S#1: 6
        //DEBUG: s.Printable#1: 9
        //DEBUG: e.Tail#1: 7

        refalrts::reset_allocator();
        //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
        //RESULT: Tile{ [[ } </11 & Xxout-Scan$6=1/12 </13 & Xxout-Chars/14 Tile{ HalfReuse: (/0 HalfReuse: )/4 AsIs: 'P'/5 AsIs: s.S#1/6 AsIs: s.Printable#1/9 AsIs: e.Tail#1/7 AsIs: >/1 } >/15 Tile{ ]] }
        if( ! refalrts::alloc_open_call( context[11] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_name( context[12], ref_gen_Xxoutm_Scan_S6A1.ref.function ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_open_call( context[13] ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_name( context[14], ref_Xxoutm_Chars.ref.function ) )
          return refalrts::cNoMemory;
        if( ! refalrts::alloc_close_call( context[15] ) )
          return refalrts::cNoMemory;
        refalrts::reinit_open_bracket( context[0] );
        refalrts::reinit_close_bracket( context[4] );
        refalrts::push_stack( context[15] );
        refalrts::push_stack( context[11] );
        refalrts::push_stack( context[1] );
        refalrts::push_stack( context[13] );
        refalrts::link_brackets( context[0], context[4] );
        refalrts::Iter trash_prev = arg_begin->prev;
        refalrts::use(trash_prev);
        refalrts::Iter res = arg_end->next;
        res = refalrts::splice_evar( res, context[15], context[15] );
        res = refalrts::splice_evar( res, context[0], context[1] );
        res = refalrts::splice_evar( res, context[11], context[14] );
        refalrts::use( res );
        return refalrts::cSuccess;
      } while ( 0 );
      refalrts::stop_sentence();

      // </0 & Xxout-Scan/4 'O'/5 s.S#1/6 s.Other#1/9 e.Tail#1/7 >/1
      if( ! refalrts::char_term( 'O', context[5] ) )
        continue;
      // closed e.Tail#1 as range 7
      //DEBUG: s.S#1: 6
      //DEBUG: s.Other#1: 9
      //DEBUG: e.Tail#1: 7

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </11 & Xxout-Scan$7=1/12 </13 & Xxout-Chars/14 Tile{ HalfReuse: (/0 HalfReuse: )/4 AsIs: 'O'/5 AsIs: s.S#1/6 AsIs: s.Other#1/9 AsIs: e.Tail#1/7 AsIs: >/1 } >/15 Tile{ ]] }
      if( ! refalrts::alloc_open_call( context[11] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_name( context[12], ref_gen_Xxoutm_Scan_S7A1.ref.function ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_call( context[13] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_name( context[14], ref_Xxoutm_Chars.ref.function ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_call( context[15] ) )
        return refalrts::cNoMemory;
      refalrts::reinit_open_bracket( context[0] );
      refalrts::reinit_close_bracket( context[4] );
      refalrts::push_stack( context[15] );
      refalrts::push_stack( context[11] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[13] );
      refalrts::link_brackets( context[0], context[4] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = arg_end->next;
      res = refalrts::splice_evar( res, context[15], context[15] );
      res = refalrts::splice_evar( res, context[0], context[1] );
      res = refalrts::splice_evar( res, context[11], context[14] );
      refalrts::use( res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Xxout-Scan/4 'B'/5 s.0#1/6 (/9 e.Inner#1/11 )/10 e.Tail#1/7 >/1
    context[11] = 0;
    context[12] = 0;
    if( ! refalrts::brackets_term( context[11], context[12], context[9] ) )
      continue;
    if( ! refalrts::char_term( 'B', context[5] ) )
      continue;
    // closed e.Inner#1 as range 11
    // closed e.Tail#1 as range 7
    //DEBUG: s.0#1: 6
    //DEBUG: e.Inner#1: 11
    //DEBUG: e.Tail#1: 7

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} s.0#1/6 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
    //RESULT: Tile{ [[ } '('/13 Tile{ AsIs: </0 AsIs: & Xxout-Scan/4 HalfReuse: </5 } & Type/14 Tile{ AsIs: e.Inner#1/11 } >/15 Tile{ HalfReuse: >/9 } ')'/16 </17 & Xxout-Scan/18 </19 Tile{ HalfReuse: & Type/10 AsIs: e.Tail#1/7 AsIs: >/1 } >/20 Tile{ ]] }
    if( ! refalrts::alloc_char( context[13], '(' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[14], ref_Type.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[15] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_char( context[16], ')' ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[17] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_name( context[18], ref_Xxoutm_Scan.ref.function ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_open_call( context[19] ) )
      return refalrts::cNoMemory;
    if( ! refalrts::alloc_close_call( context[20] ) )
      return refalrts::cNoMemory;
    refalrts::reinit_open_call( context[5] );
    refalrts::reinit_close_call( context[9] );
    refalrts::reinit_name( context[10], ref_Type.ref.function );
    refalrts::push_stack( context[20] );
    refalrts::push_stack( context[17] );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[19] );
    refalrts::push_stack( context[9] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[15] );
    refalrts::push_stack( context[5] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[20], context[20] );
    res = refalrts::splice_evar( res, context[10], context[1] );
    res = refalrts::splice_evar( res, context[16], context[19] );
    res = refalrts::splice_evar( res, context[9], context[9] );
    res = refalrts::splice_evar( res, context[15], context[15] );
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[14], context[14] );
    res = refalrts::splice_evar( res, context[0], context[5] );
    res = refalrts::splice_evar( res, context[13], context[13] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Xxout-Scan/4 '*'/5 s.0#1/6 >/1
  if( ! refalrts::char_term( '*', context[5] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.0#1: 6

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Xxout-Scan/4 '*'/5 s.0#1/6 >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ ]] }
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Xxoutm_Scan("Xxout-Scan", 877573369U, 332537286U, func_Xxoutm_Scan);


static refalrts::FnResult func_gen_Xxoutm_Chars_S1B1S2B1S6A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 26 elems
  refalrts::Iter context[26];
  refalrts::zeros( context, 26 );
  // </0 & Xxout-Chars$1:1$2:1$6=1/4 (/7 e.Scanned#1/5 )/8 (/11 e.Tail#1/9 )/12 (/15 s.Hi#4/17 )/16 s.Low#4/18 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  context[13] = 0;
  context[14] = 0;
  context[15] = refalrts::brackets_left( context[13], context[14], context[2], context[3] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[15], context[16]);
  // closed e.Scanned#1 as range 5
  // closed e.Tail#1 as range 9
  if( ! refalrts::svar_left( context[17], context[13], context[14] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[13], context[14] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[18], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: e.Scanned#1: 5
  //DEBUG: e.Tail#1: 9
  //DEBUG: s.Hi#4: 17
  //DEBUG: s.Low#4: 18

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Xxout-Chars/4 AsIs: (/7 AsIs: e.Scanned#1/5 HalfReuse: '\\'/8 HalfReuse: 'x'/11 } Tile{ HalfReuse: </12 HalfReuse: & Hex/15 AsIs: s.Hi#4/17 } >/19 </20 Tile{ HalfReuse: & Hex/16 AsIs: s.Low#4/18 AsIs: >/1 } )/21 </22 & Type/23 Tile{ AsIs: e.Tail#1/9 } >/24 >/25 Tile{ ]] }
  if( ! refalrts::alloc_close_call( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[20] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[23], ref_Type.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[24] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[25] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Xxoutm_Chars.ref.function );
  refalrts::reinit_char( context[8], '\\' );
  refalrts::reinit_char( context[11], 'x' );
  refalrts::reinit_open_call( context[12] );
  refalrts::reinit_name( context[15], ref_Hex.ref.function );
  refalrts::reinit_name( context[16], ref_Hex.ref.function );
  refalrts::push_stack( context[25] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[24] );
  refalrts::push_stack( context[22] );
  refalrts::link_brackets( context[7], context[21] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[20] );
  refalrts::push_stack( context[19] );
  refalrts::push_stack( context[12] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[24], context[25] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[21], context[23] );
  res = refalrts::splice_evar( res, context[16], context[1] );
  res = refalrts::splice_evar( res, context[19], context[20] );
  res = refalrts::splice_evar( res, context[12], context[17] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Xxoutm_Chars_S1B1S2B1S6A1("Xxout-Chars$1:1$2:1$6=1", 877573369U, 332537286U, func_gen_Xxoutm_Chars_S1B1S2B1S6A1);


static refalrts::FnResult func_gen_Xxoutm_Chars_S1B1S2B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 24 elems
  refalrts::Iter context[24];
  refalrts::zeros( context, 24 );
  // </0 & Xxout-Chars$1:1$2:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Xxout-Chars$1:1$2:1/4 (/7 e.new#1/5 )/8 (/11 e.new#2/9 )/12 s.new#3/13 s.new#4/14 s.new#5/15 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[2], context[3] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  // closed e.new#1 as range 5
  // closed e.new#2 as range 9
  if( ! refalrts::svar_left( context[13], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[14], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[15], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // </0 & Xxout-Chars$1:1$2:1/4 (/7 e.Scanned#1/5 )/8 (/11 e.Tail#1/9 )/12 'L'/13 s.S#3/14 s.Letter#3/15 >/1
    if( ! refalrts::char_term( 'L', context[13] ) )
      continue;
    // closed e.Scanned#1 as range 5
    // closed e.Tail#1 as range 9
    //DEBUG: s.S#3: 14
    //DEBUG: s.Letter#3: 15
    //DEBUG: e.Scanned#1: 5
    //DEBUG: e.Tail#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.S#3/14 s.Letter#3/15 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Xxout-Chars/4 AsIs: (/7 AsIs: e.Scanned#1/5 HalfReuse: s.Letter3 #15/8 HalfReuse: )/11 } Tile{ HalfReuse: </12 HalfReuse: & Type/13 } Tile{ AsIs: e.Tail#1/9 } >/16 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Xxoutm_Chars.ref.function );
    refalrts::reinit_svar( context[8], context[15] );
    refalrts::reinit_close_bracket( context[11] );
    refalrts::reinit_open_call( context[12] );
    refalrts::reinit_name( context[13], ref_Type.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[12] );
    refalrts::link_brackets( context[7], context[11] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[12], context[13] );
    refalrts::splice_to_freelist_open( context[11], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Xxout-Chars$1:1$2:1/4 (/7 e.Scanned#1/5 )/8 (/11 e.Tail#1/9 )/12 'D'/13 s.S#3/14 s.Digit#3/15 >/1
    if( ! refalrts::char_term( 'D', context[13] ) )
      continue;
    // closed e.Scanned#1 as range 5
    // closed e.Tail#1 as range 9
    //DEBUG: s.S#3: 14
    //DEBUG: s.Digit#3: 15
    //DEBUG: e.Scanned#1: 5
    //DEBUG: e.Tail#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.S#3/14 s.Digit#3/15 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Xxout-Chars/4 AsIs: (/7 AsIs: e.Scanned#1/5 HalfReuse: s.Digit3 #15/8 HalfReuse: )/11 } Tile{ HalfReuse: </12 HalfReuse: & Type/13 } Tile{ AsIs: e.Tail#1/9 } >/16 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Xxoutm_Chars.ref.function );
    refalrts::reinit_svar( context[8], context[15] );
    refalrts::reinit_close_bracket( context[11] );
    refalrts::reinit_open_call( context[12] );
    refalrts::reinit_name( context[13], ref_Type.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[12] );
    refalrts::link_brackets( context[7], context[11] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[12], context[13] );
    refalrts::splice_to_freelist_open( context[11], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Xxout-Chars$1:1$2:1/4 (/7 e.Scanned#1/5 )/8 (/11 e.Tail#1/9 )/12 'W'/13 s.S#3/14 s.Word#3/15 >/1
    if( ! refalrts::char_term( 'W', context[13] ) )
      continue;
    // closed e.Scanned#1 as range 5
    // closed e.Tail#1 as range 9
    //DEBUG: s.S#3: 14
    //DEBUG: s.Word#3: 15
    //DEBUG: e.Scanned#1: 5
    //DEBUG: e.Tail#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} & Xxout-Chars$1:1$2:1/4 (/7 {REMOVED TILE} )/8 (/11 {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: (/0 } Tile{ AsIs: e.Scanned#1/5 } Tile{ AsIs: )/12 AsIs: 'W'/13 AsIs: s.S#3/14 AsIs: s.Word#3/15 } Tile{ AsIs: e.Tail#1/9 } Tile{ ]] }
    refalrts::reinit_open_bracket( context[0] );
    refalrts::link_brackets( context[0], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[12], context[15] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    refalrts::splice_to_freelist_open( context[0], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Xxout-Chars$1:1$2:1/4 (/7 e.Scanned#1/5 )/8 (/11 e.Tail#1/9 )/12 'N'/13 s.0#3/14 s.Number#3/15 >/1
    if( ! refalrts::char_term( 'N', context[13] ) )
      continue;
    // closed e.Scanned#1 as range 5
    // closed e.Tail#1 as range 9
    //DEBUG: s.0#3: 14
    //DEBUG: s.Number#3: 15
    //DEBUG: e.Scanned#1: 5
    //DEBUG: e.Tail#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} & Xxout-Chars$1:1$2:1/4 (/7 {REMOVED TILE} )/8 (/11 {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ HalfReuse: (/0 } Tile{ AsIs: e.Scanned#1/5 } Tile{ AsIs: )/12 AsIs: 'N'/13 AsIs: s.0#3/14 AsIs: s.Number#3/15 } Tile{ AsIs: e.Tail#1/9 } Tile{ ]] }
    refalrts::reinit_open_bracket( context[0] );
    refalrts::link_brackets( context[0], context[12] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[12], context[15] );
    res = refalrts::splice_evar( res, context[5], context[6] );
    refalrts::splice_to_freelist_open( context[0], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Xxout-Chars$1:1$2:1/4 (/7 e.Scanned#1/5 )/8 (/11 e.Tail#1/9 )/12 'P'/13 s.S#3/14 s.Printable#3/15 >/1
    if( ! refalrts::char_term( 'P', context[13] ) )
      continue;
    // closed e.Scanned#1 as range 5
    // closed e.Tail#1 as range 9
    //DEBUG: s.S#3: 14
    //DEBUG: s.Printable#3: 15
    //DEBUG: e.Scanned#1: 5
    //DEBUG: e.Tail#1: 9

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.S#3/14 s.Printable#3/15 {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Xxout-Chars/4 AsIs: (/7 AsIs: e.Scanned#1/5 HalfReuse: s.Printable3 #15/8 HalfReuse: )/11 } Tile{ HalfReuse: </12 HalfReuse: & Type/13 } Tile{ AsIs: e.Tail#1/9 } >/16 Tile{ AsIs: >/1 ]] }
    if( ! refalrts::alloc_close_call( context[16] ) )
      return refalrts::cNoMemory;
    refalrts::update_name( context[4], ref_Xxoutm_Chars.ref.function );
    refalrts::reinit_svar( context[8], context[15] );
    refalrts::reinit_close_bracket( context[11] );
    refalrts::reinit_open_call( context[12] );
    refalrts::reinit_name( context[13], ref_Type.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    refalrts::push_stack( context[16] );
    refalrts::push_stack( context[12] );
    refalrts::link_brackets( context[7], context[11] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    res = refalrts::splice_evar( res, context[16], context[16] );
    res = refalrts::splice_evar( res, context[9], context[10] );
    res = refalrts::splice_evar( res, context[12], context[13] );
    refalrts::splice_to_freelist_open( context[11], res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Xxout-Chars$1:1$2:1/4 (/7 e.Scanned#1/5 )/8 (/11 e.Tail#1/9 )/12 'O'/13 s.S#3/14 s.Other#3/15 >/1
  if( ! refalrts::char_term( 'O', context[13] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Scanned#1 as range 5
  // closed e.Tail#1 as range 9
  //DEBUG: s.S#3: 14
  //DEBUG: s.Other#3: 15
  //DEBUG: e.Scanned#1: 5
  //DEBUG: e.Tail#1: 9

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} s.S#3/14 {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </16 Tile{ HalfReuse: [*]/0 Reuse: & Xxout-Chars$1:1$2:1$6=1/4 AsIs: (/7 AsIs: e.Scanned#1/5 AsIs: )/8 AsIs: (/11 AsIs: e.Tail#1/9 AsIs: )/12 HalfReuse: {*}/13 } </17 & Divmod-Digits/18 </19 & Ord/20 Tile{ AsIs: s.Other#3/15 AsIs: >/1 } 16/21 >/22 >/23 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[18], ref_Divmodm_Digits.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[20], ref_Ord.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[21], 16UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[23] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[0] );
  refalrts::update_name( context[4], ref_gen_Xxoutm_Chars_S1B1S2B1S6A1.ref.function );
  refalrts::reinit_unwrapped_closure( context[13], context[0] );
  refalrts::push_stack( context[23] );
  refalrts::push_stack( context[16] );
  refalrts::push_stack( context[22] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[19] );
  refalrts::link_brackets( context[11], context[12] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[21], context[23] );
  res = refalrts::splice_evar( res, context[15], context[1] );
  res = refalrts::splice_evar( res, context[17], context[20] );
  res = refalrts::splice_evar( res, context[0], context[13] );
  res = refalrts::splice_evar( res, context[16], context[16] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  refalrts::wrap_closure( context[13] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Xxoutm_Chars_S1B1S2B1("Xxout-Chars$1:1$2:1", 877573369U, 332537286U, func_gen_Xxoutm_Chars_S1B1S2B1);


static refalrts::FnResult func_gen_Xxoutm_Chars_S1B1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 27 elems
  refalrts::Iter context[27];
  refalrts::zeros( context, 27 );
  // </0 & Xxout-Chars$1:1/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Xxout-Chars$1:1/4 s.new#1/5 (/8 e.new#2/6 )/9 (/12 e.new#3/10 )/13 s.new#4/14 s.new#5/15 e.new#6/2 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  context[10] = 0;
  context[11] = 0;
  context[12] = refalrts::brackets_left( context[10], context[11], context[2], context[3] );
  if( ! context[12] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[12], context[13]);
  // closed e.new#2 as range 6
  // closed e.new#3 as range 10
  if( ! refalrts::svar_left( context[14], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[15], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#6 as range 2
  do {
    // </0 & Xxout-Chars$1:1/4 s.Char#1/5 (/8 e.Scanned#1/6 )/9 (/12 e.Tail#1/10 )/13 s.T#1/14 s.S#1/15 e.Escaped-B#2/18 (/24 s.Char#1/26 e.Replace#2/22 )/25 e.Escaped-E#2/20 >/1
    context[16] = context[2];
    context[17] = context[3];
    // closed e.Scanned#1 as range 6
    // closed e.Tail#1 as range 10
    context[18] = 0;
    context[19] = 0;
    refalrts::start_e_loop();
    do {
      context[20] = context[16];
      context[21] = context[17];
      context[22] = 0;
      context[23] = 0;
      context[24] = refalrts::brackets_left( context[22], context[23], context[20], context[21] );
      if( ! context[24] )
        continue;
      refalrts::bracket_pointers(context[24], context[25]);
      if( ! refalrts::repeated_stvar_left( context[26], context[5], context[22], context[23] ) )
        continue;
      // closed e.Replace#2 as range 22
      // closed e.Escaped-E#2 as range 20
      //DEBUG: s.Char#1: 5
      //DEBUG: s.T#1: 14
      //DEBUG: s.S#1: 15
      //DEBUG: e.Scanned#1: 6
      //DEBUG: e.Tail#1: 10
      //DEBUG: e.Escaped-B#2: 18
      //DEBUG: e.Replace#2: 22
      //DEBUG: e.Escaped-E#2: 20

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} s.Char#1/5 {REMOVED TILE} {REMOVED TILE} s.T#1/14 s.S#1/15 e.Escaped-B#2/18 {REMOVED TILE} s.Char#1/26 {REMOVED TILE} {REMOVED TILE} e.Escaped-E#2/20 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Xxout-Chars/4 } Tile{ AsIs: (/8 AsIs: e.Scanned#1/6 HalfReuse: '\\'/9 } Tile{ AsIs: e.Replace#2/22 } Tile{ AsIs: )/25 } Tile{ HalfReuse: </24 } Tile{ HalfReuse: & Type/12 AsIs: e.Tail#1/10 HalfReuse: >/13 } Tile{ AsIs: >/1 ]] }
      refalrts::update_name( context[4], ref_Xxoutm_Chars.ref.function );
      refalrts::reinit_char( context[9], '\\' );
      refalrts::reinit_open_call( context[24] );
      refalrts::reinit_name( context[12], ref_Type.ref.function );
      refalrts::reinit_close_call( context[13] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::push_stack( context[13] );
      refalrts::push_stack( context[24] );
      refalrts::link_brackets( context[8], context[25] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[12], context[13] );
      res = refalrts::splice_evar( res, context[24], context[24] );
      res = refalrts::splice_evar( res, context[25], context[25] );
      res = refalrts::splice_evar( res, context[22], context[23] );
      res = refalrts::splice_evar( res, context[8], context[9] );
      refalrts::splice_to_freelist_open( context[4], res );
      return refalrts::cSuccess;
    } while ( refalrts::open_evar_advance( context[18], context[19], context[16], context[17] ) );
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Xxout-Chars$1:1/4 s.Char#1/5 (/8 e.Scanned#1/6 )/9 (/12 e.Tail#1/10 )/13 s.T#1/14 s.S#1/15 e.Escaped#2/2 >/1
  // closed e.Scanned#1 as range 6
  // closed e.Tail#1 as range 10
  // closed e.Escaped#2 as range 2
  //DEBUG: s.Char#1: 5
  //DEBUG: s.T#1: 14
  //DEBUG: s.S#1: 15
  //DEBUG: e.Scanned#1: 6
  //DEBUG: e.Tail#1: 10
  //DEBUG: e.Escaped#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} e.Escaped#2/2 {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 HalfReuse: [*]/4 } & Xxout-Chars$1:1$2:1/16 Tile{ AsIs: (/8 AsIs: e.Scanned#1/6 AsIs: )/9 AsIs: (/12 AsIs: e.Tail#1/10 AsIs: )/13 } {*}/17 Tile{ AsIs: s.T#1/14 AsIs: s.S#1/15 } Tile{ AsIs: s.Char#1/5 } Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_name( context[16], ref_gen_Xxoutm_Chars_S1B1S2B1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[17], context[4] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[4] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[12], context[13] );
  refalrts::link_brackets( context[8], context[9] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[5], context[5] );
  res = refalrts::splice_evar( res, context[14], context[15] );
  res = refalrts::splice_evar( res, context[17], context[17] );
  res = refalrts::splice_evar( res, context[8], context[13] );
  res = refalrts::splice_evar( res, context[16], context[16] );
  refalrts::splice_to_freelist_open( context[4], res );
  refalrts::wrap_closure( context[17] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Xxoutm_Chars_S1B1("Xxout-Chars$1:1", 877573369U, 332537286U, func_gen_Xxoutm_Chars_S1B1);


static refalrts::FnResult func_Xxoutm_Chars(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 60 elems
  refalrts::Iter context[60];
  refalrts::zeros( context, 60 );
  // </0 & Xxout-Chars/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Xxout-Chars/4 (/7 e.new#1/5 )/8 s.new#2/9 s.new#3/10 e.new#4/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.new#1 as range 5
  if( ! refalrts::svar_left( context[9], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#4 as range 2
  do {
    // </0 & Xxout-Chars/4 (/7 e.new#5/5 )/8 s.new#6/9 s.new#7/10 t.new#8/13 e.new#9/11 >/1
    context[11] = context[2];
    context[12] = context[3];
    // closed e.new#5 as range 5
    context[14] = refalrts::tvar_left( context[13], context[11], context[12] );
    if( ! context[14] )
      continue;
    // closed e.new#9 as range 11
    do {
      // </0 & Xxout-Chars/4 (/7 e.Scanned#1/5 )/8 s.T#1/9 s.S#1/10 s.Char#1/13 e.Tail#1/11 >/1
      if( ! refalrts::svar_term( context[13], context[13] ) )
        continue;
      // closed e.Scanned#1 as range 5
      // closed e.Tail#1 as range 11
      //DEBUG: s.Char#1: 13
      //DEBUG: s.T#1: 9
      //DEBUG: s.S#1: 10
      //DEBUG: e.Scanned#1: 5
      //DEBUG: e.Tail#1: 11

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.Char#1/13 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ } </15 [*]/16 Tile{ HalfReuse: & Xxout-Chars$1:1/0 HalfReuse: s.Char1 #13/4 AsIs: (/7 AsIs: e.Scanned#1/5 AsIs: )/8 } (/17 Tile{ AsIs: e.Tail#1/11 } )/18 Tile{ AsIs: s.T#1/9 AsIs: s.S#1/10 } {*}/19 (/20"\\\\"/21 )/23 (/24"\'\'"/25 )/27 (/28"\"\""/29 )/31 (/32"(("/33 )/35 (/36"))"/37 )/39 (/40"<<"/41 )/43 (/44">>"/45 )/47 (/48"\nn"/49 )/51 (/52"\tt"/53 )/55 (/56"\rr"/57 )/59 Tile{ AsIs: >/1 ]] }
      if( ! refalrts::alloc_open_call( context[15] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_closure_head( context[16] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[17] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[18] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_unwrapped_closure( context[19], context[16] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[20] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_chars( context[21], context[22], "\\\\", 2 ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[23] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[24] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_chars( context[25], context[26], "\'\'", 2 ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[27] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[28] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_chars( context[29], context[30], "\"\"", 2 ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[31] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[32] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_chars( context[33], context[34], "((", 2 ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[35] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[36] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_chars( context[37], context[38], "))", 2 ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[39] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[40] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_chars( context[41], context[42], "<<", 2 ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[43] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[44] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_chars( context[45], context[46], ">>", 2 ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[47] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[48] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_chars( context[49], context[50], "\nn", 2 ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[51] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[52] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_chars( context[53], context[54], "\tt", 2 ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[55] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[56] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_chars( context[57], context[58], "\rr", 2 ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[59] ) )
        return refalrts::cNoMemory;
      refalrts::reinit_name( context[0], ref_gen_Xxoutm_Chars_S1B1.ref.function );
      refalrts::reinit_svar( context[4], context[13] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[15] );
      refalrts::link_brackets( context[56], context[59] );
      refalrts::link_brackets( context[52], context[55] );
      refalrts::link_brackets( context[48], context[51] );
      refalrts::link_brackets( context[44], context[47] );
      refalrts::link_brackets( context[40], context[43] );
      refalrts::link_brackets( context[36], context[39] );
      refalrts::link_brackets( context[32], context[35] );
      refalrts::link_brackets( context[28], context[31] );
      refalrts::link_brackets( context[24], context[27] );
      refalrts::link_brackets( context[20], context[23] );
      refalrts::link_brackets( context[17], context[18] );
      refalrts::link_brackets( context[7], context[8] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[19], context[59] );
      res = refalrts::splice_evar( res, context[9], context[10] );
      res = refalrts::splice_evar( res, context[18], context[18] );
      res = refalrts::splice_evar( res, context[11], context[12] );
      res = refalrts::splice_evar( res, context[17], context[17] );
      res = refalrts::splice_evar( res, context[0], context[8] );
      res = refalrts::splice_evar( res, context[15], context[16] );
      refalrts::splice_to_freelist_open( trash_prev, res );
      refalrts::wrap_closure( context[19] );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Xxout-Chars/4 (/7 e.Scanned#1/5 )/8 'B'/9 s.0#1/10 (/13 e.Inner#1/15 )/14 e.Tail#1/11 >/1
    context[15] = 0;
    context[16] = 0;
    if( ! refalrts::brackets_term( context[15], context[16], context[13] ) )
      continue;
    if( ! refalrts::char_term( 'B', context[9] ) )
      continue;
    // closed e.Scanned#1 as range 5
    // closed e.Inner#1 as range 15
    // closed e.Tail#1 as range 11
    //DEBUG: s.0#1: 10
    //DEBUG: e.Scanned#1: 5
    //DEBUG: e.Inner#1: 15
    //DEBUG: e.Tail#1: 11

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Xxout-Chars/4 {REMOVED TILE} {REMOVED TILE} >/1 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Scanned#1/5 AsIs: )/8 AsIs: 'B'/9 AsIs: s.0#1/10 AsIs: (/13 AsIs: e.Inner#1/15 AsIs: )/14 } Tile{ AsIs: e.Tail#1/11 } Tile{ ]] }
    refalrts::link_brackets( context[13], context[14] );
    refalrts::link_brackets( context[7], context[8] );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = arg_end->next;
    res = refalrts::splice_evar( res, context[11], context[12] );
    res = refalrts::splice_evar( res, context[7], context[14] );
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Xxout-Chars/4 (/7 e.Scanned#1/5 )/8 '*'/9 s.0#1/10 >/1
  if( ! refalrts::char_term( '*', context[9] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Scanned#1 as range 5
  //DEBUG: s.0#1: 10
  //DEBUG: e.Scanned#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Xxout-Chars/4 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ AsIs: (/7 AsIs: e.Scanned#1/5 AsIs: )/8 AsIs: '*'/9 AsIs: s.0#1/10 } Tile{ ]] }
  refalrts::link_brackets( context[7], context[8] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[7], context[10] );
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Xxoutm_Chars("Xxout-Chars", 877573369U, 332537286U, func_Xxoutm_Chars);


static refalrts::FnResult func_Hex(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  // </0 & Hex/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Hex/4 s.new#1/5 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  do {
    // </0 & Hex/4 0/5 >/1
    if( ! refalrts::number_term( 0UL, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Hex/4 0/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '0'/1 ]] }
    refalrts::reinit_char( context[1], '0' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Hex/4 1/5 >/1
    if( ! refalrts::number_term( 1UL, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Hex/4 1/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '1'/1 ]] }
    refalrts::reinit_char( context[1], '1' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Hex/4 2/5 >/1
    if( ! refalrts::number_term( 2UL, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Hex/4 2/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '2'/1 ]] }
    refalrts::reinit_char( context[1], '2' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Hex/4 3/5 >/1
    if( ! refalrts::number_term( 3UL, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Hex/4 3/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '3'/1 ]] }
    refalrts::reinit_char( context[1], '3' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Hex/4 4/5 >/1
    if( ! refalrts::number_term( 4UL, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Hex/4 4/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '4'/1 ]] }
    refalrts::reinit_char( context[1], '4' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Hex/4 5/5 >/1
    if( ! refalrts::number_term( 5UL, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Hex/4 5/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '5'/1 ]] }
    refalrts::reinit_char( context[1], '5' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Hex/4 6/5 >/1
    if( ! refalrts::number_term( 6UL, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Hex/4 6/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '6'/1 ]] }
    refalrts::reinit_char( context[1], '6' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Hex/4 7/5 >/1
    if( ! refalrts::number_term( 7UL, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Hex/4 7/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '7'/1 ]] }
    refalrts::reinit_char( context[1], '7' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Hex/4 8/5 >/1
    if( ! refalrts::number_term( 8UL, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Hex/4 8/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '8'/1 ]] }
    refalrts::reinit_char( context[1], '8' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Hex/4 9/5 >/1
    if( ! refalrts::number_term( 9UL, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Hex/4 9/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '9'/1 ]] }
    refalrts::reinit_char( context[1], '9' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Hex/4 10/5 >/1
    if( ! refalrts::number_term( 10UL, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Hex/4 10/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 'A'/1 ]] }
    refalrts::reinit_char( context[1], 'A' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Hex/4 11/5 >/1
    if( ! refalrts::number_term( 11UL, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Hex/4 11/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 'B'/1 ]] }
    refalrts::reinit_char( context[1], 'B' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Hex/4 12/5 >/1
    if( ! refalrts::number_term( 12UL, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Hex/4 12/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 'C'/1 ]] }
    refalrts::reinit_char( context[1], 'C' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Hex/4 13/5 >/1
    if( ! refalrts::number_term( 13UL, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Hex/4 13/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 'D'/1 ]] }
    refalrts::reinit_char( context[1], 'D' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Hex/4 14/5 >/1
    if( ! refalrts::number_term( 14UL, context[5] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Hex/4 14/5 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: 'E'/1 ]] }
    refalrts::reinit_char( context[1], 'E' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Hex/4 15/5 >/1
  if( ! refalrts::number_term( 15UL, context[5] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Hex/4 15/5 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: 'F'/1 ]] }
  refalrts::reinit_char( context[1], 'F' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Hex("Hex", 877573369U, 332537286U, func_Hex);

#line 2331 "Library.sref"
namespace {

refalrts::FnResult string_from_seq(
  std::vector<char>& string, refalrts::Iter begin, refalrts::Iter end
) {
  std::vector<char> result;

  enum { cBufLen = 100 };
  char buffer[cBufLen + 1] = { 0 };

  unsigned read;
  while ((read = refalrts::read_chars(buffer, cBufLen, begin, end)) != 0) {
    // В текущей версии Open Watcom (и форка Open Watcom V2) есть ошибка
    // в функции vector::insert, которая возникает в случае,
    // если во время вставки вектор увеличивает свою ёмкость (capacity).
    // Для обхода этой ошибки предварительно резервируем место.
    result.reserve(result.size() + read + 1);
    result.insert(result.end(), buffer, buffer + read);
  }

  /*
    Здесь refalrts::empty_seq(begin, end) || (begin->tag != cDataChar).
  */

  if (refalrts::empty_seq(begin, end)) {
    result.push_back('\0');
    string.swap(result);
    return refalrts::cSuccess;
  } else {
    // здесь begin->tag != cDataChar
    return refalrts::cRecognitionImpossible;
  }
}

}  // unnamed namespace
#line 15395 "Library.cpp"

static refalrts::FnResult func_GetEnv(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2370 "Library.sref"
  refalrts::Iter envname_b = 0;
  refalrts::Iter envname_e = 0;
  refalrts::call_left(envname_b, envname_e, arg_begin, arg_end);

  std::vector<char> envname;
  refalrts::FnResult envname_res =
    string_from_seq(envname, envname_b, envname_e);

  if (envname_res != refalrts::cSuccess) {
    return envname_res;
  }

  refalrts::reset_allocator();
  const char *envres = getenv(& envname[0]);

  if (envres != 0) {
    refalrts::Iter env_begin;
    refalrts::Iter env_end;

    if (! refalrts::alloc_string(env_begin, env_end, envres)) {
      return refalrts::cNoMemory;
    }

    refalrts::splice_evar(arg_begin, env_begin, env_end);
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 15427 "Library.cpp"
}

static refalrts::NativeReference nat_ref_GetEnv("GetEnv", 0U, 0U, func_GetEnv);


static refalrts::FnResult func_System(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2408 "Library.sref"
  refalrts::Iter command_b = 0;
  refalrts::Iter command_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(command_b, command_e, arg_begin, arg_end);

  std::vector<char> command;
  refalrts::FnResult command_res =
    string_from_seq(command, command_b, command_e);

  if (command_res != refalrts::cSuccess) {
    return command_res;
  }

  fflush(stdout);
  fflush(stderr);

  int ret = refalrts::api::system(&command[0]);

  refalrts::reset_allocator();
  if (ret < 0) {
    refalrts::Iter minus = 0;
    if (! refalrts::alloc_char(minus, '-')) {
      return refalrts::cNoMemory;
    }

    refalrts::splice_elem(arg_begin, minus);

    ret = -ret;
  }

  refalrts::reinit_number(arg_begin, ret);

  refalrts::splice_to_freelist(pfunc_name, arg_end);
  return refalrts::cSuccess;
#line 15469 "Library.cpp"
}

static refalrts::NativeReference nat_ref_System("System", 0U, 0U, func_System);


static refalrts::FnResult func_Exit(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2454 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  int sign = +1;

  if (refalrts::char_left('+', content_b, content_e)) {
    sign = +1;
  } else if (refalrts::char_left('-', content_b, content_e)) {
    sign = -1;
  }

  refalrts::Iter pretcode = 0;
  if (
    ! refalrts::svar_left(pretcode, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
    || refalrts::cDataNumber != pretcode->tag
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::set_return_code(sign * static_cast<int>(pretcode->number_info));
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cExit;
#line 15501 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Exit("Exit", 0U, 0U, func_Exit);

#line 2487 "Library.sref"
namespace cookie_ns {

enum CloseMode { cCloseMode_Silent, cCloseMode_Fail };

extern refalrts::FnResult close(
  refalrts::Iter arg_begin, refalrts::Iter arg_end, CloseMode mode
);

}  // namespace cookie_ns
#line 15516 "Library.cpp"

static refalrts::FnResult func_Close(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2500 "Library.sref"
  return cookie_ns::close(arg_begin, arg_end, cookie_ns::cCloseMode_Silent);
#line 15521 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Close("Close", 0U, 0U, func_Close);

#line 2505 "Library.sref"
refalrts::FnResult cookie_ns::close(
  refalrts::Iter arg_begin, refalrts::Iter arg_end, CloseMode mode
) {
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;
  if (
    ! file_handle_left(pfile_handle, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = extract_file_handle(pfile_handle);
  switch (mode) {
  case cookie_ns::cCloseMode_Silent:
    if (handle) {
      if (! release_file_handle(pfile_handle)) {
        return refalrts::cRecognitionImpossible;
      }
    }
    break;

  case cookie_ns::cCloseMode_Fail:
    if (! handle) {
      return refalrts::cRecognitionImpossible;
    }

    if (! release_file_handle(pfile_handle)) {
      return refalrts::cRecognitionImpossible;
    }
    break;

  default:
    refalrts_switch_default_violation(mode);
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
}
#line 15569 "Library.cpp"

static refalrts::FnResult func_ExistFile(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2558 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  char filename[FILENAME_MAX + 1] = { '\0' };
  unsigned len =
    refalrts::read_chars(filename, FILENAME_MAX, content_b, content_e);

  if (! refalrts::empty_seq(content_b, content_e) || len == 0) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter ans = arg_begin;
  if (FILE *f = fopen(filename, "r")) {
    // Файл существует
    fclose(f);

    refalrts::reinit_ident(ans, USE_IDENT(True));
  } else {
    // Файл по-видимому не существует
    refalrts::reinit_ident(ans, USE_IDENT(False));
  }

  refalrts::splice_to_freelist(pfunc_name, arg_end);
  return refalrts::cSuccess;
#line 15599 "Library.cpp"
}

static refalrts::NativeReference nat_ref_ExistFile("ExistFile", 0U, 0U, func_ExistFile);


static refalrts::FnResult func_GetCurrentDirectory(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2593 "Library.sref"
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  char directory[FILENAME_MAX + 1] = { '\0' };

  if (! refalrts::api::get_current_directory(directory, sizeof(directory))) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::Iter directory_b = 0, directory_e = 0;
  if (! refalrts::alloc_string(directory_b, directory_e, directory)) {
    return refalrts::cNoMemory;
  }

  refalrts::splice_evar(arg_begin, directory_b, directory_e);
  refalrts::splice_to_freelist(arg_begin, arg_end);

  return refalrts::cSuccess;
#line 15629 "Library.cpp"
}

static refalrts::NativeReference nat_ref_GetCurrentDirectory("GetCurrentDirectory", 0U, 0U, func_GetCurrentDirectory);


static refalrts::FnResult func_RemoveFile(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2627 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter filename_b = content_b;
  refalrts::Iter filename_e = content_e;

  char filename[FILENAME_MAX + 1] = { '\0' };
  // возвращаемое значение не проверяем для совместимости с РЕФАЛом-5
  refalrts::read_chars(filename, FILENAME_MAX, filename_b, filename_e);

  const char *error_message = "";
  refalrts::RefalIdentifier i_result = USE_IDENT(False);

  if (! refalrts::empty_seq(filename_b, filename_e)) {
    error_message = "File name is too long.";
  } else {
    errno = 0;
    int result = remove(filename);

    if (result == 0) {
      i_result = USE_IDENT(True);
    } else {
      error_message = strerror(errno);
    }
  }

  refalrts::Iter error_b = 0, error_e = 0;
  if (! refalrts::alloc_string(error_b, error_e, error_message)) {
    return refalrts::cNoMemory;
  }

  refalrts::reinit_ident(arg_begin, i_result);
  refalrts::reinit_open_bracket(pfunc_name);
  refalrts::reinit_close_bracket(arg_end);
  refalrts::splice_evar(arg_end, error_b, error_e);
  refalrts::splice_to_freelist(content_b, content_e);
  refalrts::link_brackets(pfunc_name, arg_end);
  return refalrts::cSuccess;
#line 15677 "Library.cpp"
}

static refalrts::NativeReference nat_ref_RemoveFile("RemoveFile", 0U, 0U, func_RemoveFile);


static refalrts::FnResult func_Implodeu_Ext(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2676 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  std::vector<char> ident_str;
  refalrts::FnResult res = string_from_seq(ident_str, content_b, content_e);

  if (res != refalrts::cSuccess) {
    return res;
  }

  refalrts::RefalIdentifier ident = refalrts::ident_implode(&ident_str[0]);

  if (! ident) {
    return refalrts::cIdentTableLimit;
  }

  refalrts::reinit_ident(arg_begin, ident);
  refalrts::splice_to_freelist(pfunc_name, arg_end);

  return refalrts::cSuccess;
#line 15707 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Implodeu_Ext("Implode_Ext", 0U, 0U, func_Implodeu_Ext);


static refalrts::FnResult func_Explodeu_Ext(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 12 elems
  refalrts::Iter context[12];
  refalrts::zeros( context, 12 );
  // </0 & Explode_Ext/4 s.Compound#1/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.Compound#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </6 & __Step-Start/7 >/8 Tile{ AsIs: </0 Reuse: & Explode/4 AsIs: s.Compound#1/5 AsIs: >/1 } </9 & __Step-End/10 >/11 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], ref_u_u_Stepm_Start.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[10], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[11] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Explode.ref.function );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[9] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[6] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[9], context[11] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[6], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Explodeu_Ext("Explode_Ext", 0U, 0U, func_Explodeu_Ext);

#line 2714 "Library.sref"
namespace {

clock_t g_time_elapsed_edge = clock();

}  // unnamed namespace
#line 15770 "Library.cpp"

static refalrts::FnResult func_TimeElapsed(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2723 "Library.sref"
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  bool make_edge = refalrts::number_left(0, content_b, content_e) != 0;

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  const double fClocksPerSec = CLOCKS_PER_SEC;
  clock_t now = clock();
  double time_elapsed = (now - g_time_elapsed_edge) / fClocksPerSec;

  char str_time_elapsed[
    DBL_MAX_10_EXP + 1 /* maximum digits before point */
    + 1 /* point */
    + 6 /* default digits after point for sprintf */
    + 1 /* last '\0' */
    + 10 /* just in case */
  ] = { '\0' };

  sprintf(str_time_elapsed, "%f", time_elapsed);

  if (! refalrts::alloc_string(content_b, content_e, str_time_elapsed)) {
    return refalrts::cNoMemory;
  }

  if (make_edge) {
    g_time_elapsed_edge = now;
  }

  refalrts::splice_evar(arg_begin, content_b, content_e);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 15808 "Library.cpp"
}

static refalrts::NativeReference nat_ref_TimeElapsed("TimeElapsed", 0U, 0U, func_TimeElapsed);


static refalrts::FnResult func_gen_Compare_S2A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Compare$2=1/4 (/7 e.First#2/5 )/8 e.Second#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#2 as range 5
  // closed e.Second#2 as range 2
  //DEBUG: e.First#2: 5
  //DEBUG: e.Second#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Compare-Normed/4 AsIs: (/7 AsIs: e.First#2/5 AsIs: )/8 AsIs: e.Second#2/2 AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Comparem_Normed.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_Compare_S2A1("Compare$2=1", 877573369U, 332537286U, func_gen_Compare_S2A1);


static refalrts::FnResult func_Compare(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & Compare/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  do {
    // </0 & Compare/4 s.First#1/7 s.Second#1/8 >/1
    context[5] = context[2];
    context[6] = context[3];
    if( ! refalrts::svar_left( context[7], context[5], context[6] ) )
      continue;
    if( ! refalrts::svar_left( context[8], context[5], context[6] ) )
      continue;
    if( ! refalrts::empty_seq( context[5], context[6] ) )
      continue;
    //DEBUG: s.First#1: 7
    //DEBUG: s.Second#1: 8

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE}
    //RESULT: Tile{ [[ AsIs: </0 Reuse: & Compare-Digits/4 AsIs: s.First#1/7 AsIs: s.Second#1/8 AsIs: >/1 ]] }
    refalrts::update_name( context[4], ref_Comparem_Digits.ref.function );
    refalrts::push_stack( context[1] );
    refalrts::push_stack( context[0] );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Compare/4 e.ArithmArg#1/2 >/1
  // closed e.ArithmArg#1 as range 2
  //DEBUG: e.ArithmArg#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & Compare$2=1/6 Tile{ AsIs: </0 Reuse: & NormArithmArg/4 AsIs: e.ArithmArg#1/2 AsIs: >/1 } >/7 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_gen_Compare_S2A1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[7] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_NormArithmArg.ref.function );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[7], context[7] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Compare("Compare", 0U, 0U, func_Compare);


static refalrts::FnResult func_Comparem_Normed(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 11 elems
  refalrts::Iter context[11];
  refalrts::zeros( context, 11 );
  // </0 & Compare-Normed/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Compare-Normed/4 (/7 s.new#1/9 e.new#2/5 )/8 s.new#3/10 e.new#4/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#2 as range 5
  if( ! refalrts::svar_left( context[10], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#4 as range 2
  do {
    // </0 & Compare-Normed/4 (/7 '+'/9 e.new#5/5 )/8 s.new#6/10 e.new#7/2 >/1
    if( ! refalrts::char_term( '+', context[9] ) )
      continue;
    // closed e.new#5 as range 5
    // closed e.new#7 as range 2
    do {
      // </0 & Compare-Normed/4 (/7 '+'/9 e.First#1/5 )/8 '+'/10 e.Second#1/2 >/1
      if( ! refalrts::char_term( '+', context[10] ) )
        continue;
      // closed e.First#1 as range 5
      // closed e.Second#1 as range 2
      //DEBUG: e.First#1: 5
      //DEBUG: e.Second#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} '+'/9 {REMOVED TILE} )/8 {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Compare-Nat/4 AsIs: (/7 } Tile{ AsIs: e.First#1/5 } Tile{ HalfReuse: )/10 AsIs: e.Second#1/2 AsIs: >/1 ]] }
      refalrts::update_name( context[4], ref_Comparem_Nat.ref.function );
      refalrts::reinit_close_bracket( context[10] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[7], context[10] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[10];
      res = refalrts::splice_evar( res, context[5], context[6] );
      refalrts::splice_to_freelist_open( context[7], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & Compare-Normed/4 (/7 '+'/9 e.First#1/5 )/8 '-'/10 e.Second#1/2 >/1
      if( ! refalrts::char_term( '-', context[10] ) )
        continue;
      // closed e.First#1 as range 5
      // closed e.Second#1 as range 2
      //DEBUG: e.First#1: 5
      //DEBUG: e.Second#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} </0 & Compare-Normed/4 (/7 '+'/9 e.First#1/5 )/8 '-'/10 e.Second#1/2 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: '+'/1 ]] }
      refalrts::reinit_char( context[1], '+' );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      refalrts::splice_to_freelist_open( trash_prev, res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Compare-Normed/4 (/7 '+'/9 e.First#1/5 )/8 0/10 >/1
    if( ! refalrts::number_term( 0UL, context[10] ) )
      continue;
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    // closed e.First#1 as range 5
    //DEBUG: e.First#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-Normed/4 (/7 '+'/9 e.First#1/5 )/8 0/10 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '+'/1 ]] }
    refalrts::reinit_char( context[1], '+' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Compare-Normed/4 (/7 '-'/9 e.new#5/5 )/8 s.new#6/10 e.new#7/2 >/1
    if( ! refalrts::char_term( '-', context[9] ) )
      continue;
    // closed e.new#5 as range 5
    // closed e.new#7 as range 2
    do {
      // </0 & Compare-Normed/4 (/7 '-'/9 e.First#1/5 )/8 '+'/10 e.Second#1/2 >/1
      if( ! refalrts::char_term( '+', context[10] ) )
        continue;
      // closed e.First#1 as range 5
      // closed e.Second#1 as range 2
      //DEBUG: e.First#1: 5
      //DEBUG: e.Second#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} </0 & Compare-Normed/4 (/7 '-'/9 e.First#1/5 )/8 '+'/10 e.Second#1/2 {REMOVED TILE}
      //RESULT: Tile{ [[ } Tile{ HalfReuse: '-'/1 ]] }
      refalrts::reinit_char( context[1], '-' );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      refalrts::splice_to_freelist_open( trash_prev, res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    do {
      // </0 & Compare-Normed/4 (/7 '-'/9 e.First#1/5 )/8 '-'/10 e.Second#1/2 >/1
      if( ! refalrts::char_term( '-', context[10] ) )
        continue;
      // closed e.First#1 as range 5
      // closed e.Second#1 as range 2
      //DEBUG: e.First#1: 5
      //DEBUG: e.Second#1: 2

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} '-'/9 {REMOVED TILE} {REMOVED TILE} '-'/10 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 Reuse: & Compare-Nat/4 AsIs: (/7 } Tile{ AsIs: e.Second#1/2 } Tile{ AsIs: )/8 } Tile{ AsIs: e.First#1/5 } Tile{ AsIs: >/1 ]] }
      refalrts::update_name( context[4], ref_Comparem_Nat.ref.function );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[7], context[8] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[5], context[6] );
      res = refalrts::splice_evar( res, context[8], context[8] );
      res = refalrts::splice_evar( res, context[2], context[3] );
      refalrts::splice_to_freelist_open( context[7], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Compare-Normed/4 (/7 '-'/9 e.First#1/5 )/8 0/10 >/1
    if( ! refalrts::number_term( 0UL, context[10] ) )
      continue;
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    // closed e.First#1 as range 5
    //DEBUG: e.First#1: 5

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-Normed/4 (/7 '-'/9 e.First#1/5 )/8 0/10 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '-'/1 ]] }
    refalrts::reinit_char( context[1], '-' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Compare-Normed/4 (/7 0/9 )/8 s.new#5/10 e.new#6/2 >/1
  if( ! refalrts::number_term( 0UL, context[9] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#6 as range 2
  do {
    // </0 & Compare-Normed/4 (/7 0/9 )/8 '+'/10 e.Second#1/2 >/1
    if( ! refalrts::char_term( '+', context[10] ) )
      continue;
    // closed e.Second#1 as range 2
    //DEBUG: e.Second#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-Normed/4 (/7 0/9 )/8 '+'/10 e.Second#1/2 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '-'/1 ]] }
    refalrts::reinit_char( context[1], '-' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  do {
    // </0 & Compare-Normed/4 (/7 0/9 )/8 '-'/10 e.Second#1/2 >/1
    if( ! refalrts::char_term( '-', context[10] ) )
      continue;
    // closed e.Second#1 as range 2
    //DEBUG: e.Second#1: 2

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-Normed/4 (/7 0/9 )/8 '-'/10 e.Second#1/2 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '+'/1 ]] }
    refalrts::reinit_char( context[1], '+' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Compare-Normed/4 (/7 0/9 )/8 0/10 >/1
  if( ! refalrts::number_term( 0UL, context[10] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Compare-Normed/4 (/7 0/9 )/8 0/10 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: '0'/1 ]] }
  refalrts::reinit_char( context[1], '0' );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Comparem_Normed("Compare-Normed", 877573369U, 332537286U, func_Comparem_Normed);


static refalrts::FnResult func_Comparem_Nat(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  // </0 & Compare-Nat/4 (/7 e.First#1/5 )/8 e.Second#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.First#1 as range 5
  // closed e.Second#1 as range 2
  //DEBUG: e.First#1: 5
  //DEBUG: e.Second#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Compare-Align/4 AsIs: (/7 } (/9 )/10 Tile{ AsIs: e.First#1/5 } )/11 (/12 Tile{ AsIs: )/8 AsIs: e.Second#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_bracket( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Comparem_Align.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[12], context[8] );
  refalrts::link_brackets( context[7], context[11] );
  refalrts::link_brackets( context[9], context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[8];
  res = refalrts::splice_evar( res, context[11], context[12] );
  res = refalrts::splice_evar( res, context[5], context[6] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Comparem_Nat("Compare-Nat", 877573369U, 332537286U, func_Comparem_Nat);


static refalrts::FnResult func_Comparem_Align(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 25 elems
  refalrts::Iter context[25];
  refalrts::zeros( context, 25 );
  // </0 & Compare-Align/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Compare-Align/4 (/7 (/11 e.new#1/9 )/12 e.new#2/5 )/8 (/15 e.new#3/13 )/16 e.new#4/2 >/1
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  context[9] = 0;
  context[10] = 0;
  context[11] = refalrts::brackets_left( context[9], context[10], context[5], context[6] );
  if( ! context[11] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[11], context[12]);
  context[13] = 0;
  context[14] = 0;
  context[15] = refalrts::brackets_left( context[13], context[14], context[2], context[3] );
  if( ! context[15] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[15], context[16]);
  // closed e.new#1 as range 9
  // closed e.new#2 as range 5
  // closed e.new#3 as range 13
  // closed e.new#4 as range 2
  do {
    // </0 & Compare-Align/4 (/7 (/11 e.new#5/9 )/12 s.new#6/19 e.new#7/17 )/8 (/15 e.new#8/13 )/16 e.new#9/2 >/1
    context[17] = context[5];
    context[18] = context[6];
    // closed e.new#5 as range 9
    // closed e.new#8 as range 13
    // closed e.new#9 as range 2
    if( ! refalrts::svar_left( context[19], context[17], context[18] ) )
      continue;
    // closed e.new#7 as range 17
    do {
      // </0 & Compare-Align/4 (/7 (/11 e.First-L#1/9 )/12 s.First-Dig#1/19 e.First-R#1/17 )/8 (/15 e.Second-L#1/13 )/16 s.Second-Dig#1/22 e.Second-R#1/20 >/1
      context[20] = context[2];
      context[21] = context[3];
      // closed e.First-L#1 as range 9
      // closed e.First-R#1 as range 17
      // closed e.Second-L#1 as range 13
      if( ! refalrts::svar_left( context[22], context[20], context[21] ) )
        continue;
      // closed e.Second-R#1 as range 20
      //DEBUG: s.First-Dig#1: 19
      //DEBUG: e.First-L#1: 9
      //DEBUG: e.First-R#1: 17
      //DEBUG: e.Second-L#1: 13
      //DEBUG: s.Second-Dig#1: 22
      //DEBUG: e.Second-R#1: 20

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} s.First-Dig#1/19 {REMOVED TILE} {REMOVED TILE} s.Second-Dig#1/22 {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & Compare-Align/4 AsIs: (/7 AsIs: (/11 AsIs: e.First-L#1/9 HalfReuse: s.First-Dig1 #19/12 } )/23 Tile{ AsIs: e.First-R#1/17 } Tile{ AsIs: )/8 AsIs: (/15 AsIs: e.Second-L#1/13 HalfReuse: s.Second-Dig1 #22/16 } )/24 Tile{ AsIs: e.Second-R#1/20 } Tile{ AsIs: >/1 ]] }
      if( ! refalrts::alloc_close_bracket( context[23] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_close_bracket( context[24] ) )
        return refalrts::cNoMemory;
      refalrts::reinit_svar( context[12], context[19] );
      refalrts::reinit_svar( context[16], context[22] );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[15], context[24] );
      refalrts::link_brackets( context[7], context[8] );
      refalrts::link_brackets( context[11], context[23] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[20], context[21] );
      res = refalrts::splice_evar( res, context[24], context[24] );
      res = refalrts::splice_evar( res, context[8], context[16] );
      res = refalrts::splice_evar( res, context[17], context[18] );
      res = refalrts::splice_evar( res, context[23], context[23] );
      refalrts::splice_to_freelist_open( context[12], res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Compare-Align/4 (/7 (/11 e.First-L#1/9 )/12 s.First-Dig#1/19 e.First-R#1/17 )/8 (/15 e.Second-L#1/13 )/16 >/1
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;
    // closed e.First-L#1 as range 9
    // closed e.First-R#1 as range 17
    // closed e.Second-L#1 as range 13
    //DEBUG: s.First-Dig#1: 19
    //DEBUG: e.First-L#1: 9
    //DEBUG: e.First-R#1: 17
    //DEBUG: e.Second-L#1: 13

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-Align/4 (/7 (/11 e.First-L#1/9 )/12 s.First-Dig#1/19 e.First-R#1/17 )/8 (/15 e.Second-L#1/13 )/16 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '+'/1 ]] }
    refalrts::reinit_char( context[1], '+' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Compare-Align/4 (/7 (/11 e.new#5/9 )/12 )/8 (/15 e.new#6/13 )/16 e.new#7/2 >/1
  if( ! refalrts::empty_seq( context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.new#5 as range 9
  // closed e.new#6 as range 13
  // closed e.new#7 as range 2
  do {
    // </0 & Compare-Align/4 (/7 (/11 e.First-L#1/9 )/12 )/8 (/15 e.Second-L#1/13 )/16 s.Second-Dig#1/19 e.Second-R#1/17 >/1
    context[17] = context[2];
    context[18] = context[3];
    // closed e.First-L#1 as range 9
    // closed e.Second-L#1 as range 13
    if( ! refalrts::svar_left( context[19], context[17], context[18] ) )
      continue;
    // closed e.Second-R#1 as range 17
    //DEBUG: e.First-L#1: 9
    //DEBUG: e.Second-L#1: 13
    //DEBUG: s.Second-Dig#1: 19
    //DEBUG: e.Second-R#1: 17

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-Align/4 (/7 (/11 e.First-L#1/9 )/12 )/8 (/15 e.Second-L#1/13 )/16 s.Second-Dig#1/19 e.Second-R#1/17 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '-'/1 ]] }
    refalrts::reinit_char( context[1], '-' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Compare-Align/4 (/7 (/11 s.First-Dig#1/17 e.First#1/9 )/12 )/8 (/15 s.Second-Dig#1/18 e.Second#1/13 )/16 >/1
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[17], context[9], context[10] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.First#1 as range 9
  if( ! refalrts::svar_left( context[18], context[13], context[14] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.Second#1 as range 13
  //DEBUG: s.First-Dig#1: 17
  //DEBUG: e.First#1: 9
  //DEBUG: s.Second-Dig#1: 18
  //DEBUG: e.Second#1: 13

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} s.Second-Dig#1/18 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Compare-ByDigits/4 HalfReuse: </7 HalfReuse: & Compare-Digits/11 AsIs: s.First-Dig#1/17 } Tile{ HalfReuse: s.Second-Dig1 #18/12 HalfReuse: >/8 AsIs: (/15 } Tile{ AsIs: e.First#1/9 } Tile{ AsIs: )/16 } Tile{ AsIs: e.Second#1/13 } Tile{ AsIs: >/1 ]] }
  refalrts::update_name( context[4], ref_Comparem_ByDigits.ref.function );
  refalrts::reinit_open_call( context[7] );
  refalrts::reinit_name( context[11], ref_Comparem_Digits.ref.function );
  refalrts::reinit_svar( context[12], context[18] );
  refalrts::reinit_close_call( context[8] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[15], context[16] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[7] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[13], context[14] );
  res = refalrts::splice_evar( res, context[16], context[16] );
  res = refalrts::splice_evar( res, context[9], context[10] );
  res = refalrts::splice_evar( res, context[12], context[15] );
  refalrts::splice_to_freelist_open( context[17], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Comparem_Align("Compare-Align", 877573369U, 332537286U, func_Comparem_Align);


static refalrts::FnResult func_Comparem_ByDigits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 18 elems
  refalrts::Iter context[18];
  refalrts::zeros( context, 18 );
  // </0 & Compare-ByDigits/4 e.new#0/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.new#0 as range 2
  // </0 & Compare-ByDigits/4 s.new#1/5 (/8 e.new#2/6 )/9 e.new#3/2 >/1
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[6] = 0;
  context[7] = 0;
  context[8] = refalrts::brackets_left( context[6], context[7], context[2], context[3] );
  if( ! context[8] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[8], context[9]);
  // closed e.new#2 as range 6
  // closed e.new#3 as range 2
  do {
    // </0 & Compare-ByDigits/4 '0'/5 (/8 e.new#4/6 )/9 e.new#5/2 >/1
    if( ! refalrts::char_term( '0', context[5] ) )
      continue;
    // closed e.new#4 as range 6
    // closed e.new#5 as range 2
    do {
      // </0 & Compare-ByDigits/4 '0'/5 (/8 s.First-Dig#1/14 e.First#1/10 )/9 s.Second-Dig#1/15 e.Second#1/12 >/1
      context[10] = context[6];
      context[11] = context[7];
      context[12] = context[2];
      context[13] = context[3];
      if( ! refalrts::svar_left( context[14], context[10], context[11] ) )
        continue;
      // closed e.First#1 as range 10
      if( ! refalrts::svar_left( context[15], context[12], context[13] ) )
        continue;
      // closed e.Second#1 as range 12
      //DEBUG: s.First-Dig#1: 14
      //DEBUG: e.First#1: 10
      //DEBUG: s.Second-Dig#1: 15
      //DEBUG: e.Second#1: 12

      refalrts::reset_allocator();
      //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
      //RESULT: Tile{ [[ AsIs: </0 AsIs: & Compare-ByDigits/4 HalfReuse: </5 HalfReuse: & Compare-Digits/8 AsIs: s.First-Dig#1/14 } Tile{ AsIs: s.Second-Dig#1/15 } >/16 (/17 Tile{ AsIs: e.First#1/10 } Tile{ AsIs: )/9 } Tile{ AsIs: e.Second#1/12 } Tile{ AsIs: >/1 ]] }
      if( ! refalrts::alloc_close_call( context[16] ) )
        return refalrts::cNoMemory;
      if( ! refalrts::alloc_open_bracket( context[17] ) )
        return refalrts::cNoMemory;
      refalrts::reinit_open_call( context[5] );
      refalrts::reinit_name( context[8], ref_Comparem_Digits.ref.function );
      refalrts::push_stack( context[1] );
      refalrts::push_stack( context[0] );
      refalrts::link_brackets( context[17], context[9] );
      refalrts::push_stack( context[16] );
      refalrts::push_stack( context[5] );
      refalrts::Iter trash_prev = arg_begin->prev;
      refalrts::use(trash_prev);
      refalrts::Iter res = context[1];
      res = refalrts::splice_evar( res, context[12], context[13] );
      res = refalrts::splice_evar( res, context[9], context[9] );
      res = refalrts::splice_evar( res, context[10], context[11] );
      res = refalrts::splice_evar( res, context[16], context[17] );
      res = refalrts::splice_evar( res, context[15], context[15] );
      refalrts::use( res );
      return refalrts::cSuccess;
    } while ( 0 );
    refalrts::stop_sentence();

    // </0 & Compare-ByDigits/4 '0'/5 (/8 )/9 >/1
    if( ! refalrts::empty_seq( context[6], context[7] ) )
      continue;
    if( ! refalrts::empty_seq( context[2], context[3] ) )
      continue;

    refalrts::reset_allocator();
    //TRASH: {REMOVED TILE} </0 & Compare-ByDigits/4 '0'/5 (/8 )/9 {REMOVED TILE}
    //RESULT: Tile{ [[ } Tile{ HalfReuse: '0'/1 ]] }
    refalrts::reinit_char( context[1], '0' );
    refalrts::Iter trash_prev = arg_begin->prev;
    refalrts::use(trash_prev);
    refalrts::Iter res = context[1];
    refalrts::splice_to_freelist_open( trash_prev, res );
    return refalrts::cSuccess;
  } while ( 0 );
  refalrts::stop_sentence();

  // </0 & Compare-ByDigits/4 s.Compare-Res#1/5 (/8 e.First#1/6 )/9 e.Second#1/2 >/1
  // closed e.First#1 as range 6
  // closed e.Second#1 as range 2
  //DEBUG: s.Compare-Res#1: 5
  //DEBUG: e.First#1: 6
  //DEBUG: e.Second#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} </0 & Compare-ByDigits/4 s.Compare-Res#1/5 (/8 e.First#1/6 )/9 e.Second#1/2 {REMOVED TILE}
  //RESULT: Tile{ [[ } Tile{ HalfReuse: s.Compare-Res1 #5/1 ]] }
  refalrts::reinit_svar( context[1], context[5] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  refalrts::splice_to_freelist_open( trash_prev, res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Comparem_ByDigits("Compare-ByDigits", 877573369U, 332537286U, func_Comparem_ByDigits);


static refalrts::FnResult func_Comparem_Digits(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2818 "Library.sref"
  ARITHM_PRELUDE

  char res = first < second ? '-' : first > second ? '+' : '0';

  refalrts::reinit_char(arg_begin, res);
  refalrts::splice_to_freelist(pFunc, arg_end);
  return refalrts::cSuccess;
#line 16509 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Comparem_Digits("Compare-Digits", 877573369U, 332537286U, func_Comparem_Digits);


static refalrts::FnResult func_DeSysfun(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 16 elems
  refalrts::Iter context[16];
  refalrts::zeros( context, 16 );
  // </0 & DeSysfun/4 e.FileName#1/2 (/7 s.Width#1/9 e.ObjectExpression#1/5 )/8 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_right( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.FileName#1 as range 2
  if( ! refalrts::svar_left( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.ObjectExpression#1 as range 5
  //DEBUG: e.FileName#1: 2
  //DEBUG: s.Width#1: 9
  //DEBUG: e.ObjectExpression#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </10 & __Step-Start/11 >/12 Tile{ AsIs: </0 Reuse: & Sysfun-Xxout/4 AsIs: e.FileName#1/2 AsIs: (/7 AsIs: s.Width#1/9 AsIs: e.ObjectExpression#1/5 AsIs: )/8 AsIs: >/1 } </13 & __Step-End/14 >/15 Tile{ ]] }
  if( ! refalrts::alloc_open_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[11], ref_u_u_Stepm_Start.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[15] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Sysfunm_Xxout.ref.function );
  refalrts::push_stack( context[15] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::link_brackets( context[7], context[8] );
  refalrts::push_stack( context[12] );
  refalrts::push_stack( context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[13], context[15] );
  res = refalrts::splice_evar( res, context[0], context[1] );
  res = refalrts::splice_evar( res, context[10], context[12] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_DeSysfun("DeSysfun", 0U, 0U, func_DeSysfun);

#line 2853 "Library.sref"
namespace {

class RndGen {
  /*
    See D. E. Knuth, The Art of Computer Programming,
    Volume 2, chapter 3.2.2, program A
  */
public:
  typedef refalrts::RefalNumber UInt;

  enum {
    cMaxVal = ~(UInt(0)),
    cMinDelay = 24,
    cMaxDelay = 55,
  };

  RndGen();

  UInt next_value() {
    m_y[m_k] = m_y[m_k] + m_y[m_j];
    UInt result = m_y[m_k];
    m_k = (m_k + cMaxDelay - 1) % cMaxDelay;
    m_j = (m_j + cMaxDelay - 1) % cMaxDelay;
    return result;
  }

  UInt next_in_range(UInt max);

private:
  /*
    Variable names from Knuth.
  */
  int m_k;
  int m_j;
  UInt m_y[cMaxDelay];
};

RndGen::RndGen()
  : m_k(cMaxDelay - 1), m_j(cMinDelay - 1)
{
  UInt seed = static_cast<UInt>(time(NULL));

  for (size_t i = 0; i < cMaxDelay; ++i) {
    seed = seed * 1103515245 + 12345;
    m_y[i] = seed;
  }
}

RndGen::UInt RndGen::next_in_range(RndGen::UInt max) {
  if (0 == max) {
    return 0;
  } else if (cMaxVal == max) {
    return next_value();
  } else {
    ++max;

    const UInt cBucketSize = cMaxVal / max;
    const UInt cInvalid = cBucketSize * max;
    UInt val;

    do {
      val = next_value();
    } while(val > cInvalid);

    return val / cBucketSize;
  }
}

RndGen g_gen;

bool positive_digit_arg(
  refalrts::Iter& pfunc_name, refalrts::RefalNumber& value,
  refalrts::Iter arg_begin, refalrts::Iter arg_end
) {
  refalrts::Iter content_b = 0, content_e = 0;
  pfunc_name = refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  // don't check return value
  refalrts::char_left('+', content_b, content_e);

  refalrts::Iter pnumber = 0;
  if (
    refalrts::svar_left(pnumber, content_b, content_e)
    && refalrts::empty_seq(content_b, content_e)
    && refalrts::cDataNumber == pnumber->tag
  ) {
    value = pnumber->number_info;
    return true;
  } else {
    return false;
  }
}

}  // unnamed namespace
#line 16670 "Library.cpp"

static refalrts::FnResult func_Random(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 2951 "Library.sref"
  refalrts::Iter pfunc_name = 0;
  refalrts::RefalNumber max = 0;

  if (! positive_digit_arg(pfunc_name, max, arg_begin, arg_end)) {
    return refalrts::cRecognitionImpossible;
  }

  max = g_gen.next_in_range(max);

  if (0 == max) {
    max = 1;
  }

  refalrts::reset_allocator();
  bool zero = true;
  for (size_t i = 0; i < static_cast<size_t>(max); ++i) {
    refalrts::RefalNumber digit = g_gen.next_value();
    if (digit != 0 || ! zero) {
      zero = false;

      refalrts::Iter dummy = 0;
      if (! refalrts::alloc_number(dummy, digit)) {
        return refalrts::cNoMemory;
      }
    }
  }

  if (zero) {
    refalrts::Iter dummy = 0;
    if (! refalrts::alloc_number(dummy, 0)) {
      return refalrts::cNoMemory;
    }
  }

  refalrts::splice_from_freelist(arg_begin);
  refalrts::splice_to_freelist(arg_begin, arg_end);

  return refalrts::cSuccess;
#line 16712 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Random("Random", 0U, 0U, func_Random);


static refalrts::FnResult func_RandomDigit(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 3000 "Library.sref"
  refalrts::Iter pfunc_name = 0;
  refalrts::RefalNumber max = 0;

  if (! positive_digit_arg(pfunc_name, max, arg_begin, arg_end)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber digit = g_gen.next_in_range(max);

  refalrts::reinit_number(arg_begin, digit);
  refalrts::splice_to_freelist(pfunc_name, arg_end);

  return refalrts::cSuccess;
#line 16733 "Library.cpp"
}

static refalrts::NativeReference nat_ref_RandomDigit("RandomDigit", 0U, 0U, func_RandomDigit);


static refalrts::FnResult func_Write(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 21 elems
  refalrts::Iter context[21];
  refalrts::zeros( context, 21 );
  // </0 & Write/4 s.FileNo#1/5 e.AnyExpression#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.AnyExpression#1 as range 2
  //DEBUG: s.FileNo#1: 5
  //DEBUG: e.AnyExpression#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & __Step-Start/4 } >/6 </7 & Autoopen/8 'w'/9 Tile{ AsIs: s.FileNo#1/5 } >/10 </11 & Write-Aux/12 </13 & ZeroHandle/14 s.FileNo#1/5/15 # stderr/16 >/17 Tile{ AsIs: e.AnyExpression#1/2 } >/18 </19 & __Step-End/20 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_close_call( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_Autoopen.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_char( context[9], 'w' ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[12], ref_Writem_Aux.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[13] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[14], ref_ZeroHandle.ref.function ) )
    return refalrts::cNoMemory;
  if (! refalrts::copy_stvar(context[15], context[5]))
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[16], ident_stderr ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[18] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[19] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[20], ref_u_u_Stepm_End.ref.function ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_u_u_Stepm_Start.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[19] );
  refalrts::push_stack( context[18] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[17] );
  refalrts::push_stack( context[13] );
  refalrts::push_stack( context[10] );
  refalrts::push_stack( context[7] );
  refalrts::push_stack( context[6] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[18], context[20] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[10], context[17] );
  res = refalrts::splice_evar( res, context[5], context[5] );
  res = refalrts::splice_evar( res, context[6], context[9] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_Write("Write", 0U, 0U, func_Write);


static refalrts::FnResult func_Writem_Aux(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 3030 "Library.sref"
  return cookie_ns::fwrite_line(arg_begin, arg_end, cookie_ns::cFlags_NoEOL);
#line 16818 "Library.cpp"
}

static refalrts::NativeReference nat_ref_Writem_Aux("Write-Aux", 877573369U, 332537286U, func_Writem_Aux);


static refalrts::FnResult func_ListOfBuiltin(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 307 elems
  refalrts::Iter context[307];
  refalrts::zeros( context, 307 );
  // </0 & ListOfBuiltin/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: (/0 HalfReuse: 1/4 HalfReuse: # Mu/1 } # special/5 )/6 (/7 2/8 # Add/9 # regular/10 )/11 (/12 3/13 # Arg/14 # regular/15 )/16 (/17 4/18 # Br/19 # regular/20 )/21 (/22 5/23 # Card/24 # regular/25 )/26 (/27 6/28 # Chr/29 # regular/30 )/31 (/32 7/33 # Cp/34 # regular/35 )/36 (/37 8/38 # Dg/39 # regular/40 )/41 (/42 9/43 # Dgall/44 # regular/45 )/46 (/47 10/48 # Div/49 # regular/50 )/51 (/52 11/53 # Divmod/54 # regular/55 )/56 (/57 12/58 # Explode/59 # regular/60 )/61 (/62 13/63 # First/64 # regular/65 )/66 (/67 14/68 # Get/69 # regular/70 )/71 (/72 15/73 # Implode/74 # regular/75 )/76 (/77 16/78 # Last/79 # regular/80 )/81 (/82 17/83 # Lenw/84 # regular/85 )/86 (/87 18/88 # Lower/89 # regular/90 )/91 (/92 19/93 # Mod/94 # regular/95 )/96 (/97 20/98 # Mul/99 # regular/100 )/101 (/102 21/103 # Numb/104 # regular/105 )/106 (/107 22/108 # Open/109 # regular/110 )/111 (/112 23/113 # Ord/114 # regular/115 )/116 (/117 24/118 # Print/119 # regular/120 )/121 (/122 25/123 # Prout/124 # regular/125 )/126 (/127 26/128 # Put/129 # regular/130 )/131 (/132 27/133 # Putout/134 # regular/135 )/136 (/137 28/138 # Rp/139 # regular/140 )/141 (/142 29/143 # Step/144 # regular/145 )/146 (/147 30/148 # Sub/149 # regular/150 )/151 (/152 31/153 # Symb/154 # regular/155 )/156 (/157 32/158 # Time/159 # regular/160 )/161 (/162 33/163 # Type/164 # regular/165 )/166 (/167 34/168 # Upper/169 # regular/170 )/171 (/172 35/173 # Sysfun/174 # regular/175 )/176 (/177 45/178 # Freeze/179 # regular/180 )/181 (/182 46/183 # Freezer/184 # regular/185 )/186 (/187 47/188 # Dn/189 # regular/190 )/191 (/192 48/193 # Up/194 # special/195 )/196 (/197 49/198 # Ev-met/199 # special/200 )/201 (/202 50/203 # Residue/204 # special/205 )/206 (/207 51/208 # GetEnv/209 # regular/210 )/211 (/212 52/213 # System/214 # regular/215 )/216 (/217 53/218 # Exit/219 # regular/220 )/221 (/222 54/223 # Close/224 # regular/225 )/226 (/227 55/228 # ExistFile/229 # regular/230 )/231 (/232 56/233 # GetCurrentDirectory/234 # regular/235 )/236 (/237 57/238 # RemoveFile/239 # regular/240 )/241 (/242 58/243 # Implode_Ext/244 # regular/245 )/246 (/247 59/248 # Explode_Ext/249 # regular/250 )/251 (/252 60/253 # TimeElapsed/254 # regular/255 )/256 (/257 61/258 # Compare/259 # regular/260 )/261 (/262 62/263 # DeSysfun/264 # regular/265 )/266 (/267 63/268 # XMLParse/269 # regular/270 )/271 (/272 64/273 # Random/274 # regular/275 )/276 (/277 65/278 # RandomDigit/279 # regular/280 )/281 (/282 66/283 # Write/284 # regular/285 )/286 (/287 67/288 # ListOfBuiltin/289 # regular/290 )/291 (/292 68/293 # SizeOf/294 # regular/295 )/296 (/297 69/298 # GetPID/299 # regular/300 )/301 (/302 71/303 # GetPPID/304 # regular/305 )/306 Tile{ ]] }
  if( ! refalrts::alloc_ident( context[5], ident_special ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[6] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[7] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[8], 2UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[9], ident_Add ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[10], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[11] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[13], 3UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[14], ident_Arg ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[15], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[16] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[17] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[18], 4UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[19], ident_Br ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[20], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[21] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[22] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[23], 5UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[24], ident_Card ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[25], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[26] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[27] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[28], 6UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[29], ident_Chr ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[30], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[31] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[32] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[33], 7UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[34], ident_Cp ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[35], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[36] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[37] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[38], 8UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[39], ident_Dg ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[40], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[41] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[42] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[43], 9UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[44], ident_Dgall ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[45], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[46] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[47] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[48], 10UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[49], ident_Div ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[50], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[51] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[52] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[53], 11UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[54], ident_Divmod ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[55], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[56] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[57] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[58], 12UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[59], ident_Explode ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[60], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[61] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[62] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[63], 13UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[64], ident_First ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[65], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[66] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[67] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[68], 14UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[69], ident_Get ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[70], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[71] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[72] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[73], 15UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[74], ident_Implode ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[75], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[76] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[77] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[78], 16UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[79], ident_Last ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[80], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[81] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[82] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[83], 17UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[84], ident_Lenw ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[85], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[86] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[87] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[88], 18UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[89], ident_Lower ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[90], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[91] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[92] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[93], 19UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[94], ident_Mod ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[95], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[96] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[97] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[98], 20UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[99], ident_Mul ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[100], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[101] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[102] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[103], 21UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[104], ident_Numb ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[105], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[106] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[107] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[108], 22UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[109], ident_Open ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[110], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[111] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[112] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[113], 23UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[114], ident_Ord ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[115], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[116] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[117] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[118], 24UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[119], ident_Print ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[120], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[121] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[122] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[123], 25UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[124], ident_Prout ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[125], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[126] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[127] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[128], 26UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[129], ident_Put ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[130], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[131] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[132] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[133], 27UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[134], ident_Putout ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[135], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[136] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[137] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[138], 28UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[139], ident_Rp ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[140], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[141] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[142] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[143], 29UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[144], ident_Step ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[145], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[146] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[147] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[148], 30UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[149], ident_Sub ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[150], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[151] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[152] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[153], 31UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[154], ident_Symb ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[155], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[156] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[157] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[158], 32UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[159], ident_Time ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[160], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[161] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[162] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[163], 33UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[164], ident_Type ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[165], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[166] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[167] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[168], 34UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[169], ident_Upper ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[170], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[171] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[172] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[173], 35UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[174], ident_Sysfun ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[175], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[176] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[177] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[178], 45UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[179], ident_Freeze ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[180], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[181] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[182] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[183], 46UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[184], ident_Freezer ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[185], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[186] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[187] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[188], 47UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[189], ident_Dn ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[190], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[191] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[192] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[193], 48UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[194], ident_Up ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[195], ident_special ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[196] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[197] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[198], 49UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[199], ident_Evm_met ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[200], ident_special ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[201] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[202] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[203], 50UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[204], ident_Residue ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[205], ident_special ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[206] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[207] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[208], 51UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[209], ident_GetEnv ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[210], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[211] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[212] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[213], 52UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[214], ident_System ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[215], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[216] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[217] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[218], 53UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[219], ident_Exit ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[220], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[221] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[222] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[223], 54UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[224], ident_Close ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[225], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[226] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[227] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[228], 55UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[229], ident_ExistFile ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[230], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[231] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[232] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[233], 56UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[234], ident_GetCurrentDirectory ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[235], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[236] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[237] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[238], 57UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[239], ident_RemoveFile ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[240], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[241] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[242] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[243], 58UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[244], ident_Implodeu_Ext ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[245], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[246] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[247] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[248], 59UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[249], ident_Explodeu_Ext ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[250], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[251] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[252] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[253], 60UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[254], ident_TimeElapsed ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[255], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[256] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[257] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[258], 61UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[259], ident_Compare ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[260], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[261] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[262] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[263], 62UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[264], ident_DeSysfun ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[265], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[266] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[267] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[268], 63UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[269], ident_XMLParse ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[270], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[271] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[272] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[273], 64UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[274], ident_Random ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[275], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[276] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[277] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[278], 65UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[279], ident_RandomDigit ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[280], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[281] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[282] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[283], 66UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[284], ident_Write ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[285], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[286] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[287] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[288], 67UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[289], ident_ListOfBuiltin ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[290], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[291] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[292] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[293], 68UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[294], ident_SizeOf ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[295], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[296] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[297] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[298], 69UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[299], ident_GetPID ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[300], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[301] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[302] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_number( context[303], 71UL ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[304], ident_GetPPID ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_ident( context[305], ident_regular ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[306] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_number( context[4], 1UL );
  refalrts::reinit_ident( context[1], ident_Mu );
  refalrts::link_brackets( context[302], context[306] );
  refalrts::link_brackets( context[297], context[301] );
  refalrts::link_brackets( context[292], context[296] );
  refalrts::link_brackets( context[287], context[291] );
  refalrts::link_brackets( context[282], context[286] );
  refalrts::link_brackets( context[277], context[281] );
  refalrts::link_brackets( context[272], context[276] );
  refalrts::link_brackets( context[267], context[271] );
  refalrts::link_brackets( context[262], context[266] );
  refalrts::link_brackets( context[257], context[261] );
  refalrts::link_brackets( context[252], context[256] );
  refalrts::link_brackets( context[247], context[251] );
  refalrts::link_brackets( context[242], context[246] );
  refalrts::link_brackets( context[237], context[241] );
  refalrts::link_brackets( context[232], context[236] );
  refalrts::link_brackets( context[227], context[231] );
  refalrts::link_brackets( context[222], context[226] );
  refalrts::link_brackets( context[217], context[221] );
  refalrts::link_brackets( context[212], context[216] );
  refalrts::link_brackets( context[207], context[211] );
  refalrts::link_brackets( context[202], context[206] );
  refalrts::link_brackets( context[197], context[201] );
  refalrts::link_brackets( context[192], context[196] );
  refalrts::link_brackets( context[187], context[191] );
  refalrts::link_brackets( context[182], context[186] );
  refalrts::link_brackets( context[177], context[181] );
  refalrts::link_brackets( context[172], context[176] );
  refalrts::link_brackets( context[167], context[171] );
  refalrts::link_brackets( context[162], context[166] );
  refalrts::link_brackets( context[157], context[161] );
  refalrts::link_brackets( context[152], context[156] );
  refalrts::link_brackets( context[147], context[151] );
  refalrts::link_brackets( context[142], context[146] );
  refalrts::link_brackets( context[137], context[141] );
  refalrts::link_brackets( context[132], context[136] );
  refalrts::link_brackets( context[127], context[131] );
  refalrts::link_brackets( context[122], context[126] );
  refalrts::link_brackets( context[117], context[121] );
  refalrts::link_brackets( context[112], context[116] );
  refalrts::link_brackets( context[107], context[111] );
  refalrts::link_brackets( context[102], context[106] );
  refalrts::link_brackets( context[97], context[101] );
  refalrts::link_brackets( context[92], context[96] );
  refalrts::link_brackets( context[87], context[91] );
  refalrts::link_brackets( context[82], context[86] );
  refalrts::link_brackets( context[77], context[81] );
  refalrts::link_brackets( context[72], context[76] );
  refalrts::link_brackets( context[67], context[71] );
  refalrts::link_brackets( context[62], context[66] );
  refalrts::link_brackets( context[57], context[61] );
  refalrts::link_brackets( context[52], context[56] );
  refalrts::link_brackets( context[47], context[51] );
  refalrts::link_brackets( context[42], context[46] );
  refalrts::link_brackets( context[37], context[41] );
  refalrts::link_brackets( context[32], context[36] );
  refalrts::link_brackets( context[27], context[31] );
  refalrts::link_brackets( context[22], context[26] );
  refalrts::link_brackets( context[17], context[21] );
  refalrts::link_brackets( context[12], context[16] );
  refalrts::link_brackets( context[7], context[11] );
  refalrts::link_brackets( context[0], context[6] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[306] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_ListOfBuiltin("ListOfBuiltin", 0U, 0U, func_ListOfBuiltin);


static refalrts::FnResult func_SizeOf(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 3115 "Library.sref"
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter ptype = 0;
  if (
    ! refalrts::svar_left(ptype, content_b, content_e)
    || refalrts::cDataChar != ptype->tag
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber result;

  switch (ptype->char_info) {
    case 'c': result = sizeof(char); break;
    case 's': result = sizeof(short); break;
    case 'i': result = sizeof(int); break;
    case 'l': result = sizeof(long); break;
    case 'p': result = sizeof(char *); break;

    default:
      return refalrts::cRecognitionImpossible;
  }

  refalrts::reinit_number(arg_begin, result);
  refalrts::splice_to_freelist(pfunc_name, arg_end);
  return refalrts::cSuccess;
#line 17551 "Library.cpp"
}

static refalrts::NativeReference nat_ref_SizeOf("SizeOf", 0U, 0U, func_SizeOf);

#line 3152 "Library.sref"
namespace cookie_ns {

refalrts::FnResult return_pid(
  refalrts::RefalNumber pid, refalrts::Iter arg_begin, refalrts::Iter arg_end
);

}  // namespace cookie_ns
#line 17564 "Library.cpp"

static refalrts::FnResult func_GetPID(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 3163 "Library.sref"
  return cookie_ns::return_pid(refalrts::api::get_pid(), arg_begin, arg_end);
#line 17569 "Library.cpp"
}

static refalrts::NativeReference nat_ref_GetPID("GetPID", 0U, 0U, func_GetPID);

#line 3168 "Library.sref"
refalrts::FnResult cookie_ns::return_pid(
  refalrts::RefalNumber pid, refalrts::Iter arg_begin, refalrts::Iter arg_end
) {
  refalrts::Iter content_b = 0, content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reinit_number(arg_begin, pid);
  refalrts::splice_to_freelist(pfunc_name, arg_end);
  return refalrts::cSuccess;
}
#line 17590 "Library.cpp"

static refalrts::FnResult func_GetPPID(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 3191 "Library.sref"
  return cookie_ns::return_pid(refalrts::api::get_ppid(), arg_begin, arg_end);
#line 17595 "Library.cpp"
}

static refalrts::NativeReference nat_ref_GetPPID("GetPPID", 0U, 0U, func_GetPPID);


static refalrts::FnResult func_FClose(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 3210 "Library.sref"
  return cookie_ns::close(arg_begin, arg_end, cookie_ns::cCloseMode_Fail);
#line 17604 "Library.cpp"
}

static refalrts::NativeReference nat_ref_FClose("FClose", 0U, 0U, func_FClose);


static refalrts::FnResult func_gen_FOpen_A1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 13 elems
  refalrts::Iter context[13];
  refalrts::zeros( context, 13 );
  // </0 & FOpen=1/4 t.Mode#1/5 s.FileNameChar#1/7 (/10 e.FileName#1/8 )/11 s.FreeHandle#2/12 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[7], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  context[8] = 0;
  context[9] = 0;
  context[10] = refalrts::brackets_left( context[8], context[9], context[2], context[3] );
  if( ! context[10] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[10], context[11]);
  // closed e.FileName#1 as range 8
  if( ! refalrts::svar_left( context[12], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: t.Mode#1: 5
  //DEBUG: s.FileNameChar#1: 7
  //DEBUG: e.FileName#1: 8
  //DEBUG: s.FreeHandle#2: 12

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} s.FileNameChar#1/7 {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Open/4 AsIs: t.Mode#1/5 } Tile{ HalfReuse: s.FreeHandle2 #12/1 } Tile{ HalfReuse: s.FileNameChar1 #7/10 AsIs: e.FileName#1/8 HalfReuse: >/11 AsIs: s.FreeHandle#2/12 } Tile{ ]] }
  refalrts::update_name( context[4], ref_Open.ref.function );
  refalrts::reinit_svar( context[1], context[12] );
  refalrts::reinit_svar( context[10], context[7] );
  refalrts::reinit_close_call( context[11] );
  refalrts::push_stack( context[11] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[10], context[12] );
  res = refalrts::splice_evar( res, context[1], context[1] );
  refalrts::splice_to_freelist_open( context[6], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_FOpen_A1("FOpen=1", 877573369U, 332537286U, func_gen_FOpen_A1);


static refalrts::FnResult func_FOpen(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 15 elems
  refalrts::Iter context[15];
  refalrts::zeros( context, 15 );
  // </0 & FOpen/4 t.Mode#1/5 s.FileNameChar#1/7 e.FileName#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[6] = refalrts::tvar_left( context[5], context[2], context[3] );
  if( ! context[6] )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::svar_left( context[7], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.FileName#1 as range 2
  //DEBUG: t.Mode#1: 5
  //DEBUG: s.FileNameChar#1: 7
  //DEBUG: e.FileName#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE} {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </8 Tile{ HalfReuse: [*]/0 Reuse: & FOpen=1/4 AsIs: t.Mode#1/5 AsIs: s.FileNameChar#1/7 } (/9 Tile{ AsIs: e.FileName#1/2 } )/10 {*}/11 </12 & GetFreeHandle/13 >/14 Tile{ AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[8] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_bracket( context[9] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_bracket( context[10] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_unwrapped_closure( context[11], context[0] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_open_call( context[12] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[13], ref_GetFreeHandle.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_close_call( context[14] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_closure_head( context[0] );
  refalrts::update_name( context[4], ref_gen_FOpen_A1.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[8] );
  refalrts::push_stack( context[14] );
  refalrts::push_stack( context[12] );
  refalrts::link_brackets( context[9], context[10] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[1];
  res = refalrts::splice_evar( res, context[10], context[14] );
  res = refalrts::splice_evar( res, context[2], context[3] );
  res = refalrts::splice_evar( res, context[9], context[9] );
  res = refalrts::splice_evar( res, context[0], context[7] );
  res = refalrts::splice_evar( res, context[8], context[8] );
  refalrts::use( res );
  refalrts::wrap_closure( context[11] );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_FOpen("FOpen", 0U, 0U, func_FOpen);


static refalrts::FnResult func_FReadLine(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 7 elems
  refalrts::Iter context[7];
  refalrts::zeros( context, 7 );
  // </0 & FReadLine/4 s.FileNo#1/5 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::svar_left( context[5], context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;
  //DEBUG: s.FileNo#1: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } s.FileNo#1/5/6 Tile{ AsIs: </0 Reuse: & Get-Aux/4 AsIs: s.FileNo#1/5 AsIs: >/1 ]] }
  if (! refalrts::copy_stvar(context[6], context[5]))
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Getm_Aux.ref.function );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[0];
  res = refalrts::splice_evar( res, context[6], context[6] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_FReadLine("FReadLine", 0U, 0U, func_FReadLine);


static refalrts::FnResult func_FWriteLine(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 3243 "Library.sref"
  return cookie_ns::fwrite_line(
    arg_begin, arg_end, cookie_ns::cFlags_ReturnHandle
  );
#line 17765 "Library.cpp"
}

static refalrts::NativeReference nat_ref_FWriteLine("FWriteLine", 0U, 0U, func_FWriteLine);


static refalrts::FnResult func_GetFreeHandle(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 3256 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  if (! refalrts::empty_seq(content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber free_file = 1;
  while (free_file < cMaxFileHandles && g_file_handles[free_file] != 0) {
    ++free_file;
  }

  if (free_file == cMaxFileHandles) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reinit_number(arg_begin, free_file);
  refalrts::splice_to_freelist(pfunc_name, arg_end);
  return refalrts::cSuccess;
#line 17794 "Library.cpp"
}

static refalrts::NativeReference nat_ref_GetFreeHandle("GetFreeHandle", 877573369U, 332537286U, func_GetFreeHandle);


static refalrts::FnResult func_ReadLine(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  // </0 & ReadLine/4 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  if( ! refalrts::empty_seq( context[2], context[3] ) )
    return refalrts::cRecognitionImpossible;

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ AsIs: </0 Reuse: & Get/4 HalfReuse: # stdin/1 } >/5 Tile{ ]] }
  if( ! refalrts::alloc_close_call( context[5] ) )
    return refalrts::cNoMemory;
  refalrts::update_name( context[4], ref_Get.ref.function );
  refalrts::reinit_ident( context[1], ident_stdin );
  refalrts::push_stack( context[5] );
  refalrts::push_stack( context[0] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[5], context[5] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_ReadLine("ReadLine", 0U, 0U, func_ReadLine);


static refalrts::FnResult func_WriteLine(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 6 elems
  refalrts::Iter context[6];
  refalrts::zeros( context, 6 );
  // </0 & WriteLine/4 e.AnyExpression#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.AnyExpression#1 as range 2
  //DEBUG: e.AnyExpression#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 Tile{ HalfReuse: & Putout/0 HalfReuse: # stdout/4 AsIs: e.AnyExpression#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  refalrts::reinit_name( context[0], ref_Putout.ref.function );
  refalrts::reinit_ident( context[4], ident_stdout );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[5] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[0];
  res = refalrts::splice_evar( res, context[5], context[5] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_WriteLine("WriteLine", 0U, 0U, func_WriteLine);


static refalrts::FnResult func_gen_IntFromStr_L1(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 10 elems
  refalrts::Iter context[10];
  refalrts::zeros( context, 10 );
  // </0 & IntFromStr\1/4 (/7 e.MacroDigits#2/5 s.LastDigit#2/9 )/8 e.Rest#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  context[5] = 0;
  context[6] = 0;
  context[7] = refalrts::brackets_left( context[5], context[6], context[2], context[3] );
  if( ! context[7] )
    return refalrts::cRecognitionImpossible;
  refalrts::bracket_pointers(context[7], context[8]);
  // closed e.Rest#2 as range 2
  if( ! refalrts::svar_right( context[9], context[5], context[6] ) )
    return refalrts::cRecognitionImpossible;
  // closed e.MacroDigits#2 as range 5
  //DEBUG: e.Rest#2: 2
  //DEBUG: s.LastDigit#2: 9
  //DEBUG: e.MacroDigits#2: 5

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} (/7 e.MacroDigits#2/5 s.LastDigit#2/9 )/8 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: # Success/0 HalfReuse: s.LastDigit2 #9/4 } Tile{ AsIs: e.Rest#2/2 } Tile{ ]] }
  refalrts::reinit_ident( context[0], ident_Success );
  refalrts::reinit_svar( context[4], context[9] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::splice_to_freelist_open( context[4], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_IntFromStr_L1("IntFromStr\\1", 877573369U, 332537286U, func_gen_IntFromStr_L1);


static refalrts::FnResult func_gen_IntFromStr_L2(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 5 elems
  refalrts::Iter context[5];
  refalrts::zeros( context, 5 );
  // </0 & IntFromStr\2/4 e.Rest#2/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.Rest#2 as range 2
  //DEBUG: e.Rest#2: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} & IntFromStr\2/4 {REMOVED TILE} >/1 {REMOVED TILE}
  //RESULT: Tile{ [[ HalfReuse: # Fails/0 } Tile{ AsIs: e.Rest#2/2 } Tile{ ]] }
  refalrts::reinit_ident( context[0], ident_Fails );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = arg_end->next;
  res = refalrts::splice_evar( res, context[2], context[3] );
  refalrts::splice_to_freelist_open( context[0], res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_gen_IntFromStr_L2("IntFromStr\\2", 877573369U, 332537286U, func_gen_IntFromStr_L2);


static refalrts::FnResult func_IntFromStr(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
  refalrts::this_is_generated_function();
  // issue here memory for vars with 9 elems
  refalrts::Iter context[9];
  refalrts::zeros( context, 9 );
  // </0 & IntFromStr/4 e.String#1/2 >/1
  context[0] = arg_begin;
  context[1] = arg_end;
  context[2] = 0;
  context[3] = 0;
  context[4] = refalrts::call_left( context[2], context[3], context[0], context[1] );
  // closed e.String#1 as range 2
  //DEBUG: e.String#1: 2

  refalrts::reset_allocator();
  //TRASH: {REMOVED TILE} {REMOVED TILE}
  //RESULT: Tile{ [[ } </5 & DoNumb/6 & IntFromStr\1/7 & IntFromStr\2/8 Tile{ HalfReuse: (/0 HalfReuse: )/4 AsIs: e.String#1/2 AsIs: >/1 ]] }
  if( ! refalrts::alloc_open_call( context[5] ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[6], ref_DoNumb.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[7], ref_gen_IntFromStr_L1.ref.function ) )
    return refalrts::cNoMemory;
  if( ! refalrts::alloc_name( context[8], ref_gen_IntFromStr_L2.ref.function ) )
    return refalrts::cNoMemory;
  refalrts::reinit_open_bracket( context[0] );
  refalrts::reinit_close_bracket( context[4] );
  refalrts::push_stack( context[1] );
  refalrts::push_stack( context[5] );
  refalrts::link_brackets( context[0], context[4] );
  refalrts::Iter trash_prev = arg_begin->prev;
  refalrts::use(trash_prev);
  refalrts::Iter res = context[0];
  res = refalrts::splice_evar( res, context[5], context[8] );
  refalrts::use( res );
  return refalrts::cSuccess;
}

static refalrts::NativeReference nat_ref_IntFromStr("IntFromStr", 0U, 0U, func_IntFromStr);


static refalrts::FnResult func_StrFromInt(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 3326 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter number = 0;
  if (
    ! refalrts::svar_left(number, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
    || refalrts::cDataNumber != number->tag
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();
  refalrts::Iter begin_splice = arg_begin;

  if (refalrts::RefalNumber num = number->number_info) {
    // Длина десятичного числа = 0,3 * длина двоичного числа,
    // т.к. lg(2) = 0,3. Хрен с ним, что много. Главное, что не мало.
    enum { cMaxNumberLen = 8 * sizeof(refalrts::RefalNumber) * 3 / 10 + 2 };

    char buffer[cMaxNumberLen + 1] = { 0 };
    char *lim_digit = buffer + cMaxNumberLen;
    char *cur_digit = lim_digit;

    while (num != 0) {
      -- cur_digit;
      *cur_digit = static_cast<char>((num % 10) + '0');
      num /= 10;
    }

    refalrts::Iter num_begin;
    refalrts::Iter num_end;
    bool allocated = refalrts::alloc_chars(
      num_begin, num_end, cur_digit, unsigned(lim_digit - cur_digit)
    );

    if (! allocated) {
      return refalrts::cNoMemory;
    }

    refalrts::splice_evar(arg_begin, num_begin, num_end);
  } else {
    refalrts::reinit_char(arg_begin, '0');
    begin_splice = pfunc_name;
  }

  refalrts::splice_to_freelist(begin_splice, arg_end);

  return refalrts::cSuccess;
#line 18032 "Library.cpp"
}

static refalrts::NativeReference nat_ref_StrFromInt("StrFromInt", 0U, 0U, func_StrFromInt);

#line 3385 "Library.sref"
namespace cookie_ns {

bool compare(refalrts::Iter left, refalrts::Iter right);

} // namespace cookie_ns
#line 18043 "Library.cpp"

static refalrts::FnResult func_SymbCompare(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 3394 "Library.sref"
  refalrts::Iter pX = 0, pY = 0;
  refalrts::Iter pFunc = refalrts::call_left(pX, pY, arg_begin, arg_end);

  if (pX->next != pY) {
    return refalrts::cRecognitionImpossible;
  }

  if (! cookie_ns::compare(pX, pY)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(arg_begin, pFunc);
  refalrts::splice_to_freelist(pY, arg_end);
  return refalrts::cSuccess;
#line 18061 "Library.cpp"
}

static refalrts::NativeReference nat_ref_SymbCompare("SymbCompare", 0U, 0U, func_SymbCompare);

#line 3412 "Library.sref"
namespace cookie_ns {

template <typename T>
char compare_char(T x, T y) {
  if (x < y) {
    return '<';
  } else if (x == y) {
    return '=';
  } else {
    return '>';
  }
}

char strcmp_char(const char *x, const char *y) {
  int res = strcmp(x, y);
  if (res < 0) {
    return '<';
  } else if (res > 0) {
    return '>';
  } else {
    return '=';
  }
}

} // namespace cookie_ns

bool cookie_ns::compare(refalrts::Iter left, refalrts::Iter right) {
  int rank[refalrts::cData_COUNT] = { 0 };

  rank[refalrts::cDataNumber] = 5;
  rank[refalrts::cDataChar] = 4;
  rank[refalrts::cDataFunction] = 3;
  rank[refalrts::cDataIdentifier] = 2;
  rank[refalrts::cDataFile] = 1;

  if (! rank[left->tag] || ! rank[right->tag]) {
    return false;
  }

  char order;

  if (rank[left->tag] > rank[right->tag]) {
    order = '>';
  } else if (rank[left->tag] < rank[right->tag]) {
    order = '<';
  } else {
    assert(left->tag == right->tag);

    switch(left->tag) {
      case refalrts::cDataNumber:
        order = compare_char(left->number_info, right->number_info);
        break;

      case refalrts::cDataChar:
        order = compare_char(left->char_info, right->char_info);
        break;

      case refalrts::cDataFunction:
        {
          refalrts::RefalFunction *fl = left->function_info;
          refalrts::RefalFunction *fr = right->function_info;

          order = strcmp_char(fl->name.name, fr->name.name);
          if (order == '=') {
            order = compare_char(fl->name.cookie1, fr->name.cookie1);
          }
          if (order == '=') {
            order = compare_char(fl->name.cookie2, fr->name.cookie2);
          }
          if (order == '=') {
            order = compare_char(fl->rasl, fr->rasl);
          }
        }
        break;

      case refalrts::cDataIdentifier:
        order =
          strcmp_char(left->ident_info->name(), right->ident_info->name());
        break;

      case refalrts::cDataFile:
        order = compare_char(left->file_info, right->file_info);
        break;

      default:
        refalrts_switch_default_violation(left->tag);
    }
  }

  refalrts::reinit_char(left, order);
  return true;
}
#line 18159 "Library.cpp"

static refalrts::FnResult func_FWriteBytes(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 3515 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;

  if (! file_handle_left(pfile_handle, content_b, content_e)) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = extract_file_handle(pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  int fputc_return = 0;

  while (fputc_return != EOF && ! refalrts::empty_seq(content_b, content_e)) {
    switch (content_b->tag) {
      case refalrts::cDataChar:
        fputc_return = fputc(content_b->char_info, handle);
        break;

      case refalrts::cDataNumber:
        fputc_return = fputc(content_b->number_info & 0xFF, handle);
        break;

      default:
        return refalrts::cRecognitionImpossible;
    }

    refalrts::move_left(content_b, content_e);
  }

  if (fputc_return == EOF) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 18203 "Library.cpp"
}

static refalrts::NativeReference nat_ref_FWriteBytes("FWriteBytes", 0U, 0U, func_FWriteBytes);


static refalrts::FnResult func_FReadBytes(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 3569 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;
  refalrts::Iter pcount_bytes = 0;

  if (
    ! file_handle_left(pfile_handle, content_b, content_e)
    || ! refalrts::svar_left(pcount_bytes, content_b, content_e)
    || refalrts::cDataNumber != pcount_bytes->tag
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reset_allocator();

  FILE *handle = extract_file_handle(pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::RefalNumber count = pcount_bytes->number_info;

  refalrts::Iter begin = 0;
  refalrts::Iter end = 0;

  clearerr(handle);
  int cur_char = 0;
  while (count > 0 && (cur_char = getc(handle)) != EOF) {
    /*
      Пользуемся тем фактом, что в данной реализации размещёные в свободной
      памяти узлы располагаются в последовательных адресах.
    */
    refalrts::RefalNumber value = cur_char & 0xFFU;
    if (! refalrts::alloc_number(end, value)) {
      return refalrts::cNoMemory;
    }

    if (begin == 0) {
      begin = end;
    }
    --count;
  }

  if (begin == 0) assert (end == 0);
  if (begin != 0) assert (end != 0);

  if (cur_char == EOF && ferror(handle)) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_evar(arg_begin, begin, end);
  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 18267 "Library.cpp"
}

static refalrts::NativeReference nat_ref_FReadBytes("FReadBytes", 0U, 0U, func_FReadBytes);


static refalrts::FnResult func_FTell(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 3634 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;

  if (
    ! file_handle_left(pfile_handle, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = extract_file_handle(pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  long int pos = ftell(handle);

  if (pos == -1L) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::reinit_number(arg_begin, static_cast<refalrts::RefalNumber>(pos));
  refalrts::splice_to_freelist(pfunc_name, arg_end);
  return refalrts::cSuccess;
#line 18303 "Library.cpp"
}

static refalrts::NativeReference nat_ref_FTell("FTell", 0U, 0U, func_FTell);


static refalrts::FnResult func_FSeek(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 3677 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter pfile_handle = 0;
  refalrts::Iter porigin = 0;
  refalrts::Iter psign = 0;
  refalrts::Iter poffset = 0;

  if (
    ! file_handle_left(pfile_handle, content_b, content_e)
    || ! refalrts::svar_left(porigin, content_b, content_e)
    || refalrts::cDataIdentifier != porigin->tag
    || ! refalrts::svar_left(psign, content_b, content_e)
    || refalrts::cDataChar != psign->tag
    || ! refalrts::svar_left(poffset, content_b, content_e)
    || refalrts::cDataNumber != poffset->tag
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  FILE *handle = extract_file_handle(pfile_handle);
  if (! handle) {
    return refalrts::cRecognitionImpossible;
  }

  int origin;
  if (USE_IDENT(BEGIN) == porigin->ident_info) {
    origin = SEEK_SET;
  } else if (USE_IDENT(CURRENT) == porigin->ident_info) {
    origin = SEEK_CUR;
  } else if (USE_IDENT(END) == porigin->ident_info) {
    origin = SEEK_END;
  } else {
    return refalrts::cRecognitionImpossible;
  }

  signed sign;
  if ('+' == psign->char_info) {
    sign = +1;
  } else if ('-' == psign->char_info) {
    sign = -1;
  } else {
    return refalrts::cRecognitionImpossible;
  }

  long int offset = sign * static_cast<long int>(poffset->number_info);

  if (fseek(handle, offset, origin) != 0) {
    return refalrts::cRecognitionImpossible;
  }

  refalrts::splice_to_freelist(arg_begin, arg_end);
  return refalrts::cSuccess;
#line 18366 "Library.cpp"
}

static refalrts::NativeReference nat_ref_FSeek("FSeek", 0U, 0U, func_FSeek);


static refalrts::FnResult func_RenameFile(refalrts::Iter arg_begin, refalrts::Iter arg_end) {
#line 3741 "Library.sref"
  refalrts::Iter content_b = 0;
  refalrts::Iter content_e = 0;
  refalrts::Iter pfunc_name =
    refalrts::call_left(content_b, content_e, arg_begin, arg_end);

  refalrts::Iter source_b = 0;
  refalrts::Iter source_e = 0;
  refalrts::Iter target_b = 0;
  refalrts::Iter target_e = 0;

  if (
    ! refalrts::brackets_left(source_b, source_e, content_b, content_e)
    || ! refalrts::brackets_left(target_b, target_e, content_b, content_e)
    || ! refalrts::empty_seq(content_b, content_e)
  ) {
    return refalrts::cRecognitionImpossible;
  }

  char source[FILENAME_MAX + 1] = { '\0' };
  unsigned source_len =
    refalrts::read_chars(source, FILENAME_MAX, source_b, source_e);

  if (! refalrts::empty_seq(source_b, source_e) || source_len == 0) {
    return refalrts::cRecognitionImpossible;
  }

  char target[FILENAME_MAX + 1] = { '\0' };
  unsigned target_len =
    refalrts::read_chars(target, FILENAME_MAX, target_b, target_e);

  if (! refalrts::empty_seq(target_b, target_e) || target_len == 0) {
    return refalrts::cRecognitionImpossible;
  }

  int result = rename(source, target);

  refalrts::RefalIdentifier i_result =
    result == 0 ? USE_IDENT(True) : USE_IDENT(False);

  refalrts::reinit_ident(arg_begin, i_result);
  refalrts::splice_to_freelist(pfunc_name, arg_end);
  return refalrts::cSuccess;
#line 18416 "Library.cpp"
}

static refalrts::NativeReference nat_ref_RenameFile("RenameFile", 0U, 0U, func_RenameFile);


//End of file
